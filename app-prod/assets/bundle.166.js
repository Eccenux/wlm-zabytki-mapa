/*! For license information please see bundle.166.js.LICENSE.txt */
(self.webpackChunk = self.webpackChunk || []).push([ [ 166 ], {
    195: () => {
        !function(window, angular) {
            "use strict";
            var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, ELEMENT_NODE = 1, ADD_CLASS_SUFFIX = "-add", REMOVE_CLASS_SUFFIX = "-remove";
            void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend ? (TRANSITION_PROP = "WebkitTransition", 
            TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", 
            TRANSITIONEND_EVENT = "transitionend"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend ? (ANIMATION_PROP = "WebkitAnimation", 
            ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", 
            ANIMATIONEND_EVENT = "animationend");
            var ANIMATION_DELAY_PROP = ANIMATION_PROP + "Delay", ANIMATION_DURATION_PROP = ANIMATION_PROP + "Duration", TRANSITION_DELAY_PROP = TRANSITION_PROP + "Delay", TRANSITION_DURATION_PROP = TRANSITION_PROP + "Duration", ngMinErr = angular.$$minErr("ng");
            function assertArg(arg, name, reason) {
                if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
                return arg;
            }
            function mergeClasses(a, b) {
                return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
                a + " " + b) : a : b : "";
            }
            function pendClasses(classes, fix, isPrefix) {
                var className = "";
                return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], 
                forEach(classes, (function(klass, i) {
                    klass && klass.length > 0 && (className += i > 0 ? " " : "", className += isPrefix ? fix + klass : klass + fix);
                })), className;
            }
            function stripCommentsFromElement(element) {
                if (element instanceof jqLite) switch (element.length) {
                  case 0:
                    return element;

                  case 1:
                    if (element[0].nodeType === ELEMENT_NODE) return element;
                    break;

                  default:
                    return jqLite(extractElementNode(element));
                }
                if (element.nodeType === ELEMENT_NODE) return jqLite(element);
            }
            function extractElementNode(element) {
                if (!element[0]) return element;
                for (var i = 0; i < element.length; i++) {
                    var elm = element[i];
                    if (elm.nodeType === ELEMENT_NODE) return elm;
                }
            }
            function applyAnimationClassesFactory($$jqLite) {
                return function(element, options) {
                    options.addClass && (!function($$jqLite, element, className) {
                        forEach(element, (function(elm) {
                            $$jqLite.addClass(elm, className);
                        }));
                    }($$jqLite, element, options.addClass), options.addClass = null), options.removeClass && (!function($$jqLite, element, className) {
                        forEach(element, (function(elm) {
                            $$jqLite.removeClass(elm, className);
                        }));
                    }($$jqLite, element, options.removeClass), options.removeClass = null);
                };
            }
            function prepareAnimationOptions(options) {
                if (!(options = options || {}).$$prepared) {
                    var domOperation = options.domOperation || noop;
                    options.domOperation = function() {
                        options.$$domOperationFired = !0, domOperation(), domOperation = noop;
                    }, options.$$prepared = !0;
                }
                return options;
            }
            function applyAnimationStyles(element, options) {
                applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
            }
            function applyAnimationFromStyles(element, options) {
                options.from && (element.css(options.from), options.from = null);
            }
            function applyAnimationToStyles(element, options) {
                options.to && (element.css(options.to), options.to = null);
            }
            function mergeAnimationDetails(element, oldAnimation, newAnimation) {
                var target = oldAnimation.options || {}, newOptions = newAnimation.options || {}, toAdd = (target.addClass || "") + " " + (newOptions.addClass || ""), toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = function(existing, toAdd, toRemove) {
                    var ADD_CLASS = 1, REMOVE_CLASS = -1, flags = {};
                    existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), 
                    forEach(toAdd, (function(value, key) {
                        flags[key] = ADD_CLASS;
                    })), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, (function(value, key) {
                        flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
                    }));
                    var classes = {
                        addClass: "",
                        removeClass: ""
                    };
                    function splitClassesToLookup(classes) {
                        isString(classes) && (classes = classes.split(" "));
                        var obj = {};
                        return forEach(classes, (function(klass) {
                            klass.length && (obj[klass] = !0);
                        })), obj;
                    }
                    return forEach(flags, (function(val, klass) {
                        var prop, allow;
                        val === ADD_CLASS ? (prop = "addClass", allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX]) : val === REMOVE_CLASS && (prop = "removeClass", 
                        allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX]), allow && (classes[prop].length && (classes[prop] += " "), 
                        classes[prop] += klass);
                    })), classes;
                }(element.attr("class"), toAdd, toRemove);
                newOptions.preparationClasses && (target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses), 
                delete newOptions.preparationClasses);
                var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
                return extend(target, newOptions), realDomOperation && (target.domOperation = realDomOperation), 
                classes.addClass ? target.addClass = classes.addClass : target.addClass = null, 
                classes.removeClass ? target.removeClass = classes.removeClass : target.removeClass = null, 
                oldAnimation.addClass = target.addClass, oldAnimation.removeClass = target.removeClass, 
                target;
            }
            function getDomNode(element) {
                return element instanceof jqLite ? element[0] : element;
            }
            function blockKeyframeAnimations(node, applyBlock) {
                var value = applyBlock ? "paused" : "", key = ANIMATION_PROP + "PlayState";
                return applyInlineStyle(node, [ key, value ]), [ key, value ];
            }
            function applyInlineStyle(node, styleTuple) {
                var prop = styleTuple[0], value = styleTuple[1];
                node.style[prop] = value;
            }
            function concatWithSpace(a, b) {
                return a ? b ? a + " " + b : a : b;
            }
            var helpers_blockTransitions = function(node, duration) {
                var value = duration ? "-" + duration + "s" : "";
                return applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]), [ TRANSITION_DELAY_PROP, value ];
            }, $$AnimateChildrenDirective = [ "$interpolate", function($interpolate) {
                return {
                    link: function(scope, element, attrs) {
                        var val = attrs.ngAnimateChildren;
                        function setData(value) {
                            value = "on" === value || "true" === value, element.data("$$ngAnimateChildren", value);
                        }
                        isString(val) && 0 === val.length ? element.data("$$ngAnimateChildren", !0) : (setData($interpolate(val)(scope)), 
                        attrs.$observe("ngAnimateChildren", setData));
                    }
                };
            } ], DETECT_CSS_PROPERTIES = {
                transitionDuration: TRANSITION_DURATION_PROP,
                transitionDelay: TRANSITION_DELAY_PROP,
                transitionProperty: TRANSITION_PROP + "Property",
                animationDuration: ANIMATION_DURATION_PROP,
                animationDelay: ANIMATION_DELAY_PROP,
                animationIterationCount: ANIMATION_PROP + "IterationCount"
            }, DETECT_STAGGER_CSS_PROPERTIES = {
                transitionDuration: TRANSITION_DURATION_PROP,
                transitionDelay: TRANSITION_DELAY_PROP,
                animationDuration: ANIMATION_DURATION_PROP,
                animationDelay: ANIMATION_DELAY_PROP
            };
            function getCssDelayStyle(delay, isKeyframeAnimation) {
                return [ isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP, delay + "s" ];
            }
            function computeCssStyles($window, element, properties) {
                var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
                return forEach(properties, (function(formalStyleName, actualStyleName) {
                    var maxValue, values, val = detectedStyles[formalStyleName];
                    if (val) {
                        var c = val.charAt(0);
                        ("-" === c || "+" === c || c >= 0) && (maxValue = 0, values = val.split(/\s*,\s*/), 
                        forEach(values, (function(value) {
                            "s" === value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
                            value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
                        })), val = maxValue), 0 === val && (val = null), styles[actualStyleName] = val;
                    }
                })), styles;
            }
            function truthyTimingValue(val) {
                return 0 === val || null != val;
            }
            function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
                var style = TRANSITION_PROP, value = duration + "s";
                return applyOnlyDuration ? style += "Duration" : value += " linear all", [ style, value ];
            }
            function registerRestorableStyles(backup, node, properties) {
                forEach(properties, (function(prop) {
                    backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
                }));
            }
            var copy, extend, forEach, isArray, isDefined, isElement, isFunction, isObject, isString, isUndefined, jqLite, noop, $AnimateCssProvider = [ "$animateProvider", function($animateProvider) {
                this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$animateCache", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function($window, $$jqLite, $$AnimateRunner, $timeout, $$animateCache, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
                    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    var rafWaitQueue = [];
                    function waitUntilQuiet(callback) {
                        rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet((function() {
                            $$animateCache.flush();
                            for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                            rafWaitQueue.length = 0;
                        }));
                    }
                    function computeTimings(node, className, cacheKey, allowNoDuration) {
                        var timings = function(node, className, cacheKey, allowNoDuration, properties) {
                            var timings = $$animateCache.get(cacheKey);
                            timings || "infinite" === (timings = computeCssStyles($window, node, properties)).animationIterationCount && (timings.animationIterationCount = 1);
                            var hasDuration = allowNoDuration || timings.transitionDuration > 0 || timings.animationDuration > 0;
                            return $$animateCache.put(cacheKey, timings, hasDuration), timings;
                        }(node, 0, cacheKey, allowNoDuration, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                        return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), 
                        timings;
                    }
                    return function(element, initialOptions) {
                        var options = initialOptions || {};
                        options.$$prepared || (options = prepareAnimationOptions(copy(options)));
                        var restoreStyles = {}, node = getDomNode(element);
                        if (!node || !node.parentNode || !$$animateQueue.enabled()) return closeAndReturnNoopAnimator();
                        var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelay, maxDelayTime, maxDuration, maxDurationTime, startTime, temporaryStyles = [], styles = (element.attr("class"), 
                        function(options) {
                            var styles = {};
                            return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), 
                            styles;
                        }(options)), events = [];
                        if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
                        var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                        isStructural ? structuralClassName = pendClasses(method, "ng-", !0) : method && (structuralClassName = method), 
                        options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX)), 
                        options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), 
                        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)), options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
                        var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim(), hasToStyles = styles.to && Object.keys(styles.to).length > 0;
                        if (!((options.keyframeStyle || "").length > 0) && !hasToStyles && !preparationClasses) return closeAndReturnNoopAnimator();
                        var stagger, applyOnlyDuration, cacheKey = $$animateCache.cacheKey(node, method, options.addClass, options.removeClass);
                        if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) return preparationClasses = null, 
                        closeAndReturnNoopAnimator();
                        if (options.stagger > 0) {
                            var staggerVal = parseFloat(options.stagger);
                            stagger = {
                                transitionDelay: staggerVal,
                                animationDelay: staggerVal,
                                transitionDuration: 0,
                                animationDuration: 0
                            };
                        } else stagger = function(node, className, cacheKey, properties) {
                            var stagger, staggerCacheKey = "stagger-" + cacheKey;
                            if ($$animateCache.count(cacheKey) > 0 && !(stagger = $$animateCache.get(staggerCacheKey))) {
                                var staggerClassName = pendClasses(className, "-stagger");
                                $$jqLite.addClass(node, staggerClassName), (stagger = computeCssStyles($window, node, properties)).animationDuration = Math.max(stagger.animationDuration, 0), 
                                stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), $$jqLite.removeClass(node, staggerClassName), 
                                $$animateCache.put(staggerCacheKey, stagger, !0);
                            }
                            return stagger || {};
                        }(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                        if (options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses), 
                        options.transitionStyle) {
                            var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                            applyInlineStyle(node, transitionStyle), temporaryStyles.push(transitionStyle);
                        }
                        if (options.duration >= 0) {
                            applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                            var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                            applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle);
                        }
                        if (options.keyframeStyle) {
                            var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                            applyInlineStyle(node, keyframeStyle), temporaryStyles.push(keyframeStyle);
                        }
                        var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : $$animateCache.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                        isFirst && !options.skipBlocking && helpers_blockTransitions(node, 9999);
                        var timings = computeTimings(node, 0, cacheKey, !isStructural), relativeDelay = timings.maxDelay;
                        maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration;
                        var flags = {};
                        if (flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0, 
                        flags.hasTransitionAll = flags.hasTransitions && "all" === timings.transitionProperty, 
                        flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), 
                        flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), 
                        flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, 
                        flags.recalculateTimingStyles = addRemoveClassName.length > 0, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, 
                        flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, 
                        applyOnlyDuration = node.style[TRANSITION_PROP + "Property"].length > 0, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), 
                        flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, 
                        temporaryStyles.push([ ANIMATION_DURATION_PROP, maxDuration + "s" ]))), 0 === maxDuration && !flags.recalculateTimingStyles) return closeAndReturnNoopAnimator();
                        var delayStyle, activeClasses = pendClasses(preparationClasses, "-active");
                        null != options.delay && ("boolean" != typeof options.delay && (delayStyle = parseFloat(options.delay), 
                        maxDelay = Math.max(delayStyle, 0)), flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle)), 
                        flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, !0)));
                        return null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), 
                        maxDelayTime = 1e3 * maxDelay, maxDurationTime = 1e3 * maxDuration, options.skipBlocking || (flags.blockTransition = timings.transitionDuration > 0, 
                        flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration), 
                        options.from && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from)), 
                        applyAnimationFromStyles(element, options)), flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || helpers_blockTransitions(node, !1), 
                        {
                            $$willAnimate: !0,
                            end: endFn,
                            start: function() {
                                if (!animationClosed) return runner = new $$AnimateRunner(runnerHost = {
                                    end: endFn,
                                    cancel: cancelFn,
                                    resume: null,
                                    pause: null
                                }), waitUntilQuiet(start), runner;
                            }
                        };
                        function endFn() {
                            close();
                        }
                        function cancelFn() {
                            close(!0);
                        }
                        function close(rejected) {
                            if (!(animationClosed || animationCompleted && animationPaused)) {
                                animationClosed = !0, animationPaused = !1, preparationClasses && !options.$$skipPreparationClasses && $$jqLite.removeClass(element, preparationClasses), 
                                activeClasses && $$jqLite.removeClass(element, activeClasses), blockKeyframeAnimations(node, !1), 
                                helpers_blockTransitions(node, !1), forEach(temporaryStyles, (function(entry) {
                                    node.style[entry[0]] = "";
                                })), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                                Object.keys(restoreStyles).length && forEach(restoreStyles, (function(value, prop) {
                                    value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                                })), options.onDone && options.onDone(), events && events.length && element.off(events.join(" "), onAnimationProgress);
                                var animationTimerData = element.data("$$animateCss");
                                animationTimerData && ($timeout.cancel(animationTimerData[0].timer), element.removeData("$$animateCss")), 
                                runner && runner.complete(!rejected);
                            }
                        }
                        function applyBlocking(duration) {
                            flags.blockTransition && helpers_blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration);
                        }
                        function closeAndReturnNoopAnimator() {
                            return runner = new $$AnimateRunner({
                                end: endFn,
                                cancel: cancelFn
                            }), waitUntilQuiet(noop), close(), {
                                $$willAnimate: !1,
                                start: function() {
                                    return runner;
                                },
                                end: endFn
                            };
                        }
                        function onAnimationProgress(event) {
                            event.stopPropagation();
                            var ev = event.originalEvent || event;
                            if (ev.target === node) {
                                var timeStamp = ev.$manualTimeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                                Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && (animationCompleted = !0, 
                                close());
                            }
                        }
                        function start() {
                            if (!animationClosed) if (node.parentNode) {
                                var playPause = function(playAnimation) {
                                    if (animationCompleted) animationPaused && playAnimation && (animationPaused = !1, 
                                    close()); else if (animationPaused = !playAnimation, timings.animationDuration) {
                                        var value = blockKeyframeAnimations(node, animationPaused);
                                        animationPaused ? temporaryStyles.push(value) : (val = value, index = (arr = temporaryStyles).indexOf(val), 
                                        val >= 0 && arr.splice(index, 1));
                                    }
                                    var arr, val, index;
                                }, maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                                maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * 1e3), !1) : triggerAnimationStart(), 
                                runnerHost.resume = function() {
                                    playPause(!0);
                                }, runnerHost.pause = function() {
                                    playPause(!1);
                                };
                            } else close();
                            function triggerAnimationStart() {
                                if (!animationClosed) {
                                    if (applyBlocking(!1), forEach(temporaryStyles, (function(entry) {
                                        var key = entry[0], value = entry[1];
                                        node.style[key] = value;
                                    })), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), 
                                    flags.recalculateTimingStyles) {
                                        if (node.getAttribute("class") + " " + preparationClasses, cacheKey = $$animateCache.cacheKey(node, method, options.addClass, options.removeClass), 
                                        timings = computeTimings(node, 0, cacheKey, !1), relativeDelay = timings.maxDelay, 
                                        maxDelay = Math.max(relativeDelay, 0), 0 === (maxDuration = timings.maxDuration)) return void close();
                                        flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0;
                                    }
                                    if (flags.applyAnimationDelay && (relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, 
                                    maxDelay = Math.max(relativeDelay, 0), timings.animationDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay, !0), 
                                    temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), maxDelayTime = 1e3 * maxDelay, 
                                    maxDurationTime = 1e3 * maxDuration, options.easing) {
                                        var easeProp, easeVal = options.easing;
                                        flags.hasTransitions && (easeProp = TRANSITION_PROP + "TimingFunction", temporaryStyles.push([ easeProp, easeVal ]), 
                                        node.style[easeProp] = easeVal), flags.hasAnimations && (easeProp = ANIMATION_PROP + "TimingFunction", 
                                        temporaryStyles.push([ easeProp, easeVal ]), node.style[easeProp] = easeVal);
                                    }
                                    timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), 
                                    startTime = Date.now();
                                    var timerTime = maxDelayTime + 1.5 * maxDurationTime, endTime = startTime + timerTime, animationsData = element.data("$$animateCss") || [], setupFallbackTimer = !0;
                                    if (animationsData.length) {
                                        var currentTimerData = animationsData[0];
                                        (setupFallbackTimer = endTime > currentTimerData.expectedEndTime) ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close);
                                    }
                                    if (setupFallbackTimer) {
                                        var timer = $timeout(onAnimationExpired, timerTime, !1);
                                        animationsData[0] = {
                                            timer,
                                            expectedEndTime: endTime
                                        }, animationsData.push(close), element.data("$$animateCss", animationsData);
                                    }
                                    events.length && element.on(events.join(" "), onAnimationProgress), options.to && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to)), 
                                    applyAnimationToStyles(element, options));
                                }
                            }
                            function onAnimationExpired() {
                                var animationsData = element.data("$$animateCss");
                                if (animationsData) {
                                    for (var i = 1; i < animationsData.length; i++) animationsData[i]();
                                    element.removeData("$$animateCss");
                                }
                            }
                        }
                    };
                } ];
            } ], $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
                $$animationProvider.drivers.push("$$animateCssDriver");
                this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
                    if (!$sniffer.animations && !$sniffer.transitions) return noop;
                    var node, bodyNode = $document[0].body, rootNode = getDomNode($rootElement), rootBodyElement = jqLite((node = rootNode).parentNode && 11 === node.parentNode.nodeType || bodyNode.contains(rootNode) ? rootNode : bodyNode);
                    return function(animationDetails) {
                        return animationDetails.from && animationDetails.to ? function(from, to, classes, anchors) {
                            var fromAnimation = prepareRegularAnimation(from), toAnimation = prepareRegularAnimation(to), anchorAnimations = [];
                            if (forEach(anchors, (function(anchor) {
                                var animator = function(classes, outAnchor, inAnchor) {
                                    var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                                    outAnchor.addClass("ng-animate-shim"), inAnchor.addClass("ng-animate-shim"), clone.addClass("ng-anchor"), 
                                    rootBodyElement.append(clone);
                                    var animatorIn, animatorOut = prepareOutAnimation();
                                    if (!animatorOut && !(animatorIn = prepareInAnimation())) return end();
                                    var startingAnimator = animatorOut || animatorIn;
                                    return {
                                        start: function() {
                                            var runner, currentAnimation = startingAnimator.start();
                                            return currentAnimation.done((function() {
                                                if (currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation())) return (currentAnimation = animatorIn.start()).done((function() {
                                                    currentAnimation = null, end(), runner.complete();
                                                })), currentAnimation;
                                                end(), runner.complete();
                                            })), runner = new $$AnimateRunner({
                                                end: endFn,
                                                cancel: endFn
                                            });
                                            function endFn() {
                                                currentAnimation && currentAnimation.end();
                                            }
                                        }
                                    };
                                    function calculateAnchorStyles(anchor) {
                                        var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                                        return forEach([ "width", "height", "top", "left" ], (function(key) {
                                            var value = coords[key];
                                            switch (key) {
                                              case "top":
                                                value += bodyNode.scrollTop;
                                                break;

                                              case "left":
                                                value += bodyNode.scrollLeft;
                                            }
                                            styles[key] = Math.floor(value) + "px";
                                        })), styles;
                                    }
                                    function prepareOutAnimation() {
                                        var animator = $animateCss(clone, {
                                            addClass: "ng-anchor-out",
                                            delay: !0,
                                            from: calculateAnchorStyles(outAnchor)
                                        });
                                        return animator.$$willAnimate ? animator : null;
                                    }
                                    function getClassVal(element) {
                                        return element.attr("class") || "";
                                    }
                                    function prepareInAnimation() {
                                        var endingClasses = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(endingClasses, startingClasses), toRemove = getUniqueValues(startingClasses, endingClasses), animator = $animateCss(clone, {
                                            to: calculateAnchorStyles(inAnchor),
                                            addClass: "ng-anchor-in " + toAdd,
                                            removeClass: "ng-anchor-out " + toRemove,
                                            delay: !0
                                        });
                                        return animator.$$willAnimate ? animator : null;
                                    }
                                    function end() {
                                        clone.remove(), outAnchor.removeClass("ng-animate-shim"), inAnchor.removeClass("ng-animate-shim");
                                    }
                                }(0, anchor.out, anchor.in);
                                animator && anchorAnimations.push(animator);
                            })), !fromAnimation && !toAnimation && 0 === anchorAnimations.length) return;
                            return {
                                start: function() {
                                    var animationRunners = [];
                                    fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                                    forEach(anchorAnimations, (function(animation) {
                                        animationRunners.push(animation.start());
                                    }));
                                    var runner = new $$AnimateRunner({
                                        end: endFn,
                                        cancel: endFn
                                    });
                                    return $$AnimateRunner.all(animationRunners, (function(status) {
                                        runner.complete(status);
                                    })), runner;
                                    function endFn() {
                                        forEach(animationRunners, (function(runner) {
                                            runner.end();
                                        }));
                                    }
                                }
                            };
                        }(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
                    };
                    function filterCssClasses(classes) {
                        return classes.replace(/\bng-\S+\b/g, "");
                    }
                    function getUniqueValues(a, b) {
                        return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter((function(val) {
                            return -1 === b.indexOf(val);
                        })).join(" ");
                    }
                    function prepareRegularAnimation(animationDetails) {
                        var element = animationDetails.element, options = animationDetails.options || {};
                        animationDetails.structural && (options.event = animationDetails.event, options.structural = !0, 
                        options.applyClassesEarly = !0, "leave" === animationDetails.event && (options.onDone = options.domOperation)), 
                        options.preparationClasses && (options.event = concatWithSpace(options.event, options.preparationClasses));
                        var animator = $animateCss(element, options);
                        return animator.$$willAnimate ? animator : null;
                    }
                } ];
            } ], $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
                this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
                    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    return function(element, event, classes, options) {
                        var animationClosed = !1;
                        3 === arguments.length && isObject(classes) && (options = classes, classes = null), 
                        options = prepareAnimationOptions(options), classes || (classes = element.attr("class") || "", 
                        options.addClass && (classes += " " + options.addClass), options.removeClass && (classes += " " + options.removeClass));
                        var before, after, afterFn, beforeFn, runner, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = function(classes) {
                            classes = isArray(classes) ? classes : classes.split(" ");
                            for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                                var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                                animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), 
                                flagMap[klass] = !0);
                            }
                            return matches;
                        }(classes);
                        animations.length && ("leave" === event ? (beforeFn = "leave", afterFn = "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), 
                        afterFn = event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), 
                        after = packageAnimations(element, event, options, animations, afterFn));
                        if (before || after) return {
                            $$willAnimate: !0,
                            end: function() {
                                return runner ? runner.end() : (close(), (runner = new $$AnimateRunner).complete(!0)), 
                                runner;
                            },
                            start: function() {
                                if (runner) return runner;
                                var closeActiveAnimations;
                                runner = new $$AnimateRunner;
                                var chain = [];
                                return before && chain.push((function(fn) {
                                    closeActiveAnimations = before(fn);
                                })), chain.length ? chain.push((function(fn) {
                                    applyOptions(), fn(!0);
                                })) : applyOptions(), after && chain.push((function(fn) {
                                    closeActiveAnimations = after(fn);
                                })), runner.setHost({
                                    end: function() {
                                        endAnimations();
                                    },
                                    cancel: function() {
                                        endAnimations(!0);
                                    }
                                }), $$AnimateRunner.chain(chain, onComplete), runner;
                                function onComplete(success) {
                                    close(), runner.complete(success);
                                }
                                function endAnimations(cancelled) {
                                    animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled));
                                }
                            }
                        };
                        function applyOptions() {
                            options.domOperation(), applyAnimationClasses(element, options);
                        }
                        function close() {
                            animationClosed = !0, applyOptions(), applyAnimationStyles(element, options);
                        }
                        function groupEventedAnimations(element, event, options, animations, fnName) {
                            var operations = [];
                            return forEach(animations, (function(ani) {
                                var animation = ani[fnName];
                                animation && operations.push((function() {
                                    var runner, endProgressCb, resolved = !1, onAnimationComplete = function(rejected) {
                                        resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected));
                                    };
                                    return runner = new $$AnimateRunner({
                                        end: function() {
                                            onAnimationComplete();
                                        },
                                        cancel: function() {
                                            onAnimationComplete(!0);
                                        }
                                    }), endProgressCb = function(fn, element, event, options, onDone) {
                                        var args;
                                        switch (event) {
                                          case "animate":
                                            args = [ element, options.from, options.to, onDone ];
                                            break;

                                          case "setClass":
                                            args = [ element, classesToAdd, classesToRemove, onDone ];
                                            break;

                                          case "addClass":
                                            args = [ element, classesToAdd, onDone ];
                                            break;

                                          case "removeClass":
                                            args = [ element, classesToRemove, onDone ];
                                            break;

                                          default:
                                            args = [ element, onDone ];
                                        }
                                        args.push(options);
                                        var value = fn.apply(fn, args);
                                        if (value) if (isFunction(value.start) && (value = value.start()), value instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value)) return value;
                                        return noop;
                                    }(animation, element, event, options, (function(result) {
                                        onAnimationComplete(!1 === result);
                                    })), runner;
                                }));
                            })), operations;
                        }
                        function packageAnimations(element, event, options, animations, fnName) {
                            var a, b, operations = groupEventedAnimations(element, event, options, animations, fnName);
                            0 === operations.length && ("beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), 
                            b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), 
                            b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), 
                            a && (operations = operations.concat(a)), b && (operations = operations.concat(b)));
                            if (0 !== operations.length) return function(callback) {
                                var runners = [];
                                return operations.length && forEach(operations, (function(animateFn) {
                                    runners.push(animateFn());
                                })), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function(reject) {
                                    forEach(runners, (function(runner) {
                                        reject ? runner.cancel() : runner.end();
                                    }));
                                };
                            };
                        }
                    };
                } ];
            } ], $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
                $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
                    return function(animationDetails) {
                        if (animationDetails.from && animationDetails.to) {
                            var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                            if (!fromAnimation && !toAnimation) return;
                            return {
                                start: function() {
                                    var animationRunners = [];
                                    fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                                    $$AnimateRunner.all(animationRunners, (function(status) {
                                        runner.complete(status);
                                    }));
                                    var runner = new $$AnimateRunner({
                                        end: endFnFactory(),
                                        cancel: endFnFactory()
                                    });
                                    return runner;
                                    function endFnFactory() {
                                        return function() {
                                            forEach(animationRunners, (function(runner) {
                                                runner.end();
                                            }));
                                        };
                                    }
                                }
                            };
                        }
                        return prepareAnimation(animationDetails);
                    };
                    function prepareAnimation(animationDetails) {
                        var element = animationDetails.element, event = animationDetails.event, options = animationDetails.options, classes = animationDetails.classes;
                        return $$animateJs(element, event, classes, options);
                    }
                } ];
            } ], $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
                var ONE_SPACE = " ", rules = this.rules = {
                    skip: [],
                    cancel: [],
                    join: []
                };
                function getEventData(options) {
                    return {
                        addClass: options.addClass,
                        removeClass: options.removeClass,
                        from: options.from,
                        to: options.to
                    };
                }
                function hasMatchingClasses(newClassString, currentClassString) {
                    if (newClassString && currentClassString) {
                        var currentClassMap = function(classString) {
                            if (!classString) return null;
                            var keys = classString.split(ONE_SPACE), map = Object.create(null);
                            return forEach(keys, (function(key) {
                                map[key] = !0;
                            })), map;
                        }(currentClassString);
                        return newClassString.split(ONE_SPACE).some((function(className) {
                            return currentClassMap[className];
                        }));
                    }
                }
                function isAllowed(ruleType, currentAnimation, previousAnimation) {
                    return rules[ruleType].some((function(fn) {
                        return fn(currentAnimation, previousAnimation);
                    }));
                }
                function hasAnimationClasses(animation, and) {
                    var a = (animation.addClass || "").length > 0, b = (animation.removeClass || "").length > 0;
                    return and ? a && b : a || b;
                }
                rules.join.push((function(newAnimation, currentAnimation) {
                    return !newAnimation.structural && hasAnimationClasses(newAnimation);
                })), rules.skip.push((function(newAnimation, currentAnimation) {
                    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
                })), rules.skip.push((function(newAnimation, currentAnimation) {
                    return "leave" === currentAnimation.event && newAnimation.structural;
                })), rules.skip.push((function(newAnimation, currentAnimation) {
                    return currentAnimation.structural && 2 === currentAnimation.state && !newAnimation.structural;
                })), rules.cancel.push((function(newAnimation, currentAnimation) {
                    return currentAnimation.structural && newAnimation.structural;
                })), rules.cancel.push((function(newAnimation, currentAnimation) {
                    return 2 === currentAnimation.state && newAnimation.structural;
                })), rules.cancel.push((function(newAnimation, currentAnimation) {
                    if (currentAnimation.structural) return !1;
                    var nA = newAnimation.addClass, nR = newAnimation.removeClass, cA = currentAnimation.addClass, cR = currentAnimation.removeClass;
                    return !(isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) && (hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA));
                })), this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function($$rAF, $rootScope, $rootElement, $document, $$Map, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden) {
                    var activeAnimationsLookup = new $$Map, disabledElementsLookup = new $$Map, animationsEnabled = null;
                    function removeFromDisabledElementsLookup(evt) {
                        disabledElementsLookup.delete(evt.target);
                    }
                    var deregisterWatch = $rootScope.$watch((function() {
                        return 0 === $templateRequest.totalPendingRequests;
                    }), (function(isEmpty) {
                        isEmpty && (deregisterWatch(), $rootScope.$$postDigest((function() {
                            $rootScope.$$postDigest((function() {
                                null === animationsEnabled && (animationsEnabled = !0);
                            }));
                        })));
                    })), callbackRegistry = Object.create(null), customFilter = $animateProvider.customFilter(), classNameFilter = $animateProvider.classNameFilter(), returnTrue = function() {
                        return !0;
                    }, isAnimatableByFilter = customFilter || returnTrue, isAnimatableClassName = classNameFilter ? function(node, options) {
                        var className = [ node.getAttribute("class"), options.addClass, options.removeClass ].join(" ");
                        return classNameFilter.test(className);
                    } : returnTrue, applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    function normalizeAnimationDetails(element, animation) {
                        return mergeAnimationDetails(element, animation, {});
                    }
                    var contains = window.Node.prototype.contains || function(arg) {
                        return this === arg || !!(16 & this.compareDocumentPosition(arg));
                    };
                    function filterFromRegistry(list, matchContainer, matchCallback) {
                        var containerNode = extractElementNode(matchContainer);
                        return list.filter((function(entry) {
                            return !(entry.node === containerNode && (!matchCallback || entry.callback === matchCallback));
                        }));
                    }
                    function cleanupEventListeners(phase, node) {
                        "close" !== phase || node.parentNode || $animate.off(node);
                    }
                    var $animate = {
                        on: function(event, container, callback) {
                            var node = extractElementNode(container);
                            callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                                node,
                                callback
                            }), jqLite(container).on("$destroy", (function() {
                                activeAnimationsLookup.get(node) || $animate.off(event, container, callback);
                            }));
                        },
                        off: function(event, container, callback) {
                            if (1 !== arguments.length || isString(arguments[0])) {
                                var entries = callbackRegistry[event];
                                entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback));
                            } else for (var eventType in container = arguments[0], callbackRegistry) callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                        },
                        pin: function(element, parentElement) {
                            assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), 
                            element.data("$ngAnimatePin", parentElement);
                        },
                        push: function(element, event, options, domOperation) {
                            return (options = options || {}).domOperation = domOperation, function(originalElement, event, initialOptions) {
                                var options = copy(initialOptions), element = stripCommentsFromElement(originalElement), node = getDomNode(element), parentNode = node && node.parentNode;
                                options = prepareAnimationOptions(options);
                                var runner = new $$AnimateRunner, runInNextPostDigestOrNow = (postDigestCalled = !1, 
                                function(fn) {
                                    postDigestCalled ? fn() : $rootScope.$$postDigest((function() {
                                        postDigestCalled = !0, fn();
                                    }));
                                });
                                var postDigestCalled;
                                isArray(options.addClass) && (options.addClass = options.addClass.join(" "));
                                options.addClass && !isString(options.addClass) && (options.addClass = null);
                                isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" "));
                                options.removeClass && !isString(options.removeClass) && (options.removeClass = null);
                                options.from && !isObject(options.from) && (options.from = null);
                                options.to && !isObject(options.to) && (options.to = null);
                                if (!(animationsEnabled && node && isAnimatableByFilter(node, event, initialOptions) && isAnimatableClassName(node, options))) return close(), 
                                runner;
                                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, documentHidden = $$isDocumentHidden(), skipAnimations = documentHidden || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                                skipAnimations || hasExistingAnimation && 1 === existingAnimation.state || (skipAnimations = !function(node, parentNode) {
                                    var animateChildren, bodyNode = $document[0].body, rootNode = getDomNode($rootElement), bodyNodeDetected = node === bodyNode || "HTML" === node.nodeName, rootNodeDetected = node === rootNode, parentAnimationDetected = !1, elementDisabled = disabledElementsLookup.get(node), parentHost = jqLite.data(node, "$ngAnimatePin");
                                    parentHost && (parentNode = getDomNode(parentHost));
                                    for (;parentNode && (rootNodeDetected || (rootNodeDetected = parentNode === rootNode), 
                                    parentNode.nodeType === ELEMENT_NODE); ) {
                                        var details = activeAnimationsLookup.get(parentNode) || {};
                                        if (!parentAnimationDetected) {
                                            var parentNodeDisabled = disabledElementsLookup.get(parentNode);
                                            if (!0 === parentNodeDisabled && !1 !== elementDisabled) {
                                                elementDisabled = !0;
                                                break;
                                            }
                                            !1 === parentNodeDisabled && (elementDisabled = !1), parentAnimationDetected = details.structural;
                                        }
                                        if (isUndefined(animateChildren) || !0 === animateChildren) {
                                            var value = jqLite.data(parentNode, "$$ngAnimateChildren");
                                            isDefined(value) && (animateChildren = value);
                                        }
                                        if (parentAnimationDetected && !1 === animateChildren) break;
                                        if (bodyNodeDetected || (bodyNodeDetected = parentNode === bodyNode), bodyNodeDetected && rootNodeDetected) break;
                                        parentNode = rootNodeDetected || !(parentHost = jqLite.data(parentNode, "$ngAnimatePin")) ? parentNode.parentNode : getDomNode(parentHost);
                                    }
                                    return (!parentAnimationDetected || animateChildren) && !0 !== elementDisabled && rootNodeDetected && bodyNodeDetected;
                                }(node, parentNode));
                                if (skipAnimations) return documentHidden && notifyProgress(runner, event, "start", getEventData(options)), 
                                close(), documentHidden && notifyProgress(runner, event, "close", getEventData(options)), 
                                runner;
                                isStructural && function(node) {
                                    var children = node.querySelectorAll("[data-ng-animate]");
                                    forEach(children, (function(child) {
                                        var state = parseInt(child.getAttribute("data-ng-animate"), 10), animationDetails = activeAnimationsLookup.get(child);
                                        if (animationDetails) switch (state) {
                                          case 2:
                                            animationDetails.runner.end();

                                          case 1:
                                            activeAnimationsLookup.delete(child);
                                        }
                                    }));
                                }(node);
                                var newAnimation = {
                                    structural: isStructural,
                                    element,
                                    event,
                                    addClass: options.addClass,
                                    removeClass: options.removeClass,
                                    close,
                                    options,
                                    runner
                                };
                                if (hasExistingAnimation) {
                                    if (isAllowed("skip", newAnimation, existingAnimation)) return 2 === existingAnimation.state ? (close(), 
                                    runner) : (mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner);
                                    if (isAllowed("cancel", newAnimation, existingAnimation)) if (2 === existingAnimation.state) existingAnimation.runner.end(); else {
                                        if (!existingAnimation.structural) return mergeAnimationDetails(element, existingAnimation, newAnimation), 
                                        existingAnimation.runner;
                                        existingAnimation.close();
                                    } else if (isAllowed("join", newAnimation, existingAnimation)) {
                                        if (2 !== existingAnimation.state) return function($$jqLite, element, event, options) {
                                            var classes = "";
                                            event && (classes = pendClasses(event, "ng-", !0)), options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX))), 
                                            options.removeClass && (classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX))), 
                                            classes.length && (options.preparationClasses = classes, element.addClass(classes));
                                        }(0, element, isStructural ? event : null, options), event = newAnimation.event = existingAnimation.event, 
                                        options = mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner;
                                        normalizeAnimationDetails(element, newAnimation);
                                    }
                                } else normalizeAnimationDetails(element, newAnimation);
                                var isValidAnimation = newAnimation.structural;
                                isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation));
                                if (!isValidAnimation) return close(), clearElementAnimationState(node), runner;
                                var counter = (existingAnimation.counter || 0) + 1;
                                return newAnimation.counter = counter, markElementAnimationState(node, 1, newAnimation), 
                                $rootScope.$$postDigest((function() {
                                    element = stripCommentsFromElement(originalElement);
                                    var animationDetails = activeAnimationsLookup.get(node), animationCancelled = !animationDetails;
                                    animationDetails = animationDetails || {};
                                    var isValidAnimation = (element.parent() || []).length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails));
                                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) return animationCancelled && (applyAnimationClasses(element, options), 
                                    applyAnimationStyles(element, options)), (animationCancelled || isStructural && animationDetails.event !== event) && (options.domOperation(), 
                                    runner.end()), void (isValidAnimation || clearElementAnimationState(node));
                                    event = !animationDetails.structural && hasAnimationClasses(animationDetails, !0) ? "setClass" : animationDetails.event, 
                                    markElementAnimationState(node, 2);
                                    var realRunner = $$animation(element, event, animationDetails.options);
                                    runner.setHost(realRunner), notifyProgress(runner, event, "start", getEventData(options)), 
                                    realRunner.done((function(status) {
                                        close(!status);
                                        var animationDetails = activeAnimationsLookup.get(node);
                                        animationDetails && animationDetails.counter === counter && clearElementAnimationState(node), 
                                        notifyProgress(runner, event, "close", getEventData(options));
                                    }));
                                })), runner;
                                function notifyProgress(runner, event, phase, data) {
                                    runInNextPostDigestOrNow((function() {
                                        var callbacks = function(targetParentNode, targetNode, event) {
                                            var matches = [], entries = callbackRegistry[event];
                                            return entries && forEach(entries, (function(entry) {
                                                (contains.call(entry.node, targetNode) || "leave" === event && contains.call(entry.node, targetParentNode)) && matches.push(entry.callback);
                                            })), matches;
                                        }(parentNode, node, event);
                                        callbacks.length ? $$rAF((function() {
                                            forEach(callbacks, (function(callback) {
                                                callback(element, phase, data);
                                            })), cleanupEventListeners(phase, node);
                                        })) : cleanupEventListeners(phase, node);
                                    })), runner.progress(event, phase, data);
                                }
                                function close(reject) {
                                    !function(element, options) {
                                        options.preparationClasses && (element.removeClass(options.preparationClasses), 
                                        options.preparationClasses = null), options.activeClasses && (element.removeClass(options.activeClasses), 
                                        options.activeClasses = null);
                                    }(element, options), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                                    options.domOperation(), runner.complete(!reject);
                                }
                            }(element, event, options);
                        },
                        enabled: function(element, bool) {
                            var argCount = arguments.length;
                            if (0 === argCount) bool = !!animationsEnabled; else if (isElement(element)) {
                                var node = getDomNode(element);
                                1 === argCount ? bool = !disabledElementsLookup.get(node) : (disabledElementsLookup.has(node) || jqLite(element).on("$destroy", removeFromDisabledElementsLookup), 
                                disabledElementsLookup.set(node, !bool));
                            } else bool = animationsEnabled = !!element;
                            return bool;
                        }
                    };
                    return $animate;
                    function clearElementAnimationState(node) {
                        node.removeAttribute("data-ng-animate"), activeAnimationsLookup.delete(node);
                    }
                    function markElementAnimationState(node, state, details) {
                        (details = details || {}).state = state, node.setAttribute("data-ng-animate", state);
                        var oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, details) : details;
                        activeAnimationsLookup.set(node, newValue);
                    }
                } ];
            } ], $$AnimationProvider = [ "$animateProvider", function($animateProvider) {
                var drivers = this.drivers = [];
                function getRunner(element) {
                    return element.data("$$animationRunner");
                }
                this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", "$$animateCache", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler, $$animateCache) {
                    var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                    return function(element, event, options) {
                        options = prepareAnimationOptions(options);
                        var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, runner = new $$AnimateRunner({
                            end: function() {
                                close();
                            },
                            cancel: function() {
                                close(!0);
                            }
                        });
                        if (!drivers.length) return close(), runner;
                        var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                        return tempClasses && (classes += " " + tempClasses, options.tempClasses = null), 
                        isStructural && element.data("$$animatePrepareClasses", "ng-" + event + "-prepare"), 
                        function(element, runner) {
                            element.data("$$animationRunner", runner);
                        }(element, runner), animationQueue.push({
                            element,
                            classes,
                            event,
                            structural: isStructural,
                            options,
                            beforeStart: function() {
                                tempClasses = (tempClasses ? tempClasses + " " : "") + "ng-animate", $$jqLite.addClass(element, tempClasses);
                                var prepareClassName = element.data("$$animatePrepareClasses");
                                prepareClassName && ($$jqLite.removeClass(element, prepareClassName), prepareClassName = null);
                            },
                            close
                        }), element.on("$destroy", handleDestroyedElement), animationQueue.length > 1 || $rootScope.$$postDigest((function() {
                            var animations = [];
                            forEach(animationQueue, (function(entry) {
                                getRunner(entry.element) ? animations.push(entry) : entry.close();
                            })), animationQueue.length = 0;
                            var groupedAnimations = function(animations) {
                                var preparedAnimations = [], refLookup = {};
                                forEach(animations, (function(animation, index) {
                                    var node = getDomNode(animation.element), event = animation.event, enterOrMove = [ "enter", "move" ].indexOf(event) >= 0, anchorNodes = animation.structural ? function(node) {
                                        var SELECTOR = "[ng-animate-ref]", items = node.hasAttribute("ng-animate-ref") ? [ node ] : node.querySelectorAll(SELECTOR), anchors = [];
                                        return forEach(items, (function(node) {
                                            var attr = node.getAttribute("ng-animate-ref");
                                            attr && attr.length && anchors.push(node);
                                        })), anchors;
                                    }(node) : [];
                                    if (anchorNodes.length) {
                                        var direction = enterOrMove ? "to" : "from";
                                        forEach(anchorNodes, (function(anchor) {
                                            var key = anchor.getAttribute("ng-animate-ref");
                                            refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                                animationID: index,
                                                element: jqLite(anchor)
                                            };
                                        }));
                                    } else preparedAnimations.push(animation);
                                }));
                                var usedIndicesLookup = {}, anchorGroups = {};
                                return forEach(refLookup, (function(operations, key) {
                                    var from = operations.from, to = operations.to;
                                    if (from && to) {
                                        var fromAnimation = animations[from.animationID], toAnimation = animations[to.animationID], lookupKey = from.animationID.toString();
                                        if (!anchorGroups[lookupKey]) {
                                            var group = anchorGroups[lookupKey] = {
                                                structural: !0,
                                                beforeStart: function() {
                                                    fromAnimation.beforeStart(), toAnimation.beforeStart();
                                                },
                                                close: function() {
                                                    fromAnimation.close(), toAnimation.close();
                                                },
                                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                                from: fromAnimation,
                                                to: toAnimation,
                                                anchors: []
                                            };
                                            group.classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), 
                                            preparedAnimations.push(toAnimation));
                                        }
                                        anchorGroups[lookupKey].anchors.push({
                                            out: from.element,
                                            in: to.element
                                        });
                                    } else {
                                        var index = from ? from.animationID : to.animationID, indexKey = index.toString();
                                        usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, preparedAnimations.push(animations[index]));
                                    }
                                })), preparedAnimations;
                            }(animations), toBeSortedAnimations = [];
                            forEach(groupedAnimations, (function(animationEntry) {
                                var element = animationEntry.from ? animationEntry.from.element : animationEntry.element, extraClasses = options.addClass;
                                extraClasses = (extraClasses ? extraClasses + " " : "") + "ng-animate";
                                var cacheKey = $$animateCache.cacheKey(element[0], animationEntry.event, extraClasses, options.removeClass);
                                toBeSortedAnimations.push({
                                    element,
                                    domNode: getDomNode(element),
                                    fn: function() {
                                        var startAnimationFn, closeFn = animationEntry.close;
                                        if ($$animateCache.containsCachedAnimationWithoutDuration(cacheKey)) closeFn(); else {
                                            if (animationEntry.beforeStart(), getRunner(animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element)) {
                                                var operation = function(animationDetails) {
                                                    for (var i = drivers.length - 1; i >= 0; i--) {
                                                        var driverName = drivers[i], driver = $injector.get(driverName)(animationDetails);
                                                        if (driver) return driver;
                                                    }
                                                }(animationEntry);
                                                operation && (startAnimationFn = operation.start);
                                            }
                                            if (startAnimationFn) {
                                                var animationRunner = startAnimationFn();
                                                animationRunner.done((function(status) {
                                                    closeFn(!status);
                                                })), function(animation, newRunner) {
                                                    animation.from && animation.to ? (update(animation.from.element), update(animation.to.element)) : update(animation.element);
                                                    function update(element) {
                                                        var runner = getRunner(element);
                                                        runner && runner.setHost(newRunner);
                                                    }
                                                }(animationEntry, animationRunner);
                                            } else closeFn();
                                        }
                                    }
                                });
                            }));
                            for (var finalAnimations = function(animations) {
                                var i, tree = {
                                    children: []
                                }, lookup = new $$Map;
                                for (i = 0; i < animations.length; i++) {
                                    var animation = animations[i];
                                    lookup.set(animation.domNode, animations[i] = {
                                        domNode: animation.domNode,
                                        element: animation.element,
                                        fn: animation.fn,
                                        children: []
                                    });
                                }
                                for (i = 0; i < animations.length; i++) processNode(animations[i]);
                                return function(tree) {
                                    var i, result = [], queue = [];
                                    for (i = 0; i < tree.children.length; i++) queue.push(tree.children[i]);
                                    var remainingLevelEntries = queue.length, nextLevelEntries = 0, row = [];
                                    for (i = 0; i < queue.length; i++) {
                                        var entry = queue[i];
                                        remainingLevelEntries <= 0 && (remainingLevelEntries = nextLevelEntries, nextLevelEntries = 0, 
                                        result.push(row), row = []), row.push(entry), entry.children.forEach((function(childEntry) {
                                            nextLevelEntries++, queue.push(childEntry);
                                        })), remainingLevelEntries--;
                                    }
                                    return row.length && result.push(row), result;
                                }(tree);
                                function processNode(entry) {
                                    if (entry.processed) return entry;
                                    entry.processed = !0;
                                    var parentEntry, elementNode = entry.domNode, parentNode = elementNode.parentNode;
                                    for (lookup.set(elementNode, entry); parentNode; ) {
                                        if (parentEntry = lookup.get(parentNode)) {
                                            parentEntry.processed || (parentEntry = processNode(parentEntry));
                                            break;
                                        }
                                        parentNode = parentNode.parentNode;
                                    }
                                    return (parentEntry || tree).children.push(entry), entry;
                                }
                            }(toBeSortedAnimations), i = 0; i < finalAnimations.length; i++) for (var innerArray = finalAnimations[i], j = 0; j < innerArray.length; j++) {
                                var entry = innerArray[j], element = entry.element;
                                if (finalAnimations[i][j] = entry.fn, 0 !== i) {
                                    var prepareClassName = element.data("$$animatePrepareClasses");
                                    prepareClassName && $$jqLite.addClass(element, prepareClassName);
                                } else element.removeData("$$animatePrepareClasses");
                            }
                            $$rAFScheduler(finalAnimations);
                        })), runner;
                        function cssClassesIntersection(a, b) {
                            a = a.split(" "), b = b.split(" ");
                            for (var matches = [], i = 0; i < a.length; i++) {
                                var aa = a[i];
                                if ("ng-" !== aa.substring(0, 3)) for (var j = 0; j < b.length; j++) if (aa === b[j]) {
                                    matches.push(aa);
                                    break;
                                }
                            }
                            return matches.join(" ");
                        }
                        function handleDestroyedElement() {
                            var runner = getRunner(element);
                            !runner || "leave" === event && options.$$domOperationFired || runner.end();
                        }
                        function close(rejected) {
                            element.off("$destroy", handleDestroyedElement), function(element) {
                                element.removeData("$$animationRunner");
                            }(element), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                            options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), 
                            runner.complete(!rejected);
                        }
                    };
                } ];
            } ];
            angular.module("ngAnimate", [], (function() {
                noop = angular.noop, copy = angular.copy, extend = angular.extend, jqLite = angular.element, 
                forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, 
                isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, 
                isFunction = angular.isFunction, isElement = angular.isElement;
            })).info({
                angularVersion: "1.8.3"
            }).directive("ngAnimateSwap", [ "$animate", function($animate) {
                return {
                    restrict: "A",
                    transclude: "element",
                    terminal: !0,
                    priority: 550,
                    link: function(scope, $element, attrs, ctrl, $transclude) {
                        var previousElement, previousScope;
                        scope.$watchCollection(attrs.ngAnimateSwap || attrs.for, (function(value) {
                            previousElement && $animate.leave(previousElement), previousScope && (previousScope.$destroy(), 
                            previousScope = null), (value || 0 === value) && $transclude((function(clone, childScope) {
                                previousElement = clone, previousScope = childScope, $animate.enter(clone, null, $element);
                            }));
                        }));
                    }
                };
            } ]).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", [ "$$rAF", function($$rAF) {
                var queue, cancelFn;
                function scheduler(tasks) {
                    queue = queue.concat(tasks), nextTick();
                }
                return queue = scheduler.queue = [], scheduler.waitUntilQuiet = function(fn) {
                    cancelFn && cancelFn(), cancelFn = $$rAF((function() {
                        cancelFn = null, fn(), nextTick();
                    }));
                }, scheduler;
                function nextTick() {
                    if (queue.length) {
                        for (var items = queue.shift(), i = 0; i < items.length; i++) items[i]();
                        cancelFn || $$rAF((function() {
                            cancelFn || nextTick();
                        }));
                    }
                }
            } ]).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animateCache", (function() {
                var KEY = "$$ngAnimateParentKey", parentCounter = 0, cache = Object.create(null);
                this.$get = [ function() {
                    return {
                        cacheKey: function(node, method, addClass, removeClass) {
                            var parentNode = node.parentNode, parts = [ parentNode[KEY] || (parentNode[KEY] = ++parentCounter), method, node.getAttribute("class") ];
                            return addClass && parts.push(addClass), removeClass && parts.push(removeClass), 
                            parts.join(" ");
                        },
                        containsCachedAnimationWithoutDuration: function(key) {
                            var entry = cache[key];
                            return entry && !entry.isValid || !1;
                        },
                        flush: function() {
                            cache = Object.create(null);
                        },
                        count: function(key) {
                            var entry = cache[key];
                            return entry ? entry.total : 0;
                        },
                        get: function(key) {
                            var entry = cache[key];
                            return entry && entry.value;
                        },
                        put: function(key, value, isValid) {
                            cache[key] ? (cache[key].total++, cache[key].value = value) : cache[key] = {
                                total: 1,
                                value,
                                isValid
                            };
                        }
                    };
                } ];
            })).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
        }(window, window.angular);
    },
    811: (module, __unused_webpack_exports, __webpack_require__) => {
        __webpack_require__(195), module.exports = "ngAnimate";
    },
    725: () => {
        !function(window, angular) {
            "use strict";
            var ngAriaModule = angular.module("ngAria", [ "ng" ]).info({
                angularVersion: "1.8.3"
            }).provider("$aria", (function() {
                var config = {
                    ariaHidden: !0,
                    ariaChecked: !0,
                    ariaReadonly: !0,
                    ariaDisabled: !0,
                    ariaRequired: !0,
                    ariaInvalid: !0,
                    ariaValue: !0,
                    tabindex: !0,
                    bindKeydown: !0,
                    bindRoleForClick: !0
                };
                function watchExpr(attrName, ariaAttr, nativeAriaNodeNames, negate) {
                    return function(scope, elem, attr) {
                        if (!attr.hasOwnProperty("ngAriaDisable")) {
                            var ariaCamelName = attr.$normalize(ariaAttr);
                            !config[ariaCamelName] || isNodeOneOf(elem, nativeAriaNodeNames) || attr[ariaCamelName] || scope.$watch(attr[attrName], (function(boolVal) {
                                boolVal = negate ? !boolVal : !!boolVal, elem.attr(ariaAttr, boolVal);
                            }));
                        }
                    };
                }
                this.config = function(newConfig) {
                    config = angular.extend(config, newConfig);
                }, this.$get = function() {
                    return {
                        config: function(key) {
                            return config[key];
                        },
                        $$watchExpr: watchExpr
                    };
                };
            })), nativeAriaNodeNames = [ "BUTTON", "A", "INPUT", "TEXTAREA", "SELECT", "DETAILS", "SUMMARY" ], isNodeOneOf = function(elem, nodeTypeArray) {
                if (-1 !== nodeTypeArray.indexOf(elem[0].nodeName)) return !0;
            };
            ngAriaModule.directive("ngShow", [ "$aria", function($aria) {
                return $aria.$$watchExpr("ngShow", "aria-hidden", [], !0);
            } ]).directive("ngHide", [ "$aria", function($aria) {
                return $aria.$$watchExpr("ngHide", "aria-hidden", [], !1);
            } ]).directive("ngValue", [ "$aria", function($aria) {
                return $aria.$$watchExpr("ngValue", "aria-checked", nativeAriaNodeNames, !1);
            } ]).directive("ngChecked", [ "$aria", function($aria) {
                return $aria.$$watchExpr("ngChecked", "aria-checked", nativeAriaNodeNames, !1);
            } ]).directive("ngReadonly", [ "$aria", function($aria) {
                return $aria.$$watchExpr("ngReadonly", "aria-readonly", nativeAriaNodeNames, !1);
            } ]).directive("ngRequired", [ "$aria", function($aria) {
                return $aria.$$watchExpr("ngRequired", "aria-required", nativeAriaNodeNames, !1);
            } ]).directive("ngModel", [ "$aria", function($aria) {
                function shouldAttachAttr(attr, normalizedAttr, elem, allowNonAriaNodes) {
                    return $aria.config(normalizedAttr) && !elem.attr(attr) && (allowNonAriaNodes || !isNodeOneOf(elem, nativeAriaNodeNames)) && ("hidden" !== elem.attr("type") || "INPUT" !== elem[0].nodeName);
                }
                function shouldAttachRole(role, elem) {
                    return !elem.attr("role") && elem.attr("type") === role && !isNodeOneOf(elem, nativeAriaNodeNames);
                }
                return {
                    restrict: "A",
                    require: "ngModel",
                    priority: 200,
                    compile: function(elem, attr) {
                        if (!attr.hasOwnProperty("ngAriaDisable")) {
                            var shape = function(attr) {
                                var type = attr.type, role = attr.role;
                                return "checkbox" === (type || role) || "menuitemcheckbox" === role ? "checkbox" : "radio" === (type || role) || "menuitemradio" === role ? "radio" : "range" === type || "progressbar" === role || "slider" === role ? "range" : "";
                            }(attr);
                            return {
                                post: function(scope, elem, attr, ngModel) {
                                    var needsTabIndex = shouldAttachAttr("tabindex", "tabindex", elem, !1);
                                    function ngAriaWatchModelValue() {
                                        return ngModel.$modelValue;
                                    }
                                    switch (shape) {
                                      case "radio":
                                      case "checkbox":
                                        shouldAttachRole(shape, elem) && elem.attr("role", shape), shouldAttachAttr("aria-checked", "ariaChecked", elem, !1) && scope.$watch(ngAriaWatchModelValue, "radio" === shape ? function(newVal) {
                                            var boolVal = attr.value == ngModel.$viewValue;
                                            elem.attr("aria-checked", boolVal);
                                        } : function() {
                                            elem.attr("aria-checked", !ngModel.$isEmpty(ngModel.$viewValue));
                                        }), needsTabIndex && elem.attr("tabindex", 0);
                                        break;

                                      case "range":
                                        if (shouldAttachRole(shape, elem) && elem.attr("role", "slider"), $aria.config("ariaValue")) {
                                            var needsAriaValuemin = !elem.attr("aria-valuemin") && (attr.hasOwnProperty("min") || attr.hasOwnProperty("ngMin")), needsAriaValuemax = !elem.attr("aria-valuemax") && (attr.hasOwnProperty("max") || attr.hasOwnProperty("ngMax")), needsAriaValuenow = !elem.attr("aria-valuenow");
                                            needsAriaValuemin && attr.$observe("min", (function(newVal) {
                                                elem.attr("aria-valuemin", newVal);
                                            })), needsAriaValuemax && attr.$observe("max", (function(newVal) {
                                                elem.attr("aria-valuemax", newVal);
                                            })), needsAriaValuenow && scope.$watch(ngAriaWatchModelValue, (function(newVal) {
                                                elem.attr("aria-valuenow", newVal);
                                            }));
                                        }
                                        needsTabIndex && elem.attr("tabindex", 0);
                                    }
                                    !attr.hasOwnProperty("ngRequired") && ngModel.$validators.required && shouldAttachAttr("aria-required", "ariaRequired", elem, !1) && attr.$observe("required", (function() {
                                        elem.attr("aria-required", !!attr.required);
                                    })), shouldAttachAttr("aria-invalid", "ariaInvalid", elem, !0) && scope.$watch((function() {
                                        return ngModel.$invalid;
                                    }), (function(newVal) {
                                        elem.attr("aria-invalid", !!newVal);
                                    }));
                                }
                            };
                        }
                    }
                };
            } ]).directive("ngDisabled", [ "$aria", function($aria) {
                return $aria.$$watchExpr("ngDisabled", "aria-disabled", nativeAriaNodeNames, !1);
            } ]).directive("ngMessages", (function() {
                return {
                    restrict: "A",
                    require: "?ngMessages",
                    link: function(scope, elem, attr, ngMessages) {
                        attr.hasOwnProperty("ngAriaDisable") || elem.attr("aria-live") || elem.attr("aria-live", "assertive");
                    }
                };
            })).directive("ngClick", [ "$aria", "$parse", function($aria, $parse) {
                return {
                    restrict: "A",
                    compile: function(elem, attr) {
                        if (!attr.hasOwnProperty("ngAriaDisable")) {
                            var fn = $parse(attr.ngClick);
                            return function(scope, elem, attr) {
                                isNodeOneOf(elem, nativeAriaNodeNames) || ($aria.config("bindRoleForClick") && !elem.attr("role") && elem.attr("role", "button"), 
                                $aria.config("tabindex") && !elem.attr("tabindex") && elem.attr("tabindex", 0), 
                                !$aria.config("bindKeydown") || attr.ngKeydown || attr.ngKeypress || attr.ngKeyup || elem.on("keydown", (function(event) {
                                    var keyCode = event.which || event.keyCode;
                                    13 !== keyCode && 32 !== keyCode || (-1 !== nativeAriaNodeNames.indexOf(event.target.nodeName) || event.target.isContentEditable || event.preventDefault(), 
                                    scope.$apply((function() {
                                        fn(scope, {
                                            $event: event
                                        });
                                    })));
                                })));
                            };
                        }
                    }
                };
            } ]).directive("ngDblclick", [ "$aria", function($aria) {
                return function(scope, elem, attr) {
                    attr.hasOwnProperty("ngAriaDisable") || !$aria.config("tabindex") || elem.attr("tabindex") || isNodeOneOf(elem, nativeAriaNodeNames) || elem.attr("tabindex", 0);
                };
            } ]);
        }(window, window.angular);
    },
    613: (module, __unused_webpack_exports, __webpack_require__) => {
        __webpack_require__(725), module.exports = "ngAria";
    },
    536: () => {
        (function(angular) {
            "use strict";
            angular.module("leaflet-directive", []).directive("leaflet", [ "$q", "leafletData", "leafletMapDefaults", "leafletHelpers", "leafletMapEvents", function($q, leafletData, leafletMapDefaults, leafletHelpers, leafletMapEvents) {
                return {
                    restrict: "EA",
                    replace: !0,
                    scope: {
                        center: "=",
                        lfCenter: "=",
                        defaults: "=",
                        maxbounds: "=",
                        bounds: "=",
                        markers: "=",
                        legend: "=",
                        geojson: "=",
                        paths: "=",
                        tiles: "=",
                        layers: "=",
                        controls: "=",
                        decorations: "=",
                        eventBroadcast: "=",
                        markersWatchOptions: "=",
                        geojsonWatchOptions: "="
                    },
                    transclude: !0,
                    template: '<div class="angular-leaflet-map"><div ng-transclude></div></div>',
                    controller: [ "$scope", function($scope) {
                        this._leafletMap = $q.defer(), this.getMap = function() {
                            return this._leafletMap.promise;
                        }, this.getLeafletScope = function() {
                            return $scope;
                        };
                    } ],
                    link: function(scope, element, attrs, ctrl) {
                        var isDefined = leafletHelpers.isDefined, defaults = leafletMapDefaults.setDefaults(scope.defaults, attrs.id), mapEvents = leafletMapEvents.getAvailableMapEvents(), addEvents = leafletMapEvents.addEvents;
                        function updateWidth() {
                            isNaN(attrs.width) ? element.css("width", attrs.width) : element.css("width", attrs.width + "px");
                        }
                        function updateHeight() {
                            isNaN(attrs.height) ? element.css("height", attrs.height) : element.css("height", attrs.height + "px");
                        }
                        scope.mapId = attrs.id, leafletData.setDirectiveControls({}, attrs.id), isDefined(attrs.width) && (updateWidth(), 
                        scope.$watch((function() {
                            return element[0].getAttribute("width");
                        }), (function() {
                            updateWidth(), map.invalidateSize();
                        }))), isDefined(attrs.height) && (updateHeight(), scope.$watch((function() {
                            return element[0].getAttribute("height");
                        }), (function() {
                            updateHeight(), map.invalidateSize();
                        })));
                        var map = new L.Map(element[0], leafletMapDefaults.getMapCreationDefaults(attrs.id));
                        if (ctrl._leafletMap.resolve(map), isDefined(attrs.center) || isDefined(attrs.lfCenter) || map.setView([ defaults.center.lat, defaults.center.lng ], defaults.center.zoom), 
                        !isDefined(attrs.tiles) && !isDefined(attrs.layers)) {
                            var tileLayerObj = L.tileLayer(defaults.tileLayer, defaults.tileLayerOptions);
                            tileLayerObj.addTo(map), leafletData.setTiles(tileLayerObj, attrs.id);
                        }
                        if (isDefined(map.zoomControl) && isDefined(defaults.zoomControlPosition) && map.zoomControl.setPosition(defaults.zoomControlPosition), 
                        isDefined(map.zoomControl) && !1 === defaults.zoomControl && map.zoomControl.removeFrom(map), 
                        isDefined(map.zoomsliderControl) && isDefined(defaults.zoomsliderControl) && !1 === defaults.zoomsliderControl && map.zoomsliderControl.removeFrom(map), 
                        !isDefined(attrs.eventBroadcast)) {
                            addEvents(map, mapEvents, "eventName", scope, "broadcast");
                        }
                        map.whenReady((function() {
                            leafletData.setMap(map, attrs.id);
                        })), scope.$on("$destroy", (function() {
                            leafletMapDefaults.reset(), map.remove(), leafletData.unresolveMap(attrs.id);
                        })), scope.$on("invalidateSize", (function() {
                            map.invalidateSize();
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").factory("leafletBoundsHelpers", [ "$log", "leafletHelpers", function($log, leafletHelpers) {
                var isArray = leafletHelpers.isArray, isNumber = leafletHelpers.isNumber, isFunction = leafletHelpers.isFunction, isDefined = leafletHelpers.isDefined;
                function _isValidBounds(bounds) {
                    return angular.isDefined(bounds) && angular.isDefined(bounds.southWest) && angular.isDefined(bounds.northEast) && angular.isNumber(bounds.southWest.lat) && angular.isNumber(bounds.southWest.lng) && angular.isNumber(bounds.northEast.lat) && angular.isNumber(bounds.northEast.lng);
                }
                return {
                    createLeafletBounds: function(bounds) {
                        if (_isValidBounds(bounds)) return L.latLngBounds([ bounds.southWest.lat, bounds.southWest.lng ], [ bounds.northEast.lat, bounds.northEast.lng ]);
                    },
                    isValidBounds: _isValidBounds,
                    createBoundsFromArray: function(boundsArray) {
                        if (isArray(boundsArray) && 2 === boundsArray.length && isArray(boundsArray[0]) && isArray(boundsArray[1]) && 2 === boundsArray[0].length && 2 === boundsArray[1].length && isNumber(boundsArray[0][0]) && isNumber(boundsArray[0][1]) && isNumber(boundsArray[1][0]) && isNumber(boundsArray[1][1])) return {
                            northEast: {
                                lat: boundsArray[0][0],
                                lng: boundsArray[0][1]
                            },
                            southWest: {
                                lat: boundsArray[1][0],
                                lng: boundsArray[1][1]
                            }
                        };
                        $log.error("[AngularJS - Leaflet] The bounds array is not valid.");
                    },
                    createBoundsFromLeaflet: function(lfBounds) {
                        if (isDefined(lfBounds) && isFunction(lfBounds.getNorthEast) && isFunction(lfBounds.getSouthWest)) {
                            var northEast = lfBounds.getNorthEast(), southWest = lfBounds.getSouthWest();
                            return {
                                northEast: {
                                    lat: northEast.lat,
                                    lng: northEast.lng
                                },
                                southWest: {
                                    lat: southWest.lat,
                                    lng: southWest.lng
                                }
                            };
                        }
                        $log.error("[AngularJS - Leaflet] The leaflet bounds is not valid object.");
                    }
                };
            } ]), angular.module("leaflet-directive").factory("leafletControlHelpers", [ "$rootScope", "$log", "leafletHelpers", "leafletLayerHelpers", "leafletMapDefaults", function($rootScope, $log, leafletHelpers, leafletLayerHelpers, leafletMapDefaults) {
                var isDefined = leafletHelpers.isDefined, isObject = leafletHelpers.isObject, createLayer = leafletLayerHelpers.createLayer, _controls = {}, errorHeader = leafletHelpers.errorHeader + " [Controls] ", _controlLayersMustBeVisible = function(baselayers, overlays, mapId) {
                    if (!leafletMapDefaults.getDefaults(mapId).controls.layers.visible) return !1;
                    var atLeastOneControlItemMustBeShown = !1;
                    return isObject(baselayers) && Object.keys(baselayers).forEach((function(key) {
                        var layer = baselayers[key];
                        isDefined(layer.layerOptions) && !1 === layer.layerOptions.showOnSelector || (atLeastOneControlItemMustBeShown = !0);
                    })), isObject(overlays) && Object.keys(overlays).forEach((function(key) {
                        var layer = overlays[key];
                        isDefined(layer.layerParams) && !1 === layer.layerParams.showOnSelector || (atLeastOneControlItemMustBeShown = !0);
                    })), atLeastOneControlItemMustBeShown;
                }, controlTypes = {
                    draw: {
                        isPluginLoaded: function() {
                            return !!angular.isDefined(L.Control.Draw) || ($log.error(errorHeader + " Draw plugin is not loaded."), 
                            !1);
                        },
                        checkValidParams: function() {
                            return !0;
                        },
                        createControl: function(params) {
                            return new L.Control.Draw(params);
                        }
                    },
                    scale: {
                        isPluginLoaded: function() {
                            return !0;
                        },
                        checkValidParams: function() {
                            return !0;
                        },
                        createControl: function(params) {
                            return new L.control.scale(params);
                        }
                    },
                    fullscreen: {
                        isPluginLoaded: function() {
                            return !!angular.isDefined(L.Control.Fullscreen) || ($log.error(errorHeader + " Fullscreen plugin is not loaded."), 
                            !1);
                        },
                        checkValidParams: function() {
                            return !0;
                        },
                        createControl: function(params) {
                            return new L.Control.Fullscreen(params);
                        }
                    },
                    search: {
                        isPluginLoaded: function() {
                            return !!angular.isDefined(L.Control.Search) || ($log.error(errorHeader + " Search plugin is not loaded."), 
                            !1);
                        },
                        checkValidParams: function() {
                            return !0;
                        },
                        createControl: function(params) {
                            return new L.Control.Search(params);
                        }
                    },
                    custom: {},
                    minimap: {
                        isPluginLoaded: function() {
                            return !!angular.isDefined(L.Control.MiniMap) || ($log.error(errorHeader + " Minimap plugin is not loaded."), 
                            !1);
                        },
                        checkValidParams: function(params) {
                            return !!isDefined(params.layer) || ($log.warn(errorHeader + ' minimap "layer" option should be defined.'), 
                            !1);
                        },
                        createControl: function(params) {
                            var layer = createLayer(params.layer);
                            if (isDefined(layer)) return new L.Control.MiniMap(layer, params);
                            $log.warn(errorHeader + ' minimap control "layer" could not be created.');
                        }
                    }
                };
                return {
                    layersControlMustBeVisible: _controlLayersMustBeVisible,
                    isValidControlType: function(type) {
                        return -1 !== Object.keys(controlTypes).indexOf(type);
                    },
                    createControl: function(type, params) {
                        if (controlTypes[type].checkValidParams(params)) return controlTypes[type].createControl(params);
                    },
                    updateLayersControl: function(map, mapId, loaded, baselayers, overlays, leafletLayers) {
                        var i, _layersControl = _controls[mapId], mustBeLoaded = _controlLayersMustBeVisible(baselayers, overlays, mapId);
                        if (isDefined(_layersControl) && loaded) {
                            for (i in leafletLayers.baselayers) _layersControl.removeLayer(leafletLayers.baselayers[i]);
                            for (i in leafletLayers.overlays) _layersControl.removeLayer(leafletLayers.overlays[i]);
                            map.removeControl(_layersControl), delete _controls[mapId];
                        }
                        if (mustBeLoaded) {
                            for (i in _layersControl = function(mapId) {
                                var defaults = leafletMapDefaults.getDefaults(mapId), controlOptions = {
                                    collapsed: defaults.controls.layers.collapsed,
                                    position: defaults.controls.layers.position,
                                    autoZIndex: !1
                                };
                                return angular.extend(controlOptions, defaults.controls.layers.options), defaults.controls.layers && isDefined(defaults.controls.layers.control) ? defaults.controls.layers.control.apply(this, [ [], [], controlOptions ]) : new L.control.layers([], [], controlOptions);
                            }(mapId), _controls[mapId] = _layersControl, baselayers) {
                                !(isDefined(baselayers[i].layerOptions) && !1 === baselayers[i].layerOptions.showOnSelector) && isDefined(leafletLayers.baselayers[i]) && _layersControl.addBaseLayer(leafletLayers.baselayers[i], baselayers[i].name);
                            }
                            for (i in overlays) {
                                !(isDefined(overlays[i].layerParams) && !1 === overlays[i].layerParams.showOnSelector) && isDefined(leafletLayers.overlays[i]) && _layersControl.addOverlay(leafletLayers.overlays[i], overlays[i].name);
                            }
                            map.addControl(_layersControl);
                        }
                        return mustBeLoaded;
                    }
                };
            } ]), angular.module("leaflet-directive").service("leafletData", [ "$log", "$q", "leafletHelpers", function($log, $q, leafletHelpers) {
                var getDefer = leafletHelpers.getDefer, getUnresolvedDefer = leafletHelpers.getUnresolvedDefer, setResolvedDefer = leafletHelpers.setResolvedDefer, _private = {}, self = this, _privateItems = [ "map", "tiles", "layers", "paths", "markers", "geoJSON", "UTFGrid", "decorations", "directiveControls" ];
                _privateItems.forEach((function(itemName) {
                    _private[itemName] = {};
                })), this.unresolveMap = function(scopeId) {
                    var id = leafletHelpers.obtainEffectiveMapId(_private.map, scopeId);
                    _privateItems.forEach((function(itemName) {
                        _private[itemName][id] = void 0;
                    }));
                }, _privateItems.forEach((function(itemName) {
                    var string, name = (string = itemName).charAt(0).toUpperCase() + string.slice(1);
                    self["set" + name] = function(lObject, scopeId) {
                        getUnresolvedDefer(_private[itemName], scopeId).resolve(lObject), setResolvedDefer(_private[itemName], scopeId);
                    }, self["get" + name] = function(scopeId) {
                        return getDefer(_private[itemName], scopeId).promise;
                    };
                }));
            } ]), angular.module("leaflet-directive").service("leafletDirectiveControlsHelpers", [ "$log", "leafletData", "leafletHelpers", function($log, leafletData, leafletHelpers) {
                var _isDefined = leafletHelpers.isDefined, _isString = leafletHelpers.isString, _isObject = leafletHelpers.isObject, _errorHeader = leafletHelpers.errorHeader + "[leafletDirectiveControlsHelpers";
                return {
                    extend: function(id, thingToAddName, createFn, cleanFn) {
                        var _fnHeader = _errorHeader + ".extend] ", extender = {};
                        if (_isDefined(thingToAddName)) {
                            if (_isString(thingToAddName) && _isDefined(createFn) && _isDefined(cleanFn)) extender[thingToAddName] = {
                                create: createFn,
                                clean: cleanFn
                            }; else {
                                if (!_isObject(thingToAddName) || _isDefined(createFn) || _isDefined(cleanFn)) return void $log.error(_fnHeader + "incorrect arguments");
                                extender = thingToAddName;
                            }
                            leafletData.getDirectiveControls().then((function(controls) {
                                angular.extend(controls, extender), leafletData.setDirectiveControls(controls, id);
                            }));
                        } else $log.error(_fnHeader + "thingToAddName cannot be undefined");
                    }
                };
            } ]), angular.module("leaflet-directive").service("leafletGeoJsonHelpers", [ "leafletHelpers", "leafletIterators", function(leafletHelpers, leafletIterators) {
                var lHlp = leafletHelpers, lIt = leafletIterators, Point = function(lat, lng) {
                    return this.lat = lat, this.lng = lng, this;
                }, _validateCoords = function(coords) {
                    if (lHlp.isUndefined(coords)) return !1;
                    if (lHlp.isArray(coords)) {
                        if (2 === coords.length && lHlp.isNumber(coords[0]) && lHlp.isNumber(coords[1])) return !0;
                    } else if (lHlp.isDefined(coords.type) && "Point" === coords.type && lHlp.isArray(coords.coordinates) && 2 === coords.coordinates.length && lHlp.isNumber(coords.coordinates[0]) && lHlp.isNumber(coords.coordinates[1])) return !0;
                    return lIt.all([ "lat", "lng" ], (function(pos) {
                        return lHlp.isDefined(coords[pos]) && lHlp.isNumber(coords[pos]);
                    }));
                };
                return {
                    getLat: function(value) {
                        return Array.isArray(value) && 2 === value.length ? value[1] : lHlp.isDefined(value.type) && "Point" === value.type ? +value.coordinates[1] : +value.lat;
                    },
                    getLng: function(value) {
                        return Array.isArray(value) && 2 === value.length ? value[0] : lHlp.isDefined(value.type) && "Point" === value.type ? +value.coordinates[0] : +value.lng;
                    },
                    validateCoords: _validateCoords,
                    getCoords: function(value) {
                        if (value && _validateCoords(value)) {
                            var p = null;
                            if (Array.isArray(value) && 2 === value.length) p = new Point(value[1], value[0]); else {
                                if (!lHlp.isDefined(value.type) || "Point" !== value.type) return value;
                                p = new Point(value.coordinates[1], value.coordinates[0]);
                            }
                            return angular.extend(value, p);
                        }
                    }
                };
            } ]), angular.module("leaflet-directive").service("leafletHelpers", [ "$q", "$log", function($q, $log) {
                var _errorHeader = "[AngularJS - Leaflet] ", _copy = angular.copy;
                function _obtainEffectiveMapId(d, mapId) {
                    var id, i;
                    if (angular.isDefined(mapId)) id = mapId; else if (0 === Object.keys(d).length) id = "main"; else if (Object.keys(d).length >= 1) for (i in d) d.hasOwnProperty(i) && (id = i); else $log.error(_errorHeader + "- You have more than 1 map on the DOM, you must provide the map ID to the leafletData.getXXX call");
                    return id;
                }
                function _getUnresolvedDefer(d, mapId) {
                    var defer, id = _obtainEffectiveMapId(d, mapId);
                    return angular.isDefined(d[id]) && !0 !== d[id].resolvedDefer ? defer = d[id].defer : (defer = $q.defer(), 
                    d[id] = {
                        defer,
                        resolvedDefer: !1
                    }), defer;
                }
                var _isDefined = function(value) {
                    return angular.isDefined(value) && null !== value;
                }, SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, MOZ_HACK_REGEXP = /^moz([A-Z])/, PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, camelCase = function(name) {
                    return name.replace(SPECIAL_CHARS_REGEXP, (function(_, separator, letter, offset) {
                        return offset ? letter.toUpperCase() : letter;
                    })).replace(MOZ_HACK_REGEXP, "Moz$1");
                };
                return {
                    camelCase,
                    directiveNormalize: function(name) {
                        return camelCase(name.replace(PREFIX_REGEXP, ""));
                    },
                    copy: _copy,
                    clone: _copy,
                    errorHeader: _errorHeader,
                    getObjectValue: function(object, pathStr) {
                        var obj;
                        if (object && angular.isObject(object)) return null !== pathStr && angular.isString(pathStr) ? (obj = object, 
                        pathStr.split(".").forEach((function(value) {
                            obj && (obj = obj[value]);
                        })), obj) : pathStr;
                    },
                    getObjectArrayPath: function(pathStr) {
                        return pathStr.split(".").reduce((function(previous, current) {
                            return previous + '["' + current + '"]';
                        }));
                    },
                    getObjectDotPath: function(arrayOfStrings) {
                        return arrayOfStrings.reduce((function(previous, current) {
                            return previous + "." + current;
                        }));
                    },
                    defaultTo: function(val, _default) {
                        return _isDefined(val) ? val : _default;
                    },
                    isTruthy: function(val) {
                        return "true" === val || !0 === val;
                    },
                    isEmpty: function(value) {
                        return 0 === Object.keys(value).length;
                    },
                    isUndefinedOrEmpty: function(value) {
                        return angular.isUndefined(value) || null === value || 0 === Object.keys(value).length;
                    },
                    isDefined: _isDefined,
                    isUndefined: function(value) {
                        return !_isDefined(value);
                    },
                    isNumber: angular.isNumber,
                    isString: angular.isString,
                    isArray: angular.isArray,
                    isObject: angular.isObject,
                    isFunction: angular.isFunction,
                    equals: angular.equals,
                    isValidCenter: function(center) {
                        return angular.isDefined(center) && angular.isNumber(center.lat) && angular.isNumber(center.lng) && angular.isNumber(center.zoom);
                    },
                    isValidPoint: function(point) {
                        return !!angular.isDefined(point) && (angular.isArray(point) ? 2 === point.length && angular.isNumber(point[0]) && angular.isNumber(point[1]) : angular.isNumber(point.lat) && angular.isNumber(point.lng));
                    },
                    isSameCenterOnMap: function(centerModel, map) {
                        var mapCenter = map.getCenter(), zoom = map.getZoom();
                        return !(!centerModel.lat || !centerModel.lng || mapCenter.lat.toFixed(4) !== centerModel.lat.toFixed(4) || mapCenter.lng.toFixed(4) !== centerModel.lng.toFixed(4) || zoom !== centerModel.zoom);
                    },
                    safeApply: function($scope, fn) {
                        var phase = $scope.$root.$$phase;
                        "$apply" === phase || "$digest" === phase ? $scope.$eval(fn) : $scope.$evalAsync(fn);
                    },
                    obtainEffectiveMapId: _obtainEffectiveMapId,
                    getDefer: function(d, mapId) {
                        var id = _obtainEffectiveMapId(d, mapId);
                        return angular.isDefined(d[id]) && !1 !== d[id].resolvedDefer ? d[id].defer : _getUnresolvedDefer(d, mapId);
                    },
                    getUnresolvedDefer: _getUnresolvedDefer,
                    setResolvedDefer: function(d, mapId) {
                        d[_obtainEffectiveMapId(d, mapId)].resolvedDefer = !0;
                    },
                    rangeIsSupported: function() {
                        var testrange = document.createElement("input");
                        return testrange.setAttribute("type", "range"), "range" === testrange.type;
                    },
                    FullScreenControlPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.Control.Fullscreen);
                        }
                    },
                    MiniMapControlPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.Control.MiniMap);
                        }
                    },
                    AwesomeMarkersPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.AwesomeMarkers) && angular.isDefined(L.AwesomeMarkers.Icon);
                        },
                        is: function(icon) {
                            return !!this.isLoaded() && icon instanceof L.AwesomeMarkers.Icon;
                        },
                        equal: function(iconA, iconB) {
                            return !!this.isLoaded() && (!!this.is(iconA) && angular.equals(iconA, iconB));
                        }
                    },
                    VectorMarkersPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.VectorMarkers) && angular.isDefined(L.VectorMarkers.Icon);
                        },
                        is: function(icon) {
                            return !!this.isLoaded() && icon instanceof L.VectorMarkers.Icon;
                        },
                        equal: function(iconA, iconB) {
                            return !!this.isLoaded() && (!!this.is(iconA) && angular.equals(iconA, iconB));
                        }
                    },
                    DomMarkersPlugin: {
                        isLoaded: function() {
                            return !(!angular.isDefined(L.DomMarkers) || !angular.isDefined(L.DomMarkers.Icon));
                        },
                        is: function(icon) {
                            return !!this.isLoaded() && icon instanceof L.DomMarkers.Icon;
                        },
                        equal: function(iconA, iconB) {
                            return !!this.isLoaded() && (!!this.is(iconA) && angular.equals(iconA, iconB));
                        }
                    },
                    PolylineDecoratorPlugin: {
                        isLoaded: function() {
                            return !!angular.isDefined(L.PolylineDecorator);
                        },
                        is: function(decoration) {
                            return !!this.isLoaded() && decoration instanceof L.PolylineDecorator;
                        },
                        equal: function(decorationA, decorationB) {
                            return !!this.isLoaded() && (!!this.is(decorationA) && angular.equals(decorationA, decorationB));
                        }
                    },
                    MakiMarkersPlugin: {
                        isLoaded: function() {
                            return !(!angular.isDefined(L.MakiMarkers) || !angular.isDefined(L.MakiMarkers.Icon));
                        },
                        is: function(icon) {
                            return !!this.isLoaded() && icon instanceof L.MakiMarkers.Icon;
                        },
                        equal: function(iconA, iconB) {
                            return !!this.isLoaded() && (!!this.is(iconA) && angular.equals(iconA, iconB));
                        }
                    },
                    ExtraMarkersPlugin: {
                        isLoaded: function() {
                            return !(!angular.isDefined(L.ExtraMarkers) || !angular.isDefined(L.ExtraMarkers.Icon));
                        },
                        is: function(icon) {
                            return !!this.isLoaded() && icon instanceof L.ExtraMarkers.Icon;
                        },
                        equal: function(iconA, iconB) {
                            return !!this.isLoaded() && (!!this.is(iconA) && angular.equals(iconA, iconB));
                        }
                    },
                    LabelPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.Label);
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.MarkerClusterGroup;
                        }
                    },
                    MarkerClusterPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.MarkerClusterGroup);
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.MarkerClusterGroup;
                        }
                    },
                    GoogleLayerPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.Google);
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.Google;
                        }
                    },
                    LeafletProviderPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.TileLayer.Provider);
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.TileLayer.Provider;
                        }
                    },
                    ChinaLayerPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.tileLayer.chinaProvider);
                        }
                    },
                    HeatLayerPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.heatLayer);
                        }
                    },
                    WebGLHeatMapLayerPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.TileLayer.WebGLHeatMap);
                        }
                    },
                    BingLayerPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.BingLayer);
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.BingLayer;
                        }
                    },
                    WFSLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.GeoJSON.WFS;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.GeoJSON.WFS;
                        }
                    },
                    AGSBaseLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.esri && void 0 !== L.esri.basemapLayer;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.esri.basemapLayer;
                        }
                    },
                    AGSLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== lvector && void 0 !== lvector.AGS;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof lvector.AGS;
                        }
                    },
                    AGSFeatureLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.esri && void 0 !== L.esri.featureLayer;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.esri.featureLayer;
                        }
                    },
                    AGSTiledMapLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.esri && void 0 !== L.esri.tiledMapLayer;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.esri.tiledMapLayer;
                        }
                    },
                    AGSDynamicMapLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.esri && void 0 !== L.esri.dynamicMapLayer;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.esri.dynamicMapLayer;
                        }
                    },
                    AGSImageMapLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.esri && void 0 !== L.esri.imageMapLayer;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.esri.imageMapLayer;
                        }
                    },
                    AGSClusteredLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.esri && void 0 !== L.esri.clusteredFeatureLayer;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.esri.clusteredFeatureLayer;
                        }
                    },
                    AGSHeatmapLayerPlugin: {
                        isLoaded: function() {
                            return void 0 !== L.esri && void 0 !== L.esri.heatmapFeatureLayer;
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.esri.heatmapFeatureLayer;
                        }
                    },
                    YandexLayerPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.Yandex);
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.Yandex;
                        }
                    },
                    GeoJSONPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.TileLayer.GeoJSON);
                        },
                        is: function(layer) {
                            return !!this.isLoaded() && layer instanceof L.TileLayer.GeoJSON;
                        }
                    },
                    UTFGridPlugin: {
                        isLoaded: function() {
                            return angular.isDefined(L.UtfGrid);
                        },
                        is: function(layer) {
                            return this.isLoaded() ? layer instanceof L.UtfGrid : ($log.error("[AngularJS - Leaflet] No UtfGrid plugin found."), 
                            !1);
                        }
                    },
                    CartoDB: {
                        isLoaded: function() {
                            return cartodb;
                        },
                        is: function() {
                            return !0;
                        }
                    },
                    Leaflet: {
                        DivIcon: {
                            is: function(icon) {
                                return icon instanceof L.DivIcon;
                            },
                            equal: function(iconA, iconB) {
                                return !!this.is(iconA) && angular.equals(iconA, iconB);
                            }
                        },
                        Icon: {
                            is: function(icon) {
                                return icon instanceof L.Icon;
                            },
                            equal: function(iconA, iconB) {
                                return !!this.is(iconA) && angular.equals(iconA, iconB);
                            }
                        }
                    },
                    watchOptions: {
                        doWatch: !0,
                        isDeep: !0,
                        individual: {
                            doWatch: !0,
                            isDeep: !0
                        }
                    }
                };
            } ]), angular.module("leaflet-directive").service("leafletIterators", [ "$log", "leafletHelpers", function($log, leafletHelpers) {
                var _extendOwn, keysFunc, undefinedOnly, lHlp = leafletHelpers, errorHeader = leafletHelpers.errorHeader + "leafletIterators: ", _keys = Object.keys, _isFunction = lHlp.isFunction, _isObject = lHlp.isObject, MAX_ARRAY_INDEX = Math.pow(2, 53) - 1, _identity = function(value) {
                    return value;
                };
                keysFunc = _keys, _extendOwn = function(obj) {
                    var length = arguments.length;
                    if (length < 2 || null === obj) return obj;
                    for (var index = 1; index < length; index++) for (var source = arguments[index], keys = keysFunc(source), l = keys.length, i = 0; i < l; i++) {
                        var key = keys[i];
                        undefinedOnly && void 0 !== obj[key] || (obj[key] = source[key]);
                    }
                    return obj;
                };
                var _matcher;
                _matcher = function(attrs) {
                    return attrs = _extendOwn({}, attrs), function(obj) {
                        return function(object, attrs) {
                            var keys = _keys(attrs), length = keys.length;
                            if (null === object) return !length;
                            for (var obj = Object(object), i = 0; i < length; i++) {
                                var key = keys[i];
                                if (attrs[key] !== obj[key] || !(key in obj)) return !1;
                            }
                            return !0;
                        }(obj, attrs);
                    };
                };
                var _every, _all;
                _every = _all = function(obj, predicate, context) {
                    predicate = function(value, context, argCount) {
                        return null === value ? _identity : _isFunction(value) ? function(func, context, argCount) {
                            if (void 0 === context) return func;
                            switch (null === argCount ? 3 : argCount) {
                              case 1:
                                return function(value) {
                                    return func.call(context, value);
                                };

                              case 2:
                                return function(value, other) {
                                    return func.call(context, value, other);
                                };

                              case 3:
                                return function(value, index, collection) {
                                    return func.call(context, value, index, collection);
                                };

                              case 4:
                                return function(accumulator, value, index, collection) {
                                    return func.call(context, accumulator, value, index, collection);
                                };
                            }
                            return function() {
                                return func.apply(context, arguments);
                            };
                        }(value, context, argCount) : _isObject(value) ? _matcher(value) : (key = value, 
                        function(obj) {
                            return null === obj ? void 0 : obj[key];
                        });
                        var key;
                    }(predicate, context);
                    for (var keys = !function(collection) {
                        var length = null !== collection && collection.length;
                        return lHlp.isNumber(length) && length >= 0 && length <= MAX_ARRAY_INDEX;
                    }(obj) && _keys(obj), length = (keys || obj).length, index = 0; index < length; index++) {
                        var currentKey = keys ? keys[index] : index;
                        if (!predicate(obj[currentKey], currentKey, obj)) return !1;
                    }
                    return !0;
                };
                var _hasErrors = function(collection, cb, ignoreCollection, cbName) {
                    return !(ignoreCollection || lHlp.isDefined(collection) && lHlp.isDefined(cb)) || !lHlp.isFunction(cb) && (cbName = lHlp.defaultTo(cb, "cb"), 
                    $log.error(errorHeader + cbName + " is not a function"), !0);
                }, _each = function(collection, cb) {
                    !function(collection, externalCb, internalCb) {
                        if (!_hasErrors(void 0, internalCb, !0, "internalCb") && !_hasErrors(collection, externalCb)) for (var key in collection) collection.hasOwnProperty(key) && internalCb(collection[key], key);
                    }(collection, cb, (function(val, key) {
                        cb(val, key);
                    }));
                };
                return {
                    each: _each,
                    forEach: _each,
                    every: _every,
                    all: _all
                };
            } ]), angular.module("leaflet-directive").factory("leafletLayerHelpers", [ "$rootScope", "$log", "$q", "leafletHelpers", "leafletIterators", function($rootScope, $log, $q, leafletHelpers, leafletIterators) {
                var Helpers = leafletHelpers, isString = leafletHelpers.isString, isObject = leafletHelpers.isObject, isArray = leafletHelpers.isArray, isDefined = leafletHelpers.isDefined, errorHeader = leafletHelpers.errorHeader, $it = leafletIterators, utfGridCreateLayer = function(params) {
                    if (Helpers.UTFGridPlugin.isLoaded()) {
                        var utfgrid = new L.UtfGrid(params.url, params.pluginOptions);
                        return utfgrid.on("mouseover", (function(e) {
                            $rootScope.$broadcast("leafletDirectiveMap.utfgridMouseover", e);
                        })), utfgrid.on("mouseout", (function(e) {
                            $rootScope.$broadcast("leafletDirectiveMap.utfgridMouseout", e);
                        })), utfgrid.on("click", (function(e) {
                            $rootScope.$broadcast("leafletDirectiveMap.utfgridClick", e);
                        })), utfgrid.on("mousemove", (function(e) {
                            $rootScope.$broadcast("leafletDirectiveMap.utfgridMousemove", e);
                        })), utfgrid;
                    }
                    $log.error("[AngularJS - Leaflet] The UTFGrid plugin is not loaded.");
                }, layerTypes = {
                    xyz: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            return L.tileLayer(params.url, params.options);
                        }
                    },
                    mapbox: {
                        mustHaveKey: !0,
                        createLayer: function(params) {
                            var version = 3;
                            isDefined(params.options.version) && 4 === params.options.version && (version = params.options.version);
                            var url = 3 === version ? "//{s}.tiles.mapbox.com/v3/" + params.key + "/{z}/{x}/{y}.png" : "//api.tiles.mapbox.com/v4/" + params.key + "/{z}/{x}/{y}.png?access_token=" + params.apiKey;
                            return L.tileLayer(url, params.options);
                        }
                    },
                    geoJSON: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.GeoJSONPlugin.isLoaded()) return new L.TileLayer.GeoJSON(params.url, params.pluginOptions, params.options);
                        }
                    },
                    geoJSONShape: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            return new L.GeoJSON(params.data, params.options);
                        }
                    },
                    geoJSONAwesomeMarker: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            return new L.geoJson(params.data, {
                                pointToLayer: function(feature, latlng) {
                                    return L.marker(latlng, {
                                        icon: L.AwesomeMarkers.icon(params.icon)
                                    });
                                }
                            });
                        }
                    },
                    geoJSONVectorMarker: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            return new L.geoJson(params.data, {
                                pointToLayer: function(feature, latlng) {
                                    return L.marker(latlng, {
                                        icon: L.VectorMarkers.icon(params.icon)
                                    });
                                }
                            });
                        }
                    },
                    utfGrid: {
                        mustHaveUrl: !0,
                        createLayer: utfGridCreateLayer
                    },
                    cartodbTiles: {
                        mustHaveKey: !0,
                        createLayer: function(params) {
                            var url = "//" + params.user + ".cartodb.com/api/v1/map/" + params.key + "/{z}/{x}/{y}.png";
                            return L.tileLayer(url, params.options);
                        }
                    },
                    cartodbUTFGrid: {
                        mustHaveKey: !0,
                        mustHaveLayer: !0,
                        createLayer: function(params) {
                            return params.url = "//" + params.user + ".cartodb.com/api/v1/map/" + params.key + "/" + params.layer + "/{z}/{x}/{y}.grid.json", 
                            utfGridCreateLayer(params);
                        }
                    },
                    cartodbInteractive: {
                        mustHaveKey: !0,
                        mustHaveLayer: !0,
                        createLayer: function(params) {
                            var tilesURL = "//" + params.user + ".cartodb.com/api/v1/map/" + params.key + "/{z}/{x}/{y}.png", tileLayer = L.tileLayer(tilesURL, params.options);
                            params.url = "//" + params.user + ".cartodb.com/api/v1/map/" + params.key + "/" + params.layer + "/{z}/{x}/{y}.grid.json";
                            var utfLayer = utfGridCreateLayer(params);
                            return L.layerGroup([ tileLayer, utfLayer ]);
                        }
                    },
                    wms: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            return L.tileLayer.wms(params.url, params.options);
                        }
                    },
                    wmts: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            return L.tileLayer.wmts(params.url, params.options);
                        }
                    },
                    wfs: {
                        mustHaveUrl: !0,
                        mustHaveLayer: !0,
                        createLayer: function(params) {
                            if (Helpers.WFSLayerPlugin.isLoaded()) {
                                var options = angular.copy(params.options);
                                return options.crs && "string" == typeof options.crs && (options.crs = eval(options.crs)), 
                                new L.GeoJSON.WFS(params.url, params.layer, options);
                            }
                        }
                    },
                    group: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            var lyrs = [];
                            return $it.each(params.options.layers, (function(l) {
                                lyrs.push(createLayer(l));
                            })), params.options.loadedDefer = function() {
                                var defers = [];
                                if (isDefined(params.options.layers)) for (var i = 0; i < params.options.layers.length; i++) {
                                    var d = params.options.layers[i].layerOptions.loadedDefer;
                                    isDefined(d) && defers.push(d);
                                }
                                return defers;
                            }, L.layerGroup(lyrs);
                        }
                    },
                    featureGroup: {
                        mustHaveUrl: !1,
                        createLayer: function() {
                            return L.featureGroup();
                        }
                    },
                    google: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            var type = params.type || "SATELLITE";
                            if (Helpers.GoogleLayerPlugin.isLoaded()) return new L.Google(type, params.options);
                        }
                    },
                    here: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            var provider = params.provider || "HERE.terrainDay";
                            if (Helpers.LeafletProviderPlugin.isLoaded()) return new L.TileLayer.Provider(provider, params.options);
                        }
                    },
                    china: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            var type = params.type || "";
                            if (Helpers.ChinaLayerPlugin.isLoaded()) return L.tileLayer.chinaProvider(type, params.options);
                        }
                    },
                    agsBase: {
                        mustHaveLayer: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSBaseLayerPlugin.isLoaded()) return L.esri.basemapLayer(params.layer, params.options);
                        }
                    },
                    ags: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSLayerPlugin.isLoaded()) {
                                var options = angular.copy(params.options);
                                angular.extend(options, {
                                    url: params.url
                                });
                                var layer = new lvector.AGS(options);
                                return layer.onAdd = function(map) {
                                    this.setMap(map);
                                }, layer.onRemove = function() {
                                    this.setMap(null);
                                }, layer;
                            }
                        }
                    },
                    agsFeature: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSFeatureLayerPlugin.isLoaded()) {
                                params.options.url = params.url;
                                var layer = L.esri.featureLayer(params.options), load = function() {
                                    isDefined(params.options.loadedDefer) && params.options.loadedDefer.resolve();
                                };
                                return layer.on("loading", (function() {
                                    params.options.loadedDefer = $q.defer(), layer.off("load", load), layer.on("load", load);
                                })), layer;
                            }
                            $log.warn(errorHeader + " The esri plugin is not loaded.");
                        }
                    },
                    agsTiled: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSTiledMapLayerPlugin.isLoaded()) return params.options.url = params.url, 
                            L.esri.tiledMapLayer(params.options);
                            $log.warn(errorHeader + " The esri plugin is not loaded.");
                        }
                    },
                    agsDynamic: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSDynamicMapLayerPlugin.isLoaded()) return params.options.url = params.url, 
                            L.esri.dynamicMapLayer(params.options);
                            $log.warn(errorHeader + " The esri plugin is not loaded.");
                        }
                    },
                    agsImage: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSImageMapLayerPlugin.isLoaded()) return params.options.url = params.url, 
                            L.esri.imageMapLayer(params.options);
                            $log.warn(errorHeader + " The esri plugin is not loaded.");
                        }
                    },
                    agsClustered: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSClusteredLayerPlugin.isLoaded()) {
                                if (Helpers.MarkerClusterPlugin.isLoaded()) return L.esri.clusteredFeatureLayer(params.url, params.options);
                                $log.warn(errorHeader + " The markercluster plugin is not loaded.");
                            } else $log.warn(errorHeader + " The esri clustered layer plugin is not loaded.");
                        }
                    },
                    agsHeatmap: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            if (Helpers.AGSHeatmapLayerPlugin.isLoaded()) {
                                if (Helpers.HeatLayerPlugin.isLoaded()) return L.esri.heatmapFeatureLayer(params.url, params.options);
                                $log.warn(errorHeader + " The heatlayer plugin is not loaded.");
                            } else $log.warn(errorHeader + " The esri heatmap layer plugin is not loaded.");
                        }
                    },
                    markercluster: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            if (Helpers.MarkerClusterPlugin.isLoaded()) return new L.MarkerClusterGroup(params.options);
                            $log.warn(errorHeader + " The markercluster plugin is not loaded.");
                        }
                    },
                    bing: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            if (Helpers.BingLayerPlugin.isLoaded()) return new L.BingLayer(params.key, params.options);
                        }
                    },
                    webGLHeatmap: {
                        mustHaveUrl: !1,
                        mustHaveData: !0,
                        createLayer: function(params) {
                            if (Helpers.WebGLHeatMapLayerPlugin.isLoaded()) {
                                var layer = new L.TileLayer.WebGLHeatMap(params.options);
                                return isDefined(params.data) && layer.setData(params.data), layer;
                            }
                        }
                    },
                    heat: {
                        mustHaveUrl: !1,
                        mustHaveData: !0,
                        createLayer: function(params) {
                            if (Helpers.HeatLayerPlugin.isLoaded()) {
                                var layer = new L.heatLayer;
                                return isArray(params.data) && layer.setLatLngs(params.data), isObject(params.options) && layer.setOptions(params.options), 
                                layer;
                            }
                        }
                    },
                    yandex: {
                        mustHaveUrl: !1,
                        createLayer: function(params) {
                            var type = params.type || "map";
                            if (Helpers.YandexLayerPlugin.isLoaded()) return new L.Yandex(type, params.options);
                        }
                    },
                    imageOverlay: {
                        mustHaveUrl: !0,
                        mustHaveBounds: !0,
                        createLayer: function(params) {
                            return L.imageOverlay(params.url, params.bounds, params.options);
                        }
                    },
                    iip: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            return L.tileLayer.iip(params.url, params.options);
                        }
                    },
                    custom: {
                        createLayer: function(params) {
                            if (params.layer instanceof L.Class) return angular.copy(params.layer);
                            $log.error("[AngularJS - Leaflet] A custom layer must be a leaflet Class");
                        }
                    },
                    cartodb: {
                        mustHaveUrl: !0,
                        createLayer: function(params) {
                            return cartodb.createLayer(params.map, params.url);
                        }
                    }
                };
                function isValidLayerType(layerDefinition) {
                    return isString(layerDefinition.type) ? -1 === Object.keys(layerTypes).indexOf(layerDefinition.type) ? ($log.error("[AngularJS - Leaflet] A layer must have a valid type: " + Object.keys(layerTypes)), 
                    !1) : layerTypes[layerDefinition.type].mustHaveUrl && !isString(layerDefinition.url) ? ($log.error("[AngularJS - Leaflet] A base layer must have an url"), 
                    !1) : layerTypes[layerDefinition.type].mustHaveData && !isDefined(layerDefinition.data) ? ($log.error('[AngularJS - Leaflet] The base layer must have a "data" array attribute'), 
                    !1) : layerTypes[layerDefinition.type].mustHaveLayer && !isDefined(layerDefinition.layer) ? ($log.error("[AngularJS - Leaflet] The type of layer " + layerDefinition.type + " must have an layer defined"), 
                    !1) : layerTypes[layerDefinition.type].mustHaveBounds && !isDefined(layerDefinition.bounds) ? ($log.error("[AngularJS - Leaflet] The type of layer " + layerDefinition.type + " must have bounds defined"), 
                    !1) : !(layerTypes[layerDefinition.type].mustHaveKey && !isDefined(layerDefinition.key)) || ($log.error("[AngularJS - Leaflet] The type of layer " + layerDefinition.type + " must have key defined"), 
                    !1) : ($log.error("[AngularJS - Leaflet] A layer must have a valid type defined."), 
                    !1);
                }
                function createLayer(layerDefinition) {
                    if (isValidLayerType(layerDefinition)) {
                        if (isString(layerDefinition.name)) {
                            for (var attrname in isObject(layerDefinition.layerParams) || (layerDefinition.layerParams = {}), 
                            isObject(layerDefinition.layerOptions) || (layerDefinition.layerOptions = {}), layerDefinition.layerParams) layerDefinition.layerOptions[attrname] = layerDefinition.layerParams[attrname];
                            var params = {
                                url: layerDefinition.url,
                                data: layerDefinition.data,
                                options: layerDefinition.layerOptions,
                                layer: layerDefinition.layer,
                                icon: layerDefinition.icon,
                                type: layerDefinition.layerType,
                                bounds: layerDefinition.bounds,
                                key: layerDefinition.key,
                                apiKey: layerDefinition.apiKey,
                                pluginOptions: layerDefinition.pluginOptions,
                                user: layerDefinition.user
                            };
                            return layerTypes[layerDefinition.type].createLayer(params);
                        }
                        $log.error("[AngularJS - Leaflet] A base layer must have a name");
                    }
                }
                function safeAddLayer(map, layer) {
                    layer && "function" == typeof layer.addTo ? layer.addTo(map) : map.addLayer(layer);
                }
                function safeRemoveLayer(map, layer, layerOptions) {
                    if (isDefined(layerOptions) && isDefined(layerOptions.loadedDefer)) if (angular.isFunction(layerOptions.loadedDefer)) {
                        var defers = layerOptions.loadedDefer();
                        $log.debug("Loaded Deferred", defers);
                        var count = defers.length;
                        if (count > 0) for (var resolve = function() {
                            0 === --count && map.removeLayer(layer);
                        }, i = 0; i < defers.length; i++) defers[i].promise.then(resolve); else map.removeLayer(layer);
                    } else layerOptions.loadedDefer.promise.then((function() {
                        map.removeLayer(layer);
                    })); else map.removeLayer(layer);
                }
                return {
                    createLayer,
                    safeAddLayer,
                    safeRemoveLayer
                };
            } ]), angular.module("leaflet-directive").factory("leafletLegendHelpers", (function() {
                var _updateLegend = function(div, legendData, type, url) {
                    if (div.innerHTML = "", legendData.error) div.innerHTML += '<div class="info-title alert alert-danger">' + legendData.error.message + "</div>"; else if ("arcgis" === type) for (var i = 0; i < legendData.layers.length; i++) {
                        var layer = legendData.layers[i];
                        div.innerHTML += '<div class="info-title" data-layerid="' + layer.layerId + '">' + layer.layerName + "</div>";
                        for (var j = 0; j < layer.legend.length; j++) {
                            var leg = layer.legend[j];
                            div.innerHTML += '<div class="inline" data-layerid="' + layer.layerId + '"><img src="data:' + leg.contentType + ";base64," + leg.imageData + '" /></div><div class="info-label" data-layerid="' + layer.layerId + '">' + leg.label + "</div>";
                        }
                    } else "image" === type && (div.innerHTML = '<img src="' + url + '"/>');
                };
                return {
                    getOnAddLegend: function(legendData, legendClass, type, url) {
                        return function() {
                            var div = L.DomUtil.create("div", legendClass);
                            return L.Browser.touch ? L.DomEvent.on(div, "click", L.DomEvent.stopPropagation) : (L.DomEvent.disableClickPropagation(div), 
                            L.DomEvent.on(div, "mousewheel", L.DomEvent.stopPropagation)), _updateLegend(div, legendData, type, url), 
                            div;
                        };
                    },
                    getOnAddArrayLegend: function(legend, legendClass) {
                        return function() {
                            for (var div = L.DomUtil.create("div", legendClass), i = 0; i < legend.colors.length; i++) div.innerHTML += '<div class="outline"><i style="background:' + legend.colors[i] + '"></i></div><div class="info-label">' + legend.labels[i] + "</div>";
                            return L.Browser.touch ? L.DomEvent.on(div, "click", L.DomEvent.stopPropagation) : (L.DomEvent.disableClickPropagation(div), 
                            L.DomEvent.on(div, "mousewheel", L.DomEvent.stopPropagation)), div;
                        };
                    },
                    updateLegend: _updateLegend
                };
            })), angular.module("leaflet-directive").factory("leafletMapDefaults", [ "$q", "leafletHelpers", function($q, leafletHelpers) {
                var isDefined = leafletHelpers.isDefined, isObject = leafletHelpers.isObject, obtainEffectiveMapId = leafletHelpers.obtainEffectiveMapId, defaults = {};
                return {
                    reset: function() {
                        defaults = {};
                    },
                    getDefaults: function(scopeId) {
                        var mapId = obtainEffectiveMapId(defaults, scopeId);
                        return defaults[mapId];
                    },
                    getMapCreationDefaults: function(scopeId) {
                        var mapId = obtainEffectiveMapId(defaults, scopeId), d = defaults[mapId], mapDefaults = {
                            maxZoom: d.maxZoom,
                            keyboard: d.keyboard,
                            dragging: d.dragging,
                            zoomControl: d.zoomControl,
                            doubleClickZoom: d.doubleClickZoom,
                            scrollWheelZoom: d.scrollWheelZoom,
                            tap: d.tap,
                            touchZoom: d.touchZoom,
                            attributionControl: d.attributionControl,
                            worldCopyJump: d.worldCopyJump,
                            crs: d.crs
                        };
                        if (isDefined(d.minZoom) && (mapDefaults.minZoom = d.minZoom), isDefined(d.zoomAnimation) && (mapDefaults.zoomAnimation = d.zoomAnimation), 
                        isDefined(d.fadeAnimation) && (mapDefaults.fadeAnimation = d.fadeAnimation), isDefined(d.markerZoomAnimation) && (mapDefaults.markerZoomAnimation = d.markerZoomAnimation), 
                        d.map) for (var option in d.map) mapDefaults[option] = d.map[option];
                        return mapDefaults;
                    },
                    setDefaults: function(userDefaults, scopeId) {
                        var newDefaults = {
                            keyboard: !0,
                            dragging: !0,
                            worldCopyJump: !1,
                            doubleClickZoom: !0,
                            scrollWheelZoom: !0,
                            tap: !0,
                            touchZoom: !0,
                            zoomControl: !0,
                            zoomsliderControl: !1,
                            zoomControlPosition: "topleft",
                            attributionControl: !0,
                            controls: {
                                layers: {
                                    visible: !0,
                                    position: "topright",
                                    collapsed: !0
                                }
                            },
                            nominatim: {
                                server: " http://nominatim.openstreetmap.org/search"
                            },
                            crs: L.CRS.EPSG3857,
                            tileLayer: "//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                            tileLayerOptions: {
                                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                            },
                            path: {
                                weight: 10,
                                opacity: 1,
                                color: "#0000ff"
                            },
                            center: {
                                lat: 0,
                                lng: 0,
                                zoom: 1
                            }
                        };
                        isDefined(userDefaults) && (newDefaults.doubleClickZoom = isDefined(userDefaults.doubleClickZoom) ? userDefaults.doubleClickZoom : newDefaults.doubleClickZoom, 
                        newDefaults.scrollWheelZoom = isDefined(userDefaults.scrollWheelZoom) ? userDefaults.scrollWheelZoom : newDefaults.doubleClickZoom, 
                        newDefaults.tap = isDefined(userDefaults.tap) ? userDefaults.tap : newDefaults.tap, 
                        newDefaults.touchZoom = isDefined(userDefaults.touchZoom) ? userDefaults.touchZoom : newDefaults.doubleClickZoom, 
                        newDefaults.zoomControl = isDefined(userDefaults.zoomControl) ? userDefaults.zoomControl : newDefaults.zoomControl, 
                        newDefaults.zoomsliderControl = isDefined(userDefaults.zoomsliderControl) ? userDefaults.zoomsliderControl : newDefaults.zoomsliderControl, 
                        newDefaults.attributionControl = isDefined(userDefaults.attributionControl) ? userDefaults.attributionControl : newDefaults.attributionControl, 
                        newDefaults.tileLayer = isDefined(userDefaults.tileLayer) ? userDefaults.tileLayer : newDefaults.tileLayer, 
                        newDefaults.zoomControlPosition = isDefined(userDefaults.zoomControlPosition) ? userDefaults.zoomControlPosition : newDefaults.zoomControlPosition, 
                        newDefaults.keyboard = isDefined(userDefaults.keyboard) ? userDefaults.keyboard : newDefaults.keyboard, 
                        newDefaults.dragging = isDefined(userDefaults.dragging) ? userDefaults.dragging : newDefaults.dragging, 
                        isDefined(userDefaults.controls) && angular.extend(newDefaults.controls, userDefaults.controls), 
                        isObject(userDefaults.crs) ? newDefaults.crs = userDefaults.crs : isDefined(L.CRS[userDefaults.crs]) && (newDefaults.crs = L.CRS[userDefaults.crs]), 
                        isDefined(userDefaults.center) && angular.copy(userDefaults.center, newDefaults.center), 
                        isDefined(userDefaults.tileLayerOptions) && angular.copy(userDefaults.tileLayerOptions, newDefaults.tileLayerOptions), 
                        isDefined(userDefaults.maxZoom) && (newDefaults.maxZoom = userDefaults.maxZoom), 
                        isDefined(userDefaults.minZoom) && (newDefaults.minZoom = userDefaults.minZoom), 
                        isDefined(userDefaults.zoomAnimation) && (newDefaults.zoomAnimation = userDefaults.zoomAnimation), 
                        isDefined(userDefaults.fadeAnimation) && (newDefaults.fadeAnimation = userDefaults.fadeAnimation), 
                        isDefined(userDefaults.markerZoomAnimation) && (newDefaults.markerZoomAnimation = userDefaults.markerZoomAnimation), 
                        isDefined(userDefaults.worldCopyJump) && (newDefaults.worldCopyJump = userDefaults.worldCopyJump), 
                        isDefined(userDefaults.map) && (newDefaults.map = userDefaults.map), isDefined(userDefaults.path) && (newDefaults.path = userDefaults.path));
                        var mapId = obtainEffectiveMapId(defaults, scopeId);
                        return defaults[mapId] = newDefaults, newDefaults;
                    }
                };
            } ]), angular.module("leaflet-directive").service("leafletMarkersHelpers", [ "$rootScope", "$timeout", "leafletHelpers", "$log", "$compile", "leafletGeoJsonHelpers", function($rootScope, $timeout, leafletHelpers, $log, $compile, leafletGeoJsonHelpers) {
                var isDefined = leafletHelpers.isDefined, defaultTo = leafletHelpers.defaultTo, MarkerClusterPlugin = leafletHelpers.MarkerClusterPlugin, AwesomeMarkersPlugin = leafletHelpers.AwesomeMarkersPlugin, VectorMarkersPlugin = leafletHelpers.VectorMarkersPlugin, MakiMarkersPlugin = leafletHelpers.MakiMarkersPlugin, ExtraMarkersPlugin = leafletHelpers.ExtraMarkersPlugin, DomMarkersPlugin = leafletHelpers.DomMarkersPlugin, safeApply = leafletHelpers.safeApply, Helpers = leafletHelpers, isString = leafletHelpers.isString, isNumber = leafletHelpers.isNumber, isObject = leafletHelpers.isObject, groups = {}, geoHlp = leafletGeoJsonHelpers, errorHeader = leafletHelpers.errorHeader, _string = function(marker) {
                    var retStr = "";
                    return [ "_icon", "_latlng", "_leaflet_id", "_map", "_shadow" ].forEach((function(prop) {
                        retStr += prop + ": " + defaultTo(marker[prop], "undefined") + " \n";
                    })), "[leafletMarker] : \n" + retStr;
                }, createLeafletIcon = function(iconData) {
                    if (isDefined(iconData) && isDefined(iconData.type) && "awesomeMarker" === iconData.type) return AwesomeMarkersPlugin.isLoaded() || $log.error(errorHeader + " The AwesomeMarkers Plugin is not loaded."), 
                    new L.AwesomeMarkers.icon(iconData);
                    if (isDefined(iconData) && isDefined(iconData.type) && "vectorMarker" === iconData.type) return VectorMarkersPlugin.isLoaded() || $log.error(errorHeader + " The VectorMarkers Plugin is not loaded."), 
                    new L.VectorMarkers.icon(iconData);
                    if (isDefined(iconData) && isDefined(iconData.type) && "makiMarker" === iconData.type) return MakiMarkersPlugin.isLoaded() || $log.error(errorHeader + "The MakiMarkers Plugin is not loaded."), 
                    new L.MakiMarkers.icon(iconData);
                    if (isDefined(iconData) && isDefined(iconData.type) && "extraMarker" === iconData.type) return ExtraMarkersPlugin.isLoaded() || $log.error(errorHeader + "The ExtraMarkers Plugin is not loaded."), 
                    new L.ExtraMarkers.icon(iconData);
                    if (isDefined(iconData) && isDefined(iconData.type) && "div" === iconData.type) return new L.divIcon(iconData);
                    if (isDefined(iconData) && isDefined(iconData.type) && "dom" === iconData.type) {
                        DomMarkersPlugin.isLoaded() || $log.error(errorHeader + "The DomMarkers Plugin is not loaded.");
                        var markerScope = angular.isFunction(iconData.getMarkerScope) ? iconData.getMarkerScope() : $rootScope, template = $compile(iconData.template)(markerScope), iconDataCopy = angular.copy(iconData);
                        return iconDataCopy.element = template[0], new L.DomMarkers.icon(iconDataCopy);
                    }
                    if (isDefined(iconData) && isDefined(iconData.type) && "icon" === iconData.type) return iconData.icon;
                    return isDefined(iconData) && isDefined(iconData.iconUrl) ? new L.Icon(iconData) : new L.Icon.Default({
                        iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAGmklEQVRYw7VXeUyTZxjvNnfELFuyIzOabermMZEeQC/OclkO49CpOHXOLJl/CAURuYbQi3KLgEhbrhZ1aDwmaoGqKII6odATmH/scDFbdC7LvFqOCc+e95s2VG50X/LLm/f4/Z7neY/ne18aANCmAr5E/xZf1uDOkTcGcWR6hl9247tT5U7Y6SNvWsKT63P58qbfeLJG8M5qcgTknrvvrdDbsT7Ml+tv82X6vVxJE33aRmgSyYtcWVMqX97Yv2JvW39UhRE2HuyBL+t+gK1116ly06EeWFNlAmHxlQE0OMiV6mQCScusKRlhS3QLeVJdl1+23h5dY4FNB3thrbYboqptEFlphTC1hSpJnbRvxP4NWgsE5Jyz86QNNi/5qSUTGuFk1gu54tN9wuK2wc3o+Wc13RCmsoBwEqzGcZsxsvCSy/9wJKf7UWf1mEY8JWfewc67UUoDbDjQC+FqK4QqLVMGGR9d2wurKzqBk3nqIT/9zLxRRjgZ9bqQgub+DdoeCC03Q8j+0QhFhBHR/eP3U/zCln7Uu+hihJ1+bBNffLIvmkyP0gpBZWYXhKussK6mBz5HT6M1Nqpcp+mBCPXosYQfrekGvrjewd59/GvKCE7TbK/04/ZV5QZYVWmDwH1mF3xa2Q3ra3DBC5vBT1oP7PTj4C0+CcL8c7C2CtejqhuCnuIQHaKHzvcRfZpnylFfXsYJx3pNLwhKzRAwAhEqG0SpusBHfAKkxw3w4627MPhoCH798z7s0ZnBJ/MEJbZSbXPhER2ih7p2ok/zSj2cEJDd4CAe+5WYnBCgR2uruyEw6zRoW6/DWJ/OeAP8pd/BGtzOZKpG8oke0SX6GMmRk6GFlyAc59K32OTEinILRJRchah8HQwND8N435Z9Z0FY1EqtxUg+0SO6RJ/mmXz4VuS+DpxXC3gXmZwIL7dBSH4zKE50wESf8qwVgrP1EIlTO5JP9Igu0aexdh28F1lmAEGJGfh7jE6ElyM5Rw/FDcYJjWhbeiBYoYNIpc2FT/SILivp0F1ipDWk4BIEo2VuodEJUifhbiltnNBIXPUFCMpthtAyqws/BPlEF/VbaIxErdxPphsU7rcCp8DohC+GvBIPJS/tW2jtvTmmAeuNO8BNOYQeG8G/2OzCJ3q+soYB5i6NhMaKr17FSal7GIHheuV3uSCY8qYVuEm1cOzqdWr7ku/R0BDoTT+DT+ohCM6/CCvKLKO4RI+dXPeAuaMqksaKrZ7L3FE5FIFbkIceeOZ2OcHO6wIhTkNo0ffgjRGxEqogXHYUPHfWAC/lADpwGcLRY3aeK4/oRGCKYcZXPVoeX/kelVYY8dUGf8V5EBRbgJXT5QIPhP9ePJi428JKOiEYhYXFBqou2Guh+p/mEB1/RfMw6rY7cxcjTrneI1FrDyuzUSRm9miwEJx8E/gUmqlyvHGkneiwErR21F3tNOK5Tf0yXaT+O7DgCvALTUBXdM4YhC/IawPU+2PduqMvuaR6eoxSwUk75ggqsYJ7VicsnwGIkZBSXKOUww73WGXyqP+J2/b9c+gi1YAg/xpwck3gJuucNrh5JvDPvQr0WFXf0piyt8f8/WI0hV4pRxxkQZdJDfDJNOAmM0Ag8jyT6hz0WGXWuP94Yh2jcfjmXAGvHCMslRimDHYuHuDsy2QtHuIavznhbYURq5R57KpzBBRZKPJi8eQg48h4j8SDdowifdIrEVdU+gbO6QNvRRt4ZBthUaZhUnjlYObNagV3keoeru3rU7rcuceqU1mJBxy+BWZYlNEBH+0eH4vRiB+OYybU2hnblYlTvkHinM4m54YnxSyaZYSF6R3jwgP7udKLGIX6r/lbNa9N6y5MFynjWDtrHd75ZvTYAPO/6RgF0k76mQla3FGq7dO+cH8sKn0Vo7nDllwAhqwLPkxrHwWmHJOo+AKJ4rab5OgrM7rVu8eWb2Pu0Dh4eDgXoOfvp7Y7QeqknRmvcTBEyq9m/HQQSCSz6LHq3z0yzsNySRfMS253wl2KyRDbcZPcfJKjZmSEOjcxyi+Y8dUOtsIEH6R2wNykdqrkYJ0RV92H0W58pkfQk7cKevsLK10Py8SdMGfXNXATY+pPbyJR/ET6n9nIfztNtZYRV9XniQu9IA2vOVgy4ir7GCLVmmd+zjkH0eAF9Po6K61pmCXHxU5rHMYd1ftc3owjwRSVRzLjKvqZEty6cRUD7jGqiOdu5HG6MdHjNcNYGqfDm5YRzLBBCCDl/2bk8a8gdbqcfwECu62Fg/HrggAAAABJRU5ErkJggg==",
                        shadowUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAYAAACoYAD2AAAC5ElEQVRYw+2YW4/TMBCF45S0S1luXZCABy5CgLQgwf//S4BYBLTdJLax0fFqmB07nnQfEGqkIydpVH85M+NLjPe++dcPc4Q8Qh4hj5D/AaQJx6H/4TMwB0PeBNwU7EGQAmAtsNfAzoZkgIa0ZgLMa4Aj6CxIAsjhjOCoL5z7Glg1JAOkaicgvQBXuncwJAWjksLtBTWZe04CnYRktUGdilALppZBOgHGZcBzL6OClABvMSVIzyBjazOgrvACf1ydC5mguqAVg6RhdkSWQFj2uxfaq/BrIZOLEWgZdALIDvcMcZLD8ZbLC9de4yR1sYMi4G20S4Q/PWeJYxTOZn5zJXANZHIxAd4JWhPIloTJZhzMQduM89WQ3MUVAE/RnhAXpTycqys3NZALOBbB7kFrgLesQl2h45Fcj8L1tTSohUwuxhy8H/Qg6K7gIs+3kkaigQCOcyEXCHN07wyQazhrmIulvKMQAwMcmLNqyCVyMAI+BuxSMeTk3OPikLY2J1uE+VHQk6ANrhds+tNARqBeaGc72cK550FP4WhXmFmcMGhTwAR1ifOe3EvPqIegFmF+C8gVy0OfAaWQPMR7gF1OQKqGoBjq90HPMP01BUjPOqGFksC4emE48tWQAH0YmvOgF3DST6xieJgHAWxPAHMuNhrImIdvoNOKNWIOcE+UXE0pYAnkX6uhWsgVXDxHdTfCmrEEmMB2zMFimLVOtiiajxiGWrbU52EeCdyOwPEQD8LqyPH9Ti2kgYMf4OhSKB7qYILbBv3CuVTJ11Y80oaseiMWOONc/Y7kJYe0xL2f0BaiFTxknHO5HaMGMublKwxFGzYdWsBF174H/QDknhTHmHHN39iWFnkZx8lPyM8WHfYELmlLKtgWNmFNzQcC1b47gJ4hL19i7o65dhH0Negbca8vONZoP7doIeOC9zXm8RjuL0Gf4d4OYaU5ljo3GYiqzrWQHfJxA6ALhDpVKv9qYeZA8eM3EhfPSCmpuD0AAAAASUVORK5CYII=",
                        iconSize: [ 25, 41 ],
                        iconAnchor: [ 12, 41 ],
                        popupAnchor: [ 1, -34 ],
                        shadowSize: [ 41, 41 ]
                    });
                }, _deleteMarker = function(marker, map, layers) {
                    if (marker.closePopup(), isDefined(layers) && isDefined(layers.overlays)) for (var key in layers.overlays) if ((layers.overlays[key] instanceof L.LayerGroup || layers.overlays[key] instanceof L.FeatureGroup) && layers.overlays[key].hasLayer(marker)) return void layers.overlays[key].removeLayer(marker);
                    if (isDefined(groups)) for (var groupKey in groups) groups[groupKey].hasLayer(marker) && groups[groupKey].removeLayer(marker);
                    map.hasLayer(marker) && map.removeLayer(marker);
                }, updatePopup = function(marker, markerScope, map) {
                    (marker._popup._contentNode.innerText || marker._popup._contentNode.textContent).length < 1 && $timeout((function() {
                        updatePopup(marker, markerScope, map);
                    }));
                    var reflow = marker._popup._contentNode.offsetWidth;
                    return marker._popup._updateLayout(), marker._popup._updatePosition(), marker._popup.options.autoPan && function(marker, map) {
                        var containerHeight = marker._popup._container.offsetHeight, layerPos = new L.Point(marker._popup._containerLeft, -containerHeight - marker._popup._containerBottom);
                        null !== map.layerPointToContainerPoint(layerPos) && marker._popup._adjustPan();
                    }(marker, map), reflow;
                }, _manageOpenPopup = function(marker, markerData, map) {
                    var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope;
                    if (!isDefined(markerData.compileMessage) || markerData.compileMessage) {
                        if (!isDefined(marker._popup) || !isDefined(marker._popup._contentNode)) return $log.error(errorHeader + "Popup is invalid or does not have any content."), 
                        !1;
                        !function(marker, markerScope) {
                            $compile(marker._popup._contentNode)(markerScope);
                        }(marker, markerScope), updatePopup(marker, markerData, map);
                    }
                }, _manageOpenLabel = function(marker, markerData) {
                    var markerScope = angular.isFunction(markerData.getMessageScope) ? markerData.getMessageScope() : $rootScope, labelScope = angular.isFunction(markerData.getLabelScope) ? markerData.getLabelScope() : markerScope, compileMessage = !isDefined(markerData.compileMessage) || markerData.compileMessage;
                    Helpers.LabelPlugin.isLoaded() && isDefined(markerData.label) && (isDefined(markerData.label.options) && !0 === markerData.label.options.noHide && marker.showLabel(), 
                    compileMessage && isDefined(marker.label) && $compile(marker.label._container)(labelScope));
                }, _updateMarker = function(markerData, oldMarkerData, marker, name, leafletScope, layers, map) {
                    if (isDefined(oldMarkerData)) {
                        if (!geoHlp.validateCoords(markerData)) return $log.warn("There are problems with lat-lng data, please verify your marker model"), 
                        void _deleteMarker(marker, map, layers);
                        var isInitializing = markerData === oldMarkerData;
                        if (isDefined(markerData.iconAngle) && oldMarkerData.iconAngle !== markerData.iconAngle && marker.setIconAngle(markerData.iconAngle), 
                        isString(markerData.layer) || isString(oldMarkerData.layer) && (isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker) && (layers.overlays[oldMarkerData.layer].removeLayer(marker), 
                        marker.closePopup()), map.hasLayer(marker) || map.addLayer(marker)), (isNumber(markerData.opacity) || isNumber(parseFloat(markerData.opacity))) && markerData.opacity !== oldMarkerData.opacity && marker.setOpacity(markerData.opacity), 
                        isString(markerData.layer) && oldMarkerData.layer !== markerData.layer) {
                            if (isString(oldMarkerData.layer) && isDefined(layers.overlays[oldMarkerData.layer]) && layers.overlays[oldMarkerData.layer].hasLayer(marker) && layers.overlays[oldMarkerData.layer].removeLayer(marker), 
                            marker.closePopup(), map.hasLayer(marker) && map.removeLayer(marker), !isDefined(layers.overlays[markerData.layer])) return void $log.error(errorHeader + "You must use a name of an existing layer");
                            var layerGroup = layers.overlays[markerData.layer];
                            if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) return void $log.error(errorHeader + 'A marker can only be added to a layer of type "group" or "featureGroup"');
                            layerGroup.addLayer(marker), map.hasLayer(marker) && !0 === markerData.focus && marker.openPopup();
                        }
                        if (!0 !== markerData.draggable && !0 === oldMarkerData.draggable && isDefined(marker.dragging) && marker.dragging.disable(), 
                        !0 === markerData.draggable && !0 !== oldMarkerData.draggable && (marker.dragging ? marker.dragging.enable() : L.Handler.MarkerDrag && (marker.dragging = new L.Handler.MarkerDrag(marker), 
                        marker.options.draggable = !0, marker.dragging.enable())), isObject(markerData.icon) || isObject(oldMarkerData.icon) && (marker.setIcon(createLeafletIcon()), 
                        marker.closePopup(), marker.unbindPopup(), isString(markerData.message) && marker.bindPopup(markerData.message, markerData.popupOptions)), 
                        isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon)) {
                            var dragG = !1;
                            marker.dragging && (dragG = marker.dragging.enabled()), marker.setIcon(createLeafletIcon(markerData.icon)), 
                            dragG && marker.dragging.enable(), marker.closePopup(), marker.unbindPopup(), isString(markerData.message) && (marker.bindPopup(markerData.message, markerData.popupOptions), 
                            map.hasLayer(marker) && !0 === markerData.focus && marker.openPopup());
                        }
                        !isString(markerData.message) && isString(oldMarkerData.message) && (marker.closePopup(), 
                        marker.unbindPopup()), Helpers.LabelPlugin.isLoaded() && (isDefined(markerData.label) && isDefined(markerData.label.message) ? "label" in oldMarkerData && "message" in oldMarkerData.label && !angular.equals(markerData.label.message, oldMarkerData.label.message) ? marker.updateLabelContent(markerData.label.message) : !angular.isFunction(marker.getLabel) || angular.isFunction(marker.getLabel) && !isDefined(marker.getLabel()) ? (marker.bindLabel(markerData.label.message, markerData.label.options), 
                        _manageOpenLabel(marker, markerData)) : _manageOpenLabel(marker, markerData) : "label" in markerData && !("message" in markerData.label) || angular.isFunction(marker.unbindLabel) && marker.unbindLabel()), 
                        isString(markerData.message) && !isString(oldMarkerData.message) && marker.bindPopup(markerData.message, markerData.popupOptions), 
                        isString(markerData.message) && isString(oldMarkerData.message) && markerData.message !== oldMarkerData.message && marker.setPopupContent(markerData.message);
                        var updatedFocus = !1;
                        !0 !== markerData.focus && !0 === oldMarkerData.focus && (marker.closePopup(), updatedFocus = !0), 
                        (!0 === markerData.focus && (!isDefined(oldMarkerData.focus) || !1 === oldMarkerData.focus) || isInitializing && !0 === markerData.focus) && (marker.openPopup(), 
                        updatedFocus = !0), oldMarkerData.zIndexOffset !== markerData.zIndexOffset && marker.setZIndexOffset(markerData.zIndexOffset);
                        var markerLatLng = marker.getLatLng();
                        isString(markerData.layer) && Helpers.MarkerClusterPlugin.is(layers.overlays[markerData.layer]) ? updatedFocus ? markerData.lat === oldMarkerData.lat && markerData.lng === oldMarkerData.lng || (layers.overlays[markerData.layer].removeLayer(marker), 
                        marker.setLatLng([ markerData.lat, markerData.lng ]), layers.overlays[markerData.layer].addLayer(marker)) : markerLatLng.lat !== markerData.lat || markerLatLng.lng !== markerData.lng || markerData.lat !== oldMarkerData.lat || markerData.lng !== oldMarkerData.lng ? (layers.overlays[markerData.layer].removeLayer(marker), 
                        marker.setLatLng([ markerData.lat, markerData.lng ]), layers.overlays[markerData.layer].addLayer(marker)) : isObject(markerData.icon) && isObject(oldMarkerData.icon) && !angular.equals(markerData.icon, oldMarkerData.icon) && (layers.overlays[markerData.layer].removeLayer(marker), 
                        layers.overlays[markerData.layer].addLayer(marker)) : markerLatLng.lat === markerData.lat && markerLatLng.lng === markerData.lng || marker.setLatLng([ markerData.lat, markerData.lng ]);
                    }
                };
                return {
                    resetMarkerGroup: function(groupName) {
                        isDefined(groups[groupName]) && groups.splice(groupName, 1);
                    },
                    resetMarkerGroups: function() {
                        groups = {};
                    },
                    deleteMarker: _deleteMarker,
                    manageOpenPopup: _manageOpenPopup,
                    manageOpenLabel: _manageOpenLabel,
                    createMarker: function(markerData) {
                        if (isDefined(markerData) && geoHlp.validateCoords(markerData)) {
                            var coords = geoHlp.getCoords(markerData);
                            if (isDefined(coords)) {
                                var markerOptions = {
                                    icon: createLeafletIcon(markerData.icon),
                                    title: isDefined(markerData.title) ? markerData.title : "",
                                    draggable: !!isDefined(markerData.draggable) && markerData.draggable,
                                    clickable: !isDefined(markerData.clickable) || markerData.clickable,
                                    riseOnHover: !!isDefined(markerData.riseOnHover) && markerData.riseOnHover,
                                    zIndexOffset: isDefined(markerData.zIndexOffset) ? markerData.zIndexOffset : 0,
                                    iconAngle: isDefined(markerData.iconAngle) ? markerData.iconAngle : 0
                                };
                                for (var markerDatum in markerData) markerData.hasOwnProperty(markerDatum) && !markerOptions.hasOwnProperty(markerDatum) && (markerOptions[markerDatum] = markerData[markerDatum]);
                                var marker = new L.marker(coords, markerOptions);
                                return isString(markerData.message) || marker.unbindPopup(), marker;
                            }
                            $log.error(errorHeader + "Unable to get coordinates from markerData.");
                        } else $log.error(errorHeader + "The marker definition is not valid.");
                    },
                    addMarkerToGroup: function(marker, groupName, groupOptions, map) {
                        isString(groupName) ? MarkerClusterPlugin.isLoaded() ? (isDefined(groups[groupName]) || (groups[groupName] = new L.MarkerClusterGroup(groupOptions), 
                        map.addLayer(groups[groupName])), groups[groupName].addLayer(marker)) : $log.error(errorHeader + "The MarkerCluster plugin is not loaded.") : $log.error(errorHeader + "The marker group you have specified is invalid.");
                    },
                    listenMarkerEvents: function(marker, markerData, leafletScope, doWatch, map) {
                        marker.on("popupopen", (function() {
                            safeApply(leafletScope, (function() {
                                (isDefined(marker._popup) || isDefined(marker._popup._contentNode)) && (markerData.focus = !0, 
                                _manageOpenPopup(marker, markerData, map));
                            }));
                        })), marker.on("popupclose", (function() {
                            safeApply(leafletScope, (function() {
                                markerData.focus = !1;
                            }));
                        })), marker.on("add", (function() {
                            safeApply(leafletScope, (function() {
                                "label" in markerData && _manageOpenLabel(marker, markerData);
                            }));
                        }));
                    },
                    updateMarker: _updateMarker,
                    addMarkerWatcher: function(marker, name, leafletScope, layers, map, isDeepWatch) {
                        var markerWatchPath = Helpers.getObjectArrayPath("markers." + name);
                        isDeepWatch = defaultTo(isDeepWatch, !0);
                        var clearWatch = leafletScope.$watch(markerWatchPath, (function(markerData, oldMarkerData) {
                            if (!isDefined(markerData)) return _deleteMarker(marker, map, layers), void clearWatch();
                            _updateMarker(markerData, oldMarkerData, marker, 0, 0, layers, map);
                        }), isDeepWatch);
                    },
                    string: _string,
                    log: function(marker, useConsole) {
                        (useConsole ? console : $log).debug(_string(marker));
                    }
                };
            } ]), angular.module("leaflet-directive").factory("leafletPathsHelpers", [ "$rootScope", "$log", "leafletHelpers", function($rootScope, $log, leafletHelpers) {
                var isDefined = leafletHelpers.isDefined, isArray = leafletHelpers.isArray, isNumber = leafletHelpers.isNumber, isValidPoint = leafletHelpers.isValidPoint, availableOptions = [ "stroke", "weight", "color", "opacity", "fill", "fillColor", "fillOpacity", "dashArray", "lineCap", "lineJoin", "clickable", "pointerEvents", "className", "smoothFactor", "noClip" ];
                function _convertToLeafletLatLngs(latlngs) {
                    return latlngs.filter((function(latlng) {
                        return isValidPoint(latlng);
                    })).map((function(latlng) {
                        return _convertToLeafletLatLng(latlng);
                    }));
                }
                function _convertToLeafletLatLng(latlng) {
                    return isArray(latlng) ? new L.LatLng(latlng[0], latlng[1]) : new L.LatLng(latlng.lat, latlng.lng);
                }
                function _convertToLeafletMultiLatLngs(paths) {
                    return paths.map((function(latlngs) {
                        return _convertToLeafletLatLngs(latlngs);
                    }));
                }
                var _updatePathOptions = function(path, data) {
                    for (var updatedStyle = {}, i = 0; i < availableOptions.length; i++) {
                        var optionName = availableOptions[i];
                        isDefined(data[optionName]) && (updatedStyle[optionName] = data[optionName]);
                    }
                    path.setStyle(data);
                }, _isValidPolyline = function(latlngs) {
                    if (!isArray(latlngs)) return !1;
                    for (var i = 0; i < latlngs.length; i++) {
                        var point = latlngs[i];
                        if (!isValidPoint(point)) return !1;
                    }
                    return !0;
                }, pathTypes = {
                    polyline: {
                        isValid: function(pathData) {
                            var latlngs = pathData.latlngs;
                            return _isValidPolyline(latlngs);
                        },
                        createPath: function(options) {
                            return new L.Polyline([], options);
                        },
                        setPath: function(path, data) {
                            path.setLatLngs(_convertToLeafletLatLngs(data.latlngs)), _updatePathOptions(path, data);
                        }
                    },
                    multiPolyline: {
                        isValid: function(pathData) {
                            var latlngs = pathData.latlngs;
                            if (!isArray(latlngs)) return !1;
                            for (var i in latlngs) {
                                var polyline = latlngs[i];
                                if (!_isValidPolyline(polyline)) return !1;
                            }
                            return !0;
                        },
                        createPath: function(options) {
                            return new L.multiPolyline([ [ [ 0, 0 ], [ 1, 1 ] ] ], options);
                        },
                        setPath: function(path, data) {
                            path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs)), _updatePathOptions(path, data);
                        }
                    },
                    polygon: {
                        isValid: function(pathData) {
                            var latlngs = pathData.latlngs;
                            return _isValidPolyline(latlngs);
                        },
                        createPath: function(options) {
                            return new L.Polygon([], options);
                        },
                        setPath: function(path, data) {
                            path.setLatLngs(_convertToLeafletLatLngs(data.latlngs)), _updatePathOptions(path, data);
                        }
                    },
                    multiPolygon: {
                        isValid: function(pathData) {
                            var latlngs = pathData.latlngs;
                            if (!isArray(latlngs)) return !1;
                            for (var i in latlngs) {
                                var polyline = latlngs[i];
                                if (!_isValidPolyline(polyline)) return !1;
                            }
                            return !0;
                        },
                        createPath: function(options) {
                            return new L.MultiPolygon([ [ [ 0, 0 ], [ 1, 1 ], [ 0, 1 ] ] ], options);
                        },
                        setPath: function(path, data) {
                            path.setLatLngs(_convertToLeafletMultiLatLngs(data.latlngs)), _updatePathOptions(path, data);
                        }
                    },
                    rectangle: {
                        isValid: function(pathData) {
                            var latlngs = pathData.latlngs;
                            if (!isArray(latlngs) || 2 !== latlngs.length) return !1;
                            for (var i in latlngs) {
                                var point = latlngs[i];
                                if (!isValidPoint(point)) return !1;
                            }
                            return !0;
                        },
                        createPath: function(options) {
                            return new L.Rectangle([ [ 0, 0 ], [ 1, 1 ] ], options);
                        },
                        setPath: function(path, data) {
                            path.setBounds(new L.LatLngBounds(_convertToLeafletLatLngs(data.latlngs))), _updatePathOptions(path, data);
                        }
                    },
                    circle: {
                        isValid: function(pathData) {
                            var point = pathData.latlngs;
                            return isValidPoint(point) && isNumber(pathData.radius);
                        },
                        createPath: function(options) {
                            return new L.Circle([ 0, 0 ], 1, options);
                        },
                        setPath: function(path, data) {
                            path.setLatLng(_convertToLeafletLatLng(data.latlngs)), isDefined(data.radius) && path.setRadius(data.radius), 
                            _updatePathOptions(path, data);
                        }
                    },
                    circleMarker: {
                        isValid: function(pathData) {
                            var point = pathData.latlngs;
                            return isValidPoint(point) && isNumber(pathData.radius);
                        },
                        createPath: function(options) {
                            return new L.CircleMarker([ 0, 0 ], options);
                        },
                        setPath: function(path, data) {
                            path.setLatLng(_convertToLeafletLatLng(data.latlngs)), isDefined(data.radius) && path.setRadius(data.radius), 
                            _updatePathOptions(path, data);
                        }
                    }
                };
                return {
                    setPathOptions: function(leafletPath, pathType, data) {
                        isDefined(pathType) || (pathType = "polyline"), pathTypes[pathType].setPath(leafletPath, data);
                    },
                    createPath: function(name, path, defaults) {
                        isDefined(path.type) || (path.type = "polyline");
                        var options = function(path, defaults) {
                            for (var options = {}, i = 0; i < availableOptions.length; i++) {
                                var optionName = availableOptions[i];
                                isDefined(path[optionName]) ? options[optionName] = path[optionName] : isDefined(defaults.path[optionName]) && (options[optionName] = defaults.path[optionName]);
                            }
                            return options;
                        }(path, defaults), pathData = function(path) {
                            var pathData = {};
                            return path.latlngs && (pathData.latlngs = path.latlngs), path.radius && (pathData.radius = path.radius), 
                            pathData;
                        }(path);
                        if (pathTypes[path.type].isValid(pathData)) return pathTypes[path.type].createPath(options);
                        $log.error("[AngularJS - Leaflet] Invalid data passed to the " + path.type + " path");
                    }
                };
            } ]), angular.module("leaflet-directive").service("leafletWatchHelpers", (function() {
                var _maybe = function(scope, watchFunctionName, thingToWatchStr, watchOptions, initCb) {
                    var unWatch = scope[watchFunctionName](thingToWatchStr, (function(newValue, oldValue) {
                        initCb(newValue, oldValue), watchOptions.doWatch || unWatch();
                    }), watchOptions.isDeep);
                    return unWatch;
                };
                return {
                    maybeWatch: function(scope, thingToWatchStr, watchOptions, initCb) {
                        return _maybe(scope, "$watch", thingToWatchStr, watchOptions, initCb);
                    },
                    maybeWatchCollection: function(scope, thingToWatchStr, watchOptions, initCb) {
                        return _maybe(scope, "$watchCollection", thingToWatchStr, watchOptions, initCb);
                    }
                };
            })), angular.module("leaflet-directive").factory("nominatimService", [ "$q", "$http", "leafletHelpers", "leafletMapDefaults", function($q, $http, leafletHelpers, leafletMapDefaults) {
                var isDefined = leafletHelpers.isDefined;
                return {
                    query: function(address, mapId) {
                        var url = leafletMapDefaults.getDefaults(mapId).nominatim.server, df = $q.defer();
                        return $http.get(url, {
                            params: {
                                format: "json",
                                limit: 1,
                                q: address
                            }
                        }).success((function(data) {
                            data.length > 0 && isDefined(data[0].boundingbox) ? df.resolve(data[0]) : df.reject("[Nominatim] Invalid address");
                        })), df.promise;
                    }
                };
            } ]), angular.module("leaflet-directive").directive("bounds", [ "$log", "$timeout", "$http", "leafletHelpers", "nominatimService", "leafletBoundsHelpers", function($log, $timeout, $http, leafletHelpers, nominatimService, leafletBoundsHelpers) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: [ "leaflet" ],
                    link: function(scope, element, attrs, controller) {
                        var isDefined = leafletHelpers.isDefined, createLeafletBounds = leafletBoundsHelpers.createLeafletBounds, leafletScope = controller[0].getLeafletScope(), mapController = controller[0], errorHeader = leafletHelpers.errorHeader + " [Bounds] ";
                        mapController.getMap().then((function(map) {
                            var lastNominatimQuery;
                            leafletScope.$on("boundsChanged", (function(event) {
                                var scope = event.currentScope, bounds = map.getBounds();
                                if (!function(bounds) {
                                    return 0 === bounds._southWest.lat && 0 === bounds._southWest.lng && 0 === bounds._northEast.lat && 0 === bounds._northEast.lng;
                                }(bounds) && !scope.settingBoundsFromScope) {
                                    scope.settingBoundsFromLeaflet = !0;
                                    var newScopeBounds = {
                                        northEast: {
                                            lat: bounds._northEast.lat,
                                            lng: bounds._northEast.lng
                                        },
                                        southWest: {
                                            lat: bounds._southWest.lat,
                                            lng: bounds._southWest.lng
                                        },
                                        options: bounds.options
                                    };
                                    angular.equals(scope.bounds, newScopeBounds) || (scope.bounds = newScopeBounds), 
                                    $timeout((function() {
                                        scope.settingBoundsFromLeaflet = !1;
                                    }));
                                }
                            })), leafletScope.$watch("bounds", (function(bounds) {
                                if (!scope.settingBoundsFromLeaflet) {
                                    if (isDefined(bounds.address) && bounds.address !== lastNominatimQuery) return scope.settingBoundsFromScope = !0, 
                                    nominatimService.query(bounds.address, attrs.id).then((function(data) {
                                        var b = data.boundingbox, newBounds = [ [ b[0], b[2] ], [ b[1], b[3] ] ];
                                        map.fitBounds(newBounds);
                                    }), (function(errMsg) {
                                        $log.error(errorHeader + " " + errMsg + ".");
                                    })), lastNominatimQuery = bounds.address, void $timeout((function() {
                                        scope.settingBoundsFromScope = !1;
                                    }));
                                    var leafletBounds = createLeafletBounds(bounds);
                                    leafletBounds && !map.getBounds().equals(leafletBounds) && (scope.settingBoundsFromScope = !0, 
                                    map.fitBounds(leafletBounds, bounds.options), $timeout((function() {
                                        scope.settingBoundsFromScope = !1;
                                    })));
                                }
                            }), !0);
                        }));
                    }
                };
            } ]);
            var centerDirectiveTypes = [ "center", "lfCenter" ], centerDirectives = {};
            centerDirectiveTypes.forEach((function(directiveName) {
                centerDirectives[directiveName] = [ "$log", "$q", "$location", "$timeout", "leafletMapDefaults", "leafletHelpers", "leafletBoundsHelpers", "leafletMapEvents", function($log, $q, $location, $timeout, leafletMapDefaults, leafletHelpers, leafletBoundsHelpers, leafletMapEvents) {
                    var _leafletCenter, isDefined = leafletHelpers.isDefined, isNumber = leafletHelpers.isNumber, isSameCenterOnMap = leafletHelpers.isSameCenterOnMap, safeApply = leafletHelpers.safeApply, isValidCenter = leafletHelpers.isValidCenter, isValidBounds = leafletBoundsHelpers.isValidBounds, isUndefinedOrEmpty = leafletHelpers.isUndefinedOrEmpty, errorHeader = leafletHelpers.errorHeader;
                    return {
                        restrict: "A",
                        scope: !1,
                        replace: !1,
                        require: "leaflet",
                        controller: function() {
                            _leafletCenter = $q.defer(), this.getCenter = function() {
                                return _leafletCenter.promise;
                            };
                        },
                        link: function(scope, element, attrs, controller) {
                            var leafletScope = controller.getLeafletScope(), centerModel = leafletScope[directiveName];
                            controller.getMap().then((function(map) {
                                var bounds, center, urlCenterHash, mapReady, defaults = leafletMapDefaults.getDefaults(attrs.id);
                                if (-1 !== attrs[directiveName].search("-")) return $log.error(errorHeader + ' The "center" variable can\'t use a "-" on its key name: "' + attrs[directiveName] + '".'), 
                                void map.setView([ defaults.center.lat, defaults.center.lng ], defaults.center.zoom);
                                if (bounds = leafletScope.bounds, center = centerModel, isDefined(bounds) && isValidBounds(bounds) && isUndefinedOrEmpty(center)) map.fitBounds(leafletBoundsHelpers.createLeafletBounds(leafletScope.bounds), leafletScope.bounds.options), 
                                centerModel = map.getCenter(), safeApply(leafletScope, (function(scope) {
                                    angular.extend(scope[directiveName], {
                                        lat: map.getCenter().lat,
                                        lng: map.getCenter().lng,
                                        zoom: map.getZoom(),
                                        autoDiscover: !1
                                    });
                                })), safeApply(leafletScope, (function(scope) {
                                    var mapBounds = map.getBounds();
                                    scope.bounds = {
                                        northEast: {
                                            lat: mapBounds._northEast.lat,
                                            lng: mapBounds._northEast.lng
                                        },
                                        southWest: {
                                            lat: mapBounds._southWest.lat,
                                            lng: mapBounds._southWest.lng
                                        }
                                    };
                                })); else {
                                    if (!isDefined(centerModel)) return $log.error(errorHeader + ' The "center" property is not defined in the main scope'), 
                                    void map.setView([ defaults.center.lat, defaults.center.lng ], defaults.center.zoom);
                                    isDefined(centerModel.lat) && isDefined(centerModel.lng) || isDefined(centerModel.autoDiscover) || angular.copy(defaults.center, centerModel);
                                }
                                if ("yes" === attrs.urlHashCenter) {
                                    var extractCenterFromUrl = function() {
                                        var centerParam, search = $location.search();
                                        if (isDefined(search.c)) {
                                            var cParam = search.c.split(":");
                                            3 === cParam.length && (centerParam = {
                                                lat: parseFloat(cParam[0]),
                                                lng: parseFloat(cParam[1]),
                                                zoom: parseInt(cParam[2], 10)
                                            });
                                        }
                                        return centerParam;
                                    };
                                    urlCenterHash = extractCenterFromUrl(), leafletScope.$on("$locationChangeSuccess", (function(event) {
                                        var scope = event.currentScope, urlCenter = extractCenterFromUrl();
                                        isDefined(urlCenter) && !isSameCenterOnMap(urlCenter, map) && angular.extend(scope[directiveName], {
                                            lat: urlCenter.lat,
                                            lng: urlCenter.lng,
                                            zoom: urlCenter.zoom
                                        });
                                    }));
                                }
                                leafletScope.$watch(directiveName, (function(center) {
                                    if (!leafletScope.settingCenterFromLeaflet) {
                                        if (isDefined(urlCenterHash) && (angular.copy(urlCenterHash, center), urlCenterHash = void 0), 
                                        isValidCenter(center) || !0 === center.autoDiscover) return !0 === center.autoDiscover ? (isNumber(center.zoom) || map.setView([ defaults.center.lat, defaults.center.lng ], defaults.center.zoom), 
                                        void (isNumber(center.zoom) && center.zoom > defaults.center.zoom ? map.locate({
                                            setView: !0,
                                            maxZoom: center.zoom
                                        }) : isDefined(defaults.maxZoom) ? map.locate({
                                            setView: !0,
                                            maxZoom: defaults.maxZoom
                                        }) : map.locate({
                                            setView: !0
                                        }))) : void (mapReady && isSameCenterOnMap(center, map) || (leafletScope.settingCenterFromScope = !0, 
                                        map.setView([ center.lat, center.lng ], center.zoom), leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map), 
                                        $timeout((function() {
                                            leafletScope.settingCenterFromScope = !1;
                                        }))));
                                        $log.warn(errorHeader + " invalid 'center'");
                                    }
                                }), !0), map.whenReady((function() {
                                    mapReady = !0;
                                })), map.on("moveend", (function() {
                                    _leafletCenter.resolve(), leafletMapEvents.notifyCenterUrlHashChanged(leafletScope, map, attrs, $location.search()), 
                                    isSameCenterOnMap(centerModel, map) || leafletScope.settingCenterFromScope || (leafletScope.settingCenterFromLeaflet = !0, 
                                    safeApply(leafletScope, (function(scope) {
                                        leafletScope.settingCenterFromScope || angular.extend(scope[directiveName], {
                                            lat: map.getCenter().lat,
                                            lng: map.getCenter().lng,
                                            zoom: map.getZoom(),
                                            autoDiscover: !1
                                        }), leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map), $timeout((function() {
                                            leafletScope.settingCenterFromLeaflet = !1;
                                        }));
                                    })));
                                })), !0 === centerModel.autoDiscover && map.on("locationerror", (function() {
                                    $log.warn(errorHeader + " The Geolocation API is unauthorized on this page."), isValidCenter(centerModel) ? (map.setView([ centerModel.lat, centerModel.lng ], centerModel.zoom), 
                                    leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map)) : (map.setView([ defaults.center.lat, defaults.center.lng ], defaults.center.zoom), 
                                    leafletMapEvents.notifyCenterChangedToBounds(leafletScope, map));
                                }));
                            }));
                        }
                    };
                } ];
            })), centerDirectiveTypes.forEach((function(dirType) {
                angular.module("leaflet-directive").directive(dirType, centerDirectives[dirType]);
            })), angular.module("leaflet-directive").directive("controls", [ "$log", "leafletHelpers", "leafletControlHelpers", function($log, leafletHelpers, leafletControlHelpers) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "?^leaflet",
                    link: function(scope, element, attrs, controller) {
                        if (controller) {
                            var createControl = leafletControlHelpers.createControl, isValidControlType = leafletControlHelpers.isValidControlType, leafletScope = controller.getLeafletScope(), isDefined = leafletHelpers.isDefined, isArray = leafletHelpers.isArray, leafletControls = {}, errorHeader = leafletHelpers.errorHeader + " [Controls] ";
                            controller.getMap().then((function(map) {
                                leafletScope.$watchCollection("controls", (function(newControls) {
                                    for (var name in leafletControls) isDefined(newControls[name]) || (map.hasControl(leafletControls[name]) && map.removeControl(leafletControls[name]), 
                                    delete leafletControls[name]);
                                    for (var newName in newControls) {
                                        var control, controlType = isDefined(newControls[newName].type) ? newControls[newName].type : newName;
                                        if (!isValidControlType(controlType)) return void $log.error(errorHeader + " Invalid control type: " + controlType + ".");
                                        if ("custom" !== controlType) control = createControl(controlType, newControls[newName]), 
                                        map.addControl(control), leafletControls[newName] = control; else {
                                            var customControlValue = newControls[newName];
                                            if (isArray(customControlValue)) for (var i in customControlValue) {
                                                var customControl = customControlValue[i];
                                                map.addControl(customControl), leafletControls[newName] = isDefined(leafletControls[newName]) ? leafletControls[newName].concat([ customControl ]) : [ customControl ];
                                            } else map.addControl(customControlValue), leafletControls[newName] = customControlValue;
                                        }
                                    }
                                }));
                            }));
                        }
                    }
                };
            } ]), angular.module("leaflet-directive").directive("decorations", [ "$log", "leafletHelpers", function($log, leafletHelpers) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "leaflet",
                    link: function(scope, element, attrs, controller) {
                        var leafletScope = controller.getLeafletScope(), PolylineDecoratorPlugin = leafletHelpers.PolylineDecoratorPlugin, isDefined = leafletHelpers.isDefined, leafletDecorations = {};
                        function setDecorationOptions(decoration, options) {
                            if (isDefined(decoration) && isDefined(options) && isDefined(options.coordinates) && isDefined(options.patterns)) return decoration.setPaths(options.coordinates), 
                            decoration.setPatterns(options.patterns), decoration;
                        }
                        controller.getMap().then((function(map) {
                            leafletScope.$watch("decorations", (function(newDecorations) {
                                for (var name in leafletDecorations) isDefined(newDecorations[name]) && angular.equals(newDecorations[name], leafletDecorations) || (map.removeLayer(leafletDecorations[name]), 
                                delete leafletDecorations[name]);
                                for (var newName in newDecorations) {
                                    var decorationData = newDecorations[newName], newDecoration = (isDefined(options = decorationData) && isDefined(options.coordinates) && (PolylineDecoratorPlugin.isLoaded() || $log.error("[AngularJS - Leaflet] The PolylineDecorator Plugin is not loaded.")), 
                                    L.polylineDecorator(options.coordinates));
                                    isDefined(newDecoration) && (leafletDecorations[newName] = newDecoration, map.addLayer(newDecoration), 
                                    setDecorationOptions(newDecoration, decorationData));
                                }
                                var options;
                            }), !0);
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("eventBroadcast", [ "$log", "$rootScope", "leafletHelpers", "leafletMapEvents", "leafletIterators", function($log, $rootScope, leafletHelpers, leafletMapEvents, leafletIterators) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "leaflet",
                    link: function(scope, element, attrs, controller) {
                        var isObject = leafletHelpers.isObject, isDefined = leafletHelpers.isDefined, leafletScope = controller.getLeafletScope(), eventBroadcast = leafletScope.eventBroadcast, availableMapEvents = leafletMapEvents.getAvailableMapEvents(), addEvents = leafletMapEvents.addEvents;
                        controller.getMap().then((function(map) {
                            var mapEvents = [], logic = "broadcast";
                            isDefined(eventBroadcast.map) ? isObject(eventBroadcast.map) ? ("emit" !== eventBroadcast.map.logic && "broadcast" !== eventBroadcast.map.logic ? $log.warn("[AngularJS - Leaflet] Available event propagation logic are: 'emit' or 'broadcast'.") : logic = eventBroadcast.map.logic, 
                            isObject(eventBroadcast.map.enable) && eventBroadcast.map.enable.length >= 0 ? leafletIterators.each(eventBroadcast.map.enable, (function(eventName) {
                                -1 === mapEvents.indexOf(eventName) && -1 !== availableMapEvents.indexOf(eventName) && mapEvents.push(eventName);
                            })) : $log.warn("[AngularJS - Leaflet] event-broadcast.map.enable must be an object check your model.")) : $log.warn("[AngularJS - Leaflet] event-broadcast.map must be an object check your model.") : mapEvents = availableMapEvents, 
                            addEvents(map, mapEvents, "eventName", leafletScope, logic);
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("geojson", [ "$log", "$rootScope", "leafletData", "leafletHelpers", "leafletWatchHelpers", "leafletDirectiveControlsHelpers", "leafletIterators", "leafletGeoJsonEvents", function($log, $rootScope, leafletData, leafletHelpers, leafletWatchHelpers, leafletDirectiveControlsHelpers, leafletIterators, leafletGeoJsonEvents) {
                var _maybeWatch = leafletWatchHelpers.maybeWatch, _watchOptions = leafletHelpers.watchOptions, _extendDirectiveControls = leafletDirectiveControlsHelpers.extend, hlp = leafletHelpers, $it = leafletIterators;
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "leaflet",
                    link: function(scope, element, attrs, controller) {
                        var isDefined = leafletHelpers.isDefined, leafletScope = controller.getLeafletScope(), leafletGeoJSON = {}, _hasSetLeafletData = !1;
                        controller.getMap().then((function(map) {
                            var watchOptions = leafletScope.geojsonWatchOptions || _watchOptions, isNested = hlp.isDefined(attrs.geojsonNested) && hlp.isTruthy(attrs.geojsonNested), _clean = function() {
                                if (leafletGeoJSON) {
                                    var _remove = function(lObject) {
                                        isDefined(lObject) && map.hasLayer(lObject) && map.removeLayer(lObject);
                                    };
                                    isNested ? $it.each(leafletGeoJSON, (function(lObject) {
                                        _remove(lObject);
                                    })) : _remove(leafletGeoJSON);
                                }
                            }, _addGeojson = function(model, maybeName) {
                                var geojson = angular.copy(model);
                                if (isDefined(geojson) && isDefined(geojson.data)) {
                                    var onEachFeature = function(geojson, maybeName) {
                                        return angular.isFunction(geojson.onEachFeature) ? geojson.onEachFeature : function(feature, layer) {
                                            leafletHelpers.LabelPlugin.isLoaded() && isDefined(feature.properties.description) && layer.bindLabel(feature.properties.description), 
                                            leafletGeoJsonEvents.bindEvents(attrs.id, layer, null, feature, leafletScope, maybeName, {
                                                resetStyleOnMouseout: geojson.resetStyleOnMouseout,
                                                mapId: attrs.id
                                            });
                                        };
                                    }(geojson, maybeName);
                                    isDefined(geojson.options) || (geojson.options = {
                                        style: geojson.style,
                                        filter: geojson.filter,
                                        onEachFeature,
                                        pointToLayer: geojson.pointToLayer
                                    });
                                    var lObject = L.geoJson(geojson.data, geojson.options);
                                    maybeName && hlp.isString(maybeName) ? leafletGeoJSON[maybeName] = lObject : leafletGeoJSON = lObject, 
                                    lObject.addTo(map), _hasSetLeafletData || (_hasSetLeafletData = !0, leafletData.setGeoJSON(leafletGeoJSON, attrs.id));
                                }
                            }, _create = function(model) {
                                if (_clean(), isNested) {
                                    if (!model || !Object.keys(model).length) return;
                                    $it.each(model, (function(m, name) {
                                        _addGeojson(m, name);
                                    }));
                                } else _addGeojson(model);
                            };
                            _extendDirectiveControls(attrs.id, "geojson", _create, _clean), _maybeWatch(leafletScope, "geojson", watchOptions, (function(geojson) {
                                _create(geojson);
                            }));
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("layercontrol", [ "$filter", "$log", "leafletData", "leafletHelpers", function($filter, $log, leafletData, leafletHelpers) {
                return {
                    restrict: "E",
                    scope: {
                        icons: "=?",
                        autoHideOpacity: "=?",
                        showGroups: "=?",
                        title: "@",
                        baseTitle: "@",
                        overlaysTitle: "@"
                    },
                    replace: !0,
                    transclude: !1,
                    require: "^leaflet",
                    controller: [ "$scope", "$element", "$sce", function($scope, $element, $sce) {
                        $log.debug("[Angular Directive - Layers] layers", $scope, $element);
                        var safeApply = leafletHelpers.safeApply, isDefined = leafletHelpers.isDefined;
                        angular.extend($scope, {
                            baselayer: "",
                            oldGroup: "",
                            layerProperties: {},
                            groupProperties: {},
                            rangeIsSupported: leafletHelpers.rangeIsSupported(),
                            changeBaseLayer: function(key, e) {
                                leafletHelpers.safeApply($scope, (function(scp) {
                                    scp.baselayer = key, leafletData.getMap().then((function(map) {
                                        leafletData.getLayers().then((function(leafletLayers) {
                                            if (!map.hasLayer(leafletLayers.baselayers[key])) {
                                                for (var i in scp.layers.baselayers) scp.layers.baselayers[i].icon = scp.icons.unradio, 
                                                map.hasLayer(leafletLayers.baselayers[i]) && map.removeLayer(leafletLayers.baselayers[i]);
                                                map.addLayer(leafletLayers.baselayers[key]), scp.layers.baselayers[key].icon = $scope.icons.radio;
                                            }
                                        }));
                                    }));
                                })), e.preventDefault();
                            },
                            moveLayer: function(ly, newIndex, e) {
                                var delta = Object.keys($scope.layers.baselayers).length;
                                if (newIndex >= 1 + delta && newIndex <= $scope.overlaysArray.length + delta) {
                                    var oldLy;
                                    for (var key in $scope.layers.overlays) if ($scope.layers.overlays[key].index === newIndex) {
                                        oldLy = $scope.layers.overlays[key];
                                        break;
                                    }
                                    oldLy && safeApply($scope, (function() {
                                        oldLy.index = ly.index, ly.index = newIndex;
                                    }));
                                }
                                e.stopPropagation(), e.preventDefault();
                            },
                            initIndex: function(layer, idx) {
                                var delta = Object.keys($scope.layers.baselayers).length;
                                layer.index = isDefined(layer.index) ? layer.index : idx + delta + 1;
                            },
                            initGroup: function(groupName) {
                                $scope.groupProperties[groupName] = $scope.groupProperties[groupName] ? $scope.groupProperties[groupName] : {};
                            },
                            toggleOpacity: function(e, layer) {
                                if (layer.visible) {
                                    if ($scope.autoHideOpacity && !$scope.layerProperties[layer.name].opacityControl) for (var k in $scope.layerProperties) $scope.layerProperties[k].opacityControl = !1;
                                    $scope.layerProperties[layer.name].opacityControl = !$scope.layerProperties[layer.name].opacityControl;
                                }
                                e.stopPropagation(), e.preventDefault();
                            },
                            toggleLegend: function(layer) {
                                $scope.layerProperties[layer.name].showLegend = !$scope.layerProperties[layer.name].showLegend;
                            },
                            showLegend: function(layer) {
                                return layer.legend && $scope.layerProperties[layer.name].showLegend;
                            },
                            unsafeHTML: function(html) {
                                return $sce.trustAsHtml(html);
                            },
                            getOpacityIcon: function(layer) {
                                return layer.visible && $scope.layerProperties[layer.name].opacityControl ? $scope.icons.close : $scope.icons.open;
                            },
                            getGroupIcon: function(group) {
                                return group.visible ? $scope.icons.check : $scope.icons.uncheck;
                            },
                            changeOpacity: function(layer) {
                                var op = $scope.layerProperties[layer.name].opacity;
                                leafletData.getMap().then((function(map) {
                                    leafletData.getLayers().then((function(leafletLayers) {
                                        var ly;
                                        for (var k in $scope.layers.overlays) if ($scope.layers.overlays[k] === layer) {
                                            ly = leafletLayers.overlays[k];
                                            break;
                                        }
                                        map.hasLayer(ly) && (ly.setOpacity && ly.setOpacity(op / 100), ly.getLayers && ly.eachLayer && ly.eachLayer((function(lay) {
                                            lay.setOpacity && lay.setOpacity(op / 100);
                                        })));
                                    }));
                                }));
                            },
                            changeGroupVisibility: function(groupName) {
                                if (isDefined($scope.groupProperties[groupName])) {
                                    var visible = $scope.groupProperties[groupName].visible;
                                    for (var k in $scope.layers.overlays) {
                                        var layer = $scope.layers.overlays[k];
                                        layer.group === groupName && (layer.visible = visible);
                                    }
                                }
                            }
                        });
                        var div = $element.get(0);
                        L.Browser.touch ? L.DomEvent.on(div, "click", L.DomEvent.stopPropagation) : (L.DomEvent.disableClickPropagation(div), 
                        L.DomEvent.on(div, "mousewheel", L.DomEvent.stopPropagation));
                    } ],
                    template: '<div class="angular-leaflet-control-layers" ng-show="overlaysArray.length"><h4 ng-if="title">{{ title }}</h4><div class="lf-baselayers"><h5 class="lf-title" ng-if="baseTitle">{{ baseTitle }}</h5><div class="lf-row" ng-repeat="(key, layer) in baselayersArray"><label class="lf-icon-bl" ng-click="changeBaseLayer(key, $event)"><input class="leaflet-control-layers-selector" type="radio" name="lf-radio" ng-show="false" ng-checked="baselayer === key" ng-value="key" /> <i class="lf-icon lf-icon-radio" ng-class="layer.icon"></i><div class="lf-text">{{layer.name}}</div></label></div></div><div class="lf-overlays"><h5 class="lf-title" ng-if="overlaysTitle">{{ overlaysTitle }}</h5><div class="lf-container"><div class="lf-row" ng-repeat="layer in (o = (overlaysArray | orderBy:\'index\':order))" ng-init="initIndex(layer, $index)"><label class="lf-icon-ol-group" ng-if="showGroups &amp;&amp; layer.group &amp;&amp; layer.group != o[$index-1].group"><input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-change="changeGroupVisibility(layer.group)" ng-model="groupProperties[layer.group].visible"/> <i class="lf-icon lf-icon-check" ng-class="getGroupIcon(groupProperties[layer.group])"></i><div class="lf-text">{{ layer.group }}</div></label><label class="lf-icon-ol"><input class="lf-control-layers-selector" type="checkbox" ng-show="false" ng-model="layer.visible"/> <i class="lf-icon lf-icon-check" ng-class="layer.icon"></i><div class="lf-text">{{layer.name}}</div></label><div class="lf-icons"><i class="lf-icon lf-up" ng-class="icons.up" ng-click="moveLayer(layer, layer.index - orderNumber, $event)"></i> <i class="lf-icon lf-down" ng-class="icons.down" ng-click="moveLayer(layer, layer.index + orderNumber, $event)"></i> <i class="lf-icon lf-toggle-legend" ng-class="icons.toggleLegend" ng-if="layer.legend" ng-click="toggleLegend(layer)"></i> <i class="lf-icon lf-open" ng-class="getOpacityIcon(layer)" ng-click="toggleOpacity($event, layer)"></i></div><div class="lf-legend" ng-if="showLegend(layer)" ng-bind-html="unsafeHTML(layer.legend)"></div><div class="lf-opacity clearfix" ng-if="layer.visible &amp;&amp; layerProperties[layer.name].opacityControl"><label ng-if="rangeIsSupported" class="pull-left" style="width: 50%">0</label><label ng-if="rangeIsSupported" class="pull-left text-right" style="width: 50%">100</label><input ng-if="rangeIsSupported" class="clearfix" type="range" min="0" max="100" class="lf-opacity-control" ng-model="layerProperties[layer.name].opacity" ng-change="changeOpacity(layer)"/><h6 ng-if="!rangeIsSupported">Range is not supported in this browser</h6></div></div></div></div></div>',
                    link: function(scope, element, attrs, controller) {
                        var isDefined = leafletHelpers.isDefined, leafletScope = controller.getLeafletScope(), layers = leafletScope.layers;
                        scope.$watch("icons", (function() {
                            var defaultIcons = {
                                uncheck: "fa fa-square-o",
                                check: "fa fa-check-square-o",
                                radio: "fa fa-dot-circle-o",
                                unradio: "fa fa-circle-o",
                                up: "fa fa-angle-up",
                                down: "fa fa-angle-down",
                                open: "fa fa-angle-double-down",
                                close: "fa fa-angle-double-up",
                                toggleLegend: "fa fa-pencil-square-o"
                            };
                            isDefined(scope.icons) ? (angular.extend(defaultIcons, scope.icons), angular.extend(scope.icons, defaultIcons)) : scope.icons = defaultIcons;
                        })), attrs.order = !isDefined(attrs.order) || "normal" !== attrs.order && "reverse" !== attrs.order ? "normal" : attrs.order, 
                        scope.order = "normal" === attrs.order, scope.orderNumber = "normal" === attrs.order ? -1 : 1, 
                        scope.layers = layers, controller.getMap().then((function(map) {
                            leafletScope.$watch("layers.baselayers", (function(newBaseLayers) {
                                var baselayersArray = {};
                                leafletData.getLayers().then((function(leafletLayers) {
                                    var key;
                                    for (key in newBaseLayers) {
                                        var layer = newBaseLayers[key];
                                        layer.icon = scope.icons[map.hasLayer(leafletLayers.baselayers[key]) ? "radio" : "unradio"], 
                                        baselayersArray[key] = layer;
                                    }
                                    scope.baselayersArray = baselayersArray;
                                }));
                            })), leafletScope.$watch("layers.overlays", (function(newOverlayLayers) {
                                var overlaysArray = [], groupVisibleCount = {};
                                leafletData.getLayers().then((function(leafletLayers) {
                                    var key;
                                    for (key in newOverlayLayers) {
                                        var layer = newOverlayLayers[key];
                                        layer.icon = scope.icons[layer.visible ? "check" : "uncheck"], overlaysArray.push(layer), 
                                        isDefined(scope.layerProperties[layer.name]) || (scope.layerProperties[layer.name] = {
                                            opacity: isDefined(layer.layerOptions.opacity) ? 100 * layer.layerOptions.opacity : 100,
                                            opacityControl: !1,
                                            showLegend: !0
                                        }), isDefined(layer.group) && (isDefined(scope.groupProperties[layer.group]) || (scope.groupProperties[layer.group] = {
                                            visible: !1
                                        }), groupVisibleCount[layer.group] = isDefined(groupVisibleCount[layer.group]) ? groupVisibleCount[layer.group] : {
                                            count: 0,
                                            visibles: 0
                                        }, groupVisibleCount[layer.group].count++, layer.visible && groupVisibleCount[layer.group].visibles++), 
                                        isDefined(layer.index) && leafletLayers.overlays[key].setZIndex && leafletLayers.overlays[key].setZIndex(newOverlayLayers[key].index);
                                    }
                                    for (key in groupVisibleCount) scope.groupProperties[key].visible = groupVisibleCount[key].visibles === groupVisibleCount[key].count;
                                    scope.overlaysArray = overlaysArray;
                                }));
                            }), !0);
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("layers", [ "$log", "$q", "leafletData", "leafletHelpers", "leafletLayerHelpers", "leafletControlHelpers", function($log, $q, leafletData, leafletHelpers, leafletLayerHelpers, leafletControlHelpers) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "leaflet",
                    controller: [ "$scope", function($scope) {
                        $scope._leafletLayers = $q.defer(), this.getLayers = function() {
                            return $scope._leafletLayers.promise;
                        };
                    } ],
                    link: function(scope, element, attrs, controller) {
                        var isDefined = leafletHelpers.isDefined, leafletLayers = {}, leafletScope = controller.getLeafletScope(), layers = leafletScope.layers, createLayer = leafletLayerHelpers.createLayer, safeAddLayer = leafletLayerHelpers.safeAddLayer, safeRemoveLayer = leafletLayerHelpers.safeRemoveLayer, updateLayersControl = leafletControlHelpers.updateLayersControl, isLayersControlVisible = !1;
                        controller.getMap().then((function(map) {
                            scope._leafletLayers.resolve(leafletLayers), leafletData.setLayers(leafletLayers, attrs.id), 
                            leafletLayers.baselayers = {}, leafletLayers.overlays = {};
                            var mapId = attrs.id, oneVisibleLayer = !1;
                            for (var layerName in layers.baselayers) {
                                var newBaseLayer = createLayer(layers.baselayers[layerName]);
                                isDefined(newBaseLayer) ? (leafletLayers.baselayers[layerName] = newBaseLayer, !0 === layers.baselayers[layerName].top && (safeAddLayer(map, leafletLayers.baselayers[layerName]), 
                                oneVisibleLayer = !0)) : delete layers.baselayers[layerName];
                            }
                            for (layerName in !oneVisibleLayer && Object.keys(leafletLayers.baselayers).length > 0 && safeAddLayer(map, leafletLayers.baselayers[Object.keys(layers.baselayers)[0]]), 
                            layers.overlays) {
                                var newOverlayLayer = createLayer(layers.overlays[layerName]);
                                isDefined(newOverlayLayer) ? (leafletLayers.overlays[layerName] = newOverlayLayer, 
                                !0 === layers.overlays[layerName].visible && safeAddLayer(map, leafletLayers.overlays[layerName])) : delete layers.overlays[layerName];
                            }
                            leafletScope.$watch("layers.baselayers", (function(newBaseLayers, oldBaseLayers) {
                                if (angular.equals(newBaseLayers, oldBaseLayers)) return isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers), 
                                !0;
                                for (var name in leafletLayers.baselayers) isDefined(newBaseLayers[name]) && !newBaseLayers[name].doRefresh || (map.hasLayer(leafletLayers.baselayers[name]) && map.removeLayer(leafletLayers.baselayers[name]), 
                                delete leafletLayers.baselayers[name], newBaseLayers[name] && newBaseLayers[name].doRefresh && (newBaseLayers[name].doRefresh = !1));
                                for (var newName in newBaseLayers) if (isDefined(leafletLayers.baselayers[newName])) !0 !== newBaseLayers[newName].top || map.hasLayer(leafletLayers.baselayers[newName]) ? !1 === newBaseLayers[newName].top && map.hasLayer(leafletLayers.baselayers[newName]) && map.removeLayer(leafletLayers.baselayers[newName]) : safeAddLayer(map, leafletLayers.baselayers[newName]); else {
                                    var testBaseLayer = createLayer(newBaseLayers[newName]);
                                    isDefined(testBaseLayer) && (leafletLayers.baselayers[newName] = testBaseLayer, 
                                    !0 === newBaseLayers[newName].top && safeAddLayer(map, leafletLayers.baselayers[newName]));
                                }
                                var found = !1;
                                for (var key in leafletLayers.baselayers) if (map.hasLayer(leafletLayers.baselayers[key])) {
                                    found = !0;
                                    break;
                                }
                                !found && Object.keys(leafletLayers.baselayers).length > 0 && safeAddLayer(map, leafletLayers.baselayers[Object.keys(leafletLayers.baselayers)[0]]), 
                                isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, newBaseLayers, layers.overlays, leafletLayers);
                            }), !0), leafletScope.$watch("layers.overlays", (function(newOverlayLayers, oldOverlayLayers) {
                                if (angular.equals(newOverlayLayers, oldOverlayLayers)) return isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers), 
                                !0;
                                for (var name in leafletLayers.overlays) if (!isDefined(newOverlayLayers[name]) || newOverlayLayers[name].doRefresh) {
                                    if (map.hasLayer(leafletLayers.overlays[name])) {
                                        var options = isDefined(newOverlayLayers[name]) ? newOverlayLayers[name].layerOptions : null;
                                        safeRemoveLayer(map, leafletLayers.overlays[name], options);
                                    }
                                    delete leafletLayers.overlays[name], newOverlayLayers[name] && newOverlayLayers[name].doRefresh && (newOverlayLayers[name].doRefresh = !1);
                                }
                                for (var newName in newOverlayLayers) {
                                    if (isDefined(leafletLayers.overlays[newName])) newOverlayLayers[newName].visible && !map.hasLayer(leafletLayers.overlays[newName]) ? safeAddLayer(map, leafletLayers.overlays[newName]) : !1 === newOverlayLayers[newName].visible && map.hasLayer(leafletLayers.overlays[newName]) && safeRemoveLayer(map, leafletLayers.overlays[newName], newOverlayLayers[newName].layerOptions); else {
                                        var testOverlayLayer = createLayer(newOverlayLayers[newName]);
                                        if (!isDefined(testOverlayLayer)) continue;
                                        leafletLayers.overlays[newName] = testOverlayLayer, !0 === newOverlayLayers[newName].visible && safeAddLayer(map, leafletLayers.overlays[newName]);
                                    }
                                    newOverlayLayers[newName].visible && map._loaded && newOverlayLayers[newName].data && "heatmap" === newOverlayLayers[newName].type && (leafletLayers.overlays[newName].setData(newOverlayLayers[newName].data), 
                                    leafletLayers.overlays[newName].update());
                                }
                                isLayersControlVisible = updateLayersControl(map, mapId, isLayersControlVisible, layers.baselayers, newOverlayLayers, leafletLayers);
                            }), !0);
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("legend", [ "$log", "$http", "leafletHelpers", "leafletLegendHelpers", function($log, $http, leafletHelpers, leafletLegendHelpers) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "leaflet",
                    link: function(scope, element, attrs, controller) {
                        var legendClass, position, leafletLegend, type, isArray = leafletHelpers.isArray, isDefined = leafletHelpers.isDefined, isFunction = leafletHelpers.isFunction, leafletScope = controller.getLeafletScope(), legend = leafletScope.legend;
                        leafletScope.$watch("legend", (function(newLegend) {
                            isDefined(newLegend) && (legendClass = newLegend.legendClass ? newLegend.legendClass : "legend", 
                            position = newLegend.position || "bottomright", type = newLegend.type || "arcgis");
                        }), !0), controller.getMap().then((function(map) {
                            leafletScope.$watch("legend", (function(newLegend) {
                                isDefined(newLegend) ? isDefined(newLegend.url) || "arcgis" !== type || isArray(newLegend.colors) && isArray(newLegend.labels) && newLegend.colors.length === newLegend.labels.length ? isDefined(newLegend.url) ? $log.info("[AngularJS - Leaflet] loading legend service.") : (isDefined(leafletLegend) && (leafletLegend.removeFrom(map), 
                                leafletLegend = null), leafletLegend = L.control({
                                    position
                                }), "arcgis" === type && (leafletLegend.onAdd = leafletLegendHelpers.getOnAddArrayLegend(newLegend, legendClass)), 
                                leafletLegend.addTo(map)) : $log.warn("[AngularJS - Leaflet] legend.colors and legend.labels must be set.") : isDefined(leafletLegend) && (leafletLegend.removeFrom(map), 
                                leafletLegend = null);
                            })), leafletScope.$watch("legend.url", (function(newURL) {
                                isDefined(newURL) && $http.get(newURL).success((function(legendData) {
                                    isDefined(leafletLegend) ? leafletLegendHelpers.updateLegend(leafletLegend.getContainer(), legendData, type, newURL) : ((leafletLegend = L.control({
                                        position
                                    })).onAdd = leafletLegendHelpers.getOnAddLegend(legendData, legendClass, type, newURL), 
                                    leafletLegend.addTo(map)), isDefined(legend.loadedData) && isFunction(legend.loadedData) && legend.loadedData();
                                })).error((function() {
                                    $log.warn("[AngularJS - Leaflet] legend.url not loaded.");
                                }));
                            }));
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("markers", [ "$log", "$rootScope", "$q", "leafletData", "leafletHelpers", "leafletMapDefaults", "leafletMarkersHelpers", "leafletMarkerEvents", "leafletIterators", "leafletWatchHelpers", "leafletDirectiveControlsHelpers", function($log, $rootScope, $q, leafletData, leafletHelpers, leafletMapDefaults, leafletMarkersHelpers, leafletMarkerEvents, leafletIterators, leafletWatchHelpers, leafletDirectiveControlsHelpers) {
                var isDefined = leafletHelpers.isDefined, errorHeader = leafletHelpers.errorHeader, Helpers = leafletHelpers, isString = leafletHelpers.isString, addMarkerWatcher = leafletMarkersHelpers.addMarkerWatcher, updateMarker = leafletMarkersHelpers.updateMarker, listenMarkerEvents = leafletMarkersHelpers.listenMarkerEvents, addMarkerToGroup = leafletMarkersHelpers.addMarkerToGroup, createMarker = leafletMarkersHelpers.createMarker, deleteMarker = leafletMarkersHelpers.deleteMarker, $it = leafletIterators, _markersWatchOptions = leafletHelpers.watchOptions, maybeWatch = leafletWatchHelpers.maybeWatch, extendDirectiveControls = leafletDirectiveControlsHelpers.extend, _getLMarker = function(leafletMarkers, name, maybeLayerName) {
                    if (Object.keys(leafletMarkers).length) {
                        if (maybeLayerName && isString(maybeLayerName)) {
                            if (!leafletMarkers[maybeLayerName] || !Object.keys(leafletMarkers[maybeLayerName]).length) return;
                            return leafletMarkers[maybeLayerName][name];
                        }
                        return leafletMarkers[name];
                    }
                }, _setLMarker = function(lObject, leafletMarkers, name, maybeLayerName) {
                    return maybeLayerName && isString(maybeLayerName) ? (isDefined(leafletMarkers[maybeLayerName]) || (leafletMarkers[maybeLayerName] = {}), 
                    leafletMarkers[maybeLayerName][name] = lObject) : leafletMarkers[name] = lObject, 
                    lObject;
                }, _maybeAddMarkerToLayer = function(layerName, layers, model, marker, doIndividualWatch, map) {
                    if (!isString(layerName)) return $log.error(errorHeader + " A layername must be a string"), 
                    !1;
                    if (!isDefined(layers)) return $log.error(errorHeader + " You must add layers to the directive if the markers are going to use this functionality."), 
                    !1;
                    if (!isDefined(layers.overlays) || !isDefined(layers.overlays[layerName])) return $log.error(errorHeader + ' A marker can only be added to a layer of type "group"'), 
                    !1;
                    var layerGroup = layers.overlays[layerName];
                    return layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup ? (layerGroup.addLayer(marker), 
                    !doIndividualWatch && map.hasLayer(marker) && !0 === model.focus && marker.openPopup(), 
                    !0) : ($log.error(errorHeader + ' Adding a marker to an overlay needs a overlay of the type "group" or "featureGroup"'), 
                    !1);
                }, _addMarkers = function(mapId, markersToRender, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, maybeLayerName, skips) {
                    for (var newName in markersToRender) if (!skips[newName]) if (-1 === newName.search("-")) {
                        var model = Helpers.copy(markersToRender[newName]), pathToMarker = Helpers.getObjectDotPath(maybeLayerName ? [ maybeLayerName, newName ] : [ newName ]), maybeLMarker = _getLMarker(leafletMarkers, newName, maybeLayerName);
                        if (isDefined(maybeLMarker)) {
                            var oldModel = isDefined(oldModel) ? oldModels[newName] : void 0;
                            updateMarker(model, oldModel, maybeLMarker, pathToMarker, leafletScope, layers, map);
                        } else {
                            var marker = createMarker(model), layerName = (model ? model.layer : void 0) || maybeLayerName;
                            if (!isDefined(marker)) {
                                $log.error(errorHeader + " Received invalid data on the marker " + newName + ".");
                                continue;
                            }
                            if (_setLMarker(marker, leafletMarkers, newName, maybeLayerName), isDefined(model.message) && marker.bindPopup(model.message, model.popupOptions), 
                            isDefined(model.group)) {
                                var groupOptions = isDefined(model.groupOption) ? model.groupOption : null;
                                addMarkerToGroup(marker, model.group, groupOptions, map);
                            }
                            if (Helpers.LabelPlugin.isLoaded() && isDefined(model.label) && isDefined(model.label.message) && marker.bindLabel(model.label.message, model.label.options), 
                            isDefined(model) && (isDefined(model.layer) || isDefined(maybeLayerName))) {
                                if (!_maybeAddMarkerToLayer(layerName, layers, model, marker, watchOptions.individual.doWatch, map)) continue;
                            } else isDefined(model.group) || (map.addLayer(marker), watchOptions.individual.doWatch || !0 !== model.focus || marker.openPopup());
                            watchOptions.individual.doWatch && addMarkerWatcher(marker, pathToMarker, leafletScope, layers, map, watchOptions.individual.isDeep), 
                            listenMarkerEvents(marker, model, leafletScope, watchOptions.individual.doWatch, map), 
                            leafletMarkerEvents.bindEvents(mapId, marker, pathToMarker, model, leafletScope, layerName);
                        }
                    } else $log.error('The marker can\'t use a "-" on his key name: "' + newName + '".');
                }, _seeWhatWeAlreadyHave = function(markerModels, oldMarkerModels, lMarkers, isEqual, cb) {
                    var oldMarker, newMarker, hasLogged = !1, equals = !1, doCheckOldModel = isDefined(oldMarkerModels);
                    for (var name in lMarkers) hasLogged || ($log.debug(errorHeader + "[markers] destroy: "), 
                    hasLogged = !0), doCheckOldModel && (newMarker = markerModels[name], oldMarker = oldMarkerModels[name], 
                    equals = angular.equals(newMarker, oldMarker) && isEqual), isDefined(markerModels) && Object.keys(markerModels).length && isDefined(markerModels[name]) && Object.keys(markerModels[name]).length && !equals || cb && Helpers.isFunction(cb) && cb(newMarker, oldMarker, name);
                }, _destroy = function(markerModels, oldMarkerModels, lMarkers, map, layers) {
                    _seeWhatWeAlreadyHave(markerModels, oldMarkerModels, lMarkers, !1, (function(newMarker, oldMarker, lMarkerName) {
                        $log.debug(errorHeader + "[marker] is deleting marker: " + lMarkerName), deleteMarker(lMarkers[lMarkerName], map, layers), 
                        delete lMarkers[lMarkerName];
                    }));
                }, _getNewModelsToSkipp = function(newModels, oldModels, lMarkers) {
                    var skips = {};
                    return _seeWhatWeAlreadyHave(newModels, oldModels, lMarkers, !0, (function(newMarker, oldMarker, lMarkerName) {
                        $log.debug(errorHeader + "[marker] is already rendered, marker: " + lMarkerName), 
                        skips[lMarkerName] = newMarker;
                    })), skips;
                };
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: [ "leaflet", "?layers" ],
                    link: function(scope, element, attrs, controller) {
                        var mapController = controller[0], leafletScope = mapController.getLeafletScope();
                        mapController.getMap().then((function(map) {
                            var getLayers, leafletMarkers = {};
                            getLayers = isDefined(controller[1]) ? controller[1].getLayers : function() {
                                var deferred = $q.defer();
                                return deferred.resolve(), deferred.promise;
                            };
                            var watchOptions = leafletScope.markersWatchOptions || _markersWatchOptions;
                            isDefined(attrs.watchMarkers) && (watchOptions.doWatch = watchOptions.individual.doWatch = !isDefined(attrs.watchMarkers) || Helpers.isTruthy(attrs.watchMarkers));
                            var isNested = isDefined(attrs.markersNested) && Helpers.isTruthy(attrs.markersNested);
                            getLayers().then((function(layers) {
                                var _clean = function(models, oldModels) {
                                    isNested ? $it.each(models, (function(markerToMaybeDel, layerName) {
                                        var oldModel = isDefined(oldModel) ? oldModels[layerName] : void 0;
                                        _destroy(markerToMaybeDel, oldModel, leafletMarkers[layerName], map, layers);
                                    })) : _destroy(models, oldModels, leafletMarkers, map, layers);
                                }, _create = function(models, oldModels) {
                                    _clean(models, oldModels);
                                    var skips = null;
                                    isNested ? $it.each(models, (function(markersToAdd, layerName) {
                                        var oldModel = isDefined(oldModel) ? oldModels[layerName] : void 0;
                                        skips = _getNewModelsToSkipp(models[layerName], oldModel, leafletMarkers[layerName]), 
                                        _addMarkers(attrs.id, markersToAdd, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, layerName, skips);
                                    })) : (skips = _getNewModelsToSkipp(models, oldModels, leafletMarkers), _addMarkers(attrs.id, models, oldModels, map, layers, leafletMarkers, leafletScope, watchOptions, void 0, skips));
                                };
                                extendDirectiveControls(attrs.id, "markers", _create, _clean), leafletData.setMarkers(leafletMarkers, attrs.id), 
                                maybeWatch(leafletScope, "markers", watchOptions, (function(newMarkers, oldMarkers) {
                                    _create(newMarkers, oldMarkers);
                                }));
                            }));
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("maxbounds", [ "$log", "leafletMapDefaults", "leafletBoundsHelpers", "leafletHelpers", function($log, leafletMapDefaults, leafletBoundsHelpers, leafletHelpers) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "leaflet",
                    link: function(scope, element, attrs, controller) {
                        var leafletScope = controller.getLeafletScope(), isValidBounds = leafletBoundsHelpers.isValidBounds, isNumber = leafletHelpers.isNumber;
                        controller.getMap().then((function(map) {
                            leafletScope.$watch("maxbounds", (function(maxbounds) {
                                if (isValidBounds(maxbounds)) {
                                    var leafletBounds = leafletBoundsHelpers.createLeafletBounds(maxbounds);
                                    isNumber(maxbounds.pad) && (leafletBounds = leafletBounds.pad(maxbounds.pad)), map.setMaxBounds(leafletBounds), 
                                    attrs.center || attrs.lfCenter || map.fitBounds(leafletBounds);
                                } else map.setMaxBounds();
                            }));
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("paths", [ "$log", "$q", "leafletData", "leafletMapDefaults", "leafletHelpers", "leafletPathsHelpers", "leafletPathEvents", function($log, $q, leafletData, leafletMapDefaults, leafletHelpers, leafletPathsHelpers, leafletPathEvents) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: [ "leaflet", "?layers" ],
                    link: function(scope, element, attrs, controller) {
                        var mapController = controller[0], isDefined = leafletHelpers.isDefined, isString = leafletHelpers.isString, leafletScope = mapController.getLeafletScope(), paths = leafletScope.paths, createPath = leafletPathsHelpers.createPath, bindPathEvents = leafletPathEvents.bindPathEvents, setPathOptions = leafletPathsHelpers.setPathOptions;
                        mapController.getMap().then((function(map) {
                            var getLayers, defaults = leafletMapDefaults.getDefaults(attrs.id);
                            getLayers = isDefined(controller[1]) ? controller[1].getLayers : function() {
                                var deferred = $q.defer();
                                return deferred.resolve(), deferred.promise;
                            }, isDefined(paths) && getLayers().then((function(layers) {
                                var leafletPaths = {};
                                leafletData.setPaths(leafletPaths, attrs.id);
                                var shouldWatch = !isDefined(attrs.watchPaths) || "true" === attrs.watchPaths, watchPathFn = function(leafletPath, name) {
                                    var clearWatch = leafletScope.$watch('paths["' + name + '"]', (function(pathData, old) {
                                        if (!isDefined(pathData)) {
                                            if (isDefined(old.layer)) for (var i in layers.overlays) {
                                                layers.overlays[i].removeLayer(leafletPath);
                                            }
                                            return map.removeLayer(leafletPath), void clearWatch();
                                        }
                                        setPathOptions(leafletPath, pathData.type, pathData);
                                    }), !0);
                                };
                                leafletScope.$watchCollection("paths", (function(newPaths) {
                                    for (var name in leafletPaths) isDefined(newPaths[name]) || (map.removeLayer(leafletPaths[name]), 
                                    delete leafletPaths[name]);
                                    for (var newName in newPaths) if (0 !== newName.search("\\$")) if (-1 === newName.search("-")) {
                                        if (!isDefined(leafletPaths[newName])) {
                                            var pathData = newPaths[newName], newPath = createPath(newName, newPaths[newName], defaults);
                                            if (isDefined(newPath) && isDefined(pathData.message) && newPath.bindPopup(pathData.message, pathData.popupOptions), 
                                            leafletHelpers.LabelPlugin.isLoaded() && isDefined(pathData.label) && isDefined(pathData.label.message) && newPath.bindLabel(pathData.label.message, pathData.label.options), 
                                            isDefined(pathData) && isDefined(pathData.layer)) {
                                                if (!isString(pathData.layer)) {
                                                    $log.error("[AngularJS - Leaflet] A layername must be a string");
                                                    continue;
                                                }
                                                if (!isDefined(layers)) {
                                                    $log.error("[AngularJS - Leaflet] You must add layers to the directive if the markers are going to use this functionality.");
                                                    continue;
                                                }
                                                if (!isDefined(layers.overlays) || !isDefined(layers.overlays[pathData.layer])) {
                                                    $log.error('[AngularJS - Leaflet] A path can only be added to a layer of type "group"');
                                                    continue;
                                                }
                                                var layerGroup = layers.overlays[pathData.layer];
                                                if (!(layerGroup instanceof L.LayerGroup || layerGroup instanceof L.FeatureGroup)) {
                                                    $log.error('[AngularJS - Leaflet] Adding a path to an overlay needs a overlay of the type "group" or "featureGroup"');
                                                    continue;
                                                }
                                                leafletPaths[newName] = newPath, layerGroup.addLayer(newPath), shouldWatch ? watchPathFn(newPath, newName) : setPathOptions(newPath, pathData.type, pathData);
                                            } else isDefined(newPath) && (leafletPaths[newName] = newPath, map.addLayer(newPath), 
                                            shouldWatch ? watchPathFn(newPath, newName) : setPathOptions(newPath, pathData.type, pathData));
                                            bindPathEvents(attrs.id, newPath, newName, pathData, leafletScope);
                                        }
                                    } else $log.error('[AngularJS - Leaflet] The path name "' + newName + '" is not valid. It must not include "-" and a number.');
                                }));
                            }));
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").directive("tiles", [ "$log", "leafletData", "leafletMapDefaults", "leafletHelpers", function($log, leafletData, leafletMapDefaults, leafletHelpers) {
                return {
                    restrict: "A",
                    scope: !1,
                    replace: !1,
                    require: "leaflet",
                    link: function(scope, element, attrs, controller) {
                        var isDefined = leafletHelpers.isDefined, leafletScope = controller.getLeafletScope(), tiles = leafletScope.tiles;
                        isDefined(tiles) && isDefined(tiles.url) ? controller.getMap().then((function(map) {
                            var tileLayerObj, defaults = leafletMapDefaults.getDefaults(attrs.id);
                            leafletScope.$watch("tiles", (function(tiles, oldtiles) {
                                var tileLayerOptions = defaults.tileLayerOptions, tileLayerUrl = defaults.tileLayer;
                                if (isDefined(tiles.url) || !isDefined(tileLayerObj)) return isDefined(tileLayerObj) ? !isDefined(tiles.url) || !isDefined(tiles.options) || tiles.type === oldtiles.type && angular.equals(tiles.options, tileLayerOptions) ? void (isDefined(tiles.url) && tileLayerObj.setUrl(tiles.url)) : (map.removeLayer(tileLayerObj), 
                                tileLayerOptions = defaults.tileLayerOptions, angular.copy(tiles.options, tileLayerOptions), 
                                tileLayerUrl = tiles.url, (tileLayerObj = "wms" === tiles.type ? L.tileLayer.wms(tileLayerUrl, tileLayerOptions) : L.tileLayer(tileLayerUrl, tileLayerOptions)).addTo(map), 
                                void leafletData.setTiles(tileLayerObj, attrs.id)) : (isDefined(tiles.options) && angular.copy(tiles.options, tileLayerOptions), 
                                isDefined(tiles.url) && (tileLayerUrl = tiles.url), (tileLayerObj = "wms" === tiles.type ? L.tileLayer.wms(tileLayerUrl, tileLayerOptions) : L.tileLayer(tileLayerUrl, tileLayerOptions)).addTo(map), 
                                void leafletData.setTiles(tileLayerObj, attrs.id));
                                map.removeLayer(tileLayerObj);
                            }), !0);
                        })) : $log.warn("[AngularJS - Leaflet] The 'tiles' definition doesn't have the 'url' property.");
                    }
                };
            } ]), [ "markers", "geojson" ].forEach((function(name) {
                angular.module("leaflet-directive").directive(name + "WatchOptions", [ "$log", "$rootScope", "$q", "leafletData", "leafletHelpers", function($log, $rootScope, $q, leafletData, leafletHelpers) {
                    var isDefined = leafletHelpers.isDefined, errorHeader = leafletHelpers.errorHeader, isObject = leafletHelpers.isObject, _watchOptions = leafletHelpers.watchOptions;
                    return {
                        restrict: "A",
                        scope: !1,
                        replace: !1,
                        require: [ "leaflet" ],
                        link: function(scope, element, attrs, controller) {
                            var mapController = controller[0], leafletScope = mapController.getLeafletScope();
                            mapController.getMap().then((function() {
                                isDefined(scope[name + "WatchOptions"]) && (isObject(scope[name + "WatchOptions"]) ? angular.extend(_watchOptions, scope[name + "WatchOptions"]) : $log.error(errorHeader + "[" + name + "WatchOptions] is not an object"), 
                                leafletScope[name + "WatchOptions"] = _watchOptions);
                            }));
                        }
                    };
                } ]);
            })), angular.module("leaflet-directive").factory("LeafletEventsHelpersFactory", [ "$rootScope", "$q", "$log", "leafletHelpers", function($rootScope, $q, $log, leafletHelpers) {
                var safeApply = leafletHelpers.safeApply, isDefined = leafletHelpers.isDefined, isObject = leafletHelpers.isObject, isArray = leafletHelpers.isArray, errorHeader = leafletHelpers.errorHeader, EventsHelper = function(rootBroadcastName, lObjectType) {
                    this.rootBroadcastName = rootBroadcastName, $log.debug("LeafletEventsHelpersFactory: lObjectType: " + lObjectType + "rootBroadcastName: " + rootBroadcastName), 
                    this.lObjectType = lObjectType;
                };
                return EventsHelper.prototype.getAvailableEvents = function() {
                    return [];
                }, EventsHelper.prototype.genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {
                    var _this = this;
                    return (maybeMapId = maybeMapId || "") && (maybeMapId = "." + maybeMapId), function(e) {
                        var broadcastName = _this.rootBroadcastName + maybeMapId + "." + eventName;
                        $log.debug(broadcastName), _this.fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName, extra);
                    };
                }, EventsHelper.prototype.fire = function(scope, broadcastName, logic, event, lObject, model, modelName, layerName) {
                    safeApply(scope, (function() {
                        var toSend = {
                            leafletEvent: event,
                            leafletObject: lObject,
                            modelName,
                            model
                        };
                        isDefined(layerName) && angular.extend(toSend, {
                            layerName
                        }), "emit" === logic ? scope.$emit(broadcastName, toSend) : $rootScope.$broadcast(broadcastName, toSend);
                    }));
                }, EventsHelper.prototype.bindEvents = function(maybeMapId, lObject, name, model, leafletScope, layerName, extra) {
                    var events = [], _this = this;
                    if (isDefined(leafletScope.eventBroadcast)) if (isObject(leafletScope.eventBroadcast)) if (isDefined(leafletScope.eventBroadcast[_this.lObjectType])) if (isObject(leafletScope.eventBroadcast[_this.lObjectType])) {
                        isDefined(leafletScope.eventBroadcast[this.lObjectType].logic) && "emit" !== leafletScope.eventBroadcast[_this.lObjectType].logic && "broadcast" !== leafletScope.eventBroadcast[_this.lObjectType].logic && $log.warn(errorHeader + "Available event propagation logic are: 'emit' or 'broadcast'.");
                        var eventsEnable = !1, eventsDisable = !1;
                        isDefined(leafletScope.eventBroadcast[_this.lObjectType].enable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].enable) && (eventsEnable = !0), 
                        isDefined(leafletScope.eventBroadcast[_this.lObjectType].disable) && isArray(leafletScope.eventBroadcast[_this.lObjectType].disable) && (eventsDisable = !0), 
                        eventsEnable && eventsDisable ? $log.warn(errorHeader + "can not enable and disable events at the same time") : eventsEnable || eventsDisable ? eventsEnable ? leafletScope.eventBroadcast[this.lObjectType].enable.forEach((function(eventName) {
                            -1 !== events.indexOf(eventName) ? $log.warn(errorHeader + "This event " + eventName + " is already enabled") : -1 === _this.getAvailableEvents().indexOf(eventName) ? $log.warn(errorHeader + "This event " + eventName + " does not exist") : events.push(eventName);
                        })) : (events = this.getAvailableEvents(), leafletScope.eventBroadcast[_this.lObjectType].disable.forEach((function(eventName) {
                            var index = events.indexOf(eventName);
                            -1 === index ? $log.warn(errorHeader + "This event " + eventName + " does not exist or has been already disabled") : events.splice(index, 1);
                        }))) : $log.warn(errorHeader + "must enable or disable events");
                    } else $log.warn(errorHeader + "event-broadcast." + [ _this.lObjectType ] + " must be an object check your model."); else events = this.getAvailableEvents(); else $log.error(errorHeader + "event-broadcast must be an object check your model."); else events = this.getAvailableEvents();
                    return events.forEach((function(eventName) {
                        lObject.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, "emit", leafletScope, lObject, name, model, layerName, extra));
                    })), "emit";
                }, EventsHelper;
            } ]).service("leafletEventsHelpers", [ "LeafletEventsHelpersFactory", function(LeafletEventsHelpersFactory) {
                return new LeafletEventsHelpersFactory;
            } ]), angular.module("leaflet-directive").factory("leafletGeoJsonEvents", [ "$rootScope", "$q", "$log", "leafletHelpers", "LeafletEventsHelpersFactory", "leafletData", function($rootScope, $q, $log, leafletHelpers, LeafletEventsHelpersFactory, leafletData) {
                var safeApply = leafletHelpers.safeApply, EventsHelper = LeafletEventsHelpersFactory, GeoJsonEvents = function() {
                    EventsHelper.call(this, "leafletDirectiveGeoJson", "geojson");
                };
                return (GeoJsonEvents.prototype = new EventsHelper).genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName, extra) {
                    var base = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName), _this = this;
                    return function(e) {
                        "mouseout" === eventName && (extra.resetStyleOnMouseout && leafletData.getGeoJSON(extra.mapId).then((function(leafletGeoJSON) {
                            (layerName ? leafletGeoJSON[layerName] : leafletGeoJSON).resetStyle(e.target);
                        })), safeApply(leafletScope, (function() {
                            $rootScope.$broadcast(_this.rootBroadcastName + ".mouseout", e);
                        }))), base(e);
                    };
                }, GeoJsonEvents.prototype.getAvailableEvents = function() {
                    return [ "click", "dblclick", "mouseover", "mouseout" ];
                }, new GeoJsonEvents;
            } ]), angular.module("leaflet-directive").factory("leafletLabelEvents", [ "$rootScope", "$q", "$log", "leafletHelpers", "LeafletEventsHelpersFactory", function($rootScope, $q, $log, leafletHelpers, LeafletEventsHelpersFactory) {
                var Helpers = leafletHelpers, EventsHelper = LeafletEventsHelpersFactory, LabelEvents = function() {
                    EventsHelper.call(this, "leafletDirectiveLabel", "markers");
                };
                return (LabelEvents.prototype = new EventsHelper).genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
                    var markerName = name.replace("markers.", "");
                    return EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, markerName, model, layerName);
                }, LabelEvents.prototype.getAvailableEvents = function() {
                    return [ "click", "dblclick", "mousedown", "mouseover", "mouseout", "contextmenu" ];
                }, LabelEvents.prototype.genEvents = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
                    var _this = this, labelEvents = this.getAvailableEvents(), scopeWatchName = Helpers.getObjectArrayPath("markers." + name);
                    labelEvents.forEach((function(eventName) {
                        lObject.label.on(eventName, _this.genDispatchEvent(maybeMapId, eventName, logic, leafletScope, lObject.label, scopeWatchName, model, layerName));
                    }));
                }, LabelEvents.prototype.bindEvents = function() {}, new LabelEvents;
            } ]), angular.module("leaflet-directive").factory("leafletMapEvents", [ "$rootScope", "$q", "$log", "leafletHelpers", "leafletEventsHelpers", "leafletIterators", function($rootScope, $q, $log, leafletHelpers, leafletEventsHelpers, leafletIterators) {
                var isDefined = leafletHelpers.isDefined, fire = leafletEventsHelpers.fire, _genDispatchMapEvent = function(scope, eventName, logic, maybeMapId) {
                    return maybeMapId && (maybeMapId += "."), function(e) {
                        var broadcastName = "leafletDirectiveMap." + maybeMapId + eventName;
                        $log.debug(broadcastName), fire(scope, broadcastName, logic, e, e.target, scope);
                    };
                };
                return {
                    getAvailableMapEvents: function() {
                        return [ "click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "contextmenu", "focus", "blur", "preclick", "load", "unload", "viewreset", "movestart", "move", "moveend", "dragstart", "drag", "dragend", "zoomstart", "zoomanim", "zoomend", "zoomlevelschange", "resize", "autopanstart", "layeradd", "layerremove", "baselayerchange", "overlayadd", "overlayremove", "locationfound", "locationerror", "popupopen", "popupclose", "draw:created", "draw:edited", "draw:deleted", "draw:drawstart", "draw:drawstop", "draw:editstart", "draw:editstop", "draw:deletestart", "draw:deletestop" ];
                    },
                    genDispatchMapEvent: _genDispatchMapEvent,
                    notifyCenterChangedToBounds: function(scope) {
                        scope.$broadcast("boundsChanged");
                    },
                    notifyCenterUrlHashChanged: function(scope, map, attrs, search) {
                        if (isDefined(attrs.urlHashCenter)) {
                            var center = map.getCenter(), centerUrlHash = center.lat.toFixed(4) + ":" + center.lng.toFixed(4) + ":" + map.getZoom();
                            isDefined(search.c) && search.c === centerUrlHash || scope.$emit("centerUrlHash", centerUrlHash);
                        }
                    },
                    addEvents: function(map, mapEvents, contextName, scope, logic) {
                        leafletIterators.each(mapEvents, (function(eventName) {
                            var context = {};
                            context[contextName] = eventName, map.on(eventName, _genDispatchMapEvent(scope, eventName, logic, map._container.id || ""), context);
                        }));
                    }
                };
            } ]), angular.module("leaflet-directive").factory("leafletMarkerEvents", [ "$rootScope", "$q", "$log", "leafletHelpers", "LeafletEventsHelpersFactory", "leafletLabelEvents", function($rootScope, $q, $log, leafletHelpers, LeafletEventsHelpersFactory, leafletLabelEvents) {
                var safeApply = leafletHelpers.safeApply, isDefined = leafletHelpers.isDefined, Helpers = leafletHelpers, lblHelp = leafletLabelEvents, EventsHelper = LeafletEventsHelpersFactory, MarkerEvents = function() {
                    EventsHelper.call(this, "leafletDirectiveMarker", "markers");
                };
                return (MarkerEvents.prototype = new EventsHelper).genDispatchEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
                    var handle = EventsHelper.prototype.genDispatchEvent.call(this, maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName);
                    return function(e) {
                        "click" === eventName ? safeApply(leafletScope, (function() {
                            $rootScope.$broadcast("leafletDirectiveMarkersClick", name);
                        })) : "dragend" === eventName && (safeApply(leafletScope, (function() {
                            model.lat = lObject.getLatLng().lat, model.lng = lObject.getLatLng().lng;
                        })), model.message && !0 === model.focus && lObject.openPopup()), handle(e);
                    };
                }, MarkerEvents.prototype.getAvailableEvents = function() {
                    return [ "click", "dblclick", "mousedown", "mouseover", "mouseout", "contextmenu", "dragstart", "drag", "dragend", "move", "remove", "popupopen", "popupclose", "touchend", "touchstart", "touchmove", "touchcancel", "touchleave" ];
                }, MarkerEvents.prototype.bindEvents = function(maybeMapId, lObject, name, model, leafletScope, layerName) {
                    var logic = EventsHelper.prototype.bindEvents.call(this, maybeMapId, lObject, name, model, leafletScope, layerName);
                    Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label) && lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model, layerName);
                }, new MarkerEvents;
            } ]), angular.module("leaflet-directive").factory("leafletPathEvents", [ "$rootScope", "$q", "$log", "leafletHelpers", "leafletLabelEvents", "leafletEventsHelpers", function($rootScope, $q, $log, leafletHelpers, leafletLabelEvents, leafletEventsHelpers) {
                var isDefined = leafletHelpers.isDefined, isObject = leafletHelpers.isObject, Helpers = leafletHelpers, errorHeader = leafletHelpers.errorHeader, lblHelp = leafletLabelEvents, fire = leafletEventsHelpers.fire, _genDispatchPathEvent = function(maybeMapId, eventName, logic, leafletScope, lObject, name, model, layerName) {
                    return (maybeMapId = maybeMapId || "") && (maybeMapId = "." + maybeMapId), function(e) {
                        var broadcastName = "leafletDirectivePath" + maybeMapId + "." + eventName;
                        $log.debug(broadcastName), fire(leafletScope, broadcastName, logic, e, e.target || lObject, model, name, layerName);
                    };
                }, _getAvailablePathEvents = function() {
                    return [ "click", "dblclick", "mousedown", "mouseover", "mouseout", "contextmenu", "add", "remove", "popupopen", "popupclose" ];
                };
                return {
                    getAvailablePathEvents: _getAvailablePathEvents,
                    bindPathEvents: function(maybeMapId, lObject, name, model, leafletScope) {
                        var i, eventName, pathEvents = [], logic = "broadcast";
                        if (isDefined(leafletScope.eventBroadcast)) if (isObject(leafletScope.eventBroadcast)) if (isDefined(leafletScope.eventBroadcast.path)) if (isObject(leafletScope.eventBroadcast.paths)) $log.warn(errorHeader + "event-broadcast.path must be an object check your model."); else {
                            void 0 !== leafletScope.eventBroadcast.path.logic && null !== leafletScope.eventBroadcast.path.logic && ("emit" !== leafletScope.eventBroadcast.path.logic && "broadcast" !== leafletScope.eventBroadcast.path.logic ? $log.warn(errorHeader + "Available event propagation logic are: 'emit' or 'broadcast'.") : "emit" === leafletScope.eventBroadcast.path.logic && (logic = "emit"));
                            var pathEventsEnable = !1, pathEventsDisable = !1;
                            if (void 0 !== leafletScope.eventBroadcast.path.enable && null !== leafletScope.eventBroadcast.path.enable && "object" == typeof leafletScope.eventBroadcast.path.enable && (pathEventsEnable = !0), 
                            void 0 !== leafletScope.eventBroadcast.path.disable && null !== leafletScope.eventBroadcast.path.disable && "object" == typeof leafletScope.eventBroadcast.path.disable && (pathEventsDisable = !0), 
                            pathEventsEnable && pathEventsDisable) $log.warn(errorHeader + "can not enable and disable events at the same time"); else if (pathEventsEnable || pathEventsDisable) if (pathEventsEnable) for (i = 0; i < leafletScope.eventBroadcast.path.enable.length; i++) eventName = leafletScope.eventBroadcast.path.enable[i], 
                            -1 !== pathEvents.indexOf(eventName) ? $log.warn(errorHeader + "This event " + eventName + " is already enabled") : -1 === _getAvailablePathEvents().indexOf(eventName) ? $log.warn(errorHeader + "This event " + eventName + " does not exist") : pathEvents.push(eventName); else for (pathEvents = _getAvailablePathEvents(), 
                            i = 0; i < leafletScope.eventBroadcast.path.disable.length; i++) {
                                eventName = leafletScope.eventBroadcast.path.disable[i];
                                var index = pathEvents.indexOf(eventName);
                                -1 === index ? $log.warn(errorHeader + "This event " + eventName + " does not exist or has been already disabled") : pathEvents.splice(index, 1);
                            } else $log.warn(errorHeader + "must enable or disable events");
                        } else pathEvents = _getAvailablePathEvents(); else $log.error(errorHeader + "event-broadcast must be an object check your model."); else pathEvents = _getAvailablePathEvents();
                        for (i = 0; i < pathEvents.length; i++) eventName = pathEvents[i], lObject.on(eventName, _genDispatchPathEvent(maybeMapId, eventName, logic, leafletScope, pathEvents, name));
                        Helpers.LabelPlugin.isLoaded() && isDefined(lObject.label) && lblHelp.genEvents(maybeMapId, name, logic, leafletScope, lObject, model);
                    }
                };
            } ]);
        })(angular);
    },
    937: () => {
        !function(window, angular) {
            "use strict";
            angular.module("ngMaterial", [ "ng", "ngAnimate", "ngAria", "material.core", "material.core.animate", "material.core.gestures", "material.core.interaction", "material.core.layout", "material.core.meta", "material.core.theming.palette", "material.core.theming", "material.components.autocomplete", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.chips", "material.components.colors", "material.components.content", "material.components.datepicker", "material.components.dialog", "material.components.divider", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.menu", "material.components.menuBar", "material.components.navBar", "material.components.panel", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.truncate", "material.components.virtualRepeat", "material.components.whiteframe" ]), 
            function() {
                function DetectNgTouch($log, $injector) {
                    if ($injector.has("$swipe")) {
                        $log.warn("You are using the ngTouch module. \nAngularJS Material already has mobile click, tap, and swipe support... \nngTouch is not supported with AngularJS Material!");
                    }
                }
                function MdCoreConfigure($provide, $mdThemingProvider) {
                    $provide.decorator("$$rAF", [ "$delegate", rAFDecorator ]), $provide.decorator("$q", [ "$delegate", qDecorator ]), 
                    $mdThemingProvider.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("deep-orange").backgroundPalette("grey");
                }
                function rAFDecorator($delegate) {
                    return $delegate.throttle = function(cb) {
                        var queuedArgs, alreadyQueued, queueCb, context;
                        return function() {
                            queuedArgs = arguments, context = this, queueCb = cb, alreadyQueued || (alreadyQueued = !0, 
                            $delegate((function() {
                                queueCb.apply(context, Array.prototype.slice.call(queuedArgs)), alreadyQueued = !1;
                            })));
                        };
                    }, $delegate;
                }
                function qDecorator($delegate) {
                    return $delegate.resolve || ($delegate.resolve = $delegate.when), $delegate;
                }
                DetectNgTouch.$inject = [ "$log", "$injector" ], MdCoreConfigure.$inject = [ "$provide", "$mdThemingProvider" ], 
                rAFDecorator.$inject = [ "$delegate" ], qDecorator.$inject = [ "$delegate" ], angular.module("material.core", [ "ngAnimate", "material.core.animate", "material.core.layout", "material.core.interaction", "material.core.gestures", "material.core.theming" ]).config(MdCoreConfigure).run(DetectNgTouch);
            }(), function() {
                function MdAutofocusDirective($parse) {
                    return {
                        restrict: "A",
                        link: {
                            pre: function(scope, element, attr) {
                                var attrExp = attr.mdAutoFocus || attr.mdAutofocus || attr.mdSidenavFocus;
                                updateExpression($parse(attrExp)(scope)), attrExp && scope.$watch(attrExp, updateExpression);
                                function updateExpression(value) {
                                    angular.isUndefined(value) && (value = !0), element.toggleClass("md-autofocus", !!value);
                                }
                            }
                        }
                    };
                }
                MdAutofocusDirective.$inject = [ "$parse" ], angular.module("material.core").directive("mdAutofocus", MdAutofocusDirective);
            }(), angular.module("material.core").factory("$mdColorUtil", (function() {
                return {
                    rgbaToHex: function(color) {
                        return ((color = color.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === color.length ? "#" + ("0" + parseInt(color[1], 10).toString(16)).slice(-2) + ("0" + parseInt(color[2], 10).toString(16)).slice(-2) + ("0" + parseInt(color[3], 10).toString(16)).slice(-2) : "").toUpperCase();
                    },
                    hexToRgba: function(color) {
                        var hex = "#" === color[0] ? color.substr(1) : color, dig = hex.length / 3, red = hex.substr(0, dig), green = hex.substr(dig, dig), blue = hex.substr(2 * dig);
                        return 1 === dig && (red += red, green += green, blue += blue), "rgba(" + parseInt(red, 16) + "," + parseInt(green, 16) + "," + parseInt(blue, 16) + ",0.1)";
                    },
                    rgbToRgba: function(color) {
                        return color.replace(")", ", 0.1)").replace("(", "a(");
                    },
                    rgbaToRgb: function(color) {
                        return color ? color.replace("rgba", "rgb").replace(/,[^),]+\)/, ")") : "rgb(0,0,0)";
                    }
                };
            })), angular.module("material.core").factory("$mdConstant", (function() {
                var prefixTestEl = document.createElement("div"), vendorPrefix = function(testElement) {
                    var prop, match, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/;
                    for (prop in testElement.style) if (match = vendorRegex.exec(prop)) return match[0];
                }(prefixTestEl), isWebkit = /webkit/i.test(vendorPrefix), SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g;
                function vendorProperty(name) {
                    var ucPrefix = (vendorPrefix + "-" + name).replace(SPECIAL_CHARS_REGEXP, (function(matches, separator, letter, offset) {
                        return offset ? letter.toUpperCase() : letter;
                    })), lcPrefix = ucPrefix.charAt(0).toLowerCase() + ucPrefix.substring(1);
                    return hasStyleProperty(prefixTestEl, name) ? name : hasStyleProperty(prefixTestEl, ucPrefix) ? ucPrefix : hasStyleProperty(prefixTestEl, lcPrefix) ? lcPrefix : name;
                }
                function hasStyleProperty(testElement, property) {
                    return angular.isDefined(testElement.style[property]);
                }
                var self = {
                    isInputKey: function(e) {
                        return e.keyCode >= 31 && e.keyCode <= 90;
                    },
                    isNumPadKey: function(e) {
                        return 3 === e.location && e.keyCode >= 97 && e.keyCode <= 105;
                    },
                    isMetaKey: function(e) {
                        return e.keyCode >= 91 && e.keyCode <= 93;
                    },
                    isFnLockKey: function(e) {
                        return e.keyCode >= 112 && e.keyCode <= 145;
                    },
                    isNavigationKey: function(e) {
                        var kc = self.KEY_CODE;
                        return -1 != [ kc.SPACE, kc.ENTER, kc.UP_ARROW, kc.DOWN_ARROW ].indexOf(e.keyCode);
                    },
                    hasModifierKey: function(e) {
                        return e.ctrlKey || e.metaKey || e.altKey;
                    },
                    ELEMENT_MAX_PIXELS: 1533917,
                    BEFORE_NG_ARIA: 210,
                    KEY_CODE: {
                        COMMA: 188,
                        SEMICOLON: 186,
                        ENTER: 13,
                        ESCAPE: 27,
                        SPACE: 32,
                        PAGE_UP: 33,
                        PAGE_DOWN: 34,
                        END: 35,
                        HOME: 36,
                        LEFT_ARROW: 37,
                        UP_ARROW: 38,
                        RIGHT_ARROW: 39,
                        DOWN_ARROW: 40,
                        TAB: 9,
                        BACKSPACE: 8,
                        DELETE: 46
                    },
                    CSS: {
                        TRANSITIONEND: "transitionend" + (isWebkit ? " webkitTransitionEnd" : ""),
                        ANIMATIONEND: "animationend" + (isWebkit ? " webkitAnimationEnd" : ""),
                        TRANSFORM: vendorProperty("transform"),
                        TRANSFORM_ORIGIN: vendorProperty("transformOrigin"),
                        TRANSITION: vendorProperty("transition"),
                        TRANSITION_DURATION: vendorProperty("transitionDuration"),
                        ANIMATION_PLAY_STATE: vendorProperty("animationPlayState"),
                        ANIMATION_DURATION: vendorProperty("animationDuration"),
                        ANIMATION_NAME: vendorProperty("animationName"),
                        ANIMATION_TIMING: vendorProperty("animationTimingFunction"),
                        ANIMATION_DIRECTION: vendorProperty("animationDirection")
                    },
                    MEDIA: {
                        xs: "(max-width: 599px)",
                        "gt-xs": "(min-width: 600px)",
                        sm: "(min-width: 600px) and (max-width: 959px)",
                        "gt-sm": "(min-width: 960px)",
                        md: "(min-width: 960px) and (max-width: 1279px)",
                        "gt-md": "(min-width: 1280px)",
                        lg: "(min-width: 1280px) and (max-width: 1919px)",
                        "gt-lg": "(min-width: 1920px)",
                        xl: "(min-width: 1920px)",
                        landscape: "(orientation: landscape)",
                        portrait: "(orientation: portrait)",
                        print: "print"
                    },
                    MEDIA_PRIORITY: [ "xl", "gt-lg", "lg", "gt-md", "md", "gt-sm", "sm", "gt-xs", "xs", "landscape", "portrait", "print" ]
                };
                return self;
            })), function() {
                function MdIterator(items, reloop) {
                    var trueFn = function() {
                        return !0;
                    };
                    items && !angular.isArray(items) && (items = Array.prototype.slice.call(items)), 
                    reloop = !!reloop;
                    var _items = items || [];
                    return {
                        items: function() {
                            return [].concat(_items);
                        },
                        count: function() {
                            return _items.length;
                        },
                        inRange,
                        contains,
                        indexOf,
                        itemAt: function(index) {
                            return inRange(index) ? _items[index] : null;
                        },
                        findBy: function(key, val) {
                            return _items.filter((function(item) {
                                return item[key] === val;
                            }));
                        },
                        add: function(item, index) {
                            if (!item) return -1;
                            angular.isNumber(index) || (index = _items.length);
                            return _items.splice(index, 0, item), indexOf(item);
                        },
                        remove: function(item) {
                            contains(item) && _items.splice(indexOf(item), 1);
                        },
                        first,
                        last,
                        next: angular.bind(null, findSubsequentItem, !1),
                        previous: angular.bind(null, findSubsequentItem, !0),
                        hasPrevious: function(item) {
                            return !!item && inRange(indexOf(item) - 1);
                        },
                        hasNext: function(item) {
                            return !!item && inRange(indexOf(item) + 1);
                        }
                    };
                    function inRange(index) {
                        return _items.length && index > -1 && index < _items.length;
                    }
                    function indexOf(item) {
                        return _items.indexOf(item);
                    }
                    function contains(item) {
                        return item && indexOf(item) > -1;
                    }
                    function first() {
                        return _items.length ? _items[0] : null;
                    }
                    function last() {
                        return _items.length ? _items[_items.length - 1] : null;
                    }
                    function findSubsequentItem(backwards, item, validate, limit) {
                        validate = validate || trueFn;
                        for (var curIndex = indexOf(item); ;) {
                            if (!inRange(curIndex)) return null;
                            var nextIndex = curIndex + (backwards ? -1 : 1), foundItem = null;
                            if (inRange(nextIndex) ? foundItem = _items[nextIndex] : reloop && (nextIndex = indexOf(foundItem = backwards ? last() : first())), 
                            null === foundItem || nextIndex === limit) return null;
                            if (validate(foundItem)) return foundItem;
                            angular.isUndefined(limit) && (limit = nextIndex), curIndex = nextIndex;
                        }
                    }
                }
                angular.module("material.core").config([ "$provide", function($provide) {
                    $provide.decorator("$mdUtil", [ "$delegate", function($delegate) {
                        return $delegate.iterator = MdIterator, $delegate;
                    } ]);
                } ]);
            }(), function() {
                function mdMediaFactory($mdConstant, $rootScope, $window) {
                    var queries = {}, mqls = {}, results = {}, normalizeCache = {};
                    return $mdMedia.getResponsiveAttribute = function(attrs, attrName) {
                        for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
                            var mediaName = $mdConstant.MEDIA_PRIORITY[i];
                            if (mqls[queries[mediaName]].matches) {
                                var normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
                                if (attrs[normalizedName]) return attrs[normalizedName];
                            }
                        }
                        return attrs[getNormalizedName(attrs, attrName)];
                    }, $mdMedia.getQuery = function(name) {
                        return mqls[name];
                    }, $mdMedia.watchResponsiveAttributes = function(attrNames, attrs, watchFn) {
                        var unwatchFns = [];
                        return attrNames.forEach((function(attrName) {
                            var normalizedName = getNormalizedName(attrs, attrName);
                            for (var mediaName in angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null))), 
                            $mdConstant.MEDIA) normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName), 
                            angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                        })), function() {
                            unwatchFns.forEach((function(fn) {
                                fn();
                            }));
                        };
                    }, $mdMedia;
                    function $mdMedia(query) {
                        var validated = queries[query];
                        angular.isUndefined(validated) && (validated = queries[query] = function(query) {
                            return $mdConstant.MEDIA[query] || ("(" !== query.charAt(0) ? "(" + query + ")" : query);
                        }(query));
                        var result = results[validated];
                        return angular.isUndefined(result) && (result = function(query) {
                            var result = mqls[query];
                            result || (result = mqls[query] = $window.matchMedia(query));
                            return result.addListener(onQueryChange), results[result.media] = !!result.matches;
                        }(validated)), result;
                    }
                    function onQueryChange(query) {
                        $rootScope.$evalAsync((function() {
                            results[query.media] = !!query.matches;
                        }));
                    }
                    function getNormalizedName(attrs, attrName) {
                        return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
                    }
                }
                mdMediaFactory.$inject = [ "$mdConstant", "$rootScope", "$window" ], angular.module("material.core").factory("$mdMedia", mdMediaFactory);
            }(), function() {
                function MdPrefixer(initialAttributes, buildSelector) {
                    var PREFIXES = [ "data", "x" ];
                    return initialAttributes ? buildSelector ? _buildSelector(initialAttributes) : _buildList(initialAttributes) : {
                        buildList: _buildList,
                        buildSelector: _buildSelector,
                        hasAttribute: function(element, attribute) {
                            if (!(element = _getNativeElement(element))) return !1;
                            for (var prefixedAttrs = _buildList(attribute), i = 0; i < prefixedAttrs.length; i++) if (element.hasAttribute(prefixedAttrs[i])) return !0;
                            return !1;
                        },
                        removeAttribute: function(element, attribute) {
                            if (!(element = _getNativeElement(element))) return;
                            _buildList(attribute).forEach((function(prefixedAttribute) {
                                element.removeAttribute(prefixedAttribute);
                            }));
                        }
                    };
                    function _buildList(attributes) {
                        return (attributes = angular.isArray(attributes) ? attributes : [ attributes ]).forEach((function(item) {
                            PREFIXES.forEach((function(prefix) {
                                attributes.push(prefix + "-" + item);
                            }));
                        })), attributes;
                    }
                    function _buildSelector(attributes) {
                        return _buildList(attributes = angular.isArray(attributes) ? attributes : [ attributes ]).map((function(item) {
                            return "[" + item + "]";
                        })).join(",");
                    }
                    function _getNativeElement(element) {
                        if ((element = element[0] || element).nodeType) return element;
                    }
                }
                angular.module("material.core").config([ "$provide", function($provide) {
                    $provide.decorator("$mdUtil", [ "$delegate", function($delegate) {
                        return $delegate.prefixer = MdPrefixer, $delegate;
                    } ]);
                } ]);
            }(), function() {
                UtilFactory.$inject = [ "$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window", "$$rAF" ];
                var isIos, isAndroid, isFirefox, nextUniqueId = 0;
                if (window.navigator) {
                    var userAgent = window.navigator.userAgent || window.navigator.vendor || window.opera;
                    isIos = userAgent.match(/ipad|iphone|ipod/i), isAndroid = userAgent.match(/android/i), 
                    isFirefox = userAgent.match(/(firefox|minefield)/i);
                }
                function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window, $$rAF) {
                    var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), usesStandardSymbols = "{{" === startSymbol && "}}" === endSymbol;
                    document.contains || (document.contains = function(node) {
                        return document.body.contains(node);
                    });
                    var hasComputedStyle = function(target, key, expectedVal) {
                        var hasValue = !1;
                        if (target && target.length) {
                            var computedStyles = $window.getComputedStyle(target[0]);
                            hasValue = angular.isDefined(computedStyles[key]) && (!expectedVal || computedStyles[key] == expectedVal);
                        }
                        return hasValue;
                    };
                    function validateCssValue(value) {
                        return value ? function(value) {
                            return String(value).indexOf("px") > -1;
                        }(value) || function(value) {
                            return String(value).indexOf("%") > -1;
                        }(value) ? value : value + "px" : "0";
                    }
                    var $mdUtil = {
                        dom: {},
                        isIos,
                        isAndroid,
                        now: window.performance && window.performance.now ? angular.bind(window.performance, window.performance.now) : Date.now || function() {
                            return (new Date).getTime();
                        },
                        getModelOption: function(ngModelCtrl, optionName) {
                            if (ngModelCtrl.$options) {
                                var $options = ngModelCtrl.$options;
                                return $options.getOption ? $options.getOption(optionName) : $options[optionName];
                            }
                        },
                        isRtl: function(attrs) {
                            switch (angular.isDefined(attrs) && attrs.hasOwnProperty("dir") && attrs.dir) {
                              case "ltr":
                                return !1;

                              case "rtl":
                                return !0;
                            }
                            return "rtl" === $document[0].dir || "rtl" === $document[0].body.dir;
                        },
                        bidi: function(element, property, lValue, rValue) {
                            var ltr = !this.isRtl();
                            if (0 == arguments.length) return ltr ? "ltr" : "rtl";
                            var elem = angular.element(element);
                            ltr && angular.isDefined(lValue) ? elem.css(property, validateCssValue(lValue)) : !ltr && angular.isDefined(rValue) && elem.css(property, validateCssValue(rValue));
                        },
                        bidiProperty: function(element, lProperty, rProperty, value) {
                            var ltr = !this.isRtl(), elem = angular.element(element);
                            ltr && angular.isDefined(lProperty) ? (elem.css(lProperty, validateCssValue(value)), 
                            elem.css(rProperty, "")) : !ltr && angular.isDefined(rProperty) && (elem.css(rProperty, validateCssValue(value)), 
                            elem.css(lProperty, ""));
                        },
                        clientRect: function(element, offsetParent, isOffsetRect) {
                            var node = getNode(element);
                            offsetParent = getNode(offsetParent || node.offsetParent || document.body);
                            var nodeRect = node.getBoundingClientRect(), offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                                left: 0,
                                top: 0,
                                width: 0,
                                height: 0
                            };
                            return {
                                left: nodeRect.left - offsetRect.left,
                                top: nodeRect.top - offsetRect.top,
                                width: nodeRect.width,
                                height: nodeRect.height
                            };
                        },
                        offsetRect: function(element, offsetParent) {
                            return $mdUtil.clientRect(element, offsetParent, !0);
                        },
                        nodesToArray: function(nodes) {
                            var i, results = [];
                            for (nodes = nodes || [], i = 0; i < nodes.length; ++i) results.push(nodes.item(i));
                            return results;
                        },
                        getViewportTop: function() {
                            return $mdUtil.disableScrollAround._count && $mdUtil.disableScrollAround._viewPortTop ? $mdUtil.disableScrollAround._viewPortTop : $window.scrollY || $window.pageYOffset || 0;
                        },
                        findFocusTarget: function(containerEl, attributeVal) {
                            var elToFocus, AUTO_FOCUS = this.prefixer("md-autofocus", !0);
                            return (elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS)) || (elToFocus = scanForFocusable(containerEl, AUTO_FOCUS)), 
                            elToFocus;
                            function scanForFocusable(target, selector) {
                                var elFound, items = target[0].querySelectorAll(selector);
                                return items && items.length && items.length && angular.forEach(items, (function(it) {
                                    (it = angular.element(it)).hasClass("md-autofocus") && (elFound = it);
                                })), elFound;
                            }
                        },
                        disableScrollAround: function(element, parent, options) {
                            if (options = options || {}, $mdUtil.disableScrollAround._count = Math.max(0, $mdUtil.disableScrollAround._count || 0), 
                            $mdUtil.disableScrollAround._count++, $mdUtil.disableScrollAround._restoreScroll) return $mdUtil.disableScrollAround._restoreScroll;
                            var body = $document[0].body, restoreBody = function() {
                                var documentElement = $document[0].documentElement, prevDocumentStyle = documentElement.style.cssText || "", prevBodyStyle = body.style.cssText || "", viewportTop = $mdUtil.getViewportTop();
                                $mdUtil.disableScrollAround._viewPortTop = viewportTop;
                                var clientWidth = body.clientWidth, hasVerticalScrollbar = body.scrollHeight > body.clientHeight + 1, scrollElement = documentElement.scrollTop > 0 ? documentElement : body;
                                hasVerticalScrollbar && angular.element(body).css({
                                    position: "fixed",
                                    width: "100%",
                                    top: -viewportTop + "px"
                                });
                                body.clientWidth < clientWidth && (body.style.overflow = "hidden");
                                return function() {
                                    body.style.cssText = prevBodyStyle, documentElement.style.cssText = prevDocumentStyle, 
                                    scrollElement.scrollTop = viewportTop;
                                };
                            }(), restoreElement = function(elementToDisable, scrollMaskOptions) {
                                var scrollMask, wrappedElementToDisable = angular.element(elementToDisable || body);
                                scrollMaskOptions.disableScrollMask ? scrollMask = wrappedElementToDisable : (scrollMask = angular.element('<div class="md-scroll-mask">  <div class="md-scroll-mask-bar"></div></div>'), 
                                wrappedElementToDisable.append(scrollMask));
                                function preventDefault($event) {
                                    $event.preventDefault();
                                }
                                return scrollMask.on("wheel touchmove", preventDefault), function() {
                                    scrollMask.off("wheel touchmove", preventDefault), !scrollMaskOptions.disableScrollMask && scrollMask[0].parentNode && scrollMask[0].parentNode.removeChild(scrollMask[0]);
                                };
                            }(parent, options);
                            return $mdUtil.disableScrollAround._restoreScroll = function() {
                                --$mdUtil.disableScrollAround._count <= 0 && (delete $mdUtil.disableScrollAround._viewPortTop, 
                                restoreBody(), restoreElement(), delete $mdUtil.disableScrollAround._restoreScroll);
                            };
                        },
                        enableScrolling: function() {
                            var restoreFn = this.disableScrollAround._restoreScroll;
                            restoreFn && restoreFn();
                        },
                        floatingScrollbars: function() {
                            if (undefined === this.floatingScrollbars.cached) {
                                var tempNode = angular.element("<div><div></div></div>").css({
                                    width: "100%",
                                    "z-index": -1,
                                    position: "absolute",
                                    height: "35px",
                                    "overflow-y": "scroll"
                                });
                                tempNode.children().css("height", "60px"), $document[0].body.appendChild(tempNode[0]), 
                                this.floatingScrollbars.cached = tempNode[0].offsetWidth === tempNode[0].childNodes[0].offsetWidth, 
                                tempNode.remove();
                            }
                            return this.floatingScrollbars.cached;
                        },
                        forceFocus: function(element) {
                            var node = element[0] || element;
                            document.addEventListener("click", (function focusOnClick(ev) {
                                ev.target === node && ev.$focus && (node.focus(), ev.stopImmediatePropagation(), 
                                ev.preventDefault(), node.removeEventListener("click", focusOnClick));
                            }), !0);
                            var newEvent = document.createEvent("MouseEvents");
                            newEvent.initMouseEvent("click", !1, !0, window, {}, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), 
                            newEvent.$material = !0, newEvent.$focus = !0, node.dispatchEvent(newEvent);
                        },
                        createBackdrop: function(scope, addClass) {
                            return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [ addClass ]))(scope);
                        },
                        supplant: function(template, values, pattern) {
                            return pattern = pattern || /\{([^{}]*)\}/g, template.replace(pattern, (function(a, b) {
                                var p = b.split("."), r = values;
                                try {
                                    for (var s in p) p.hasOwnProperty(s) && (r = r[p[s]]);
                                } catch (e) {
                                    r = a;
                                }
                                return "string" == typeof r || "number" == typeof r ? r : a;
                            }));
                        },
                        fakeNgModel: function() {
                            return {
                                $fake: !0,
                                $setTouched: angular.noop,
                                $setViewValue: function(value) {
                                    this.$viewValue = value, this.$render(value), this.$viewChangeListeners.forEach((function(cb) {
                                        cb();
                                    }));
                                },
                                $isEmpty: function(value) {
                                    return 0 === ("" + value).length;
                                },
                                $parsers: [],
                                $formatters: [],
                                $viewChangeListeners: [],
                                $render: angular.noop
                            };
                        },
                        debounce: function(func, wait, scope, invokeApply) {
                            var timer;
                            return function() {
                                var context = scope, args = Array.prototype.slice.call(arguments);
                                $timeout.cancel(timer), timer = $timeout((function() {
                                    timer = undefined, func.apply(context, args);
                                }), wait || 10, invokeApply);
                            };
                        },
                        throttle: function(func, delay) {
                            var recent;
                            return function() {
                                var args = arguments, now = $mdUtil.now();
                                (!recent || now - recent > delay) && (func.apply(this, args), recent = now);
                            };
                        },
                        time: function(cb) {
                            var start = $mdUtil.now();
                            return cb(), $mdUtil.now() - start;
                        },
                        valueOnUse: function(scope, key, getter) {
                            var value = null, args = Array.prototype.slice.call(arguments), params = args.length > 3 ? args.slice(3) : [];
                            Object.defineProperty(scope, key, {
                                get: function() {
                                    return null === value && (value = getter.apply(scope, params)), value;
                                }
                            });
                        },
                        nextUid: function() {
                            return "" + nextUniqueId++;
                        },
                        disconnectScope: function(scope) {
                            if (scope && scope.$root !== scope && !scope.$$destroyed) {
                                var parent = scope.$parent;
                                scope.$$disconnected = !0, parent.$$childHead === scope && (parent.$$childHead = scope.$$nextSibling), 
                                parent.$$childTail === scope && (parent.$$childTail = scope.$$prevSibling), scope.$$prevSibling && (scope.$$prevSibling.$$nextSibling = scope.$$nextSibling), 
                                scope.$$nextSibling && (scope.$$nextSibling.$$prevSibling = scope.$$prevSibling), 
                                scope.$$nextSibling = scope.$$prevSibling = null;
                            }
                        },
                        reconnectScope: function(scope) {
                            if (scope && scope.$root !== scope && scope.$$disconnected) {
                                var child = scope, parent = child.$parent;
                                child.$$disconnected = !1, child.$$prevSibling = parent.$$childTail, parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, 
                                parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child;
                            }
                        },
                        getSiblings: function(element, tagName) {
                            var upperCasedTagName = tagName.toUpperCase();
                            return element instanceof angular.element && (element = element[0]), Array.prototype.filter.call(element.parentNode.children, (function(node) {
                                return element !== node && node.tagName.toUpperCase() === upperCasedTagName;
                            })).map((function(sibling) {
                                return angular.element(sibling);
                            }));
                        },
                        getClosest: function(el, validateWith, onlyParent) {
                            if (angular.isString(validateWith)) {
                                var tagName = validateWith.toUpperCase();
                                validateWith = function(el) {
                                    return el.nodeName.toUpperCase() === tagName;
                                };
                            }
                            if (el instanceof angular.element && (el = el[0]), onlyParent && (el = el.parentNode), 
                            !el) return null;
                            do {
                                if (validateWith(el)) return el;
                            } while (el = el.parentNode);
                            return null;
                        },
                        elementContains: function(node, child) {
                            return (window.Node && window.Node.prototype && Node.prototype.contains ? angular.bind(node, node.contains) : angular.bind(node, (function(arg) {
                                return node === child || !!(16 & this.compareDocumentPosition(arg));
                            })))(child);
                        },
                        extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
                            var found = scanTree(element);
                            return !found && warnNotFound && $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [ nodeName, element[0].outerHTML ])), 
                            angular.element(found || element);
                            function scanTree(element) {
                                return function(element) {
                                    if (element) for (var i = 0, len = element.length; i < len; i++) if (element[i].nodeName.toLowerCase() === nodeName) return element[i];
                                    return null;
                                }(element) || (scanDeep ? function(element) {
                                    var found;
                                    if (element) for (var i = 0, len = element.length; i < len; i++) {
                                        var target = element[i];
                                        if (!found) for (var j = 0, numChild = target.childNodes.length; j < numChild; j++) found = found || scanTree([ target.childNodes[j] ]);
                                    }
                                    return found;
                                }(element) : null);
                            }
                        },
                        initOptionalProperties: function(scope, attr, defaults) {
                            defaults = defaults || {}, angular.forEach(scope.$$isolateBindings, (function(binding, key) {
                                if (binding.optional && angular.isUndefined(scope[key])) {
                                    var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                                    scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                                }
                            }));
                        },
                        nextTick: function(callback, digest, scope) {
                            var nextTick = $mdUtil.nextTick, timeout = nextTick.timeout, queue = nextTick.queue || [];
                            return queue.push({
                                scope,
                                callback
                            }), null == digest && (digest = !0), nextTick.digest = nextTick.digest || digest, 
                            nextTick.queue = queue, timeout || (nextTick.timeout = $timeout((function() {
                                var queue = nextTick.queue, digest = nextTick.digest;
                                nextTick.queue = [], nextTick.timeout = null, nextTick.digest = !1, queue.forEach((function(queueItem) {
                                    queueItem.scope && queueItem.scope.$$destroyed || queueItem.callback();
                                })), digest && $rootScope.$digest();
                            }), 0, !1));
                        },
                        processTemplate: function(template) {
                            return usesStandardSymbols ? template : template && angular.isString(template) ? template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol) : template;
                        },
                        getParentWithPointerEvents: function(element) {
                            for (var parent = element.parent(); hasComputedStyle(parent, "pointer-events", "none"); ) parent = parent.parent();
                            return parent;
                        },
                        getNearestContentElement: function(element) {
                            for (var current = element.parent()[0]; current && current !== $rootElement[0] && current !== document.body && "MD-CONTENT" !== current.nodeName.toUpperCase(); ) current = current.parentNode;
                            return current;
                        },
                        checkStickySupport: function() {
                            var stickyProp, testEl = angular.element("<div>");
                            $document[0].body.appendChild(testEl[0]);
                            for (var stickyProps = [ "sticky", "-webkit-sticky" ], i = 0; i < stickyProps.length; ++i) if (testEl.css({
                                position: stickyProps[i],
                                top: 0,
                                "z-index": 2
                            }), testEl.css("position") == stickyProps[i]) {
                                stickyProp = stickyProps[i];
                                break;
                            }
                            return testEl.remove(), stickyProp;
                        },
                        parseAttributeBoolean: function(value, negatedCheck) {
                            return "" === value || !!value && (!1 === negatedCheck || "false" !== value && "0" !== value);
                        },
                        hasComputedStyle,
                        isParentFormSubmitted: function(element) {
                            var parent = $mdUtil.getClosest(element, "form"), form = parent ? angular.element(parent).controller("form") : null;
                            return !!form && form.$submitted;
                        },
                        animateScrollTo: function(element, scrollEnd, duration) {
                            var scrollStart = element.scrollTop, scrollChange = scrollEnd - scrollStart, scrollingDown = scrollStart < scrollEnd, startTime = $mdUtil.now();
                            $$rAF((function scrollChunk() {
                                var newPosition = (easeDuration = duration || 1e3, function(currentTime, start, change, duration) {
                                    if (currentTime > duration) return start + change;
                                    var ts = (currentTime /= duration) * currentTime, tc = ts * currentTime;
                                    return start + change * (-2 * tc + 3 * ts);
                                }($mdUtil.now() - startTime, scrollStart, scrollChange, easeDuration));
                                var easeDuration;
                                element.scrollTop = newPosition, (scrollingDown ? newPosition < scrollEnd : newPosition > scrollEnd) && $$rAF(scrollChunk);
                            }));
                        },
                        uniq: function(array) {
                            if (array) return array.filter((function(value, index, self) {
                                return self.indexOf(value) === index;
                            }));
                        },
                        getInnerHTML: function(element) {
                            var serializer = new XMLSerializer;
                            return Array.prototype.map.call(element.childNodes, (function(child) {
                                return serializer.serializeToString(child);
                            })).join("");
                        },
                        getOuterHTML: function(element) {
                            return (new XMLSerializer).serializeToString(element);
                        },
                        msie: window.document.documentMode,
                        getTouchAction: function() {
                            for (var testEl = document.createElement("div"), vendorPrefixes = [ "", "webkit", "Moz", "MS", "ms", "o" ], i = 0; i < vendorPrefixes.length; i++) {
                                var prefix = vendorPrefixes[i], property = prefix ? prefix + "TouchAction" : "touchAction";
                                if (angular.isDefined(testEl.style[property])) return property;
                            }
                        },
                        getEventPath: function(event) {
                            for (var path = [], currentTarget = event.target; currentTarget; ) path.push(currentTarget), 
                            currentTarget = currentTarget.parentElement;
                            return -1 === path.indexOf(window) && -1 === path.indexOf(document) && path.push(document), 
                            -1 === path.indexOf(window) && path.push(window), path;
                        },
                        sanitize: function(term) {
                            return term ? term.replace(/[\\^$*+?.()|{}[]/g, "\\$&") : term;
                        },
                        isDisabled: function(element) {
                            return element.hasAttribute("disabled");
                        },
                        isVisible: function(element) {
                            return $mdUtil.hasGeometry(element) && "visible" === getComputedStyle(element).visibility;
                        },
                        isTabbable: function(element) {
                            var frameElement = $mdUtil.getFrameElement($mdUtil.getWindow(element));
                            if (frameElement) {
                                if (-1 === $mdUtil.getTabIndexValue(frameElement)) return !1;
                                if (!$mdUtil.isVisible(frameElement)) return !1;
                            }
                            var nodeName = element.nodeName.toLowerCase(), tabIndexValue = $mdUtil.getTabIndexValue(element);
                            return element.hasAttribute("contenteditable") ? -1 !== tabIndexValue : "iframe" !== nodeName && "object" !== nodeName && (!(isIos && !$mdUtil.isPotentiallyTabbableIOS(element)) && ("audio" === nodeName ? !!element.hasAttribute("controls") && -1 !== tabIndexValue : "video" === nodeName ? -1 !== tabIndexValue && (null !== tabIndexValue || (isFirefox || element.hasAttribute("controls"))) : element.tabIndex >= 0));
                        },
                        isFocusable: function(element) {
                            return $mdUtil.isPotentiallyFocusable(element) && !$mdUtil.isDisabled(element) && $mdUtil.isVisible(element);
                        },
                        isPotentiallyFocusable: function(element) {
                            return !$mdUtil.isHiddenInput(element) && ($mdUtil.isNativeFormElement(element) || $mdUtil.isAnchorWithHref(element) || element.hasAttribute("contenteditable") || $mdUtil.hasValidTabIndex(element));
                        },
                        isPotentiallyTabbableIOS: function(element) {
                            var nodeName = element.nodeName.toLowerCase(), inputType = "input" === nodeName && element.type;
                            return "text" === inputType || "password" === inputType || "select" === nodeName || "textarea" === nodeName;
                        },
                        getTabIndexValue: function(element) {
                            if (!$mdUtil.hasValidTabIndex(element)) return null;
                            var tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
                            return isNaN(tabIndex) ? -1 : tabIndex;
                        },
                        hasValidTabIndex: function(element) {
                            if (!element.hasAttribute("tabindex") || undefined === element.tabIndex) return !1;
                            var tabIndex = element.getAttribute("tabindex");
                            return "-32768" != tabIndex && !(!tabIndex || isNaN(parseInt(tabIndex, 10)));
                        },
                        hasGeometry: function(element) {
                            return !!(element.offsetWidth || element.offsetHeight || "function" == typeof element.getClientRects && element.getClientRects().length);
                        },
                        getFrameElement: function(window) {
                            try {
                                return window.frameElement;
                            } catch (error) {
                                return null;
                            }
                        },
                        getWindow: function(node) {
                            return node.ownerDocument && node.ownerDocument.defaultView || window;
                        },
                        isNativeFormElement: function(element) {
                            var nodeName = element.nodeName.toLowerCase();
                            return "input" === nodeName || "select" === nodeName || "button" === nodeName || "textarea" === nodeName;
                        },
                        isHiddenInput: function(element) {
                            return $mdUtil.isInputElement(element) && "hidden" == element.type;
                        },
                        isAnchorWithHref: function(element) {
                            return $mdUtil.isAnchorElement(element) && element.hasAttribute("href");
                        },
                        isInputElement: function(element) {
                            return "input" == element.nodeName.toLowerCase();
                        },
                        isAnchorElement: function(element) {
                            return "a" == element.nodeName.toLowerCase();
                        },
                        getFirstTabbableElement: function(root) {
                            if ($mdUtil.isFocusable(root) && $mdUtil.isTabbable(root)) return root;
                            for (var children = root.children || root.childNodes, i = 0; i < children.length; i++) {
                                var tabbableChild = children[i].nodeType === $document[0].ELEMENT_NODE ? $mdUtil.getFirstTabbableElement(children[i]) : null;
                                if (tabbableChild) return tabbableChild;
                            }
                            return null;
                        },
                        getLastTabbableElement: function(root) {
                            if ($mdUtil.isFocusable(root) && $mdUtil.isTabbable(root)) return root;
                            for (var children = root.children || root.childNodes, i = children.length - 1; i >= 0; i--) {
                                var tabbableChild = children[i].nodeType === $document[0].ELEMENT_NODE ? $mdUtil.getLastTabbableElement(children[i]) : null;
                                if (tabbableChild) return tabbableChild;
                            }
                            return null;
                        }
                    };
                    return $mdUtil.dom.animator = $$mdAnimate($mdUtil), $mdUtil;
                    function getNode(el) {
                        return el[0] || el;
                    }
                }
                angular.module("material.core").factory("$mdUtil", UtilFactory), angular.element.prototype.focus = angular.element.prototype.focus || function() {
                    return this.length && this[0].focus(), this;
                }, angular.element.prototype.blur = angular.element.prototype.blur || function() {
                    return this.length && this[0].blur(), this;
                };
            }(), angular.module("material.core").factory("$$mdAnimate", [ "$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss) {
                return function($mdUtil) {
                    return function($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
                        var self;
                        return self = {
                            translate3d: function(target, from, to, options) {
                                return $animateCss(target, {
                                    from,
                                    to,
                                    addClass: options.transitionInClass,
                                    removeClass: options.transitionOutClass,
                                    duration: options.duration
                                }).start().then((function() {
                                    return reverseTranslate;
                                }));
                                function reverseTranslate(newFrom) {
                                    return $animateCss(target, {
                                        to: newFrom || from,
                                        addClass: options.transitionOutClass,
                                        removeClass: options.transitionInClass,
                                        duration: options.duration
                                    }).start();
                                }
                            },
                            waitTransitionEnd: function(element, opts) {
                                var TIMEOUT = 3e3;
                                return $q((function(resolve, reject) {
                                    noTransitionFound((opts = opts || {}).cachedTransitionStyles) && (TIMEOUT = 0);
                                    var timer = $timeout(finished, opts.timeout || TIMEOUT);
                                    function finished(ev) {
                                        ev && ev.target !== element[0] || (ev && $timeout.cancel(timer), element.off($mdConstant.CSS.TRANSITIONEND, finished), 
                                        resolve());
                                    }
                                    function noTransitionFound(styles) {
                                        return "0s" === (styles = styles || window.getComputedStyle(element[0])).transitionDuration || !styles.transition && !styles.transitionProperty;
                                    }
                                    element.on($mdConstant.CSS.TRANSITIONEND, finished);
                                }));
                            },
                            calculateTransformValues: function(element, originator) {
                                var origin = originator.element, bounds = originator.bounds;
                                if (origin || bounds) {
                                    var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds), dialogRect = self.copyRect(element[0].getBoundingClientRect()), dialogCenterPt = self.centerPointFor(dialogRect), originCenterPt = self.centerPointFor(originBnds);
                                    return {
                                        centerX: originCenterPt.x - dialogCenterPt.x,
                                        centerY: originCenterPt.y - dialogCenterPt.y,
                                        scaleX: Math.round(100 * Math.min(.5, originBnds.width / dialogRect.width)) / 100,
                                        scaleY: Math.round(100 * Math.min(.5, originBnds.height / dialogRect.height)) / 100
                                    };
                                }
                                return {
                                    centerX: 0,
                                    centerY: 0,
                                    scaleX: .5,
                                    scaleY: .5
                                };
                                function currentBounds() {
                                    var container = element ? element.parent() : null, parent = container ? container.parent() : null;
                                    return parent ? self.clientRect(parent) : null;
                                }
                            },
                            calculateZoomToOrigin: function(element, originator) {
                                var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )";
                                return angular.bind(null, $mdUtil.supplant, zoomTemplate)(self.calculateTransformValues(element, originator));
                            },
                            calculateSlideToOrigin: function(element, originator) {
                                var slideTemplate = "translate3d( {centerX}px, {centerY}px, 0 )";
                                return angular.bind(null, $mdUtil.supplant, slideTemplate)(self.calculateTransformValues(element, originator));
                            },
                            toCss: function(raw) {
                                var css = {}, lookups = "left top right bottom width height x y min-width min-height max-width max-height";
                                return angular.forEach(raw, (function(value, key) {
                                    if (!angular.isUndefined(value)) if (lookups.indexOf(key) >= 0) css[key] = value + "px"; else switch (key) {
                                      case "transition":
                                        convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                                        break;

                                      case "transform":
                                        convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                                        break;

                                      case "transformOrigin":
                                        convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                                        break;

                                      case "font-size":
                                        css["font-size"] = value;
                                    }
                                })), css;
                                function convertToVendor(key, vendor, value) {
                                    angular.forEach(vendor.split(" "), (function(key) {
                                        css[key] = value;
                                    }));
                                }
                            },
                            toTransformCss: function(transform, addTransition, transition) {
                                var css = {};
                                return angular.forEach($mdConstant.CSS.TRANSFORM.split(" "), (function(key) {
                                    css[key] = transform;
                                })), addTransition && (transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important", 
                                css.transition = transition), css;
                            },
                            copyRect: function(source, destination) {
                                return source ? (destination = destination || {}, angular.forEach("left top right bottom width height".split(" "), (function(key) {
                                    destination[key] = Math.round(source[key]);
                                })), destination.width = destination.width || destination.right - destination.left, 
                                destination.height = destination.height || destination.bottom - destination.top, 
                                destination) : null;
                            },
                            clientRect: function(element) {
                                var rect, bounds = angular.element(element)[0].getBoundingClientRect();
                                return (rect = bounds) && rect.width > 0 && rect.height > 0 ? self.copyRect(bounds) : null;
                            },
                            centerPointFor: function(targetRect) {
                                return targetRect ? {
                                    x: Math.round(targetRect.left + targetRect.width / 2),
                                    y: Math.round(targetRect.top + targetRect.height / 2)
                                } : {
                                    x: 0,
                                    y: 0
                                };
                            }
                        };
                    }($mdUtil, $q, $timeout, $mdConstant, $animateCss);
                };
            } ]), angular.version.minor >= 4 ? angular.module("material.core.animate", []) : function() {
                var forEach = angular.forEach, WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance), PREFIX = WEBKIT ? "-webkit-" : "", TRANSITION_EVENTS = (WEBKIT ? "webkitTransitionEnd " : "") + "transitionend", ANIMATION_EVENTS = (WEBKIT ? "webkitAnimationEnd " : "") + "animationend", $$AnimateRunnerFactory = [ "$q", "$$rAFMutex", function($q, $$rAFMutex) {
                    function AnimateRunner(host) {
                        this.setHost(host), this._doneCallbacks = [], this._runInAnimationFrame = $$rAFMutex(), 
                        this._state = 0;
                    }
                    return AnimateRunner.prototype = {
                        setHost: function(host) {
                            this.host = host || {};
                        },
                        done: function(fn) {
                            2 === this._state ? fn() : this._doneCallbacks.push(fn);
                        },
                        progress: angular.noop,
                        getPromise: function() {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q((function(resolve, reject) {
                                    self.done((function(status) {
                                        !1 === status ? reject() : resolve();
                                    }));
                                }));
                            }
                            return this.promise;
                        },
                        then: function(resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler);
                        },
                        catch: function(handler) {
                            return this.getPromise().catch(handler);
                        },
                        finally: function(handler) {
                            return this.getPromise().finally(handler);
                        },
                        pause: function() {
                            this.host.pause && this.host.pause();
                        },
                        resume: function() {
                            this.host.resume && this.host.resume();
                        },
                        end: function() {
                            this.host.end && this.host.end(), this._resolve(!0);
                        },
                        cancel: function() {
                            this.host.cancel && this.host.cancel(), this._resolve(!1);
                        },
                        complete: function(response) {
                            var self = this;
                            0 === self._state && (self._state = 1, self._runInAnimationFrame((function() {
                                self._resolve(response);
                            })));
                        },
                        _resolve: function(response) {
                            2 !== this._state && (forEach(this._doneCallbacks, (function(fn) {
                                fn(response);
                            })), this._doneCallbacks.length = 0, this._state = 2);
                        }
                    }, AnimateRunner.all = function(runners, callback) {
                        var count = 0, status = !0;
                        function onProgress(response) {
                            status = status && response, ++count === runners.length && callback(status);
                        }
                        forEach(runners, (function(runner) {
                            runner.done(onProgress);
                        }));
                    }, AnimateRunner;
                } ];
                function camelCase(str) {
                    return str.replace(/-[a-z]/g, (function(str) {
                        return str.charAt(1).toUpperCase();
                    }));
                }
                angular.module("material.core.animate", []).factory("$$forceReflow", [ "$document", function($document) {
                    return function() {
                        return $document[0].body.clientWidth + 1;
                    };
                } ]).factory("$$AnimateRunner", $$AnimateRunnerFactory).factory("$$rAFMutex", [ "$$rAF", function($$rAF) {
                    return function() {
                        var passed = !1;
                        return $$rAF((function() {
                            passed = !0;
                        })), function(fn) {
                            passed ? fn() : $$rAF(fn);
                        };
                    };
                } ]).factory("$animateCss", [ "$window", "$$rAF", "$$AnimateRunner", "$$forceReflow", "$$jqLite", "$timeout", "$animate", function($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout, $animate) {
                    function applyClasses(element, options) {
                        options.addClass && ($$jqLite.addClass(element, options.addClass), options.addClass = null), 
                        options.removeClass && ($$jqLite.removeClass(element, options.removeClass), options.removeClass = null);
                    }
                    function parseMaxTime(str) {
                        var maxValue = 0, values = (str || "").split(/\s*,\s*/);
                        return forEach(values, (function(value) {
                            "s" == value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
                            value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
                        })), maxValue;
                    }
                    var cancelLastRAFRequest, rafWaitQueue = [];
                    function applyAnimationFromStyles(element, options) {
                        options.from && (element.css(options.from), options.from = null);
                    }
                    function applyAnimationToStyles(element, options) {
                        options.to && (element.css(options.to), options.to = null);
                    }
                    function getDomNode(element) {
                        for (var i = 0; i < element.length; i++) if (1 === element[i].nodeType) return element[i];
                    }
                    function blockTransition(element, bool) {
                        var node = getDomNode(element), key = camelCase(PREFIX + "transition-delay");
                        node.style[key] = bool ? "-9999s" : "";
                    }
                    return function(element, options) {
                        var temporaryStyles = [], node = getDomNode(element), areAnimationsAllowed = node && $animate.enabled(), hasCompleteStyles = !1, hasCompleteClasses = !1;
                        areAnimationsAllowed && (options.transitionStyle && temporaryStyles.push([ PREFIX + "transition", options.transitionStyle ]), 
                        options.keyframeStyle && temporaryStyles.push([ PREFIX + "animation", options.keyframeStyle ]), 
                        options.delay && temporaryStyles.push([ PREFIX + "transition-delay", options.delay + "s" ]), 
                        options.duration && temporaryStyles.push([ PREFIX + "transition-duration", options.duration + "s" ]), 
                        hasCompleteStyles = options.keyframeStyle || options.to && (options.duration > 0 || options.transitionStyle), 
                        hasCompleteClasses = !!options.addClass || !!options.removeClass, blockTransition(element, !0));
                        var hasCompleteAnimation = areAnimationsAllowed && (hasCompleteStyles || hasCompleteClasses);
                        applyAnimationFromStyles(element, options);
                        var events, eventFn, animationClosed = !1;
                        return {
                            close: $window.close,
                            start: function() {
                                var callback, runner = new $$AnimateRunner;
                                return callback = function() {
                                    if (blockTransition(element, !1), !hasCompleteAnimation) return close();
                                    forEach(temporaryStyles, (function(entry) {
                                        var key = entry[0], value = entry[1];
                                        node.style[camelCase(key)] = value;
                                    })), applyClasses(element, options);
                                    var timings = function(element) {
                                        var node = getDomNode(element), cs = $window.getComputedStyle(node), tdr = parseMaxTime(cs[prop("transitionDuration")]), adr = parseMaxTime(cs[prop("animationDuration")]), tdy = parseMaxTime(cs[prop("transitionDelay")]), ady = parseMaxTime(cs[prop("animationDelay")]);
                                        adr *= parseInt(cs[prop("animationIterationCount")], 10) || 1;
                                        var duration = Math.max(adr, tdr), delay = Math.max(ady, tdy);
                                        return {
                                            duration,
                                            delay,
                                            animationDuration: adr,
                                            transitionDuration: tdr,
                                            animationDelay: ady,
                                            transitionDelay: tdy
                                        };
                                        function prop(key) {
                                            return WEBKIT ? "Webkit" + key.charAt(0).toUpperCase() + key.substr(1) : key;
                                        }
                                    }(element);
                                    if (0 === timings.duration) return close();
                                    var moreStyles = [];
                                    options.easing && (timings.transitionDuration && moreStyles.push([ PREFIX + "transition-timing-function", options.easing ]), 
                                    timings.animationDuration && moreStyles.push([ PREFIX + "animation-timing-function", options.easing ])), 
                                    options.delay && timings.animationDelay && moreStyles.push([ PREFIX + "animation-delay", options.delay + "s" ]), 
                                    options.duration && timings.animationDuration && moreStyles.push([ PREFIX + "animation-duration", options.duration + "s" ]), 
                                    forEach(moreStyles, (function(entry) {
                                        var key = entry[0], value = entry[1];
                                        node.style[camelCase(key)] = value, temporaryStyles.push(entry);
                                    }));
                                    var maxDelayTime = 1e3 * timings.delay, maxDuration = timings.duration, maxDurationTime = 1e3 * maxDuration, startTime = Date.now();
                                    events = [], timings.transitionDuration && events.push(TRANSITION_EVENTS), timings.animationDuration && events.push(ANIMATION_EVENTS), 
                                    events = events.join(" "), eventFn = function(event) {
                                        event.stopPropagation();
                                        var ev = event.originalEvent || event, timeStamp = ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                                        Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && close();
                                    }, element.on(events, eventFn), applyAnimationToStyles(element, options), $timeout(close, maxDelayTime + 1.5 * maxDurationTime, !1);
                                }, cancelLastRAFRequest && cancelLastRAFRequest(), rafWaitQueue.push(callback), 
                                cancelLastRAFRequest = $$rAF((function() {
                                    cancelLastRAFRequest = null;
                                    for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                                    rafWaitQueue.length = 0;
                                })), runner;
                                function close() {
                                    if (!animationClosed) return animationClosed = !0, events && eventFn && element.off(events, eventFn), 
                                    applyClasses(element, options), function(element, options) {
                                        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
                                    }(element, options), forEach(temporaryStyles, (function(entry) {
                                        node.style[camelCase(entry[0])] = "";
                                    })), runner.complete(!0), runner;
                                }
                            }
                        };
                    };
                } ]);
            }(), function() {
                function MdAriaService($$rAF, $log, $window, $interpolate) {
                    var showWarnings = this.showWarnings;
                    return {
                        expect,
                        expectAsync,
                        expectWithText: function(element, attrName) {
                            var content = getText(element) || "";
                            content.indexOf($interpolate.startSymbol()) > -1 ? expectAsync(element, attrName, (function() {
                                return getText(element);
                            })) : expect(element, attrName, content);
                        },
                        expectWithoutText: function(element, attrName) {
                            var content = getText(element);
                            content.indexOf($interpolate.startSymbol()) > -1 || content || expect(element, attrName, content);
                        },
                        getText,
                        hasAriaLabel,
                        parentHasAriaLabel: function parentHasAriaLabel(element, level) {
                            level = level || 1;
                            var node = angular.element(element)[0] || element;
                            if (!node.parentNode) return !1;
                            if (function(parentNode) {
                                if (!hasAriaLabel(parentNode)) return !1;
                                if (parentNode.hasAttribute("role")) switch (parentNode.getAttribute("role").toLowerCase()) {
                                  case "command":
                                  case "definition":
                                  case "directory":
                                  case "grid":
                                  case "list":
                                  case "listitem":
                                  case "log":
                                  case "marquee":
                                  case "menu":
                                  case "menubar":
                                  case "note":
                                  case "presentation":
                                  case "separator":
                                  case "scrollbar":
                                  case "status":
                                  case "tablist":
                                    return !1;
                                }
                                switch (parentNode.tagName.toLowerCase()) {
                                  case "abbr":
                                  case "acronym":
                                  case "address":
                                  case "applet":
                                  case "audio":
                                  case "b":
                                  case "bdi":
                                  case "bdo":
                                  case "big":
                                  case "blockquote":
                                  case "br":
                                  case "canvas":
                                  case "caption":
                                  case "center":
                                  case "cite":
                                  case "code":
                                  case "col":
                                  case "data":
                                  case "dd":
                                  case "del":
                                  case "dfn":
                                  case "dir":
                                  case "div":
                                  case "dl":
                                  case "em":
                                  case "embed":
                                  case "fieldset":
                                  case "figcaption":
                                  case "font":
                                  case "h1":
                                  case "h2":
                                  case "h3":
                                  case "h4":
                                  case "h5":
                                  case "h6":
                                  case "hgroup":
                                  case "html":
                                  case "i":
                                  case "ins":
                                  case "isindex":
                                  case "kbd":
                                  case "keygen":
                                  case "label":
                                  case "legend":
                                  case "li":
                                  case "map":
                                  case "mark":
                                  case "menu":
                                  case "object":
                                  case "ol":
                                  case "output":
                                  case "pre":
                                  case "presentation":
                                  case "q":
                                  case "rt":
                                  case "ruby":
                                  case "samp":
                                  case "small":
                                  case "source":
                                  case "span":
                                  case "status":
                                  case "strike":
                                  case "strong":
                                  case "sub":
                                  case "sup":
                                  case "svg":
                                  case "tbody":
                                  case "td":
                                  case "th":
                                  case "thead":
                                  case "time":
                                  case "tr":
                                  case "track":
                                  case "tt":
                                  case "ul":
                                  case "var":
                                    return !1;
                                }
                                return !0;
                            }(node.parentNode)) return !0;
                            if (--level) return parentHasAriaLabel(node.parentNode, level);
                            return !1;
                        }
                    };
                    function expect(element, attrName, defaultValue) {
                        var node = angular.element(element)[0] || element;
                        !node || node.hasAttribute(attrName) && 0 !== node.getAttribute(attrName).length || function(node, attrName) {
                            var hasChildren = node.hasChildNodes(), hasAttr = !1;
                            function isHidden(el) {
                                return "none" === (el.currentStyle ? el.currentStyle : $window.getComputedStyle(el)).display;
                            }
                            if (hasChildren) for (var children = node.childNodes, i = 0; i < children.length; i++) {
                                var child = children[i];
                                1 === child.nodeType && child.hasAttribute(attrName) && (isHidden(child) || (hasAttr = !0));
                            }
                            return hasAttr;
                        }(node, attrName) || ((defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : "").length ? element.attr(attrName, defaultValue) : showWarnings && $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node));
                    }
                    function expectAsync(element, attrName, defaultValueGetter) {
                        $$rAF((function() {
                            expect(element, attrName, defaultValueGetter());
                        }));
                    }
                    function getText(element) {
                        element = element[0] || element;
                        for (var node, walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null, !1), text = ""; node = walker.nextNode(); ) isAriaHiddenNode(node) || (text += node.textContent);
                        return text.trim() || "";
                        function isAriaHiddenNode(node) {
                            for (;node.parentNode && (node = node.parentNode) !== element; ) if (node.getAttribute && "true" === node.getAttribute("aria-hidden")) return !0;
                        }
                    }
                    function hasAriaLabel(element) {
                        var node = angular.element(element)[0] || element;
                        return !!node.hasAttribute && (node.hasAttribute("aria-label") || node.hasAttribute("aria-labelledby") || node.hasAttribute("aria-describedby"));
                    }
                }
                MdAriaService.$inject = [ "$$rAF", "$log", "$window", "$interpolate" ], angular.module("material.core").provider("$mdAria", (function() {
                    var config = {
                        showWarnings: !0
                    };
                    return {
                        disableWarnings: function() {
                            config.showWarnings = !1;
                        },
                        $get: [ "$$rAF", "$log", "$window", "$interpolate", function($$rAF, $log, $window, $interpolate) {
                            return MdAriaService.apply(config, arguments);
                        } ]
                    };
                }));
            }(), function() {
                function MdCompilerProvider() {
                    function MdCompilerService($q, $templateRequest, $injector, $compile, $controller) {
                        this.$q = $q, this.$templateRequest = $templateRequest, this.$injector = $injector, 
                        this.$compile = $compile, this.$controller = $controller;
                    }
                    this.$get = [ "$q", "$templateRequest", "$injector", "$compile", "$controller", function($q, $templateRequest, $injector, $compile, $controller) {
                        return new MdCompilerService($q, $templateRequest, $injector, $compile, $controller);
                    } ], MdCompilerService.prototype.compile = function(options) {
                        return options.contentElement ? this._prepareContentElement(options) : this._compileTemplate(options);
                    }, MdCompilerService.prototype._prepareContentElement = function(options) {
                        var contentElement = this._fetchContentElement(options);
                        return this.$q.resolve({
                            element: contentElement.element,
                            cleanup: contentElement.restore,
                            locals: {},
                            link: function() {
                                return contentElement.element;
                            }
                        });
                    }, MdCompilerService.prototype._compileTemplate = function(options) {
                        var self = this, templateUrl = options.templateUrl, template = options.template || "", resolve = angular.extend({}, options.resolve), locals = angular.extend({}, options.locals), transformTemplate = options.transformTemplate || angular.identity;
                        return angular.forEach(resolve, (function(value, key) {
                            angular.isString(value) ? resolve[key] = self.$injector.get(value) : resolve[key] = self.$injector.invoke(value);
                        })), angular.extend(resolve, locals), resolve.$$ngTemplate = templateUrl ? this.$templateRequest(templateUrl) : this.$q.when(template), 
                        this.$q.all(resolve).then((function(locals) {
                            var template = transformTemplate(locals.$$ngTemplate, options), element = options.element || angular.element("<div>").html(template.trim()).contents();
                            return self._compileElement(locals, element, options);
                        }));
                    }, MdCompilerService.prototype._compileElement = function(locals, element, options) {
                        var self = this, ngLinkFn = this.$compile(element), compileData = {
                            element,
                            cleanup: element.remove.bind(element),
                            locals,
                            link: function(scope) {
                                if (locals.$scope = scope, options.controller) {
                                    var injectLocals = angular.extend({}, locals, {
                                        $element: element
                                    }), ctrl = self._createController(options, injectLocals, locals);
                                    angular.isFunction(ctrl.$onDestroy) && scope.$on("$destroy", (function() {
                                        angular.isFunction(ctrl.$onDestroy) && ctrl.$onDestroy();
                                    })), element.data("$ngControllerController", ctrl), element.children().data("$ngControllerController", ctrl), 
                                    compileData.controller = ctrl;
                                }
                                return ngLinkFn(scope);
                            }
                        };
                        return compileData;
                    }, MdCompilerService.prototype._createController = function(options, injectLocals, locals) {
                        var ctrl = this.$controller(options.controller, injectLocals);
                        return options.bindToController && angular.extend(ctrl, locals), options.controllerAs && (injectLocals.$scope[options.controllerAs] = ctrl), 
                        angular.isFunction(ctrl.$onInit) && ctrl.$onInit(), ctrl;
                    }, MdCompilerService.prototype._fetchContentElement = function(options) {
                        var restoreFn, contentEl = options.contentElement;
                        return angular.isString(contentEl) ? restoreFn = createRestoreFn(contentEl = document.querySelector(contentEl)) : (contentEl = contentEl[0] || contentEl, 
                        restoreFn = document.contains(contentEl) ? createRestoreFn(contentEl) : function() {
                            contentEl.parentNode && contentEl.parentNode.removeChild(contentEl);
                        }), {
                            element: angular.element(contentEl),
                            restore: restoreFn
                        };
                        function createRestoreFn(element) {
                            var parent = element.parentNode, nextSibling = element.nextElementSibling;
                            return function() {
                                nextSibling ? parent.insertBefore(element, nextSibling) : parent.appendChild(element);
                            };
                        }
                    };
                }
                angular.module("material.core").provider("$mdCompiler", MdCompilerProvider), MdCompilerProvider.$inject = [ "$compileProvider" ];
            }(), function() {
                MdGesture.$inject = [ "$$MdGestureHandler", "$$rAF", "$timeout", "$mdUtil" ], attachToDocument.$inject = [ "$mdGesture", "$$MdGestureHandler", "$mdUtil" ];
                var pointer, lastPointer, HANDLERS = {}, maxClickDistance = 6, forceSkipClickHijack = !1, disableAllGestures = !1, lastLabelClickPos = null, isInitialized = !1;
                function MdGestureProvider() {}
                function MdGesture($$MdGestureHandler, $$rAF, $timeout, $mdUtil) {
                    var touchActionProperty = $mdUtil.getTouchAction(), hasJQuery = void 0 !== window.jQuery && angular.element === window.jQuery, self = {
                        handler: function(name, definition) {
                            var handler = new $$MdGestureHandler(name);
                            return angular.extend(handler, definition), HANDLERS[name] = handler, self;
                        },
                        register: function(element, handlerName, options) {
                            var handler = HANDLERS[handlerName.replace(/^\$md./, "")];
                            if (!handler) throw new Error("Failed to register element with handler " + handlerName + ". Available handlers: " + Object.keys(HANDLERS).join(", "));
                            return handler.registerElement(element, options);
                        },
                        isAndroid: $mdUtil.isAndroid,
                        isIos: $mdUtil.isIos,
                        isHijackingClicks: ($mdUtil.isIos || $mdUtil.isAndroid) && !hasJQuery && !forceSkipClickHijack
                    };
                    function checkDistanceAndEmit(eventName) {
                        return function(ev, pointer) {
                            pointer.distance < this.state.options.maxDistance && this.dispatchEvent(ev, eventName, pointer);
                        };
                    }
                    return self.isHijackingClicks && (self.handler("click", {
                        options: {
                            maxDistance: maxClickDistance
                        },
                        onEnd: checkDistanceAndEmit("click")
                    }), self.handler("focus", {
                        options: {
                            maxDistance: maxClickDistance
                        },
                        onEnd: function(ev, pointer) {
                            pointer.distance < this.state.options.maxDistance && canFocus(ev.target) && (this.dispatchEvent(ev, "focus", pointer), 
                            ev.target.focus());
                        }
                    }), self.handler("mouseup", {
                        options: {
                            maxDistance: maxClickDistance
                        },
                        onEnd: checkDistanceAndEmit("mouseup")
                    }), self.handler("mousedown", {
                        onStart: function(ev) {
                            this.dispatchEvent(ev, "mousedown");
                        }
                    })), self.handler("press", {
                        onStart: function(ev, pointer) {
                            this.dispatchEvent(ev, "$md.pressdown");
                        },
                        onEnd: function(ev, pointer) {
                            this.dispatchEvent(ev, "$md.pressup");
                        }
                    }).handler("hold", {
                        options: {
                            maxDistance: 6,
                            delay: 500
                        },
                        onCancel: function() {
                            $timeout.cancel(this.state.timeout);
                        },
                        onStart: function(ev, pointer) {
                            if (!this.state.registeredParent) return this.cancel();
                            this.state.pos = {
                                x: pointer.x,
                                y: pointer.y
                            }, this.state.timeout = $timeout(angular.bind(this, (function() {
                                this.dispatchEvent(ev, "$md.hold"), this.cancel();
                            })), this.state.options.delay, !1);
                        },
                        onMove: function(ev, pointer) {
                            touchActionProperty || "touchmove" !== ev.type || ev.preventDefault();
                            var dx = this.state.pos.x - pointer.x, dy = this.state.pos.y - pointer.y;
                            Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance && this.cancel();
                        },
                        onEnd: function() {
                            this.onCancel();
                        }
                    }).handler("drag", {
                        options: {
                            minDistance: 6,
                            horizontal: !0,
                            cancelMultiplier: 1.5
                        },
                        onSetup: function(element, options) {
                            touchActionProperty && (this.oldTouchAction = element[0].style[touchActionProperty], 
                            element[0].style[touchActionProperty] = options.horizontal ? "pan-y" : "pan-x");
                        },
                        onCleanup: function(element) {
                            this.oldTouchAction ? element[0].style[touchActionProperty] = this.oldTouchAction : element[0].style[touchActionProperty] = null;
                        },
                        onStart: function(ev) {
                            this.state.registeredParent || this.cancel();
                        },
                        onMove: function(ev, pointer) {
                            var shouldStartDrag, shouldCancel;
                            touchActionProperty || "touchmove" !== ev.type || ev.preventDefault(), this.state.dragPointer ? this.dispatchDragMove(ev) : (this.state.options.horizontal ? (shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance, 
                            shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier) : (shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance, 
                            shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier), 
                            shouldStartDrag ? (this.state.dragPointer = makeStartPointer(ev), updatePointerState(ev, this.state.dragPointer), 
                            this.dispatchEvent(ev, "$md.dragstart", this.state.dragPointer)) : shouldCancel && this.cancel());
                        },
                        dispatchDragMove: $$rAF.throttle((function(ev) {
                            this.state.isRunning && (updatePointerState(ev, this.state.dragPointer), this.dispatchEvent(ev, "$md.drag", this.state.dragPointer));
                        })),
                        onEnd: function(ev, pointer) {
                            this.state.dragPointer && (updatePointerState(ev, this.state.dragPointer), this.dispatchEvent(ev, "$md.dragend", this.state.dragPointer));
                        }
                    }).handler("swipe", {
                        options: {
                            minVelocity: .65,
                            minDistance: 10
                        },
                        onEnd: function(ev, pointer) {
                            var eventType;
                            Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance ? (eventType = "left" == pointer.directionX ? "$md.swipeleft" : "$md.swiperight", 
                            this.dispatchEvent(ev, eventType)) : Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance && (eventType = "up" == pointer.directionY ? "$md.swipeup" : "$md.swipedown", 
                            this.dispatchEvent(ev, eventType));
                        }
                    });
                }
                function GestureHandler(name) {
                    this.name = name, this.state = {};
                }
                function attachToDocument($mdGesture, $$MdGestureHandler, $mdUtil) {
                    if (!disableAllGestures) {
                        !isInitialized && $mdGesture.isHijackingClicks && (document.addEventListener("click", (function(ev) {
                            var isKeyClick;
                            isKeyClick = $mdUtil.isIos ? angular.isDefined(ev.webkitForce) && 0 === ev.webkitForce : 0 === ev.clientX && 0 === ev.clientY;
                            isKeyClick || ev.$material || ev.isIonicTap || isInputEventFromLabelClick(ev) ? (lastLabelClickPos = null, 
                            "label" === ev.target.tagName.toLowerCase() && (lastLabelClickPos = {
                                x: ev.x,
                                y: ev.y
                            })) : (ev.preventDefault(), ev.stopPropagation(), lastLabelClickPos = null);
                        }), !0), document.addEventListener("mouseup", mouseInputHijacker, !0), document.addEventListener("mousedown", mouseInputHijacker, !0), 
                        document.addEventListener("focus", mouseInputHijacker, !0), isInitialized = !0);
                        angular.element(document).on("mousedown touchstart pointerdown", (function(ev) {
                            if (pointer) return;
                            var now = +Date.now();
                            if (lastPointer && !typesMatch(ev, lastPointer) && now - lastPointer.endTime < 1500) return;
                            pointer = makeStartPointer(ev), runHandlers("start", ev);
                        })).on("mousemove touchmove pointermove", (function(ev) {
                            if (!pointer || !typesMatch(ev, pointer)) return;
                            updatePointerState(ev, pointer), runHandlers("move", ev);
                        })).on("mouseup mouseleave touchend touchcancel pointerup pointercancel", (function(ev) {
                            if (!pointer || !typesMatch(ev, pointer)) return;
                            updatePointerState(ev, pointer), pointer.endTime = +Date.now(), "pointercancel" !== ev.type && runHandlers("end", ev);
                            lastPointer = pointer, pointer = null;
                        })).on("$$mdGestureReset", (function() {
                            lastPointer = pointer = null;
                        }));
                    }
                    function mouseInputHijacker(ev) {
                        !ev.clientX && !ev.clientY || ev.$material || ev.isIonicTap || isInputEventFromLabelClick(ev) || "mousedown" === ev.type && (canFocus(ev.target) || canFocus(document.activeElement)) || (ev.preventDefault(), 
                        ev.stopPropagation());
                    }
                    function runHandlers(handlerEvent, event) {
                        var handler;
                        for (var name in HANDLERS) (handler = HANDLERS[name]) instanceof $$MdGestureHandler && ("start" === handlerEvent && handler.cancel(), 
                        handler[handlerEvent](event, pointer));
                    }
                }
                function makeStartPointer(ev) {
                    var point = getEventPoint(ev), startPointer = {
                        startTime: +Date.now(),
                        target: ev.target,
                        type: ev.type.charAt(0)
                    };
                    return startPointer.startX = startPointer.x = point.pageX, startPointer.startY = startPointer.y = point.pageY, 
                    startPointer;
                }
                function typesMatch(ev, pointer) {
                    return ev && pointer && ev.type.charAt(0) === pointer.type;
                }
                function isInputEventFromLabelClick(event) {
                    return lastLabelClickPos && lastLabelClickPos.x === event.x && lastLabelClickPos.y === event.y;
                }
                function updatePointerState(ev, pointer) {
                    var point = getEventPoint(ev), x = pointer.x = point.pageX, y = pointer.y = point.pageY;
                    pointer.distanceX = x - pointer.startX, pointer.distanceY = y - pointer.startY, 
                    pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY), 
                    pointer.directionX = pointer.distanceX > 0 ? "right" : pointer.distanceX < 0 ? "left" : "", 
                    pointer.directionY = pointer.distanceY > 0 ? "down" : pointer.distanceY < 0 ? "up" : "", 
                    pointer.duration = +Date.now() - pointer.startTime, pointer.velocityX = pointer.distanceX / pointer.duration, 
                    pointer.velocityY = pointer.distanceY / pointer.duration;
                }
                function getEventPoint(ev) {
                    return (ev = ev.originalEvent || ev).touches && ev.touches[0] || ev.changedTouches && ev.changedTouches[0] || ev;
                }
                function canFocus(element) {
                    return !!element && "-1" !== element.getAttribute("tabindex") && !element.hasAttribute("disabled") && (element.hasAttribute("tabindex") || element.hasAttribute("href") || element.isContentEditable || -1 !== [ "INPUT", "SELECT", "BUTTON", "TEXTAREA", "VIDEO", "AUDIO" ].indexOf(element.nodeName));
                }
                angular.module("material.core.gestures", []).provider("$mdGesture", MdGestureProvider).factory("$$MdGestureHandler", (function() {
                    var hasJQuery = void 0 !== window.jQuery && angular.element === window.jQuery;
                    return GestureHandler.prototype = {
                        options: {},
                        dispatchEvent: hasJQuery ? function(srcEvent, eventType, eventPointer) {
                            eventPointer = eventPointer || pointer;
                            var eventObj = new angular.element.Event(eventType);
                            eventObj.$material = !0, eventObj.pointer = eventPointer, eventObj.srcEvent = srcEvent, 
                            angular.extend(eventObj, {
                                clientX: eventPointer.x,
                                clientY: eventPointer.y,
                                screenX: eventPointer.x,
                                screenY: eventPointer.y,
                                pageX: eventPointer.x,
                                pageY: eventPointer.y,
                                ctrlKey: srcEvent.ctrlKey,
                                altKey: srcEvent.altKey,
                                shiftKey: srcEvent.shiftKey,
                                metaKey: srcEvent.metaKey
                            }), angular.element(eventPointer.target).trigger(eventObj);
                        } : function(srcEvent, eventType, eventPointer) {
                            var eventObj;
                            eventPointer = eventPointer || pointer, "click" === eventType || "mouseup" === eventType || "mousedown" === eventType ? "function" == typeof window.MouseEvent ? eventObj = new MouseEvent(eventType, {
                                bubbles: !0,
                                cancelable: !0,
                                screenX: Number(srcEvent.screenX),
                                screenY: Number(srcEvent.screenY),
                                clientX: Number(eventPointer.x),
                                clientY: Number(eventPointer.y),
                                ctrlKey: srcEvent.ctrlKey,
                                altKey: srcEvent.altKey,
                                shiftKey: srcEvent.shiftKey,
                                metaKey: srcEvent.metaKey,
                                button: srcEvent.button,
                                buttons: srcEvent.buttons,
                                relatedTarget: srcEvent.relatedTarget || null
                            }) : (eventObj = document.createEvent("MouseEvents")).initMouseEvent(eventType, !0, !0, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null) : "function" == typeof window.CustomEvent ? eventObj = new CustomEvent(eventType, {
                                bubbles: !0,
                                cancelable: !0,
                                detail: {}
                            }) : (eventObj = document.createEvent("CustomEvent")).initCustomEvent(eventType, !0, !0, {});
                            eventObj.$material = !0, eventObj.pointer = eventPointer, eventObj.srcEvent = srcEvent, 
                            eventPointer.target.dispatchEvent(eventObj);
                        },
                        onSetup: angular.noop,
                        onCleanup: angular.noop,
                        onStart: angular.noop,
                        onMove: angular.noop,
                        onEnd: angular.noop,
                        onCancel: angular.noop,
                        start: function(ev, pointer) {
                            if (!this.state.isRunning) {
                                var parentTarget = this.getNearestParent(ev.target), parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
                                this.state = {
                                    isRunning: !0,
                                    options: angular.extend({}, this.options, parentTargetOptions),
                                    registeredParent: parentTarget
                                }, this.onStart(ev, pointer);
                            }
                        },
                        move: function(ev, pointer) {
                            this.state.isRunning && this.onMove(ev, pointer);
                        },
                        end: function(ev, pointer) {
                            this.state.isRunning && (this.state.isRunning = !1, this.onEnd(ev, pointer));
                        },
                        cancel: function(ev, pointer) {
                            this.onCancel(ev, pointer), this.state = {};
                        },
                        getNearestParent: function(node) {
                            for (var current = node; current; ) {
                                if ((current.$mdGesture || {})[this.name]) return current;
                                current = current.parentNode;
                            }
                            return null;
                        },
                        registerElement: function(element, options) {
                            var self = this;
                            return element[0].$mdGesture = element[0].$mdGesture || {}, element[0].$mdGesture[this.name] = options || {}, 
                            element.on("$destroy", onDestroy), self.onSetup(element, options || {}), onDestroy;
                            function onDestroy() {
                                delete element[0].$mdGesture[self.name], element.off("$destroy", onDestroy), self.onCleanup(element, options || {});
                            }
                        }
                    }, GestureHandler;
                })).run(attachToDocument), MdGestureProvider.prototype = {
                    disableAll: function() {
                        disableAllGestures = !0;
                    },
                    skipClickHijack: function() {
                        return forceSkipClickHijack = !0;
                    },
                    setMaxClickDistance: function(clickDistance) {
                        maxClickDistance = parseInt(clickDistance);
                    },
                    $get: [ "$$MdGestureHandler", "$$rAF", "$timeout", "$mdUtil", function($$MdGestureHandler, $$rAF, $timeout, $mdUtil) {
                        return new MdGesture($$MdGestureHandler, $$rAF, $timeout, $mdUtil);
                    } ]
                };
            }(), function() {
                function MdInteractionService($timeout, $mdUtil, $rootScope) {
                    this.$timeout = $timeout, this.$mdUtil = $mdUtil, this.$rootScope = $rootScope, 
                    this.pointerEvent = "MSPointerEvent" in window ? "MSPointerDown" : "PointerEvent" in window ? "pointerdown" : null, 
                    this.bodyElement = angular.element(document.body), this.isBuffering = !1, this.bufferTimeout = null, 
                    this.lastInteractionType = null, this.lastInteractionTime = null, this.inputHandler = this.onInputEvent.bind(this), 
                    this.bufferedInputHandler = this.onBufferInputEvent.bind(this), this.inputEventMap = {
                        keydown: "keyboard",
                        mousedown: "mouse",
                        mouseenter: "mouse",
                        touchstart: "touch",
                        pointerdown: "pointer",
                        MSPointerDown: "pointer"
                    }, this.iePointerMap = {
                        2: "touch",
                        3: "touch",
                        4: "mouse"
                    }, this.initializeEvents(), this.$rootScope.$on("$destroy", this.deregister.bind(this));
                }
                MdInteractionService.$inject = [ "$timeout", "$mdUtil", "$rootScope" ], angular.module("material.core.interaction", []).service("$mdInteraction", MdInteractionService), 
                MdInteractionService.prototype.deregister = function() {
                    this.bodyElement.off("keydown mousedown", this.inputHandler), "ontouchstart" in document.documentElement && this.bodyElement.off("touchstart", this.bufferedInputHandler), 
                    this.pointerEvent && this.bodyElement.off(this.pointerEvent, this.inputHandler);
                }, MdInteractionService.prototype.initializeEvents = function() {
                    this.bodyElement.on("keydown mousedown", this.inputHandler), "ontouchstart" in document.documentElement && this.bodyElement.on("touchstart", this.bufferedInputHandler), 
                    this.pointerEvent && this.bodyElement.on(this.pointerEvent, this.inputHandler);
                }, MdInteractionService.prototype.onInputEvent = function(event) {
                    if (!this.isBuffering) {
                        var type = this.inputEventMap[event.type];
                        "pointer" === type && (type = this.iePointerMap[event.pointerType] || event.pointerType), 
                        this.lastInteractionType = type, this.lastInteractionTime = this.$mdUtil.now();
                    }
                }, MdInteractionService.prototype.onBufferInputEvent = function(event) {
                    this.$timeout.cancel(this.bufferTimeout), this.onInputEvent(event), this.isBuffering = !0, 
                    this.bufferTimeout = this.$timeout(function() {
                        this.isBuffering = !1;
                    }.bind(this), 650, !1);
                }, MdInteractionService.prototype.getLastInteractionType = function() {
                    return this.lastInteractionType;
                }, MdInteractionService.prototype.isUserInvoked = function(checkDelay) {
                    var delay = angular.isNumber(checkDelay) ? checkDelay : 15;
                    return this.lastInteractionTime >= this.$mdUtil.now() - delay;
                };
            }(), angular.module("material.core").provider("$$interimElement", (function() {
                return InterimElementFactory.$inject = [ "$document", "$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector", "$exceptionHandler" ], 
                createInterimElementProvider.$get = InterimElementFactory, createInterimElementProvider;
                function createInterimElementProvider(interimFactoryName) {
                    factory.$inject = [ "$$interimElement", "$injector" ];
                    var EXPOSED_METHODS = [ "onHide", "onShow", "onRemove" ], customMethods = {}, providerConfig = {
                        presets: {}
                    }, provider = {
                        setDefaults: function(definition) {
                            return providerConfig.optionsFactory = definition.options, providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS), 
                            provider;
                        },
                        addPreset: function(name, definition) {
                            if ((definition = definition || {}).methods = definition.methods || [], definition.options = definition.options || function() {
                                return {};
                            }, /^cancel|hide|show$/.test(name)) throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
                            if (definition.methods.indexOf("_options") > -1) throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
                            return providerConfig.presets[name] = {
                                methods: definition.methods.concat(EXPOSED_METHODS),
                                optionsFactory: definition.options,
                                argOption: definition.argOption
                            }, provider;
                        },
                        addMethod: function(name, fn) {
                            return customMethods[name] = fn, provider;
                        },
                        $get: factory
                    };
                    return provider.addPreset("build", {
                        methods: [ "controller", "controllerAs", "resolve", "multiple", "template", "templateUrl", "themable", "transformTemplate", "parent", "contentElement" ]
                    }), provider;
                    function factory($$interimElement, $injector) {
                        var defaultMethods, defaultOptions, interimElementService = $$interimElement(), publicService = {
                            hide: interimElementService.hide,
                            cancel: interimElementService.cancel,
                            show: function(opts) {
                                return (opts = opts || {})._options && (opts = opts._options), interimElementService.show(angular.extend({}, defaultOptions, opts));
                            },
                            destroy: function(opts) {
                                return interimElementService.destroy(opts);
                            }
                        };
                        return defaultMethods = providerConfig.methods || [], defaultOptions = invokeFactory(providerConfig.optionsFactory, {}), 
                        angular.forEach(customMethods, (function(fn, name) {
                            publicService[name] = fn;
                        })), angular.forEach(providerConfig.presets, (function(definition, name) {
                            var presetDefaults = invokeFactory(definition.optionsFactory, {}), presetMethods = (definition.methods || []).concat(defaultMethods);
                            function Preset(opts) {
                                this._options = angular.extend({}, presetDefaults, opts);
                            }
                            if (angular.extend(presetDefaults, {
                                $type: name
                            }), angular.forEach(presetMethods, (function(name) {
                                Preset.prototype[name] = function(value) {
                                    return this._options[name] = value, this;
                                };
                            })), definition.argOption) {
                                var methodName = "show" + name.charAt(0).toUpperCase() + name.slice(1);
                                publicService[methodName] = function(arg) {
                                    var config = publicService[name](arg);
                                    return publicService.show(config);
                                };
                            }
                            publicService[name] = function(arg) {
                                return arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg) ? (new Preset)[definition.argOption](arg) : new Preset(arg);
                            };
                        })), publicService;
                        function invokeFactory(factory, defaultVal) {
                            var locals = {};
                            return locals[interimFactoryName] = publicService, $injector.invoke(factory || function() {
                                return defaultVal;
                            }, {}, locals);
                        }
                    }
                }
                function InterimElementFactory($document, $q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector, $exceptionHandler) {
                    return function() {
                        var service, showPromises = [], hidePromises = [], showingInterims = [];
                        return service = {
                            show: function(options) {
                                var interimElement = new InterimElement((options = options || {}) || {}), hideAction = options.multiple ? $q.resolve() : $q.all(showPromises);
                                options.multiple || (hideAction = hideAction.then((function() {
                                    var promiseArray = hidePromises.concat(showingInterims.map(service.cancel));
                                    return $q.all(promiseArray);
                                })));
                                var showAction = hideAction.then((function() {
                                    return interimElement.show().then((function() {
                                        showingInterims.push(interimElement);
                                    })).catch((function(reason) {
                                        return reason;
                                    })).finally((function() {
                                        showPromises.splice(showPromises.indexOf(showAction), 1);
                                    }));
                                }));
                                return showPromises.push(showAction), interimElement.deferred.promise.catch((function(fault) {
                                    return fault instanceof Error && $exceptionHandler(fault), fault;
                                })), interimElement.deferred.promise;
                            },
                            hide: waitForInterim((function(reason, options) {
                                return (options = options || {}).closeAll ? $q.all(showingInterims.slice().reverse().map(closeElement)) : void 0 !== options.closeTo ? $q.all(showingInterims.slice(options.closeTo).map(closeElement)) : closeElement(showingInterims[showingInterims.length - 1]);
                                function closeElement(interim) {
                                    if (!interim) return $q.when(reason);
                                    var hideAction = interim.remove(reason, !1, options || {}).catch((function(reason) {
                                        return reason;
                                    })).finally((function() {
                                        hidePromises.splice(hidePromises.indexOf(hideAction), 1);
                                    }));
                                    return showingInterims.splice(showingInterims.indexOf(interim), 1), hidePromises.push(hideAction), 
                                    interim.deferred.promise;
                                }
                            })),
                            cancel: waitForInterim((function(reason, options) {
                                var interim = showingInterims.pop();
                                if (!interim) return $q.when(reason);
                                var cancelAction = interim.remove(reason, !0, options || {}).catch((function(reason) {
                                    return reason;
                                })).finally((function() {
                                    hidePromises.splice(hidePromises.indexOf(cancelAction), 1);
                                }));
                                return hidePromises.push(cancelAction), interim.deferred.promise.catch(angular.noop);
                            })),
                            destroy: function(targetEl) {
                                var interim = targetEl ? null : showingInterims.shift(), parentEl = angular.element(targetEl).length && angular.element(targetEl)[0].parentNode;
                                if (parentEl) {
                                    var filtered = showingInterims.filter((function(entry) {
                                        return entry.options.element[0] === parentEl;
                                    }));
                                    filtered.length && (interim = filtered[0], showingInterims.splice(showingInterims.indexOf(interim), 1));
                                }
                                return interim ? interim.remove(!1, !1, {
                                    $destroy: !0
                                }) : $q.when(!1);
                            },
                            $injector_: $injector
                        };
                        function waitForInterim(callbackFn) {
                            return function() {
                                var fnArguments = arguments;
                                return showingInterims.length ? callbackFn.apply(service, fnArguments) : showPromises.length ? showPromises[0].finally((function() {
                                    return callbackFn.apply(service, fnArguments);
                                })) : $q.when("No interim elements currently showing up.");
                            };
                        }
                        function InterimElement(options) {
                            var self, element, showAction = $q.when(!0);
                            return options = function(options) {
                                return (options = options || {}).template && (options.template = $mdUtil.processTemplate(options.template)), 
                                angular.extend({
                                    preserveScope: !1,
                                    cancelAutoHide: angular.noop,
                                    scope: options.scope || $rootScope.$new(options.isolateScope),
                                    onShow: function(scope, element, options) {
                                        return $animate.enter(element, options.parent);
                                    },
                                    onRemove: function(scope, element) {
                                        return element && $animate.leave(element) || $q.when();
                                    }
                                }, options);
                            }(options), self = {
                                options,
                                deferred: $q.defer(),
                                show: function() {
                                    return $q((function(resolve, reject) {
                                        function rejectAll(fault) {
                                            self.deferred.reject(fault), reject(fault);
                                        }
                                        options.onCompiling && options.onCompiling(options), function(options) {
                                            var compiled = options.skipCompile ? null : $mdCompiler.compile(options);
                                            return compiled || $q((function(resolve) {
                                                resolve({
                                                    locals: {},
                                                    link: function() {
                                                        return options.element;
                                                    }
                                                });
                                            }));
                                        }(options).then((function(compiledData) {
                                            element = function(compileData, options) {
                                                angular.extend(compileData.locals, options);
                                                var element = compileData.link(options.scope);
                                                return options.element = element, options.parent = function(element, options) {
                                                    var el, parent = options.parent;
                                                    return ((parent = angular.isFunction(parent) ? parent(options.scope, element, options) : angular.isString(parent) ? angular.element($document[0].querySelector(parent)) : angular.element(parent)) || {}).length ? parent : ($rootElement[0] && $rootElement[0].querySelector && (el = $rootElement[0].querySelector(":not(svg) > body")), 
                                                    el || (el = $rootElement[0]), "#comment" === el.nodeName && (el = $document[0].body), 
                                                    angular.element(el));
                                                }(element, options), options.themable && $mdTheming(element), element;
                                            }(compiledData, options), options.cleanupElement = compiledData.cleanup, showAction = function(element, options, controller) {
                                                var notifyShowing = options.onShowing || angular.noop, notifyComplete = options.onComplete || angular.noop;
                                                try {
                                                    notifyShowing(options.scope, element, options, controller);
                                                } catch (e) {
                                                    return $q.reject(e);
                                                }
                                                return $q((function(resolve, reject) {
                                                    try {
                                                        $q.when(options.onShow(options.scope, element, options)).then((function() {
                                                            notifyComplete(options.scope, element, options), startAutoHide(), resolve(element);
                                                        }), reject);
                                                    } catch (e) {
                                                        reject(e.message);
                                                    }
                                                }));
                                            }(element, options, compiledData.controller).then(resolve, rejectAll);
                                        })).catch(rejectAll);
                                    }));
                                },
                                remove: function(response, isCancelled, opts) {
                                    return element ? ((options = angular.extend(options || {}, opts || {})).cancelAutoHide && options.cancelAutoHide(), 
                                    options.element.triggerHandler("$mdInterimElementRemove"), !0 === options.$destroy ? hideElement(options.element, options).then((function() {
                                        isCancelled && rejectAll(response) || resolveAll(response);
                                    })) : ($q.when(showAction).finally((function() {
                                        hideElement(options.element, options).then((function() {
                                            isCancelled ? rejectAll(response) : resolveAll(response);
                                        }), rejectAll);
                                    })), self.deferred.promise)) : $q.when(!1);
                                    function resolveAll(response) {
                                        self.deferred.resolve(response);
                                    }
                                    function rejectAll(fault) {
                                        self.deferred.reject(fault);
                                    }
                                }
                            };
                            function startAutoHide() {
                                var autoHideTimer, cancelAutoHide = angular.noop;
                                options.hideDelay && (autoHideTimer = $timeout(service.hide, options.hideDelay), 
                                cancelAutoHide = function() {
                                    $timeout.cancel(autoHideTimer);
                                }), options.cancelAutoHide = function() {
                                    cancelAutoHide(), options.cancelAutoHide = void 0;
                                };
                            }
                            function hideElement(element, options) {
                                var announceRemoving = options.onRemoving || angular.noop;
                                return $q((function(resolve, reject) {
                                    try {
                                        var action = $q.when(options.onRemove(options.scope, element, options) || !0);
                                        announceRemoving(element, action), options.$destroy ? (resolve(element), !options.preserveScope && options.scope && action.then((function() {
                                            options.scope.$destroy();
                                        }))) : action.then((function() {
                                            !options.preserveScope && options.scope && options.scope.$destroy(), resolve(element);
                                        }), reject);
                                    } catch (e) {
                                        reject(e.message);
                                    }
                                }));
                            }
                        }
                    };
                }
            })), function() {
                var $mdUtil, $interpolate, $log, SUFFIXES = /(-gt)?-(sm|md|lg|print)/g, WHITESPACE = /\s+/g, FLEX_OPTIONS = [ "grow", "initial", "auto", "none", "noshrink", "nogrow" ], LAYOUT_OPTIONS = [ "row", "column" ], ALIGNMENT_MAIN_AXIS = [ "", "start", "center", "end", "stretch", "space-around", "space-between" ], ALIGNMENT_CROSS_AXIS = [ "", "start", "center", "end", "stretch" ], config = {
                    enabled: !0,
                    breakpoints: []
                };
                function detectDisabledLayouts() {
                    var isDisabled = !!document.querySelector("[md-layouts-disabled]");
                    config.enabled = !isDisabled;
                }
                function disableLayoutDirective() {
                    return config.enabled = !1, {
                        restrict: "A",
                        priority: "900"
                    };
                }
                function attributeWithoutValue(className) {
                    return [ "$mdUtil", "$interpolate", "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
                        return $mdUtil = _$mdUtil_, $interpolate = _$interpolate_, $log = _$log_, {
                            restrict: "A",
                            compile: function(element, attr) {
                                var linkFn;
                                return config.enabled && (validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(0, className, attr)), 
                                translateToCssClass(0, element), linkFn = translateToCssClass), linkFn || angular.noop;
                            }
                        };
                    } ];
                    function translateToCssClass(scope, element) {
                        element.addClass(className);
                    }
                }
                function validateAttributeUsage(className, attr, element, $log) {
                    var usage, nodeName = element[0].nodeName.toLowerCase();
                    "flex" === className.replace(SUFFIXES, "") && ("md-button" !== nodeName && "fieldset" !== nodeName || (usage = "<" + nodeName + " " + className + "></" + nodeName + ">", 
                    $log.warn($mdUtil.supplant("Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.", [ usage, "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers" ]))));
                }
                function validateAttributeValue(className, value, updateFn) {
                    var origValue = value;
                    if (!needsInterpolation(value)) {
                        switch (className.replace(SUFFIXES, "")) {
                          case "layout":
                            findIn(value, LAYOUT_OPTIONS) || (value = LAYOUT_OPTIONS[0]);
                            break;

                          case "flex":
                            findIn(value, FLEX_OPTIONS) || isNaN(value) && (value = "");
                            break;

                          case "flex-offset":
                          case "flex-order":
                            value && !isNaN(+value) || (value = "0");
                            break;

                          case "layout-align":
                            var axis = function(attrValue) {
                                var values, axis = {
                                    main: "start",
                                    cross: "stretch"
                                };
                                return 0 !== (attrValue = attrValue || "").indexOf("-") && 0 !== attrValue.indexOf(" ") || (attrValue = "none" + attrValue), 
                                (values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-")).length && "space" === values[0] && (values = [ values[0] + "-" + values[1], values[2] ]), 
                                values.length > 0 && (axis.main = values[0] || axis.main), values.length > 1 && (axis.cross = values[1] || axis.cross), 
                                ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0 && (axis.main = "start"), ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0 && (axis.cross = "stretch"), 
                                axis;
                            }(value);
                            value = $mdUtil.supplant("{main}-{cross}", axis);
                            break;

                          case "layout-padding":
                          case "layout-margin":
                          case "layout-fill":
                          case "layout-wrap":
                          case "layout-nowrap":
                            value = "";
                        }
                        value !== origValue && (updateFn || angular.noop)(value);
                    }
                    return value ? value.trim() : "";
                }
                function buildUpdateFn(element, className, attrs) {
                    return function(fallback) {
                        needsInterpolation(fallback) || (attrs[attrs.$normalize(className)] = fallback);
                    };
                }
                function needsInterpolation(value) {
                    return (value || "").indexOf($interpolate.startSymbol()) > -1;
                }
                function getNormalizedAttrValue(className, attrs, defaultVal) {
                    var normalizedAttr = attrs.$normalize(className);
                    return attrs[normalizedAttr] ? attrs[normalizedAttr].trim().replace(WHITESPACE, "-") : defaultVal || null;
                }
                function findIn(item, list, replaceWith) {
                    item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
                    var found = !1;
                    return item && list.forEach((function(it) {
                        it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it, found = found || it === item;
                    })), found;
                }
                !function(module) {
                    var className, PREFIX_REGEXP = /^((?:x|data)[:\-_])/i, SPECIAL_CHARS_REGEXP = /([:\-_]+(.))/g, API_WITH_VALUES = [ "layout", "flex", "flex-order", "flex-offset", "layout-align" ], API_NO_VALUES = [ "show", "hide", "layout-padding", "layout-margin" ];
                    function directiveNormalize(name) {
                        return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, (function(_, separator, letter, offset) {
                            return offset ? letter.toUpperCase() : letter;
                        }));
                    }
                    angular.forEach([ "", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print" ], (function(mqb) {
                        angular.forEach(API_WITH_VALUES, (function(name) {
                            var fullName = mqb ? name + "-" + mqb : name;
                            module.directive(directiveNormalize(fullName), function(className) {
                                return [ "$mdUtil", "$interpolate", "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
                                    return $mdUtil = _$mdUtil_, $interpolate = _$interpolate_, $log = _$log_, {
                                        restrict: "A",
                                        compile: function(element, attr) {
                                            var linkFn;
                                            return config.enabled && (validateAttributeUsage(className, 0, element, $log), validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(0, className, attr)), 
                                            linkFn = translateWithValueToCssClass), linkFn || angular.noop;
                                        }
                                    };
                                } ];
                                function translateWithValueToCssClass(scope, element, attrs) {
                                    var updateFn = function(element, className) {
                                        var lastClass;
                                        return function(newValue) {
                                            var value = validateAttributeValue(className, newValue || "");
                                            angular.isDefined(value) && (lastClass && element.removeClass(lastClass), lastClass = value ? className + "-" + value.trim().replace(WHITESPACE, "-") : className, 
                                            element.addClass(lastClass));
                                        };
                                    }(element, className), unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
                                    updateFn(getNormalizedAttrValue(className, attrs, "")), scope.$on("$destroy", (function() {
                                        unwatch();
                                    }));
                                }
                            }(fullName));
                        })), angular.forEach(API_NO_VALUES, (function(name) {
                            var fullName = mqb ? name + "-" + mqb : name;
                            module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
                        }));
                    })), module.provider("$$mdLayout", (function() {
                        return {
                            $get: angular.noop,
                            validateAttributeValue,
                            validateAttributeUsage,
                            disableLayouts: function(isDisabled) {
                                config.enabled = !0 !== isDisabled;
                            }
                        };
                    })).directive("mdLayoutCss", disableLayoutDirective).directive("ngCloak", (className = "ng-cloak", 
                    [ "$timeout", function($timeout) {
                        return {
                            restrict: "A",
                            priority: -10,
                            compile: function(element) {
                                return config.enabled ? (element.addClass(className), function(scope, element) {
                                    $timeout((function() {
                                        element.removeClass(className);
                                    }), 10, !1);
                                }) : angular.noop;
                            }
                        };
                    } ])).directive("layoutWrap", attributeWithoutValue("layout-wrap")).directive("layoutNowrap", attributeWithoutValue("layout-nowrap")).directive("layoutNoWrap", attributeWithoutValue("layout-no-wrap")).directive("layoutFill", attributeWithoutValue("layout-fill")).config(detectDisabledLayouts);
                }(angular.module("material.core.layout", [ "ng" ]));
            }(), function() {
                function MdLiveAnnouncer($timeout) {
                    this._$timeout = $timeout, this._liveElement = this._createLiveElement(), this._announceTimeout = 100;
                }
                MdLiveAnnouncer.$inject = [ "$timeout" ], angular.module("material.core").service("$mdLiveAnnouncer", MdLiveAnnouncer), 
                MdLiveAnnouncer.prototype.announce = function(message, politeness) {
                    politeness || (politeness = "polite");
                    var self = this;
                    self._liveElement.textContent = "", self._liveElement.setAttribute("aria-live", politeness), 
                    self._$timeout((function() {
                        self._liveElement.textContent = message;
                    }), self._announceTimeout, !1);
                }, MdLiveAnnouncer.prototype._createLiveElement = function() {
                    var liveEl = document.createElement("div");
                    return liveEl.classList.add("md-visually-hidden"), liveEl.setAttribute("role", "status"), 
                    liveEl.setAttribute("aria-atomic", "true"), liveEl.setAttribute("aria-live", "polite"), 
                    document.body.appendChild(liveEl), liveEl;
                };
            }(), angular.module("material.core.meta", []).provider("$$mdMeta", (function() {
                var head = angular.element(document.head), metaElements = {};
                function mapExistingElement(name) {
                    if (metaElements[name]) return !0;
                    var element = document.getElementsByName(name)[0];
                    return !!element && (metaElements[name] = angular.element(element), !0);
                }
                var module = {
                    setMeta: function(name, content) {
                        if (mapExistingElement(name), metaElements[name]) metaElements[name].attr("content", content); else {
                            var newMeta = angular.element('<meta name="' + name + '" content="' + content + '"/>');
                            head.append(newMeta), metaElements[name] = newMeta;
                        }
                        return function() {
                            metaElements[name].attr("content", ""), metaElements[name].remove(), delete metaElements[name];
                        };
                    },
                    getMeta: function(name) {
                        if (!mapExistingElement(name)) throw Error("$$mdMeta: could not find a meta tag with the name '" + name + "'");
                        return metaElements[name].attr("content");
                    }
                };
                return angular.extend({}, module, {
                    $get: function() {
                        return module;
                    }
                });
            })), function() {
                function ComponentRegistry($log, $q) {
                    var self, instances = [], pendings = {};
                    return self = {
                        notFoundError: function(handle, msgContext) {
                            $log.error((msgContext || "") + "No instance found for handle", handle);
                        },
                        getInstances: function() {
                            return instances;
                        },
                        get: function(handle) {
                            if (!isValidID(handle)) return null;
                            var i, j, instance;
                            for (i = 0, j = instances.length; i < j; i++) if ((instance = instances[i]).$$mdHandle === handle) return instance;
                            return null;
                        },
                        register: function(instance, handle) {
                            return handle ? (instance.$$mdHandle = handle, instances.push(instance), (dfd = pendings[handle]) && (dfd.forEach((function(promise) {
                                promise.resolve(instance);
                            })), delete pendings[handle]), function() {
                                var index = instances.indexOf(instance);
                                -1 !== index && instances.splice(index, 1);
                            }) : angular.noop;
                            var dfd;
                        },
                        when: function(handle) {
                            if (isValidID(handle)) {
                                var deferred = $q.defer(), instance = self.get(handle);
                                return instance ? deferred.resolve(instance) : (undefined === pendings[handle] && (pendings[handle] = []), 
                                pendings[handle].push(deferred)), deferred.promise;
                            }
                            return $q.reject("Invalid `md-component-id` value.");
                        }
                    };
                    function isValidID(handle) {
                        return handle && "" !== handle;
                    }
                }
                ComponentRegistry.$inject = [ "$log", "$q" ], angular.module("material.core").factory("$mdComponentRegistry", ComponentRegistry);
            }(), function() {
                function MdButtonInkRipple($mdInkRipple) {
                    return {
                        attach: function(scope, element, options) {
                            return options = angular.extend(function(element) {
                                return element.hasClass("md-icon-button") ? {
                                    isMenuItem: element.hasClass("md-menu-item"),
                                    fitRipple: !0,
                                    center: !0
                                } : {
                                    isMenuItem: element.hasClass("md-menu-item"),
                                    dimBackground: !0
                                };
                            }(element), options), $mdInkRipple.attach(scope, element, options);
                        }
                    };
                }
                MdButtonInkRipple.$inject = [ "$mdInkRipple" ], angular.module("material.core").factory("$mdButtonInkRipple", MdButtonInkRipple);
            }(), function() {
                function MdCheckboxInkRipple($mdInkRipple) {
                    return {
                        attach: function(scope, element, options) {
                            return $mdInkRipple.attach(scope, element, angular.extend({
                                center: !0,
                                dimBackground: !1,
                                fitRipple: !0
                            }, options));
                        }
                    };
                }
                MdCheckboxInkRipple.$inject = [ "$mdInkRipple" ], angular.module("material.core").factory("$mdCheckboxInkRipple", MdCheckboxInkRipple);
            }(), function() {
                function MdListInkRipple($mdInkRipple) {
                    return {
                        attach: function(scope, element, options) {
                            return $mdInkRipple.attach(scope, element, angular.extend({
                                center: !1,
                                dimBackground: !0,
                                outline: !1,
                                rippleSize: "full"
                            }, options));
                        }
                    };
                }
                MdListInkRipple.$inject = [ "$mdInkRipple" ], angular.module("material.core").factory("$mdListInkRipple", MdListInkRipple);
            }(), function() {
                InkRippleCtrl.$inject = [ "$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil", "$mdColorUtil" ], 
                InkRippleDirective.$inject = [ "$mdButtonInkRipple", "$mdCheckboxInkRipple" ], angular.module("material.core").provider("$mdInkRipple", (function() {
                    var isDisabledGlobally = !1;
                    return {
                        disableInkRipple: function() {
                            isDisabledGlobally = !0;
                        },
                        $get: [ "$injector", function($injector) {
                            return {
                                attach: function(scope, element, options) {
                                    return isDisabledGlobally || element.controller("mdNoInk") ? angular.noop : $injector.instantiate(InkRippleCtrl, {
                                        $scope: scope,
                                        $element: element,
                                        rippleOptions: options
                                    });
                                }
                            };
                        } ]
                    };
                })).directive("mdInkRipple", InkRippleDirective).directive("mdNoInk", attrNoDirective).directive("mdNoBar", attrNoDirective).directive("mdNoStretch", attrNoDirective);
                function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {
                    return {
                        controller: angular.noop,
                        link: function(scope, element, attr) {
                            attr.hasOwnProperty("mdInkRippleCheckbox") ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);
                        }
                    };
                }
                function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil, $mdColorUtil) {
                    this.$window = $window, this.$timeout = $timeout, this.$mdUtil = $mdUtil, this.$mdColorUtil = $mdColorUtil, 
                    this.$scope = $scope, this.$element = $element, this.options = rippleOptions, this.mousedown = !1, 
                    this.ripples = [], this.timeout = null, this.lastRipple = null, $mdUtil.valueOnUse(this, "container", this.createContainer), 
                    this.$element.addClass("md-ink-ripple"), ($element.controller("mdInkRipple") || {}).createRipple = angular.bind(this, this.createRipple), 
                    ($element.controller("mdInkRipple") || {}).setColor = angular.bind(this, this.color), 
                    this.bindEvents();
                }
                function autoCleanup(self, cleanupFn) {
                    (self.mousedown || self.lastRipple) && (self.mousedown = !1, self.$mdUtil.nextTick(angular.bind(self, cleanupFn), !1));
                }
                function attrNoDirective() {
                    return {
                        controller: angular.noop
                    };
                }
                InkRippleCtrl.prototype.color = function(value) {
                    var items, elem, self = this;
                    return angular.isDefined(value) && (self._color = self._parseColor(value)), self._color || self._parseColor(self.inkRipple()) || self._parseColor((items = self.options && self.options.colorElement ? self.options.colorElement : [], 
                    (elem = items.length ? items[0] : self.$element[0]) ? self.$window.getComputedStyle(elem).color : "rgb(0,0,0)"));
                }, InkRippleCtrl.prototype.calculateColor = function() {
                    return this.color();
                }, InkRippleCtrl.prototype._parseColor = function(color, multiplier) {
                    multiplier = multiplier || 1;
                    var colorUtil = this.$mdColorUtil;
                    if (color) return 0 === color.indexOf("rgba") ? color.replace(/\d?\.?\d*\s*\)\s*$/, (.1 * multiplier).toString() + ")") : 0 === color.indexOf("rgb") ? colorUtil.rgbToRgba(color) : 0 === color.indexOf("#") ? colorUtil.hexToRgba(color) : void 0;
                }, InkRippleCtrl.prototype.bindEvents = function() {
                    this.$element.on("mousedown", angular.bind(this, this.handleMousedown)), this.$element.on("mouseup touchend", angular.bind(this, this.handleMouseup)), 
                    this.$element.on("mouseleave", angular.bind(this, this.handleMouseup)), this.$element.on("touchmove", angular.bind(this, this.handleTouchmove));
                }, InkRippleCtrl.prototype.handleMousedown = function(event) {
                    if (!this.mousedown) if (event.hasOwnProperty("originalEvent") && (event = event.originalEvent), 
                    this.mousedown = !0, this.options.center) this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2); else if (event.srcElement !== this.$element[0]) {
                        var layerRect = this.$element[0].getBoundingClientRect(), layerX = event.clientX - layerRect.left, layerY = event.clientY - layerRect.top;
                        this.createRipple(layerX, layerY);
                    } else this.createRipple(event.offsetX, event.offsetY);
                }, InkRippleCtrl.prototype.handleMouseup = function() {
                    this.$timeout(function() {
                        autoCleanup(this, this.clearRipples);
                    }.bind(this));
                }, InkRippleCtrl.prototype.handleTouchmove = function() {
                    autoCleanup(this, this.deleteRipples);
                }, InkRippleCtrl.prototype.deleteRipples = function() {
                    for (var i = 0; i < this.ripples.length; i++) this.ripples[i].remove();
                }, InkRippleCtrl.prototype.clearRipples = function() {
                    for (var i = 0; i < this.ripples.length; i++) this.fadeInComplete(this.ripples[i]);
                }, InkRippleCtrl.prototype.createContainer = function() {
                    var container = angular.element('<div class="md-ripple-container"></div>');
                    return this.$element.append(container), container;
                }, InkRippleCtrl.prototype.clearTimeout = function() {
                    this.timeout && (this.$timeout.cancel(this.timeout), this.timeout = null);
                }, InkRippleCtrl.prototype.isRippleAllowed = function() {
                    var element = this.$element[0];
                    do {
                        if (!element.tagName || "BODY" === element.tagName) break;
                        if (element && angular.isFunction(element.hasAttribute)) {
                            if (element.hasAttribute("disabled")) return !1;
                            if ("false" === this.inkRipple() || "0" === this.inkRipple()) return !1;
                        }
                    } while (element = element.parentNode);
                    return !0;
                }, InkRippleCtrl.prototype.inkRipple = function() {
                    return this.$element.attr("md-ink-ripple");
                }, InkRippleCtrl.prototype.createRipple = function(left, top) {
                    if (this.isRippleAllowed()) {
                        var ctrl = this, colorUtil = ctrl.$mdColorUtil, ripple = angular.element('<div class="md-ripple"></div>'), width = this.$element.prop("clientWidth"), height = this.$element.prop("clientHeight"), x = 2 * Math.max(Math.abs(width - left), left), y = 2 * Math.max(Math.abs(height - top), top), size = function(fit, x, y) {
                            return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
                        }(this.options.fitRipple, x, y), color = this.calculateColor();
                        ripple.css({
                            left: left + "px",
                            top: top + "px",
                            background: "black",
                            width: size + "px",
                            height: size + "px",
                            backgroundColor: colorUtil.rgbaToRgb(color),
                            borderColor: colorUtil.rgbaToRgb(color)
                        }), this.lastRipple = ripple, this.clearTimeout(), this.timeout = this.$timeout((function() {
                            ctrl.clearTimeout(), ctrl.mousedown || ctrl.fadeInComplete(ripple);
                        }), 157.5, !1), this.options.dimBackground && this.container.css({
                            backgroundColor: color
                        }), this.container.append(ripple), this.ripples.push(ripple), ripple.addClass("md-ripple-placed"), 
                        this.$mdUtil.nextTick((function() {
                            ripple.addClass("md-ripple-scaled md-ripple-active"), ctrl.$timeout((function() {
                                ctrl.clearRipples();
                            }), 450, !1);
                        }), !1);
                    }
                }, InkRippleCtrl.prototype.fadeInComplete = function(ripple) {
                    this.lastRipple === ripple && (this.timeout || this.mousedown) || this.removeRipple(ripple);
                }, InkRippleCtrl.prototype.removeRipple = function(ripple) {
                    var ctrl = this;
                    this.ripples.indexOf(ripple) < 0 || (this.ripples.splice(this.ripples.indexOf(ripple), 1), 
                    ripple.removeClass("md-ripple-active"), ripple.addClass("md-ripple-remove"), 0 === this.ripples.length && this.container.css({
                        backgroundColor: ""
                    }), this.$timeout((function() {
                        ctrl.fadeOutComplete(ripple);
                    }), 450, !1));
                }, InkRippleCtrl.prototype.fadeOutComplete = function(ripple) {
                    ripple.remove(), this.lastRipple = null;
                };
            }(), function() {
                function MdTabInkRipple($mdInkRipple) {
                    return {
                        attach: function(scope, element, options) {
                            return $mdInkRipple.attach(scope, element, angular.extend({
                                center: !1,
                                dimBackground: !0,
                                outline: !1,
                                rippleSize: "full"
                            }, options));
                        }
                    };
                }
                MdTabInkRipple.$inject = [ "$mdInkRipple" ], angular.module("material.core").factory("$mdTabInkRipple", MdTabInkRipple);
            }(), angular.module("material.core.theming.palette", []).constant("$mdColorPalette", {
                red: {
                    50: "#ffebee",
                    100: "#ffcdd2",
                    200: "#ef9a9a",
                    300: "#e57373",
                    400: "#ef5350",
                    500: "#f44336",
                    600: "#e53935",
                    700: "#d32f2f",
                    800: "#c62828",
                    900: "#b71c1c",
                    A100: "#ff8a80",
                    A200: "#ff5252",
                    A400: "#ff1744",
                    A700: "#d50000",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 400 500 600 A100 A200 A400",
                    contrastStrongLightColors: "700 800 900 A700"
                },
                pink: {
                    50: "#fce4ec",
                    100: "#f8bbd0",
                    200: "#f48fb1",
                    300: "#f06292",
                    400: "#ec407a",
                    500: "#e91e63",
                    600: "#d81b60",
                    700: "#c2185b",
                    800: "#ad1457",
                    900: "#880e4f",
                    A100: "#ff80ab",
                    A200: "#ff4081",
                    A400: "#f50057",
                    A700: "#c51162",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 400 A100 A200 A400",
                    contrastStrongLightColors: "500 600 700 800 900 A700"
                },
                purple: {
                    50: "#f3e5f5",
                    100: "#e1bee7",
                    200: "#ce93d8",
                    300: "#ba68c8",
                    400: "#ab47bc",
                    500: "#9c27b0",
                    600: "#8e24aa",
                    700: "#7b1fa2",
                    800: "#6a1b9a",
                    900: "#4a148c",
                    A100: "#ea80fc",
                    A200: "#e040fb",
                    A400: "#d500f9",
                    A700: "#aa00ff",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 A100 A200 A400",
                    contrastStrongLightColors: "400 500 600 700 800 900 A700"
                },
                "deep-purple": {
                    50: "#ede7f6",
                    100: "#d1c4e9",
                    200: "#b39ddb",
                    300: "#9575cd",
                    400: "#7e57c2",
                    500: "#673ab7",
                    600: "#5e35b1",
                    700: "#512da8",
                    800: "#4527a0",
                    900: "#311b92",
                    A100: "#b388ff",
                    A200: "#7c4dff",
                    A400: "#651fff",
                    A700: "#6200ea",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 A100",
                    contrastStrongLightColors: "400 500 600 700 800 900 A200 A400 A700"
                },
                indigo: {
                    50: "#e8eaf6",
                    100: "#c5cae9",
                    200: "#9fa8da",
                    300: "#7986cb",
                    400: "#5c6bc0",
                    500: "#3f51b5",
                    600: "#3949ab",
                    700: "#303f9f",
                    800: "#283593",
                    900: "#1a237e",
                    A100: "#8c9eff",
                    A200: "#536dfe",
                    A400: "#3d5afe",
                    A700: "#304ffe",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 A100 A200",
                    contrastStrongLightColors: "400 500 600 700 800 900 A400 A700"
                },
                blue: {
                    50: "#e3f2fd",
                    100: "#bbdefb",
                    200: "#90caf9",
                    300: "#64b5f6",
                    400: "#42a5f5",
                    500: "#2196f3",
                    600: "#1e88e5",
                    700: "#1976d2",
                    800: "#1565c0",
                    900: "#0d47a1",
                    A100: "#82b1ff",
                    A200: "#448aff",
                    A400: "#2979ff",
                    A700: "#2962ff",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 400 500 600 A100 A200",
                    contrastStrongLightColors: "700 800 900 A400 A700"
                },
                "light-blue": {
                    50: "#e1f5fe",
                    100: "#b3e5fc",
                    200: "#81d4fa",
                    300: "#4fc3f7",
                    400: "#29b6f6",
                    500: "#03a9f4",
                    600: "#039be5",
                    700: "#0288d1",
                    800: "#0277bd",
                    900: "#01579b",
                    A100: "#80d8ff",
                    A200: "#40c4ff",
                    A400: "#00b0ff",
                    A700: "#0091ea",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "800 900 A700"
                },
                cyan: {
                    50: "#e0f7fa",
                    100: "#b2ebf2",
                    200: "#80deea",
                    300: "#4dd0e1",
                    400: "#26c6da",
                    500: "#00bcd4",
                    600: "#00acc1",
                    700: "#0097a7",
                    800: "#00838f",
                    900: "#006064",
                    A100: "#84ffff",
                    A200: "#18ffff",
                    A400: "#00e5ff",
                    A700: "#00b8d4",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "800 900"
                },
                teal: {
                    50: "#e0f2f1",
                    100: "#b2dfdb",
                    200: "#80cbc4",
                    300: "#4db6ac",
                    400: "#26a69a",
                    500: "#009688",
                    600: "#00897b",
                    700: "#00796b",
                    800: "#00695c",
                    900: "#004d40",
                    A100: "#a7ffeb",
                    A200: "#64ffda",
                    A400: "#1de9b6",
                    A700: "#00bfa5",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "600 700 800 900"
                },
                green: {
                    50: "#e8f5e9",
                    100: "#c8e6c9",
                    200: "#a5d6a7",
                    300: "#81c784",
                    400: "#66bb6a",
                    500: "#4caf50",
                    600: "#43a047",
                    700: "#388e3c",
                    800: "#2e7d32",
                    900: "#1b5e20",
                    A100: "#b9f6ca",
                    A200: "#69f0ae",
                    A400: "#00e676",
                    A700: "#00c853",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "700 800 900"
                },
                "light-green": {
                    50: "#f1f8e9",
                    100: "#dcedc8",
                    200: "#c5e1a5",
                    300: "#aed581",
                    400: "#9ccc65",
                    500: "#8bc34a",
                    600: "#7cb342",
                    700: "#689f38",
                    800: "#558b2f",
                    900: "#33691e",
                    A100: "#ccff90",
                    A200: "#b2ff59",
                    A400: "#76ff03",
                    A700: "#64dd17",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "800 900"
                },
                lime: {
                    50: "#f9fbe7",
                    100: "#f0f4c3",
                    200: "#e6ee9c",
                    300: "#dce775",
                    400: "#d4e157",
                    500: "#cddc39",
                    600: "#c0ca33",
                    700: "#afb42b",
                    800: "#9e9d24",
                    900: "#827717",
                    A100: "#f4ff81",
                    A200: "#eeff41",
                    A400: "#c6ff00",
                    A700: "#aeea00",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "900"
                },
                yellow: {
                    50: "#fffde7",
                    100: "#fff9c4",
                    200: "#fff59d",
                    300: "#fff176",
                    400: "#ffee58",
                    500: "#ffeb3b",
                    600: "#fdd835",
                    700: "#fbc02d",
                    800: "#f9a825",
                    900: "#f57f17",
                    A100: "#ffff8d",
                    A200: "#ffff00",
                    A400: "#ffea00",
                    A700: "#ffd600",
                    contrastDefaultColor: "dark"
                },
                amber: {
                    50: "#fff8e1",
                    100: "#ffecb3",
                    200: "#ffe082",
                    300: "#ffd54f",
                    400: "#ffca28",
                    500: "#ffc107",
                    600: "#ffb300",
                    700: "#ffa000",
                    800: "#ff8f00",
                    900: "#ff6f00",
                    A100: "#ffe57f",
                    A200: "#ffd740",
                    A400: "#ffc400",
                    A700: "#ffab00",
                    contrastDefaultColor: "dark"
                },
                orange: {
                    50: "#fff3e0",
                    100: "#ffe0b2",
                    200: "#ffcc80",
                    300: "#ffb74d",
                    400: "#ffa726",
                    500: "#ff9800",
                    600: "#fb8c00",
                    700: "#f57c00",
                    800: "#ef6c00",
                    900: "#e65100",
                    A100: "#ffd180",
                    A200: "#ffab40",
                    A400: "#ff9100",
                    A700: "#ff6d00",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "900"
                },
                "deep-orange": {
                    50: "#fbe9e7",
                    100: "#ffccbc",
                    200: "#ffab91",
                    300: "#ff8a65",
                    400: "#ff7043",
                    500: "#ff5722",
                    600: "#f4511e",
                    700: "#e64a19",
                    800: "#d84315",
                    900: "#bf360c",
                    A100: "#ff9e80",
                    A200: "#ff6e40",
                    A400: "#ff3d00",
                    A700: "#dd2c00",
                    contrastDefaultColor: "dark",
                    contrastStrongLightColors: "800 900 A400 A700"
                },
                brown: {
                    50: "#efebe9",
                    100: "#d7ccc8",
                    200: "#bcaaa4",
                    300: "#a1887f",
                    400: "#8d6e63",
                    500: "#795548",
                    600: "#6d4c41",
                    700: "#5d4037",
                    800: "#4e342e",
                    900: "#3e2723",
                    A100: "#d7ccc8",
                    A200: "#bcaaa4",
                    A400: "#8d6e63",
                    A700: "#5d4037",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 A100 A200",
                    contrastStrongLightColors: "400 500 600 700 800 900 A400 A700"
                },
                grey: {
                    50: "#fafafa",
                    100: "#f5f5f5",
                    200: "#eeeeee",
                    300: "#e0e0e0",
                    400: "#bdbdbd",
                    500: "#9e9e9e",
                    600: "#757575",
                    700: "#616161",
                    800: "#424242",
                    900: "#212121",
                    A100: "#ffffff",
                    A200: "#000000",
                    A400: "#303030",
                    A700: "#616161",
                    contrastDefaultColor: "dark",
                    contrastLightColors: "700 800 900 A200 A400 A700",
                    contrastStrongLightColors: "600"
                },
                "blue-grey": {
                    50: "#eceff1",
                    100: "#cfd8dc",
                    200: "#b0bec5",
                    300: "#90a4ae",
                    400: "#78909c",
                    500: "#607d8b",
                    600: "#546e7a",
                    700: "#455a64",
                    800: "#37474f",
                    900: "#263238",
                    A100: "#cfd8dc",
                    A200: "#b0bec5",
                    A400: "#78909c",
                    A700: "#455a64",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "50 100 200 300 400 A100 A200 A400",
                    contrastStrongLightColors: "500 600 700 800 900 A700"
                }
            }), function(angular) {
                function detectDisabledThemes($mdThemingProvider) {
                    var isDisabled = !!document.querySelector("[md-themes-disabled]");
                    $mdThemingProvider.disableTheming(isDisabled);
                }
                detectDisabledThemes.$inject = [ "$mdThemingProvider" ], ThemingDirective.$inject = [ "$mdTheming", "$interpolate", "$parse", "$mdUtil", "$q", "$log" ], 
                ThemableDirective.$inject = [ "$mdTheming" ], ThemingProvider.$inject = [ "$mdColorPalette", "$$mdMetaProvider" ], 
                generateAllThemes.$inject = [ "$injector", "$mdTheming" ], angular.module("material.core.theming", [ "material.core.theming.palette", "material.core.meta" ]).directive("mdTheme", ThemingDirective).directive("mdThemable", ThemableDirective).directive("mdThemesDisabled", (function() {
                    return themeConfig.disableTheming = !0, {
                        restrict: "A",
                        priority: "900"
                    };
                })).provider("$mdTheming", ThemingProvider).config(detectDisabledThemes).run(generateAllThemes);
                var PALETTES, GENERATED = {}, DARK_FOREGROUND = {
                    name: "dark"
                }, LIGHT_FOREGROUND = {
                    name: "light"
                }, DARK_SHADOW = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)", LIGHT_SHADOW = "", DARK_CONTRAST_COLOR = colorToRgbaArray("rgba(0,0,0,0.87)"), LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgba(255,255,255,0.87)"), STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgb(255,255,255)"), THEME_COLOR_TYPES = [ "primary", "accent", "warn", "background" ], DEFAULT_COLOR_TYPE = "primary", LIGHT_DEFAULT_HUES = {
                    accent: {
                        default: "A200",
                        "hue-1": "A100",
                        "hue-2": "A400",
                        "hue-3": "A700"
                    },
                    background: {
                        default: "50",
                        "hue-1": "A100",
                        "hue-2": "100",
                        "hue-3": "300"
                    }
                }, DARK_DEFAULT_HUES = {
                    background: {
                        default: "A400",
                        "hue-1": "800",
                        "hue-2": "900",
                        "hue-3": "A200"
                    }
                }, DARK_CONTRAST_OPACITY = {
                    icon: .54,
                    secondary: .54,
                    disabled: .38,
                    hint: .38,
                    divider: .12
                }, LIGHT_CONTRAST_OPACITY = {
                    icon: .87,
                    secondary: .7,
                    disabled: .5,
                    hint: .5,
                    divider: .12
                }, STRONG_LIGHT_CONTRAST_OPACITY = {
                    icon: 1,
                    secondary: .7,
                    disabled: .5,
                    hint: .5,
                    divider: .12
                };
                THEME_COLOR_TYPES.forEach((function(colorType) {
                    var defaultDefaultHues = {
                        default: "500",
                        "hue-1": "300",
                        "hue-2": "800",
                        "hue-3": "A100"
                    };
                    LIGHT_DEFAULT_HUES[colorType] || (LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues), 
                    DARK_DEFAULT_HUES[colorType] || (DARK_DEFAULT_HUES[colorType] = defaultDefaultHues);
                }));
                var VALID_HUE_VALUES = [ "50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700" ], themeConfig = {
                    disableTheming: !1,
                    generateOnDemand: !1,
                    registeredStyles: [],
                    nonce: null
                };
                function ThemingProvider($mdColorPalette, $$mdMetaProvider) {
                    ThemingService.$inject = [ "$rootScope", "$mdUtil", "$q", "$log" ], PALETTES = {};
                    var themingProvider, THEMES = {}, alwaysWatchTheme = !1, defaultTheme = "default";
                    angular.extend(PALETTES, $mdColorPalette);
                    var enableBrowserColor = function(options) {
                        var theme = (options = angular.isObject(options) ? options : {}).theme || "default", hue = options.hue || "800", palette = PALETTES[options.palette] || PALETTES[THEMES[theme].colors[options.palette || "primary"].name], color = angular.isObject(palette[hue]) ? palette[hue].hex : palette[hue];
                        return "#" !== color.substr(0, 1) && (color = "#" + color), function(color) {
                            var removeChrome = $$mdMetaProvider.setMeta("theme-color", color), removeWindows = $$mdMetaProvider.setMeta("msapplication-navbutton-color", color);
                            return function() {
                                removeChrome(), removeWindows();
                            };
                        }(color);
                    };
                    return themingProvider = {
                        definePalette: function(name, map) {
                            return map = map || {}, PALETTES[name] = checkPaletteValid(name, map), themingProvider;
                        },
                        extendPalette: function(name, map) {
                            return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
                        },
                        theme: registerTheme,
                        configuration: function() {
                            return angular.extend({}, themeConfig, {
                                defaultTheme,
                                alwaysWatchTheme,
                                registeredStyles: [].concat(themeConfig.registeredStyles)
                            });
                        },
                        disableTheming: function(isDisabled) {
                            themeConfig.disableTheming = angular.isUndefined(isDisabled) || !!isDisabled;
                        },
                        registerStyles: function(styles) {
                            themeConfig.registeredStyles.push(styles);
                        },
                        setNonce: function(nonceValue) {
                            themeConfig.nonce = nonceValue;
                        },
                        generateThemesOnDemand: function(onDemand) {
                            themeConfig.generateOnDemand = onDemand;
                        },
                        setDefaultTheme: function(theme) {
                            defaultTheme = theme;
                        },
                        alwaysWatchTheme: function(alwaysWatch) {
                            alwaysWatchTheme = alwaysWatch;
                        },
                        enableBrowserColor,
                        $get: ThemingService,
                        _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
                        _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
                        _PALETTES: PALETTES,
                        _THEMES: THEMES,
                        _parseRules: parseRules,
                        _rgba: rgba
                    };
                    function checkPaletteValid(name, map) {
                        var missingColors = VALID_HUE_VALUES.filter((function(field) {
                            return !map[field];
                        }));
                        if (missingColors.length) throw new Error("Missing colors %1 in palette %2!".replace("%1", missingColors.join(", ")).replace("%2", name));
                        return map;
                    }
                    function registerTheme(name, inheritFrom) {
                        if (THEMES[name]) return THEMES[name];
                        var parentTheme = "string" == typeof (inheritFrom = inheritFrom || "default") ? THEMES[inheritFrom] : inheritFrom, theme = new Theme(name);
                        return parentTheme && angular.forEach(parentTheme.colors, (function(color, colorType) {
                            theme.colors[colorType] = {
                                name: color.name,
                                hues: angular.extend({}, color.hues)
                            };
                        })), THEMES[name] = theme, theme;
                    }
                    function Theme(name) {
                        var self = this;
                        function setDark(isDark) {
                            if ((isDark = 0 === arguments.length || !!isDark) !== self.isDark) {
                                self.isDark = isDark, self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND, 
                                self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
                                var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES, oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
                                return angular.forEach(newDefaultHues, (function(newDefaults, colorType) {
                                    var color = self.colors[colorType], oldDefaults = oldDefaultHues[colorType];
                                    if (color) for (var hueName in color.hues) color.hues[hueName] === oldDefaults[hueName] && (color.hues[hueName] = newDefaults[hueName]);
                                })), self;
                            }
                        }
                        self.name = name, self.colors = {}, self.dark = setDark, setDark(!1), THEME_COLOR_TYPES.forEach((function(colorType) {
                            var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
                            self[colorType + "Palette"] = function(paletteName, hues) {
                                var color = self.colors[colorType] = {
                                    name: paletteName,
                                    hues: angular.extend({}, defaultHues, hues)
                                };
                                return Object.keys(color.hues).forEach((function(name) {
                                    if (!defaultHues[name]) throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", name).replace("%2", self.name).replace("%3", paletteName).replace("%4", Object.keys(defaultHues).join(", ")));
                                })), Object.keys(color.hues).map((function(key) {
                                    return color.hues[key];
                                })).forEach((function(hueValue) {
                                    if (-1 === VALID_HUE_VALUES.indexOf(hueValue)) throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", hueValue).replace("%2", self.name).replace("%3", colorType).replace("%4", paletteName).replace("%5", VALID_HUE_VALUES.join(", ")));
                                })), self;
                            };
                        }));
                    }
                    function ThemingService($rootScope, $mdUtil, $q, $log) {
                        var applyTheme = function(scope, el) {
                            void 0 === el && (el = scope, scope = void 0), void 0 === scope && (scope = $rootScope), 
                            applyTheme.inherit(el, el);
                        };
                        return Object.defineProperty(applyTheme, "THEMES", {
                            get: function() {
                                return angular.extend({}, THEMES);
                            }
                        }), Object.defineProperty(applyTheme, "PALETTES", {
                            get: function() {
                                return angular.extend({}, PALETTES);
                            }
                        }), Object.defineProperty(applyTheme, "ALWAYS_WATCH", {
                            get: function() {
                                return alwaysWatchTheme;
                            }
                        }), applyTheme.inherit = function(el, parent) {
                            var ctrl = parent.controller("mdTheme") || el.data("$mdThemeController"), scope = el.scope();
                            if (updateThemeClass(ctrl && ctrl.$mdTheme || ("default" === defaultTheme ? "" : defaultTheme)), 
                            ctrl) {
                                var watchTheme = alwaysWatchTheme || ctrl.$shouldWatch || $mdUtil.parseAttributeBoolean(el.attr("md-theme-watch"));
                                if (watchTheme || ctrl.isAsyncTheme) {
                                    var clearNameWatcher = function() {
                                        unwatch && (unwatch(), unwatch = void 0);
                                    }, unwatch = ctrl.registerChanges((function(name) {
                                        updateThemeClass(name), watchTheme || clearNameWatcher();
                                    }));
                                    scope ? scope.$on("$destroy", clearNameWatcher) : el.on("$destroy", clearNameWatcher);
                                }
                            }
                            function updateThemeClass(theme) {
                                if (theme) {
                                    registered(theme) || $log.warn("Attempted to use unregistered theme '" + theme + "'. Register it with $mdThemingProvider.theme().");
                                    var oldTheme = el.data("$mdThemeName");
                                    oldTheme && el.removeClass("md-" + oldTheme + "-theme"), el.addClass("md-" + theme + "-theme"), 
                                    el.data("$mdThemeName", theme), ctrl && el.data("$mdThemeController", ctrl);
                                }
                            }
                        }, applyTheme.registered = registered, applyTheme.defaultTheme = function() {
                            return defaultTheme;
                        }, applyTheme.generateTheme = function(name) {
                            generateTheme(THEMES[name], name, themeConfig.nonce);
                        }, applyTheme.defineTheme = function(name, options) {
                            options = options || {};
                            var theme = registerTheme(name);
                            return options.primary && theme.primaryPalette(options.primary, options.primaryHues), 
                            options.accent && theme.accentPalette(options.accent, options.accentHues), options.warn && theme.warnPalette(options.warn, options.warnHues), 
                            options.background && theme.backgroundPalette(options.background, options.backgroundHues), 
                            options.dark && theme.dark(), this.generateTheme(name), $q.resolve(name);
                        }, applyTheme.setBrowserColor = enableBrowserColor, applyTheme;
                        function registered(themeName) {
                            return void 0 === themeName || "" === themeName || void 0 !== applyTheme.THEMES[themeName];
                        }
                    }
                }
                function ThemingDirective($mdTheming, $interpolate, $parse, $mdUtil, $q, $log) {
                    return {
                        priority: 101,
                        link: {
                            pre: function(scope, el, attrs) {
                                var registeredCallbacks = [], startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), theme = attrs.mdTheme.trim(), hasInterpolation = theme.substr(0, startSymbol.length) === startSymbol && theme.lastIndexOf(endSymbol) === theme.length - endSymbol.length, oneTimeBind = "::" === attrs.mdTheme.split(startSymbol).join("").split(endSymbol).join("").trim().substr(0, 2), getTheme = function() {
                                    var interpolation = $interpolate(attrs.mdTheme)(scope);
                                    return $parse(interpolation)(scope) || interpolation;
                                }, ctrl = {
                                    isAsyncTheme: angular.isFunction(getTheme()) || angular.isFunction(getTheme().then),
                                    registerChanges: function(cb, context) {
                                        return context && (cb = angular.bind(context, cb)), registeredCallbacks.push(cb), 
                                        function() {
                                            var index = registeredCallbacks.indexOf(cb);
                                            index > -1 && registeredCallbacks.splice(index, 1);
                                        };
                                    },
                                    $setTheme: function(theme) {
                                        $mdTheming.registered(theme) || $log.warn("attempted to use unregistered theme '" + theme + "'"), 
                                        ctrl.$mdTheme = theme;
                                        for (var i = registeredCallbacks.length; i--; ) registeredCallbacks[i](theme);
                                    },
                                    $shouldWatch: $mdUtil.parseAttributeBoolean(el.attr("md-theme-watch")) || $mdTheming.ALWAYS_WATCH || hasInterpolation && !oneTimeBind
                                };
                                el.data("$mdThemeController", ctrl);
                                var setParsedTheme = function(theme) {
                                    if ("string" == typeof theme) return ctrl.$setTheme(theme);
                                    $q.when(angular.isFunction(theme) ? theme() : theme).then((function(name) {
                                        ctrl.$setTheme(name);
                                    }));
                                };
                                setParsedTheme(getTheme());
                                var unwatch = scope.$watch(getTheme, (function(theme) {
                                    theme && (setParsedTheme(theme), ctrl.$shouldWatch || unwatch());
                                }));
                            }
                        }
                    };
                }
                function ThemableDirective($mdTheming) {
                    return $mdTheming;
                }
                function parseRules(theme, colorType, rules) {
                    !function(theme, colorType) {
                        if (!PALETTES[(theme.colors[colorType] || {}).name]) throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", theme.name).replace("%2", colorType).replace("%3", Object.keys(PALETTES).join(", ")));
                    }(theme, colorType), rules = rules.replace(/THEME_NAME/g, theme.name);
                    var themeNameRegex = new RegExp("\\.md-" + theme.name + "-theme", "g"), hueRegex = new RegExp("(['\"])?{{\\s*([a-zA-Z]+)-?(color|default)?-?(contrast)?-?((?:\\d\\.?\\d*)|(?:[a-zA-Z]+))?\\s*}}([\"'])?", "g"), defaultBgHue = theme.colors.background.hues.default, defaultBgContrastType = PALETTES[theme.colors.background.name][defaultBgHue].contrastType;
                    rules = rules.replace(/'?"?{{\s*([a-zA-Z]+)-(A?\d+|hue-[0-3]|shadow|default)-?(contrast)?-?((?:\d\.?\d*)|(?:[a-zA-Z]+))?\s*}}'?"?/g, (function(match, colorType, hue, contrast, opacity) {
                        var regexColorType = colorType;
                        if ("foreground" === colorType) {
                            if ("shadow" === hue) return theme.foregroundShadow;
                            if (theme.foregroundPalette[hue]) return rgba(colorToRgbaArray(theme.foregroundPalette[hue]));
                            if (theme.foregroundPalette[1]) return rgba(colorToRgbaArray(theme.foregroundPalette[1]));
                            if (colorType = "background", contrast = "contrast", !opacity && hue) switch (hue) {
                              case "2":
                                opacity = "secondary";
                                break;

                              case "3":
                                opacity = "disabled";
                                break;

                              case "4":
                                opacity = "divider";
                            }
                            hue = "default";
                        }
                        0 !== hue.indexOf("hue") && "default" !== hue || (hue = theme.colors[colorType].hues[hue]);
                        var colorDetails = PALETTES[theme.colors[colorType].name][hue] || "";
                        if ("background" === colorType && contrast && "foreground" !== regexColorType && colorDetails.contrastType === defaultBgContrastType) switch (opacity) {
                          case "secondary":
                          case "icon":
                            if (theme.foregroundPalette[2]) return rgba(colorToRgbaArray(theme.foregroundPalette[2]));
                            break;

                          case "disabled":
                          case "hint":
                            if (theme.foregroundPalette[3]) return rgba(colorToRgbaArray(theme.foregroundPalette[3]));
                            break;

                          case "divider":
                            if (theme.foregroundPalette[4]) return rgba(colorToRgbaArray(theme.foregroundPalette[4]));
                            break;

                          default:
                            if (theme.foregroundPalette[1]) return rgba(colorToRgbaArray(theme.foregroundPalette[1]));
                        }
                        return contrast && opacity && (opacity = colorDetails.opacity[opacity] || opacity), 
                        rgba(colorDetails[contrast ? "contrast" : "value"], opacity);
                    }));
                    var generatedRules = [];
                    return angular.forEach([ "default", "hue-1", "hue-2", "hue-3" ], (function(hueName) {
                        var newRule = rules.replace(hueRegex, (function(match, _, matchedColorType, hueType, contrast, opacity) {
                            var color = theme.colors[matchedColorType], palette = PALETTES[color.name], hueValue = color.hues[hueName];
                            return contrast && opacity && (opacity = palette[hueValue].opacity[opacity] || opacity), 
                            rgba(palette[hueValue]["color" === hueType ? "value" : "contrast"], opacity);
                        }));
                        "default" !== hueName && (newRule = newRule.replace(themeNameRegex, ".md-" + theme.name + "-theme.md-" + hueName)), 
                        "default" === theme.name && (newRule = newRule.replace(/((?:\s|>|\.|\w|-|:|\(|\)|\[|]|"|'|=)*)\.md-default-theme((?:\s|>|\.|\w|-|:|\(|\)|\[|]|"|'|=)*)/g, (function(match, start, end) {
                            return match + ", " + start + end;
                        }))), generatedRules.push(newRule);
                    })), generatedRules;
                }
                var rulesByType = {};
                function generateAllThemes($injector, $mdTheming) {
                    var head = document.head, firstChild = head ? head.firstElementChild : null, themeCss = !themeConfig.disableTheming && $injector.has("$MD_THEME_CSS") ? $injector.get("$MD_THEME_CSS") : "";
                    if (themeCss += themeConfig.registeredStyles.join(""), firstChild && 0 !== themeCss.length) {
                        angular.forEach(PALETTES, (function(palette) {
                            var defaultContrast = palette.contrastDefaultColor, lightColors = palette.contrastLightColors || [], strongLightColors = palette.contrastStrongLightColors || [], darkColors = palette.contrastDarkColors || [];
                            function getContrastColor(contrastType) {
                                switch (contrastType) {
                                  default:
                                  case "strongLight":
                                    return STRONG_LIGHT_CONTRAST_COLOR;

                                  case "light":
                                    return LIGHT_CONTRAST_COLOR;

                                  case "dark":
                                    return DARK_CONTRAST_COLOR;
                                }
                            }
                            function getOpacityValues(contrastType) {
                                switch (contrastType) {
                                  default:
                                  case "strongLight":
                                    return STRONG_LIGHT_CONTRAST_OPACITY;

                                  case "light":
                                    return LIGHT_CONTRAST_OPACITY;

                                  case "dark":
                                    return DARK_CONTRAST_OPACITY;
                                }
                            }
                            "string" == typeof lightColors && (lightColors = lightColors.split(" ")), "string" == typeof strongLightColors && (strongLightColors = strongLightColors.split(" ")), 
                            "string" == typeof darkColors && (darkColors = darkColors.split(" ")), delete palette.contrastDefaultColor, 
                            delete palette.contrastLightColors, delete palette.contrastStrongLightColors, delete palette.contrastDarkColors, 
                            angular.forEach(palette, (function(hueValue, hueName) {
                                if (!angular.isObject(hueValue)) {
                                    var rgbValue = colorToRgbaArray(hueValue);
                                    if (!rgbValue) throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", hueValue).replace("%2", palette.name).replace("%3", hueName));
                                    var contrastType = function(hueName) {
                                        return ("light" === defaultContrast ? -1 !== darkColors.indexOf(hueName) : -1 === lightColors.indexOf(hueName) && -1 === strongLightColors.indexOf(hueName)) ? "dark" : -1 !== strongLightColors.indexOf(hueName) ? "strongLight" : "light";
                                    }(hueName);
                                    palette[hueName] = {
                                        hex: palette[hueName],
                                        value: rgbValue,
                                        contrastType,
                                        contrast: getContrastColor(contrastType),
                                        opacity: getOpacityValues(contrastType)
                                    };
                                }
                            }));
                        }));
                        var rules = function(themeCss) {
                            for (var result = [], currentRule = "", openedCurlyBrackets = 0, closedCurlyBrackets = 0, i = 0; i < themeCss.length; i++) {
                                var character = themeCss.charAt(i);
                                if ("'" === character || '"' === character) {
                                    var textInQuotes = themeCss.substring(i, themeCss.indexOf(character, i + 1));
                                    currentRule += textInQuotes, i += textInQuotes.length;
                                } else currentRule += character, "}" === character ? ++closedCurlyBrackets === openedCurlyBrackets && (closedCurlyBrackets = 0, 
                                openedCurlyBrackets = 0, result.push(currentRule), currentRule = "") : "{" === character && openedCurlyBrackets++;
                            }
                            return "" !== currentRule && result.push(currentRule), result;
                        }(themeCss).map((function(rule) {
                            return rule.trim();
                        }));
                        THEME_COLOR_TYPES.forEach((function(type) {
                            rulesByType[type] = "";
                        })), rules.forEach((function(rule) {
                            for (var type, i = 0; type = THEME_COLOR_TYPES[i]; i++) if (rule.indexOf(".md-" + type) > -1) return rulesByType[type] += rule;
                            for (i = 0; type = THEME_COLOR_TYPES[i]; i++) if (rule.indexOf(type) > -1) return rulesByType[type] += rule;
                            return rulesByType[DEFAULT_COLOR_TYPE] += rule;
                        })), themeConfig.generateOnDemand || angular.forEach($mdTheming.THEMES, (function(theme) {
                            GENERATED[theme.name] || "default" !== $mdTheming.defaultTheme() && "default" === theme.name || generateTheme(theme, theme.name, themeConfig.nonce);
                        }));
                    }
                }
                function generateTheme(theme, name, nonce) {
                    var head = document.head, firstChild = head ? head.firstElementChild : null;
                    GENERATED[name] || (THEME_COLOR_TYPES.forEach((function(colorType) {
                        for (var styleStrings = parseRules(theme, colorType, rulesByType[colorType]); styleStrings.length; ) {
                            var styleContent = styleStrings.shift();
                            if (styleContent) {
                                var style = document.createElement("style");
                                style.setAttribute("md-theme-style", ""), nonce && style.setAttribute("nonce", nonce), 
                                style.appendChild(document.createTextNode(styleContent)), head.insertBefore(style, firstChild);
                            }
                        }
                    })), GENERATED[theme.name] = !0);
                }
                function colorToRgbaArray(clr) {
                    if (angular.isArray(clr) && 3 === clr.length) return clr;
                    if (/^rgb/.test(clr)) return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map((function(value, i) {
                        return 3 === i ? parseFloat(value) : parseInt(value, 10);
                    }));
                    if ("#" === clr.charAt(0) && (clr = clr.substring(1)), /^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) {
                        var dig = clr.length / 3, red = clr.substr(0, dig), grn = clr.substr(dig, dig), blu = clr.substr(2 * dig);
                        return 1 === dig && (red += red, grn += grn, blu += blu), [ parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16) ];
                    }
                }
                function rgba(rgbArray, opacity) {
                    return rgbArray ? (4 === rgbArray.length && (rgbArray = angular.copy(rgbArray), 
                    opacity ? rgbArray.pop() : opacity = rgbArray.pop()), opacity && ("number" == typeof opacity || "string" == typeof opacity && opacity.length) ? "rgba(" + rgbArray.join(",") + "," + opacity + ")" : "rgb(" + rgbArray.join(",") + ")") : "rgb('0,0,0')";
                }
            }(window.angular), angular.module("material.components.autocomplete", [ "material.core", "material.components.icon", "material.components.virtualRepeat" ]), 
            function() {
                MdAutocompleteCtrl.$inject = [ "$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q", "$log", "$mdLiveAnnouncer" ], 
                angular.module("material.components.autocomplete").controller("MdAutocompleteCtrl", MdAutocompleteCtrl);
                var ITEM_HEIGHT = 48, MAX_ITEMS = 5, MENU_PADDING = 8, INPUT_PADDING = 2, MODE_STANDARD = "standard", MODE_VIRTUAL = "virtual";
                function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q, $log, $mdLiveAnnouncer) {
                    var key, handler, defaultValue, ctrl = this, itemParts = $scope.itemsExpr.split(/ in /i), itemExpr = itemParts[1], elements = null, cache = {}, noBlur = !1, selectedItemWatchers = [], hasFocus = !1, fetchesInProgress = 0, enableWrapScroll = null, inputModelCtrl = null, debouncedOnResize = $mdUtil.debounce((function() {
                        ctrl.hidden || positionDropdown();
                    })), mode = MODE_VIRTUAL;
                    ctrl.documentElement = angular.element(document.documentElement), key = "hidden", 
                    handler = function(hidden, oldHidden) {
                        var scrollContainerElement, element, elementToDisable;
                        elements && (scrollContainerElement = angular.element(elements.scrollContainer)), 
                        !hidden && oldHidden ? (positionDropdown(), reportMessages(!0, ReportType.Count | ReportType.Selected), 
                        elements && ($mdUtil.disableScrollAround(elements.scrollContainer), element = elements.wrap, 
                        (elementToDisable = angular.element(element)).on("wheel touchmove", preventDefault), 
                        enableWrapScroll = function() {
                            elementToDisable.off("wheel touchmove", preventDefault);
                        }, $mdUtil.isIos && (ctrl.documentElement.on("touchend", handleTouchOutsidePanel), 
                        scrollContainerElement && scrollContainerElement.on("touchstart touchmove touchend", stopPropagation)), 
                        ctrl.index = getDefaultIndex(), $mdUtil.nextTick((function() {
                            updateActiveOption(), updateScroll();
                        })))) : hidden && !oldHidden && ($mdUtil.isIos && (ctrl.documentElement.off("touchend", handleTouchOutsidePanel), 
                        scrollContainerElement && scrollContainerElement.off("touchstart touchmove touchend", stopPropagation)), 
                        $mdUtil.enableScrolling(), enableWrapScroll && (enableWrapScroll(), enableWrapScroll = null));
                    }, defaultValue = !0, Object.defineProperty(ctrl, key, {
                        get: function() {
                            return defaultValue;
                        },
                        set: function(newValue) {
                            var oldValue = defaultValue;
                            defaultValue = newValue, handler(newValue, oldValue);
                        }
                    }), ctrl.scope = $scope, ctrl.parent = $scope.$parent, ctrl.itemName = itemParts[0], 
                    ctrl.matches = [], ctrl.loading = !1, ctrl.hidden = !0, ctrl.index = -1, ctrl.activeOption = null, 
                    ctrl.id = $mdUtil.nextUid(), ctrl.isDisabled = null, ctrl.isRequired = null, ctrl.isReadonly = null, 
                    ctrl.hasNotFound = !1, ctrl.selectedMessage = $scope.selectedMessage || "selected", 
                    ctrl.noMatchMessage = $scope.noMatchMessage || "There are no matches available.", 
                    ctrl.singleMatchMessage = $scope.singleMatchMessage || "There is 1 match available.", 
                    ctrl.multipleMatchStartMessage = $scope.multipleMatchStartMessage || "There are ", 
                    ctrl.multipleMatchEndMessage = $scope.multipleMatchEndMessage || " matches available.", 
                    ctrl.defaultEscapeOptions = "clear", ctrl.keydown = function(event) {
                        switch (event.keyCode) {
                          case $mdConstant.KEY_CODE.DOWN_ARROW:
                            if (ctrl.loading || hasSelection()) return;
                            event.stopPropagation(), event.preventDefault(), ctrl.index = ctrl.index + 1 > ctrl.matches.length - 1 ? 0 : Math.min(ctrl.index + 1, ctrl.matches.length - 1), 
                            $mdUtil.nextTick(updateActiveOption), updateScroll();
                            break;

                          case $mdConstant.KEY_CODE.UP_ARROW:
                            if (ctrl.loading || hasSelection()) return;
                            event.stopPropagation(), event.preventDefault(), ctrl.index = ctrl.index - 1 < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1), 
                            $mdUtil.nextTick(updateActiveOption), updateScroll();
                            break;

                          case $mdConstant.KEY_CODE.TAB:
                            if (onListLeave(), ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
                            select(ctrl.index);
                            break;

                          case $mdConstant.KEY_CODE.ENTER:
                            if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
                            if (hasSelection()) return;
                            event.stopImmediatePropagation(), event.preventDefault(), select(ctrl.index);
                            break;

                          case $mdConstant.KEY_CODE.ESCAPE:
                            if (event.preventDefault(), !(hasEscapeOption("blur") || !ctrl.hidden || ctrl.loading || hasEscapeOption("clear") && $scope.searchText)) return;
                            event.stopPropagation(), clearSelectedItem(), $scope.searchText && hasEscapeOption("clear") && clearSearchText(), 
                            ctrl.hidden = !0, hasEscapeOption("blur") && doBlur(!0);
                        }
                    }, ctrl.blur = function($event) {
                        hasFocus = !1, noBlur ? angular.isObject($event) && $event.stopImmediatePropagation() : (ctrl.hidden = shouldHide(), 
                        evalAttr("ngBlur", {
                            $event
                        }));
                    }, ctrl.focus = function($event) {
                        hasFocus = !0, isSearchable() && isMinLengthMet() && handleQuery();
                        ctrl.hidden = shouldHide(), evalAttr("ngFocus", {
                            $event
                        });
                    }, ctrl.clear = function($event) {
                        $event && $event.stopPropagation();
                        clearSelectedItem(), clearSearchText();
                    }, ctrl.select = select, ctrl.listEnter = function() {
                        noBlur = !0;
                    }, ctrl.listLeave = onListLeave, ctrl.focusInput = focusInputElement, ctrl.getCurrentDisplayValue = getCurrentDisplayValue, 
                    ctrl.registerSelectedItemWatcher = function(cb) {
                        -1 === selectedItemWatchers.indexOf(cb) && selectedItemWatchers.push(cb);
                    }, ctrl.unregisterSelectedItemWatcher = function(cb) {
                        var i = selectedItemWatchers.indexOf(cb);
                        -1 !== i && selectedItemWatchers.splice(i, 1);
                    }, ctrl.notFoundVisible = notFoundVisible, ctrl.loadingIsVisible = function() {
                        return ctrl.loading && !hasSelection();
                    }, ctrl.positionDropdown = positionDropdown;
                    var wait, ReportType = {
                        Count: 1,
                        Selected: 2
                    };
                    return $mdUtil.initOptionalProperties($scope, $attrs, {
                        searchText: "",
                        selectedItem: null,
                        clearButton: !1,
                        disableVirtualRepeat: !1
                    }), $mdTheming($element), wait = parseInt($scope.delay, 10) || 0, $attrs.$observe("disabled", (function(value) {
                        ctrl.isDisabled = $mdUtil.parseAttributeBoolean(value, !1);
                    })), $attrs.$observe("required", (function(value) {
                        ctrl.isRequired = $mdUtil.parseAttributeBoolean(value, !1);
                    })), $attrs.$observe("readonly", (function(value) {
                        ctrl.isReadonly = $mdUtil.parseAttributeBoolean(value, !1);
                    })), $scope.$watch("searchText", wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText), 
                    $scope.$watch("selectedItem", selectedItemChange), angular.element($window).on("resize", debouncedOnResize), 
                    $scope.$on("$destroy", cleanup), void $mdUtil.nextTick((function() {
                        var snapWrap;
                        snapWrap = function() {
                            var element, value;
                            for (element = $element; element.length && (value = element.attr("md-autocomplete-snap"), 
                            !angular.isDefined(value)); element = element.parent()) ;
                            if (element.length) return {
                                snap: element[0],
                                wrap: "width" === value.toLowerCase() ? element[0] : $element.find("md-autocomplete-wrap")[0]
                            };
                            var wrap = $element.find("md-autocomplete-wrap")[0];
                            return {
                                snap: wrap,
                                wrap
                            };
                        }(), (elements = {
                            main: $element[0],
                            scrollContainer: $element[0].querySelector(".md-virtual-repeat-container, .md-standard-list-container"),
                            scroller: $element[0].querySelector(".md-virtual-repeat-scroller, .md-standard-list-scroller"),
                            ul: $element.find("ul")[0],
                            input: $element.find("input")[0],
                            wrap: snapWrap.wrap,
                            snap: snapWrap.snap,
                            root: document.body
                        }).li = elements.ul.getElementsByTagName("li"), elements.$ = function(elements) {
                            var obj = {};
                            for (var key in elements) elements.hasOwnProperty(key) && (obj[key] = angular.element(elements[key]));
                            return obj;
                        }(elements), mode = elements.scrollContainer.classList.contains("md-standard-list-container") ? MODE_STANDARD : MODE_VIRTUAL, 
                        inputModelCtrl = elements.$.input.controller("ngModel"), elements.$.root.length && ($mdTheming(elements.$.scrollContainer), 
                        elements.$.scrollContainer.detach(), elements.$.root.append(elements.$.scrollContainer), 
                        $animate.pin && $animate.pin(elements.$.scrollContainer, $rootElement)), $element.on("touchstart", focusInputElement), 
                        $scope.autofocus && $element.on("focus", focusInputElement), $scope.inputAriaDescribedBy && elements.input.setAttribute("aria-describedby", $scope.inputAriaDescribedBy), 
                        $scope.floatingLabel || ($scope.inputAriaLabel ? elements.input.setAttribute("aria-label", $scope.inputAriaLabel) : $scope.inputAriaLabelledBy ? elements.input.setAttribute("aria-labelledby", $scope.inputAriaLabelledBy) : $scope.placeholder && elements.input.setAttribute("aria-label", $scope.placeholder));
                    }));
                    function updateModelValidators() {
                        $scope.requireMatch && inputModelCtrl && inputModelCtrl.$setValidity("md-require-match", !!$scope.selectedItem || !$scope.searchText);
                    }
                    function positionDropdown() {
                        if (!elements) return $mdUtil.nextTick(positionDropdown, !1, $scope);
                        var styles, dropdownHeight = ($scope.dropdownItems || MAX_ITEMS) * ITEM_HEIGHT, hrect = elements.wrap.getBoundingClientRect(), vrect = elements.snap.getBoundingClientRect(), root = elements.root.getBoundingClientRect(), top = vrect.bottom - root.top, bot = root.bottom - vrect.top, left = hrect.left - root.left, width = hrect.width, offset = function() {
                            var offset = 0, inputContainer = $element.find("md-input-container");
                            if (inputContainer.length) {
                                var input = inputContainer.find("input");
                                offset = inputContainer.prop("offsetHeight"), offset -= input.prop("offsetTop"), 
                                offset -= input.prop("offsetHeight"), offset += inputContainer.prop("offsetTop");
                            }
                            return offset;
                        }(), position = $scope.dropdownPosition, bottomSpace = root.bottom - vrect.bottom - MENU_PADDING + $mdUtil.getViewportTop(), topSpace = vrect.top - MENU_PADDING;
                        position || (position = bottomSpace > dropdownHeight ? "bottom" : topSpace > dropdownHeight || topSpace > bottomSpace ? "top" : "bottom"), 
                        $attrs.mdFloatingLabel && (left += INPUT_PADDING, width -= 2 * INPUT_PADDING), styles = {
                            left: left + "px",
                            minWidth: width + "px",
                            maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + "px"
                        }, "top" === position ? (styles.top = "auto", styles.bottom = bot + "px", styles.maxHeight = Math.min(dropdownHeight, topSpace) + "px") : (bottomSpace = root.bottom - hrect.bottom - MENU_PADDING + $mdUtil.getViewportTop(), 
                        styles.top = top - offset + "px", styles.bottom = "auto", styles.maxHeight = Math.min(dropdownHeight, bottomSpace) + "px"), 
                        elements.$.scrollContainer.css(styles), $mdUtil.nextTick((function() {
                            var dropdown = elements.scrollContainer.getBoundingClientRect(), styles = {};
                            dropdown.right > root.right && (styles.left = hrect.right - dropdown.width + "px");
                            elements.$.scrollContainer.css(styles);
                        }), !1, $scope);
                    }
                    function focusInputElement() {
                        elements.input.focus();
                    }
                    function updateActiveOption() {
                        var selectedOption = elements.scroller.querySelector(".selected");
                        ctrl.activeOption = selectedOption ? selectedOption.id : null;
                    }
                    function cleanup() {
                        if (ctrl.hidden || $mdUtil.enableScrolling(), angular.element($window).off("resize", debouncedOnResize), 
                        elements) {
                            angular.forEach([ "ul", "scroller", "scrollContainer", "input" ], (function(key) {
                                elements.$[key].remove();
                            }));
                        }
                    }
                    function preventDefault($event) {
                        $event.preventDefault();
                    }
                    function stopPropagation($event) {
                        $event.stopPropagation();
                    }
                    function handleTouchOutsidePanel($event) {
                        ctrl.hidden = !0, doBlur(!0);
                    }
                    function onListLeave() {
                        hasFocus || ctrl.hidden || elements.input.focus(), noBlur = !1, ctrl.hidden = shouldHide();
                    }
                    function selectedItemChange(selectedItem, previousSelectedItem) {
                        updateModelValidators(), selectedItem ? getDisplayValue(selectedItem).then((function(val) {
                            $scope.searchText = val, function(selectedItem, previousSelectedItem) {
                                selectedItemWatchers.forEach((function(watcher) {
                                    watcher(selectedItem, previousSelectedItem);
                                }));
                            }(selectedItem, previousSelectedItem);
                        })) : previousSelectedItem && $scope.searchText && getDisplayValue(previousSelectedItem).then((function(displayValue) {
                            angular.isString($scope.searchText) && displayValue.toString().toLowerCase() === $scope.searchText.toLowerCase() && ($scope.searchText = "");
                        })), selectedItem !== previousSelectedItem && angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));
                    }
                    function handleSearchText(searchText, previousSearchText) {
                        ctrl.index = getDefaultIndex(), searchText !== previousSearchText && (updateModelValidators(), 
                        getDisplayValue($scope.selectedItem).then((function(val) {
                            searchText !== val && ($scope.selectedItem = null, searchText !== previousSearchText && angular.isFunction($scope.textChange) && $scope.textChange(), 
                            isMinLengthMet() ? handleQuery() : (ctrl.matches = [], setLoading(!1), reportMessages(!0, ReportType.Count)));
                        })));
                    }
                    function doBlur(forceBlur) {
                        forceBlur && (noBlur = !1, hasFocus = !1), elements.input.blur();
                    }
                    function getMinLength() {
                        return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
                    }
                    function getDisplayValue(item) {
                        return $q.when(function(item) {
                            return item && $scope.itemText ? $scope.itemText(getItemAsNameVal(item)) : null;
                        }(item) || item).then((function(itemText) {
                            return itemText && !angular.isString(itemText) && $log.warn("md-autocomplete: Could not resolve display value to a string. Please check the `md-item-text` attribute."), 
                            itemText;
                        }));
                    }
                    function getItemAsNameVal(item) {
                        if (item) {
                            var locals = {};
                            return ctrl.itemName && (locals[ctrl.itemName] = item), locals;
                        }
                    }
                    function getDefaultIndex() {
                        return $scope.autoselect ? 0 : -1;
                    }
                    function setLoading(value) {
                        ctrl.loading !== value && (ctrl.loading = value), ctrl.hidden = shouldHide();
                    }
                    function shouldHide() {
                        return !function() {
                            if (ctrl.isReadonly) return !1;
                            if (!isSearchable()) return !1;
                            return isMinLengthMet() && hasMatches() || notFoundVisible();
                        }();
                    }
                    function isSearchable() {
                        return !(ctrl.loading && !hasMatches()) && (!hasSelection() && !!hasFocus);
                    }
                    function hasEscapeOption(option) {
                        return angular.isString($scope.escapeOptions) ? -1 !== $scope.escapeOptions.toLowerCase().indexOf(option) : -1 !== ctrl.defaultEscapeOptions.indexOf(option);
                    }
                    function hasMatches() {
                        return !!ctrl.matches.length;
                    }
                    function hasSelection() {
                        return !!ctrl.scope.selectedItem;
                    }
                    function getCurrentDisplayValue() {
                        return getDisplayValue(ctrl.matches[ctrl.index]);
                    }
                    function isMinLengthMet() {
                        return ($scope.searchText || "").length >= getMinLength();
                    }
                    function select(index) {
                        $mdUtil.nextTick((function() {
                            getDisplayValue(ctrl.matches[index]).then((function(val) {
                                var ngModel = elements.$.input.controller("ngModel");
                                $mdLiveAnnouncer.announce(val + " " + ctrl.selectedMessage, "assertive"), ngModel.$setViewValue(val), 
                                ngModel.$render();
                            })).finally((function() {
                                $scope.selectedItem = ctrl.matches[index], setLoading(!1);
                            }));
                        }), !1);
                    }
                    function clearSelectedItem() {
                        ctrl.index = -1, $mdUtil.nextTick(updateActiveOption), ctrl.matches = [];
                    }
                    function clearSearchText() {
                        setLoading(!0), $scope.searchText = "";
                        var eventObj = document.createEvent("CustomEvent");
                        eventObj.initCustomEvent("change", !0, !0, {
                            value: ""
                        }), elements.input.dispatchEvent(eventObj), elements.input.blur(), $scope.searchText = "", 
                        elements.input.focus();
                    }
                    function reportMessages(isPolite, types) {
                        var politeness = isPolite ? "polite" : "assertive", messages = [];
                        types & ReportType.Selected && -1 !== ctrl.index && messages.push(getCurrentDisplayValue()), 
                        types & ReportType.Count && messages.push($q.resolve(function() {
                            switch (ctrl.matches.length) {
                              case 0:
                                return ctrl.noMatchMessage;

                              case 1:
                                return ctrl.singleMatchMessage;

                              default:
                                return ctrl.multipleMatchStartMessage + ctrl.matches.length + ctrl.multipleMatchEndMessage;
                            }
                        }())), $q.all(messages).then((function(data) {
                            $mdLiveAnnouncer.announce(data.join(" "), politeness);
                        }));
                    }
                    function updateScroll() {
                        var selected, containerHeight, top, bottom, scrollTop;
                        elements.li[0] && (mode === MODE_STANDARD ? (selected = elements.li[Math.max(0, ctrl.index)], 
                        containerHeight = elements.scrollContainer.offsetHeight, top = selected && selected.offsetTop || 0, 
                        bottom = top + selected.clientHeight, scrollTop = elements.scrollContainer.scrollTop, 
                        top < scrollTop ? scrollTo(top) : bottom > scrollTop + containerHeight && scrollTo(bottom - containerHeight)) : function() {
                            var optionHeight = elements.li[0].offsetHeight, top = optionHeight * Math.max(0, ctrl.index), bottom = top + optionHeight, containerHeight = elements.scroller.clientHeight, scrollTop = elements.scroller.scrollTop;
                            top < scrollTop ? scrollTo(top) : bottom > scrollTop + containerHeight && scrollTo(bottom - containerHeight);
                        }());
                    }
                    function scrollTo(offset) {
                        mode === MODE_STANDARD ? elements.scrollContainer.scrollTop = offset : elements.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(offset);
                    }
                    function notFoundVisible() {
                        var textLength = (ctrl.scope.searchText || "").length;
                        return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || 0 !== fetchesInProgress) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection();
                    }
                    function handleQuery() {
                        var searchText = $scope.searchText || "", term = searchText.toLowerCase();
                        !$scope.noCache && cache[term] ? handleResults(cache[term]) : function(searchText) {
                            var items = $scope.$parent.$eval(itemExpr), term = searchText.toLowerCase(), isList = angular.isArray(items), isPromise = !!items.then;
                            function onResultsRetrieved(matches) {
                                cache[term] = matches, (searchText || "") === ($scope.searchText || "") && handleResults(matches);
                            }
                            isList ? onResultsRetrieved(items) : isPromise && function(items) {
                                items && (items = $q.when(items), fetchesInProgress++, setLoading(!0), $mdUtil.nextTick((function() {
                                    items.then(onResultsRetrieved).finally((function() {
                                        0 == --fetchesInProgress && setLoading(!1);
                                    }));
                                }), !0, $scope));
                            }(items);
                        }(searchText), ctrl.hidden = shouldHide();
                    }
                    function handleResults(results) {
                        var searchText, matches, item;
                        ctrl.matches = results, ctrl.hidden = shouldHide(), ctrl.loading && setLoading(!1), 
                        $scope.selectOnMatch && (searchText = $scope.searchText, matches = ctrl.matches, 
                        item = matches[0], 1 === matches.length && getDisplayValue(item).then((function(displayValue) {
                            var isMatching = searchText === displayValue;
                            $scope.matchInsensitive && !isMatching && (isMatching = searchText.toLowerCase() === displayValue.toLowerCase()), 
                            isMatching && select(0);
                        }))), positionDropdown(), reportMessages(!0, ReportType.Count);
                    }
                    function evalAttr(attr, locals) {
                        $attrs[attr] && $scope.$parent.$eval($attrs[attr], locals || {});
                    }
                }
            }(), function() {
                function MdAutocomplete($$mdSvgRegistry) {
                    var REPEAT_MODES = [ "standard", "virtual" ];
                    function getRepeatMode(modeStr) {
                        return modeStr ? (modeStr = modeStr.toLowerCase(), REPEAT_MODES.indexOf(modeStr) > -1 ? modeStr : "virtual") : "virtual";
                    }
                    return {
                        controller: "MdAutocompleteCtrl",
                        controllerAs: "$mdAutocompleteCtrl",
                        scope: {
                            inputName: "@mdInputName",
                            inputMinlength: "@mdInputMinlength",
                            inputMaxlength: "@mdInputMaxlength",
                            searchText: "=?mdSearchText",
                            selectedItem: "=?mdSelectedItem",
                            itemsExpr: "@mdItems",
                            itemText: "&mdItemText",
                            placeholder: "@placeholder",
                            inputAriaDescribedBy: "@?inputAriaDescribedby",
                            inputAriaLabelledBy: "@?inputAriaLabelledby",
                            inputAriaLabel: "@?inputAriaLabel",
                            noCache: "=?mdNoCache",
                            requireMatch: "=?mdRequireMatch",
                            selectOnMatch: "=?mdSelectOnMatch",
                            matchInsensitive: "=?mdMatchCaseInsensitive",
                            itemChange: "&?mdSelectedItemChange",
                            textChange: "&?mdSearchTextChange",
                            minLength: "=?mdMinLength",
                            delay: "=?mdDelay",
                            autofocus: "=?mdAutofocus",
                            floatingLabel: "@?mdFloatingLabel",
                            autoselect: "=?mdAutoselect",
                            menuClass: "@?mdMenuClass",
                            menuContainerClass: "@?mdMenuContainerClass",
                            inputClass: "@?mdInputClass",
                            inputId: "@?mdInputId",
                            escapeOptions: "@?mdEscapeOptions",
                            dropdownItems: "=?mdDropdownItems",
                            dropdownPosition: "@?mdDropdownPosition",
                            clearButton: "=?mdClearButton",
                            selectedMessage: "@?mdSelectedMessage",
                            noMatchMessage: "@?mdNoMatchMessage",
                            singleMatchMessage: "@?mdSingleMatchMessage",
                            multipleMatchStartMessage: "@?mdMultipleMatchStartMessage",
                            multipleMatchEndMessage: "@?mdMultipleMatchEndMessage",
                            mdMode: "=?mdMode"
                        },
                        compile: function(tElement, tAttrs) {
                            var input = tElement.find("input");
                            return [ "md-select-on-focus", "md-no-asterisk", "ng-trim", "ng-pattern" ].forEach((function(attribute) {
                                var attrValue = tAttrs[tAttrs.$normalize(attribute)];
                                null !== attrValue && input.attr(attribute, attrValue);
                            })), function(scope, element, attrs, ctrl) {
                                ctrl.hasNotFound = !!element.attr("md-has-not-found"), angular.isDefined(attrs.mdClearButton) || scope.floatingLabel || (scope.clearButton = !0), 
                                scope.mdMode = getRepeatMode(attrs.mdMode), element.on("click touchstart touchend", (function(event) {
                                    event.stopPropagation();
                                }));
                            };
                        },
                        template: function(element, attr) {
                            var templateTag, template, noItemsTemplate = (templateTag = element.find("md-not-found").detach(), 
                            (template = templateTag.length ? templateTag.html() : "") ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()" class="md-autocomplete-suggestion"                         md-autocomplete-parent-scope>' + template + "</li>" : ""), itemTemplate = function() {
                                var templateTag = element.find("md-item-template").detach(), html = templateTag.length ? templateTag.html() : element.html();
                                templateTag.length || element.empty();
                                return "<md-autocomplete-parent-scope md-autocomplete-replace>" + html + "</md-autocomplete-parent-scope>";
                            }(), leftover = element.html(), tabindex = attr.tabindex;
                            return noItemsTemplate && element.attr("md-has-not-found", !0), element.attr("tabindex", "-1"), 
                            "        <md-autocomplete-wrap            ng-class=\"{ 'md-whiteframe-z1': !floatingLabel,                         'md-menu-showing': !$mdAutocompleteCtrl.hidden,                         'md-show-clear-button': !!clearButton }\">          " + (attr.mdFloatingLabel ? '            <md-input-container ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="text"                ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '                id="{{inputId || \'fl-input-\' + $mdAutocompleteCtrl.id}}"                name="{{inputName || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                ng-class="::inputClass"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-readonly="$mdAutocompleteCtrl.isReadonly"                ng-minlength="inputMinlength"                ng-maxlength="inputMaxlength"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-model-options="{ allowInvalid: true }"                ng-mousedown="$mdAutocompleteCtrl.focusInput()"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur($event)"                ng-focus="$mdAutocompleteCtrl.focus($event)"                aria-label="{{floatingLabel}}"                ng-attr-aria-autocomplete="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'list\'}}"                ng-attr-role="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'combobox\'}}"                aria-haspopup="{{!$mdAutocompleteCtrl.isDisabled}}"                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"                ng-attr-aria-owns="{{$mdAutocompleteCtrl.hidden || $mdAutocompleteCtrl.isDisabled ? undefined : \'ul-\' + $mdAutocompleteCtrl.id}}"                ng-attr-aria-activedescendant="{{!$mdAutocompleteCtrl.hidden && $mdAutocompleteCtrl.activeOption ? $mdAutocompleteCtrl.activeOption : undefined}}">              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + "</div>            </md-input-container>" : '            <input type="text"              ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '              id="{{inputId || \'input-\' + $mdAutocompleteCtrl.id}}"              name="{{inputName || \'input-\' + $mdAutocompleteCtrl.id }}"              ng-class="::inputClass"              ng-if="!floatingLabel"              autocomplete="off"              ng-required="$mdAutocompleteCtrl.isRequired"              ng-disabled="$mdAutocompleteCtrl.isDisabled"              ng-readonly="$mdAutocompleteCtrl.isReadonly"              ng-minlength="inputMinlength"              ng-maxlength="inputMaxlength"              ng-model="$mdAutocompleteCtrl.scope.searchText"              ng-mousedown="$mdAutocompleteCtrl.focusInput()"              ng-keydown="$mdAutocompleteCtrl.keydown($event)"              ng-blur="$mdAutocompleteCtrl.blur($event)"              ng-focus="$mdAutocompleteCtrl.focus($event)"              placeholder="{{placeholder}}"              aria-label="{{placeholder}}"              ng-attr-aria-autocomplete="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'list\'}}"              ng-attr-role="{{$mdAutocompleteCtrl.isDisabled ? undefined : \'combobox\'}}"              aria-haspopup="{{!$mdAutocompleteCtrl.isDisabled}}"              aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"              ng-attr-aria-owns="{{$mdAutocompleteCtrl.hidden || $mdAutocompleteCtrl.isDisabled ? undefined : \'ul-\' + $mdAutocompleteCtrl.id}}"              ng-attr-aria-activedescendant="{{!$mdAutocompleteCtrl.hidden && $mdAutocompleteCtrl.activeOption ? $mdAutocompleteCtrl.activeOption : undefined}}">') + '          <button type="button" aria-label="Clear Input" tabindex="0" ng-if="clearButton && $mdAutocompleteCtrl.scope.searchText" ng-click="$mdAutocompleteCtrl.clear($event)"><md-icon md-svg-src="' + $$mdSvgRegistry.mdClose + '"></md-icon></button>          <md-progress-linear              class="' + (attr.mdFloatingLabel ? "md-inline" : "") + '"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          ' + function(menuContainerClass, repeatMode) {
                                if (menuContainerClass = menuContainerClass ? " " + menuContainerClass : "", isVirtualRepeatDisabled(repeatMode)) return '            <div                 ng-hide="$mdAutocompleteCtrl.hidden"                class="md-standard-list-container md-autocomplete-suggestions-container md-whiteframe-z1' + menuContainerClass + '"                ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"                ng-mouseenter="$mdAutocompleteCtrl.listEnter()"                ng-mouseleave="$mdAutocompleteCtrl.listLeave()"                role="presentation">              <div class="md-standard-list-scroller" role="presentation">';
                                return '          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-virtual-repeat-container md-autocomplete-suggestions-container md-whiteframe-z1' + menuContainerClass + '"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              role="presentation">';
                            }(attr.mdMenuContainerClass, attr.mdMode) + '            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}"                ng-mouseup="$mdAutocompleteCtrl.focusInput()"                role="listbox">              <li class="md-autocomplete-suggestion" ' + ((isVirtualRepeatDisabled(attr.mdMode) ? "ng-repeat" : "md-virtual-repeat") + ' ="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-attr-id="{{\'md-option-\' + $mdAutocompleteCtrl.id + \'-\' + $index}}"                  ng-click="$mdAutocompleteCtrl.select($index)"                  role="option"                  aria-setsize="{{$mdAutocompleteCtrl.matches.length}}"                  aria-posinset="{{$index+1}}"                  aria-selected="{{$index === $mdAutocompleteCtrl.index ? true : false}}"                   md-extra-name="$mdAutocompleteCtrl.itemName">                  ') + itemTemplate + "                  </li>" + noItemsTemplate + "            </ul>          " + function(repeatMode) {
                                return isVirtualRepeatDisabled(repeatMode) ? "   </div>              </div>            </div>" : "</md-virtual-repeat-container>";
                            }(attr.mdMode) + "        </md-autocomplete-wrap>";
                            function isVirtualRepeatDisabled(repeatMode) {
                                return "virtual" !== getRepeatMode(repeatMode);
                            }
                        }
                    };
                }
                MdAutocomplete.$inject = [ "$$mdSvgRegistry" ], angular.module("material.components.autocomplete").directive("mdAutocomplete", MdAutocomplete);
            }(), function() {
                function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
                    return {
                        restrict: "AE",
                        compile: function(tElement, tAttr, transclude) {
                            return function(scope, element, attr) {
                                var scopeDigesting, newScopeDigesting, ctrl = scope.$mdAutocompleteCtrl, newScope = ctrl.parent.$new(), itemName = ctrl.itemName;
                                function watchVariable(variable, alias) {
                                    newScope[alias] = scope[variable], scope.$watch(variable, (function(value) {
                                        $mdUtil.nextTick((function() {
                                            newScope[alias] = value;
                                        }));
                                    }));
                                }
                                watchVariable("$index", "$index"), watchVariable("item", itemName), scopeDigesting = !1, 
                                newScopeDigesting = !1, scope.$watch((function() {
                                    newScopeDigesting || scopeDigesting || (scopeDigesting = !0, scope.$$postDigest((function() {
                                        newScopeDigesting || newScope.$digest(), scopeDigesting = newScopeDigesting = !1;
                                    })));
                                })), newScope.$watch((function() {
                                    newScopeDigesting = !0;
                                })), transclude(newScope, (function(clone) {
                                    element.after(clone);
                                }));
                            };
                        },
                        terminal: !0,
                        transclude: "element"
                    };
                }
                MdAutocompleteItemScopeDirective.$inject = [ "$compile", "$mdUtil" ], angular.module("material.components.autocomplete").directive("mdAutocompleteParentScope", MdAutocompleteItemScopeDirective);
            }(), function() {
                function MdHighlightCtrl($scope, $element, $attrs, $mdUtil) {
                    this.$scope = $scope, this.$element = $element, this.$attrs = $attrs, this.$mdUtil = $mdUtil, 
                    this.regex = null;
                }
                MdHighlightCtrl.$inject = [ "$scope", "$element", "$attrs", "$mdUtil" ], angular.module("material.components.autocomplete").controller("MdHighlightCtrl", MdHighlightCtrl), 
                MdHighlightCtrl.prototype.init = function(unsafeTermFn, unsafeContentFn) {
                    this.flags = this.$attrs.mdHighlightFlags || "", this.unregisterFn = this.$scope.$watch(function($scope) {
                        return {
                            term: unsafeTermFn($scope),
                            contentText: unsafeContentFn($scope)
                        };
                    }.bind(this), this.onRender.bind(this), !0), this.$element.on("$destroy", this.unregisterFn);
                }, MdHighlightCtrl.prototype.onRender = function(state, prevState) {
                    var contentText = state.contentText;
                    null !== this.regex && state.term === prevState.term || (this.regex = this.createRegex(state.term, this.flags)), 
                    state.term ? this.applyRegex(contentText) : this.$element.text(contentText);
                }, MdHighlightCtrl.prototype.applyRegex = function(text) {
                    var tokens = this.resolveTokens(text);
                    this.$element.empty(), tokens.forEach(function(token) {
                        if (token.isMatch) {
                            var tokenEl = angular.element('<span class="highlight">').text(token.text);
                            this.$element.append(tokenEl);
                        } else this.$element.append(document.createTextNode(token));
                    }.bind(this));
                }, MdHighlightCtrl.prototype.resolveTokens = function(string) {
                    var tokens = [], lastIndex = 0;
                    return string.replace(this.regex, (function(match, index) {
                        appendToken(lastIndex, index), tokens.push({
                            text: match,
                            isMatch: !0
                        }), lastIndex = index + match.length;
                    })), appendToken(lastIndex), tokens;
                    function appendToken(from, to) {
                        var targetText = string.slice(from, to);
                        targetText && tokens.push(targetText);
                    }
                }, MdHighlightCtrl.prototype.createRegex = function(term, flags) {
                    var startFlag = "", endFlag = "", regexTerm = this.$mdUtil.sanitize(term);
                    return flags.indexOf("^") >= 0 && (startFlag = "^"), flags.indexOf("$") >= 0 && (endFlag = "$"), 
                    new RegExp(startFlag + regexTerm + endFlag, flags.replace(/[$^]/g, ""));
                };
            }(), function() {
                function MdHighlight($interpolate, $parse) {
                    return {
                        terminal: !0,
                        controller: "MdHighlightCtrl",
                        compile: function(tElement, tAttr) {
                            var termExpr = $parse(tAttr.mdHighlightText), unsafeContentExpr = $interpolate(tElement.html());
                            return function(scope, element, attr, ctrl) {
                                ctrl.init(termExpr, unsafeContentExpr);
                            };
                        }
                    };
                }
                MdHighlight.$inject = [ "$interpolate", "$parse" ], angular.module("material.components.autocomplete").directive("mdHighlightText", MdHighlight);
            }(), angular.module("material.components.backdrop", [ "material.core" ]).directive("mdBackdrop", [ "$mdTheming", "$mdUtil", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function($mdTheming, $mdUtil, $animate, $rootElement, $window, $log, $$rAF, $document) {
                return {
                    restrict: "E",
                    link: function(scope, element, attrs) {
                        var bodyStyles;
                        function resize() {
                            var viewportHeight = parseInt(bodyStyles.height, 10) + Math.abs(parseInt(bodyStyles.top, 10));
                            element.css("height", viewportHeight + "px");
                        }
                        $animate.pin && $animate.pin(element, $rootElement), $$rAF((function() {
                            if ("fixed" === (bodyStyles = $window.getComputedStyle($document[0].body)).position) {
                                var resizeHandler = $mdUtil.debounce((function() {
                                    bodyStyles = $window.getComputedStyle($document[0].body), resize();
                                }), 60, null, !1);
                                resize(), angular.element($window).on("resize", resizeHandler), scope.$on("$destroy", (function() {
                                    angular.element($window).off("resize", resizeHandler);
                                }));
                            }
                            var parent = element.parent();
                            parent.length && ("BODY" === parent[0].nodeName && element.css("position", "fixed"), 
                            "static" === $window.getComputedStyle(parent[0]).position && $log.warn("<md-backdrop> may not work properly in a scrolled, static-positioned parent container."), 
                            $mdTheming.inherit(element, parent));
                        }));
                    }
                };
            } ]), function() {
                function MdBottomSheetDirective($mdBottomSheet) {
                    return {
                        restrict: "E",
                        link: function(scope, element) {
                            element.addClass("_md"), scope.$on("$destroy", (function() {
                                $mdBottomSheet.destroy();
                            }));
                        }
                    };
                }
                function MdBottomSheetProvider($$interimElementProvider) {
                    bottomSheetDefaults.$inject = [ "$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture", "$log" ];
                    var CLOSING_VELOCITY = .5, PADDING = 80;
                    return $$interimElementProvider("$mdBottomSheet").setDefaults({
                        methods: [ "disableParentScroll", "escapeToClose", "clickOutsideToClose" ],
                        options: bottomSheetDefaults
                    });
                    function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture, $log) {
                        var backdrop;
                        return {
                            themable: !0,
                            onShow: function(scope, element, options) {
                                if ((element = $mdUtil.extractElementByName(element, "md-bottom-sheet")).attr("tabindex", "-1"), 
                                element.hasClass("ng-cloak")) {
                                    $log.warn("$mdBottomSheet: using `<md-bottom-sheet ng-cloak>` will affect the bottom-sheet opening animations.", element[0]);
                                }
                                options.isLockedOpen ? (options.clickOutsideToClose = !1, options.escapeToClose = !1) : options.cleanupGestures = function(element, parent) {
                                    var deregister = $mdGesture.register(parent, "drag", {
                                        horizontal: !1
                                    });
                                    return parent.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd), 
                                    function() {
                                        deregister(), parent.off("$md.dragstart", onDragStart), parent.off("$md.drag", onDrag), 
                                        parent.off("$md.dragend", onDragEnd);
                                    };
                                    function onDragStart() {
                                        element.css($mdConstant.CSS.TRANSITION_DURATION, "0ms");
                                    }
                                    function onDrag(ev) {
                                        var transform = ev.pointer.distanceY;
                                        transform < 5 && (transform = Math.max(-PADDING, transform / 2)), element.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + (PADDING + transform) + "px,0)");
                                    }
                                    function onDragEnd(ev) {
                                        if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                                            var distanceRemaining = element.prop("offsetHeight") - ev.pointer.distanceY, transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * .75, 500);
                                            element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + "ms"), $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                                        } else element.css($mdConstant.CSS.TRANSITION_DURATION, ""), element.css($mdConstant.CSS.TRANSFORM, "");
                                    }
                                }(element, options.parent);
                                options.disableBackdrop || ((backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque"))[0].tabIndex = -1, 
                                options.clickOutsideToClose && backdrop.on("click", (function() {
                                    $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                                })), $mdTheming.inherit(backdrop, options.parent), $animate.enter(backdrop, options.parent, null));
                                $mdTheming.inherit(element, options.parent), options.disableParentScroll && (options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent));
                                return $animate.enter(element, options.parent, backdrop).then((function() {
                                    var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector("button") || element[0].querySelector("a") || element[0].querySelector($mdUtil.prefixer("ng-click", !0))) || backdrop;
                                    options.escapeToClose && (options.rootElementKeyupCallback = function(e) {
                                        e.keyCode === $mdConstant.KEY_CODE.ESCAPE && $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                                    }, $rootElement.on("keyup", options.rootElementKeyupCallback), focusable && focusable.focus());
                                }));
                            },
                            onRemove: function(scope, element, options) {
                                options.disableBackdrop || $animate.leave(backdrop);
                                return $animate.leave(element).then((function() {
                                    options.disableParentScroll && (options.restoreScroll(), delete options.restoreScroll), 
                                    options.cleanupGestures && options.cleanupGestures();
                                }));
                            },
                            disableBackdrop: !1,
                            escapeToClose: !0,
                            clickOutsideToClose: !0,
                            disableParentScroll: !0,
                            isLockedOpen: !1
                        };
                    }
                }
                MdBottomSheetDirective.$inject = [ "$mdBottomSheet" ], MdBottomSheetProvider.$inject = [ "$$interimElementProvider" ], 
                angular.module("material.components.bottomSheet", [ "material.core", "material.components.backdrop" ]).directive("mdBottomSheet", MdBottomSheetDirective).provider("$mdBottomSheet", MdBottomSheetProvider);
            }(), function() {
                function MdAnchorDirective($mdTheming) {
                    return {
                        restrict: "E",
                        link: function(scope, element) {
                            $mdTheming(element);
                        }
                    };
                }
                function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $mdInteraction) {
                    return {
                        restrict: "EA",
                        replace: !0,
                        transclude: !0,
                        template: function(element, attr) {
                            return isAnchor(attr) ? '<a class="md-button" ng-transclude></a>' : '<button class="md-button" type="' + (void 0 === attr.type ? "button" : attr.type) + '" ng-transclude></button>';
                        },
                        link: function(scope, element, attr) {
                            $mdTheming(element), $mdButtonInkRipple.attach(scope, element), $mdAria.expectWithoutText(element, "aria-label"), 
                            isAnchor(attr) && angular.isDefined(attr.ngDisabled) && !element.hasClass("_md-nav-button") && scope.$watch(attr.ngDisabled, (function(isDisabled) {
                                element.attr("tabindex", isDisabled ? -1 : 0);
                            }));
                            element.on("click", (function(e) {
                                !0 === attr.disabled && (e.preventDefault(), e.stopImmediatePropagation());
                            })), element.hasClass("md-no-focus") || (element.on("focus", (function() {
                                $mdInteraction.isUserInvoked() && "keyboard" !== $mdInteraction.getLastInteractionType() || element.addClass("md-focused");
                            })), element.on("blur", (function() {
                                element.removeClass("md-focused");
                            })));
                        }
                    };
                    function isAnchor(attr) {
                        return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
                    }
                }
                MdButtonDirective.$inject = [ "$mdButtonInkRipple", "$mdTheming", "$mdAria", "$mdInteraction" ], 
                MdAnchorDirective.$inject = [ "$mdTheming" ], angular.module("material.components.button", [ "material.core" ]).directive("mdButton", MdButtonDirective).directive("a", MdAnchorDirective);
            }(), function() {
                function mdCardDirective($mdTheming) {
                    return {
                        restrict: "E",
                        link: function($scope, $element, attr) {
                            $element.addClass("_md"), $mdTheming($element);
                        }
                    };
                }
                mdCardDirective.$inject = [ "$mdTheming" ], angular.module("material.components.card", [ "material.core" ]).directive("mdCard", mdCardDirective);
            }(), function() {
                function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $mdInteraction) {
                    return inputDirective = inputDirective[0], {
                        restrict: "E",
                        transclude: !0,
                        require: [ "^?mdInputContainer", "?ngModel", "?^form" ],
                        priority: $mdConstant.BEFORE_NG_ARIA,
                        template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-icon"></div></div><div ng-transclude class="md-label"></div>',
                        compile: function(tElement, tAttrs) {
                            return tAttrs.$set("tabindex", tAttrs.tabindex || "0"), tAttrs.$set("type", "checkbox"), 
                            tAttrs.$set("role", tAttrs.type), tElement.addClass("md-auto-horizontal-margin"), 
                            {
                                pre: function(scope, element) {
                                    element.on("click", (function(e) {
                                        this.hasAttribute("disabled") && e.stopImmediatePropagation();
                                    }));
                                },
                                post: function(scope, element, attr, ctrls) {
                                    var isIndeterminate, containerCtrl = ctrls[0], ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel(), formCtrl = ctrls[2], labelHasLink = element.find("a").length > 0;
                                    if (labelHasLink) {
                                        var labelId = "label-" + $mdUtil.nextUid();
                                        attr.$set("aria-labelledby", labelId);
                                        var label = element.children()[1];
                                        angular.element(label).remove(), label.removeAttribute("ng-transclude"), label.className = "md-checkbox-link-label", 
                                        label.setAttribute("id", labelId), element.after(label), element.next().on("click", listener);
                                    }
                                    if (containerCtrl) {
                                        var isErrorGetter = containerCtrl.isErrorGetter || function() {
                                            return ngModelCtrl.$invalid && (ngModelCtrl.$touched || formCtrl && formCtrl.$submitted);
                                        };
                                        containerCtrl.input = element, scope.$watch(isErrorGetter, containerCtrl.setInvalid);
                                    }
                                    $mdTheming(element), element.children().on("focus", (function() {
                                        element.focus();
                                    })), $mdUtil.parseAttributeBoolean(attr.mdIndeterminate) && (setIndeterminateState(), 
                                    scope.$watch(attr.mdIndeterminate, setIndeterminateState));
                                    attr.ngChecked && scope.$watch(scope.$eval.bind(scope, attr.ngChecked), (function(value) {
                                        ngModelCtrl.$setViewValue(value), ngModelCtrl.$render();
                                    }));
                                    $$watchExpr("ngDisabled", "tabindex", {
                                        true: "-1",
                                        false: attr.tabindex
                                    }), labelHasLink || $mdAria.expectWithText(element, "aria-label");
                                    function $$watchExpr(expr, htmlAttr, valueOpts) {
                                        attr[expr] && scope.$watch(attr[expr], (function(val) {
                                            valueOpts[val] && element.attr(htmlAttr, valueOpts[val]);
                                        }));
                                    }
                                    function keypressHandler(ev) {
                                        var submit, form, keyCode = ev.which || ev.keyCode;
                                        switch (ev.preventDefault(), keyCode) {
                                          case $mdConstant.KEY_CODE.SPACE:
                                            element.addClass("md-focused"), listener(ev);
                                            break;

                                          case $mdConstant.KEY_CODE.ENTER:
                                            (form = $mdUtil.getClosest(ev.target, "form")) && (submit = form.querySelector('button[type="submit"]:enabled, input[type="submit"]:enabled')) && submit.click();
                                        }
                                    }
                                    function listener(ev) {
                                        element[0].hasAttribute("disabled") || scope.skipToggle || "A" === ev.target.tagName || scope.$apply((function() {
                                            var viewValue = attr.ngChecked && attr.ngClick ? attr.checked : !ngModelCtrl.$viewValue;
                                            ngModelCtrl.$setViewValue(viewValue, ev && ev.type), ngModelCtrl.$render();
                                        }));
                                    }
                                    function render() {
                                        var checked = !!ngModelCtrl.$viewValue && !isIndeterminate;
                                        element.toggleClass("md-checked", checked), isIndeterminate || (checked ? element.attr("aria-checked", "true") : element.attr("aria-checked", "false"));
                                    }
                                    function setIndeterminateState(newValue) {
                                        (isIndeterminate = !1 !== newValue) && element.attr("aria-checked", "mixed"), element.toggleClass("md-indeterminate", isIndeterminate), 
                                        ngModelCtrl.$render();
                                    }
                                    inputDirective.link.pre(scope, {
                                        on: angular.noop,
                                        0: {}
                                    }, attr, [ ngModelCtrl ]), element.on("click", listener).on("keypress", keypressHandler).on("focus", (function() {
                                        "keyboard" === $mdInteraction.getLastInteractionType() && element.addClass("md-focused");
                                    })).on("blur", (function() {
                                        element.removeClass("md-focused");
                                    })), ngModelCtrl.$render = render;
                                }
                            };
                        }
                    };
                }
                MdCheckboxDirective.$inject = [ "inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$mdInteraction" ], 
                angular.module("material.components.checkbox", [ "material.core" ]).directive("mdCheckbox", MdCheckboxDirective);
            }(), angular.module("material.components.chips", [ "material.core", "material.components.autocomplete" ]), 
            function() {
                function MdChipCtrl($scope, $element, $mdConstant, $timeout, $mdUtil) {
                    this.$scope = $scope, this.$element = $element, this.$mdConstant = $mdConstant, 
                    this.$timeout = $timeout, this.$mdUtil = $mdUtil, this.isEditing = !1, this.parentController = undefined, 
                    this.enableChipEdit = !1;
                }
                MdChipCtrl.$inject = [ "$scope", "$element", "$mdConstant", "$timeout", "$mdUtil" ], 
                angular.module("material.components.chips").controller("MdChipCtrl", MdChipCtrl), 
                MdChipCtrl.prototype.init = function(controller) {
                    this.parentController = controller, this.enableChipEdit = this.parentController.enableChipEdit, 
                    this.enableChipEdit && (this.$element.on("keydown", this.chipKeyDown.bind(this)), 
                    this.$element.on("dblclick", this.chipMouseDoubleClick.bind(this)), this.getChipContent().addClass("_md-chip-content-edit-is-enabled"));
                }, MdChipCtrl.prototype.getChipContent = function() {
                    var chipContents = this.$element[0].getElementsByClassName("md-chip-content");
                    return angular.element(chipContents[0]);
                }, MdChipCtrl.prototype.getContentElement = function() {
                    var contentElement = angular.element(this.getChipContent().children()[0]);
                    return contentElement && 0 !== contentElement.length || (contentElement = angular.element(this.getChipContent().contents()[0])), 
                    contentElement;
                }, MdChipCtrl.prototype.getChipIndex = function() {
                    return parseInt(this.$element.attr("index"));
                }, MdChipCtrl.prototype.goOutOfEditMode = function() {
                    if (this.isEditing) {
                        this.isEditing = !1, this.$element.removeClass("_md-chip-editing"), this.getChipContent()[0].contentEditable = "false";
                        var chipIndex = this.getChipIndex(), content = this.getContentElement().text();
                        content ? (this.parentController.updateChipContents(chipIndex, content), this.$mdUtil.nextTick(function() {
                            this.parentController.selectedChip === chipIndex && this.parentController.focusChip(chipIndex);
                        }.bind(this))) : this.parentController.removeChipAndFocusInput(chipIndex);
                    }
                }, MdChipCtrl.prototype.selectNodeContents = function(node) {
                    var range, selection;
                    document.body.createTextRange ? ((range = document.body.createTextRange()).moveToElementText(node), 
                    range.select()) : window.getSelection && (selection = window.getSelection(), (range = document.createRange()).selectNodeContents(node), 
                    selection.removeAllRanges(), selection.addRange(range));
                }, MdChipCtrl.prototype.goInEditMode = function() {
                    this.isEditing = !0, this.$element.addClass("_md-chip-editing"), this.getChipContent()[0].contentEditable = "true", 
                    this.getChipContent().on("blur", function() {
                        this.goOutOfEditMode();
                    }.bind(this)), this.selectNodeContents(this.getChipContent()[0]);
                }, MdChipCtrl.prototype.chipKeyDown = function(event) {
                    this.isEditing || event.keyCode !== this.$mdConstant.KEY_CODE.ENTER && event.keyCode !== this.$mdConstant.KEY_CODE.SPACE ? this.isEditing && event.keyCode === this.$mdConstant.KEY_CODE.ENTER && (event.preventDefault(), 
                    this.goOutOfEditMode()) : (event.preventDefault(), this.goInEditMode());
                }, MdChipCtrl.prototype.chipMouseDoubleClick = function() {
                    this.enableChipEdit && !this.isEditing && this.goInEditMode();
                };
            }(), function() {
                function MdChip($mdTheming, $mdUtil, $compile, $timeout) {
                    return {
                        restrict: "E",
                        require: [ "^?mdChips", "mdChip" ],
                        link: function(scope, element, attr, ctrls) {
                            var chipsController = ctrls.shift(), chipController = ctrls.shift(), chipContentElement = angular.element(element[0].querySelector(".md-chip-content"));
                            $mdTheming(element), chipsController && (chipController.init(chipsController), chipContentElement.on("blur", (function() {
                                chipsController.resetSelectedChip(), chipsController.$scope.$applyAsync();
                            })));
                            $timeout((function() {
                                chipsController && chipsController.shouldFocusLastChip && chipsController.focusLastChipThenInput();
                            }));
                        },
                        controller: "MdChipCtrl"
                    };
                }
                MdChip.$inject = [ "$mdTheming", "$mdUtil", "$compile", "$timeout" ], angular.module("material.components.chips").directive("mdChip", MdChip);
            }(), function() {
                function MdChipRemove($timeout) {
                    return {
                        restrict: "A",
                        require: "^mdChips",
                        scope: !1,
                        link: function(scope, element, attr, ctrl) {
                            element.on("click", (function() {
                                scope.$apply((function() {
                                    ctrl.removeChip(scope.$$replacedScope.$index);
                                }));
                            })), $timeout((function() {
                                element.attr({
                                    tabindex: "-1",
                                    "aria-hidden": "true"
                                }), element.find("button").attr("tabindex", "-1");
                            }));
                        }
                    };
                }
                MdChipRemove.$inject = [ "$timeout" ], angular.module("material.components.chips").directive("mdChipRemove", MdChipRemove);
            }(), function() {
                function MdChipTransclude($compile) {
                    return {
                        restrict: "EA",
                        terminal: !0,
                        link: function(scope, element, attr) {
                            var ctrl = scope.$parent.$mdChipsCtrl, newScope = ctrl.parent.$new(!1, ctrl.parent);
                            newScope.$$replacedScope = scope, newScope.$chip = scope.$chip, newScope.$index = scope.$index, 
                            newScope.$mdChipsCtrl = ctrl;
                            var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
                            element.html(newHtml), $compile(element.contents())(newScope);
                        },
                        scope: !1
                    };
                }
                MdChipTransclude.$inject = [ "$compile" ], angular.module("material.components.chips").directive("mdChipTransclude", MdChipTransclude);
            }(), function() {
                MdChipsCtrl.$inject = [ "$scope", "$attrs", "$mdConstant", "$log", "$element", "$timeout", "$mdUtil", "$mdLiveAnnouncer", "$exceptionHandler" ];
                var DEFAULT_CHIP_APPEND_DELAY = 300;
                function MdChipsCtrl($scope, $attrs, $mdConstant, $log, $element, $timeout, $mdUtil, $mdLiveAnnouncer, $exceptionHandler) {
                    this.$timeout = $timeout, this.$mdConstant = $mdConstant, this.$scope = $scope, 
                    this.parent = $scope.$parent, this.$mdUtil = $mdUtil, this.$log = $log, this.$mdLiveAnnouncer = $mdLiveAnnouncer, 
                    this.$exceptionHandler = $exceptionHandler, this.$element = $element, this.$attrs = $attrs, 
                    this.ngModelCtrl = null, this.userInputNgModelCtrl = null, this.autocompleteCtrl = null, 
                    this.userInputElement = null, this.items = [], this.selectedChip = -1, this.enableChipEdit = $mdUtil.parseAttributeBoolean($attrs.mdEnableChipEdit), 
                    this.addOnBlur = $mdUtil.parseAttributeBoolean($attrs.mdAddOnBlur), this.inputClass = "", 
                    this.inputAriaLabel = "Chips input.", this.containerHint = "Chips container. Use arrow keys to select chips.", 
                    this.containerEmptyHint = "Chips container. Enter the text area, then type text, and press enter to add a chip.", 
                    this.deleteHint = "Press delete to remove this chip.", this.deleteButtonLabel = "Remove", 
                    this.chipBuffer = "", this.useTransformChip = !1, this.useOnAdd = !1, this.useOnRemove = !1, 
                    this.wrapperId = "", this.contentIds = [], this.ariaTabIndex = null, this.chipAppendDelay = DEFAULT_CHIP_APPEND_DELAY, 
                    this.deRegister = [], this.addedMessage = "added", this.removedMessage = "removed", 
                    this.init();
                }
                angular.module("material.components.chips").controller("MdChipsCtrl", MdChipsCtrl), 
                MdChipsCtrl.prototype.init = function() {
                    var ctrl = this;
                    this.wrapperId = "_md-chips-wrapper-" + this.$mdUtil.nextUid(), this.$element.attr("ng-model") || this.setupStaticChips(), 
                    this.deRegister.push(this.$scope.$watchCollection("$mdChipsCtrl.items", (function() {
                        ctrl.setupInputAria(), ctrl.setupWrapperAria();
                    }))), this.deRegister.push(this.$attrs.$observe("mdChipAppendDelay", (function(newValue) {
                        ctrl.chipAppendDelay = parseInt(newValue) || DEFAULT_CHIP_APPEND_DELAY;
                    })));
                }, MdChipsCtrl.prototype.$onDestroy = function() {
                    for (var $destroyFn; $destroyFn = this.deRegister.pop(); ) $destroyFn.call(this);
                }, MdChipsCtrl.prototype.setupInputAria = function() {
                    var input = this.$element.find("input");
                    input && (input.attr("role", "textbox"), input.attr("aria-multiline", !0), this.inputAriaDescribedBy && input.attr("aria-describedby", this.inputAriaDescribedBy), 
                    this.inputAriaLabelledBy ? (input.attr("aria-labelledby", this.inputAriaLabelledBy), 
                    input.removeAttr("aria-label")) : input.attr("aria-label", this.inputAriaLabel));
                }, MdChipsCtrl.prototype.setupWrapperAria = function() {
                    var ctrl = this, wrapper = this.$element.find("md-chips-wrap");
                    this.items && this.items.length ? (wrapper.attr("role", "listbox"), this.contentIds = this.items.map((function() {
                        return ctrl.wrapperId + "-chip-" + ctrl.$mdUtil.nextUid();
                    })), wrapper.attr("aria-owns", this.contentIds.join(" ")), wrapper.attr("aria-label", this.containerHint)) : (wrapper.removeAttr("role"), 
                    wrapper.removeAttr("aria-owns"), wrapper.attr("aria-label", this.containerEmptyHint));
                }, MdChipsCtrl.prototype.setupStaticChips = function() {
                    var i, staticChips, ctrl = this, wrapper = this.$element.find("md-chips-wrap");
                    this.$timeout((function() {
                        for (wrapper.attr("role", "list"), staticChips = wrapper[0].children, i = 0; i < staticChips.length; i++) staticChips[i].setAttribute("role", "listitem"), 
                        staticChips[i].setAttribute("aria-setsize", staticChips.length);
                        ctrl.inputAriaDescribedBy && wrapper.attr("aria-describedby", ctrl.inputAriaDescribedBy), 
                        ctrl.inputAriaLabelledBy ? (wrapper.attr("aria-labelledby", ctrl.inputAriaLabelledBy), 
                        wrapper.removeAttr("aria-label")) : wrapper.attr("aria-label", ctrl.inputAriaLabel);
                    }), 10);
                }, MdChipsCtrl.prototype.inputKeydown = function(event) {
                    var chipBuffer = this.getChipBuffer();
                    if (!(this.autocompleteCtrl && event.isDefaultPrevented && event.isDefaultPrevented())) {
                        if (event.keyCode === this.$mdConstant.KEY_CODE.BACKSPACE) {
                            if (0 !== this.getCursorPosition(event.target)) return;
                            return event.preventDefault(), event.stopPropagation(), void (this.items.length && this.selectAndFocusChipSafe(this.items.length - 1));
                        }
                        if ((!this.separatorKeys || this.separatorKeys.length < 1) && (this.separatorKeys = [ this.$mdConstant.KEY_CODE.ENTER ]), 
                        -1 !== this.separatorKeys.indexOf(event.keyCode)) {
                            if (this.autocompleteCtrl && this.requireMatch || !chipBuffer) return;
                            if (event.preventDefault(), this.hasMaxChipsReached()) return;
                            return this.appendChip(chipBuffer.trim()), this.resetChipBuffer(), !1;
                        }
                    }
                }, MdChipsCtrl.prototype.getCursorPosition = function(element) {
                    try {
                        if (element.selectionStart === element.selectionEnd) return element.selectionStart;
                    } catch (e) {
                        if (!element.value) return 0;
                    }
                }, MdChipsCtrl.prototype.updateChipContents = function(chipIndex, chipContents) {
                    chipIndex >= 0 && chipIndex < this.items.length && (this.items[chipIndex] = chipContents, 
                    this.updateNgModel(!0));
                }, MdChipsCtrl.prototype.isEditingChip = function() {
                    return !!this.$element[0].querySelector("._md-chip-editing");
                }, MdChipsCtrl.prototype._isChipObject = function(chip) {
                    return angular.isObject(chip);
                }, MdChipsCtrl.prototype.isRemovable = function() {
                    return !!this.ngModelCtrl && (this.readonly ? this.removable : !angular.isDefined(this.removable) || this.removable);
                }, MdChipsCtrl.prototype.chipKeydown = function(event) {
                    if (!this.getChipBuffer() && !this.isEditingChip()) switch (event.keyCode) {
                      case this.$mdConstant.KEY_CODE.BACKSPACE:
                      case this.$mdConstant.KEY_CODE.DELETE:
                        if (this.selectedChip < 0) return;
                        if (event.preventDefault(), !this.isRemovable()) return;
                        this.removeAndSelectAdjacentChip(this.selectedChip, event);
                        break;

                      case this.$mdConstant.KEY_CODE.LEFT_ARROW:
                        event.preventDefault(), (this.selectedChip < 0 || this.readonly && 0 === this.selectedChip) && (this.selectedChip = this.items.length), 
                        this.items.length && this.selectAndFocusChipSafe(this.selectedChip - 1);
                        break;

                      case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
                        event.preventDefault(), this.selectAndFocusChipSafe(this.selectedChip + 1);
                        break;

                      case this.$mdConstant.KEY_CODE.ESCAPE:
                      case this.$mdConstant.KEY_CODE.TAB:
                        if (this.selectedChip < 0) return;
                        event.preventDefault(), this.onFocus();
                    }
                }, MdChipsCtrl.prototype.getPlaceholder = function() {
                    return this.items && this.items.length && ("" === this.secondaryPlaceholder || this.secondaryPlaceholder) ? this.secondaryPlaceholder : this.placeholder;
                }, MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index, event) {
                    var self = this, selIndex = self.getAdjacentChipIndex(index);
                    this.$element[0].querySelector("md-chips-wrap"), this.$element[0].querySelector('md-chip[index="' + index + '"]');
                    self.removeChip(index, event), self.$timeout((function() {
                        self.$timeout((function() {
                            self.selectAndFocusChipSafe(selIndex);
                        }));
                    }));
                }, MdChipsCtrl.prototype.resetSelectedChip = function() {
                    this.selectedChip = -1, this.ariaTabIndex = null;
                }, MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
                    var len = this.items.length - 1;
                    return 0 === len ? -1 : index === len ? index - 1 : index;
                }, MdChipsCtrl.prototype.appendChip = function(newChip) {
                    if (this.shouldFocusLastChip = !this.addOnBlur, this.useTransformChip && this.transformChip) {
                        var transformedChip = this.transformChip({
                            $chip: newChip
                        });
                        angular.isDefined(transformedChip) && (newChip = transformedChip);
                    }
                    if (angular.isObject(newChip) && this.items.some((function(item) {
                        return angular.equals(newChip, item);
                    }))) return;
                    if (!(null == newChip || this.items.indexOf(newChip) + 1)) {
                        var index = this.items.push(newChip) - 1;
                        this.updateNgModel();
                        var chipContent = angular.isObject(newChip) ? "" : newChip;
                        this.$mdLiveAnnouncer.announce(chipContent + " " + this.addedMessage, "assertive"), 
                        this.useOnAdd && this.onAdd && this.onAdd({
                            $chip: newChip,
                            $index: index
                        });
                    }
                }, MdChipsCtrl.prototype.useTransformChipExpression = function() {
                    this.useTransformChip = !0;
                }, MdChipsCtrl.prototype.useOnAddExpression = function() {
                    this.useOnAdd = !0;
                }, MdChipsCtrl.prototype.useOnRemoveExpression = function() {
                    this.useOnRemove = !0;
                }, MdChipsCtrl.prototype.useOnSelectExpression = function() {
                    this.useOnSelect = !0;
                }, MdChipsCtrl.prototype.getChipBuffer = function() {
                    var chipBuffer = this.userInputElement ? this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value : this.chipBuffer;
                    return angular.isString(chipBuffer) ? chipBuffer : "";
                }, MdChipsCtrl.prototype.resetChipBuffer = function() {
                    this.userInputElement ? this.userInputNgModelCtrl ? (this.userInputNgModelCtrl.$setViewValue(""), 
                    this.userInputNgModelCtrl.$render()) : this.userInputElement[0].value = "" : this.chipBuffer = "";
                }, MdChipsCtrl.prototype.hasMaxChipsReached = function() {
                    return angular.isString(this.maxChips) && (this.maxChips = parseInt(this.maxChips, 10) || 0), 
                    this.maxChips > 0 && this.items.length >= this.maxChips;
                }, MdChipsCtrl.prototype.validateModel = function() {
                    this.ngModelCtrl.$setValidity("md-max-chips", !this.hasMaxChipsReached()), this.ngModelCtrl.$validate();
                }, MdChipsCtrl.prototype.updateNgModel = function(skipValidation) {
                    skipValidation || this.validateModel(), angular.forEach(this.ngModelCtrl.$viewChangeListeners, (function(listener) {
                        try {
                            listener();
                        } catch (e) {
                            this.$exceptionHandler(e);
                        }
                    }));
                }, MdChipsCtrl.prototype.removeChip = function(index, event) {
                    var removed = this.items.splice(index, 1);
                    this.updateNgModel(), this.ngModelCtrl.$setDirty();
                    var chipContent = angular.isObject(removed[0]) ? "" : removed[0];
                    this.$mdLiveAnnouncer.announce(chipContent + " " + this.removedMessage, "assertive"), 
                    removed && removed.length && this.useOnRemove && this.onRemove && this.onRemove({
                        $chip: removed[0],
                        $index: index,
                        $event: event
                    });
                }, MdChipsCtrl.prototype.removeChipAndFocusInput = function(index, $event) {
                    this.removeChip(index, $event), this.autocompleteCtrl ? (this.autocompleteCtrl.hidden = !0, 
                    this.$mdUtil.nextTick(this.onFocus.bind(this))) : this.onFocus();
                }, MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
                    if (!this.items.length || -1 === index) return this.focusInput();
                    if (index >= this.items.length) {
                        if (!this.readonly) return this.onFocus();
                        index = 0;
                    }
                    index = Math.max(index, 0), index = Math.min(index, this.items.length - 1), this.selectChip(index), 
                    this.focusChip(index);
                }, MdChipsCtrl.prototype.focusLastChipThenInput = function() {
                    var ctrl = this;
                    ctrl.shouldFocusLastChip = !1, ctrl.focusChip(this.items.length - 1), ctrl.$timeout((function() {
                        ctrl.focusInput();
                    }), ctrl.chipAppendDelay);
                }, MdChipsCtrl.prototype.focusInput = function() {
                    this.selectChip(-1), this.onFocus();
                }, MdChipsCtrl.prototype.selectChip = function(index) {
                    index >= -1 && index <= this.items.length ? (this.selectedChip = index, this.useOnSelect && this.onSelect && this.onSelect({
                        $chip: this.items[index]
                    })) : this.$log.warn("Selected Chip index out of bounds; ignoring.");
                }, MdChipsCtrl.prototype.focusChip = function(index) {
                    var chipContent = this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content');
                    this.ariaTabIndex = index, chipContent.focus();
                }, MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
                    this.ngModelCtrl = ngModelCtrl;
                    var self = this;
                    ngModelCtrl.$isEmpty = function(value) {
                        return !value || 0 === value.length;
                    }, ngModelCtrl.$render = function() {
                        self.items = self.ngModelCtrl.$viewValue;
                    };
                }, MdChipsCtrl.prototype.onFocus = function() {
                    var input = this.$element[0].querySelector("input");
                    input && input.focus(), this.resetSelectedChip();
                }, MdChipsCtrl.prototype.onInputFocus = function() {
                    this.inputHasFocus = !0, this.setupInputAria(), this.resetSelectedChip();
                }, MdChipsCtrl.prototype.onInputBlur = function() {
                    this.inputHasFocus = !1, this.shouldAddOnBlur() && (this.appendChip(this.getChipBuffer().trim()), 
                    this.resetChipBuffer());
                }, MdChipsCtrl.prototype.configureInput = function(inputElement) {
                    var ngModelCtrl = inputElement.controller("ngModel"), ctrl = this;
                    ngModelCtrl && (this.deRegister.push(this.$scope.$watch((function() {
                        return ngModelCtrl.$touched;
                    }), (function(isTouched) {
                        isTouched && ctrl.ngModelCtrl.$setTouched();
                    }))), this.deRegister.push(this.$scope.$watch((function() {
                        return ngModelCtrl.$dirty;
                    }), (function(isDirty) {
                        isDirty && ctrl.ngModelCtrl.$setDirty();
                    }))));
                }, MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
                    this.userInputElement = inputElement;
                    var ngModelCtrl = inputElement.controller("ngModel");
                    ngModelCtrl !== this.ngModelCtrl && (this.userInputNgModelCtrl = ngModelCtrl);
                    var scope = this.$scope, ctrl = this, scopeApplyFn = function(event, fn) {
                        scope.$evalAsync(angular.bind(ctrl, fn, event));
                    };
                    inputElement.attr({
                        tabindex: 0
                    }).on("keydown", (function(event) {
                        scopeApplyFn(event, ctrl.inputKeydown);
                    })).on("focus", (function(event) {
                        scopeApplyFn(event, ctrl.onInputFocus);
                    })).on("blur", (function(event) {
                        scopeApplyFn(event, ctrl.onInputBlur);
                    }));
                }, MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
                    ctrl && (this.autocompleteCtrl = ctrl, this.$element.attr("container-empty-hint") || (this.containerEmptyHint = "Chips container with autocompletion. Enter the text area, type text to search, and then use the up and down arrow keys to select an option. Press enter to add the selected option as a chip.", 
                    this.setupWrapperAria()), ctrl.registerSelectedItemWatcher(angular.bind(this, (function(item) {
                        if (item) {
                            if (this.hasMaxChipsReached()) return;
                            this.appendChip(item), this.resetChipBuffer();
                        }
                    }))), this.$element.find("input").on("focus", angular.bind(this, this.onInputFocus)).on("blur", angular.bind(this, this.onInputBlur)));
                }, MdChipsCtrl.prototype.shouldAddOnBlur = function() {
                    this.validateModel();
                    var chipBuffer = this.getChipBuffer().trim(), isModelValid = this.ngModelCtrl.$isEmpty(this.ngModelCtrl.$modelValue) || this.ngModelCtrl.$valid, isAutocompleteShowing = this.autocompleteCtrl && !this.autocompleteCtrl.hidden;
                    return this.userInputNgModelCtrl && (isModelValid = isModelValid && this.userInputNgModelCtrl.$valid), 
                    this.addOnBlur && !this.requireMatch && chipBuffer && isModelValid && !isAutocompleteShowing;
                }, MdChipsCtrl.prototype.hasFocus = function() {
                    return this.inputHasFocus || this.selectedChip >= 0;
                }, MdChipsCtrl.prototype.contentIdFor = function(index) {
                    return this.contentIds[index];
                };
            }(), function() {
                MdChips.$inject = [ "$mdTheming", "$mdUtil", "$compile", "$log", "$timeout", "$$mdSvgRegistry" ], 
                angular.module("material.components.chips").directive("mdChips", MdChips);
                var MD_CHIPS_TEMPLATE = '      <md-chips-wrap          id="{{$mdChipsCtrl.wrapperId}}"          tabindex="{{$mdChipsCtrl.readonly ? 0 : -1}}"          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(),                       \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly,                      \'md-removable\': $mdChipsCtrl.isRemovable() }"          class="md-chips">        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"             ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': !$mdChipsCtrl.ngModelCtrl || $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="{{$mdChipsCtrl.ariaTabIndex === $index ? 0 : -1}}"              id="{{$mdChipsCtrl.contentIdFor($index)}}"              role="option"              aria-selected="{{$mdChipsCtrl.selectedChip === $index}}"              aria-setsize="{{$mdChipsCtrl.items.length}}"              aria-posinset="{{$index+1}}"              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"              aria-label="{{$mdChipsCtrl._isChipObject($chip) ? \'\' : $chip + \'. \'}}{{$mdChipsCtrl.isRemovable() ? \'\' + $mdChipsCtrl.deleteHint : \'\'}}"               ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div ng-if="$mdChipsCtrl.isRemovable()"               class="md-chip-remove-container"               tabindex="-1"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div class="md-chip-input-container" ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl">          <div md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>', CHIP_INPUT_TEMPLATE = '        <input            class="md-input{{ $mdChipsCtrl.inputClass ? \' \' + $mdChipsCtrl.inputClass: \'\'}}"            tabindex="0"            aria-label="{{$mdChipsCtrl.inputAriaLabel}}"            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">', CHIP_DEFAULT_TEMPLATE = "      <span>{{$chip}}</span>", CHIP_REMOVE_TEMPLATE = '      <button          class="md-chip-remove"          ng-if="$mdChipsCtrl.isRemovable()"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index, $event)"          type="button"          tabindex="-1"          aria-label="{{$mdChipsCtrl.deleteButtonLabel}}{{$mdChipsCtrl._isChipObject($chip) ? \'\' : \' \' + $chip}}">        <md-icon md-svg-src="{{$mdChipsCtrl.mdCloseIcon}}" aria-hidden="true"></md-icon>      </button>';
                function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout, $$mdSvgRegistry) {
                    var templates = {
                        chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
                        input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
                        default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
                        remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
                    };
                    return {
                        template: function(element, attrs) {
                            return attrs.$mdUserTemplate = element.clone(), templates.chips;
                        },
                        require: [ "mdChips" ],
                        restrict: "E",
                        controller: "MdChipsCtrl",
                        controllerAs: "$mdChipsCtrl",
                        bindToController: !0,
                        compile: function(element, attr) {
                            var userTemplate = attr.$mdUserTemplate;
                            attr.$mdUserTemplate = null;
                            var chipTemplate = getTemplateByQuery("md-chips>md-chip-template"), chipRemoveTemplate = getTemplateByQuery($mdUtil.prefixer().buildList("md-chip-remove").map((function(attr) {
                                return "md-chips>*[" + attr + "]";
                            })).join(",")) || templates.remove, chipContentsTemplate = chipTemplate || templates.default, chipInputTemplate = getTemplateByQuery("md-chips>md-autocomplete") || getTemplateByQuery("md-chips>input") || templates.input, staticChips = userTemplate.find("md-chip");
                            userTemplate[0].querySelector("md-chip-template>*[md-chip-remove]") && $log.warn("invalid placement of md-chip-remove within md-chip-template.");
                            function getTemplateByQuery(query) {
                                if (attr.ngModel) {
                                    var element = userTemplate[0].querySelector(query);
                                    return element && element.outerHTML;
                                }
                            }
                            return function(scope, element, attrs, controllers) {
                                $mdUtil.initOptionalProperties(scope, attr), $mdTheming(element);
                                var mdChipsCtrl = controllers[0];
                                if (chipTemplate && (mdChipsCtrl.enableChipEdit = !1), mdChipsCtrl.chipContentsTemplate = chipContentsTemplate, 
                                mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate, mdChipsCtrl.chipInputTemplate = chipInputTemplate, 
                                mdChipsCtrl.mdCloseIcon = $$mdSvgRegistry.mdCancel, element.attr({
                                    tabindex: -1
                                }).on("focus", (function() {
                                    mdChipsCtrl.onFocus();
                                })).on("click", (function() {
                                    mdChipsCtrl.readonly || -1 !== mdChipsCtrl.selectedChip || mdChipsCtrl.onFocus();
                                })), attr.ngModel && (mdChipsCtrl.configureNgModel(element.controller("ngModel")), 
                                attrs.mdTransformChip && mdChipsCtrl.useTransformChipExpression(), attrs.mdOnAdd && mdChipsCtrl.useOnAddExpression(), 
                                attrs.mdOnRemove && mdChipsCtrl.useOnRemoveExpression(), attrs.mdOnSelect && mdChipsCtrl.useOnSelectExpression(), 
                                chipInputTemplate !== templates.input && scope.$watch("$mdChipsCtrl.readonly", (function(readonly) {
                                    readonly || $mdUtil.nextTick((function() {
                                        if (0 === chipInputTemplate.indexOf("<md-autocomplete")) {
                                            var autocompleteEl = element.find("md-autocomplete");
                                            mdChipsCtrl.configureAutocomplete(autocompleteEl.controller("mdAutocomplete"));
                                        }
                                        mdChipsCtrl.configureUserInput(element.find("input"));
                                    }));
                                })), $mdUtil.nextTick((function() {
                                    var input = element.find("input");
                                    input && (mdChipsCtrl.configureInput(input), input.toggleClass("md-input", !0));
                                }))), staticChips.length > 0) {
                                    var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
                                    $timeout((function() {
                                        element.find("md-chips-wrap").prepend(compiledStaticChips);
                                    }));
                                }
                            };
                        },
                        scope: {
                            readonly: "=?readonly",
                            removable: "=?mdRemovable",
                            placeholder: "@?",
                            secondaryPlaceholder: "@?",
                            maxChips: "@?mdMaxChips",
                            transformChip: "&mdTransformChip",
                            onAdd: "&?mdOnAdd",
                            onRemove: "&?mdOnRemove",
                            addedMessage: "@?mdAddedMessage",
                            removedMessage: "@?mdRemovedMessage",
                            onSelect: "&?mdOnSelect",
                            inputClass: "@?mdInputClass",
                            inputAriaDescribedBy: "@?inputAriaDescribedby",
                            inputAriaLabelledBy: "@?inputAriaLabelledby",
                            inputAriaLabel: "@?",
                            containerHint: "@?",
                            containerEmptyHint: "@?",
                            deleteHint: "@?",
                            deleteButtonLabel: "@?",
                            separatorKeys: "=?mdSeparatorKeys",
                            requireMatch: "=?mdRequireMatch",
                            chipAppendDelayString: "@?mdChipAppendDelay",
                            ngChange: "&?"
                        }
                    };
                }
            }(), function() {
                function MdContactChipsCtrl($attrs, $element, $timeout) {
                    this.$element = $element, this.$attrs = $attrs, this.$timeout = $timeout, this.selectedItem = null, 
                    this.searchText = "", this.deRegister = [], this.init();
                }
                MdContactChipsCtrl.$inject = [ "$attrs", "$element", "$timeout" ], angular.module("material.components.chips").controller("MdContactChipsCtrl", MdContactChipsCtrl), 
                MdContactChipsCtrl.prototype.init = function() {
                    var ctrl = this, deRegister = this.deRegister, element = this.$element;
                    this.$timeout((function() {
                        deRegister.push(element.find("md-chips").controller("mdChips").$scope.$watchCollection("$mdChipsCtrl.items", (function() {
                            ctrl.setupChipsAria(), ctrl.setupAutocompleteAria();
                        })));
                    }));
                }, MdContactChipsCtrl.prototype.setupChipsAria = function() {
                    var chips = this.$element.find("md-chips"), chipsCtrl = chips.controller("mdChips");
                    this.removedMessage && (chipsCtrl.removedMessage = this.removedMessage), this.containerHint && (chipsCtrl.containerHint = this.containerHint), 
                    this.containerEmptyHint && (chips.attr("container-empty-hint", this.containerEmptyHint), 
                    chipsCtrl.containerEmptyHint = this.containerEmptyHint), this.deleteHint && (chipsCtrl.deleteHint = this.deleteHint), 
                    this.inputAriaLabel && (chipsCtrl.inputAriaLabel = this.inputAriaLabel), this.inputClass && (chipsCtrl.inputClass = this.inputClass);
                }, MdContactChipsCtrl.prototype.setupAutocompleteAria = function() {
                    var autocompleteInput = this.$element.find("md-chips-wrap").find("md-autocomplete").find("input");
                    this.inputAriaDescribedBy && autocompleteInput.attr("aria-describedby", this.inputAriaDescribedBy), 
                    this.inputAriaLabelledBy && (autocompleteInput.removeAttr("aria-label"), autocompleteInput.attr("aria-labelledby", this.inputAriaLabelledBy));
                }, MdContactChipsCtrl.prototype.queryContact = function(searchText) {
                    return this.contactQuery({
                        $query: searchText
                    });
                }, MdContactChipsCtrl.prototype.inputKeydown = function(event) {
                    if (this.separatorKeys && !(this.separatorKeys.indexOf(event.keyCode) < 0)) {
                        event.stopPropagation(), event.preventDefault();
                        var autocompleteCtrl = angular.element(event.target).controller("mdAutocomplete");
                        autocompleteCtrl.select(autocompleteCtrl.index);
                    }
                }, MdContactChipsCtrl.prototype.itemName = function(item) {
                    return item[this.contactName];
                }, MdContactChipsCtrl.prototype.$onDestroy = function() {
                    for (var $destroyFn; $destroyFn = this.deRegister.pop(); ) $destroyFn.call(this);
                };
            }(), function() {
                MdContactChips.$inject = [ "$mdTheming", "$mdUtil" ], angular.module("material.components.chips").directive("mdContactChips", MdContactChips);
                var MD_CONTACT_CHIPS_TEMPLATE = '      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          ng-change="$mdContactChipsCtrl.ngChange($mdContactChipsCtrl.contacts)"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-max-chips="{{$mdContactChipsCtrl.maxChips}}"          md-chip-append-delay="{{$mdContactChipsCtrl.chipAppendDelay}}"          md-separator-keys="$mdContactChipsCtrl.separatorKeys"          md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-min-length="$mdContactChipsCtrl.minLength"              md-autoselect              ng-attr-md-input-class="{{$mdContactChipsCtrl.inputClass}}"              ng-keydown="$mdContactChipsCtrl.inputKeydown($event)"              placeholder="{{$mdContactChipsCtrl.contacts.length === 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>';
                function MdContactChips($mdTheming, $mdUtil) {
                    return {
                        template: function(element, attrs) {
                            return MD_CONTACT_CHIPS_TEMPLATE;
                        },
                        restrict: "E",
                        controller: "MdContactChipsCtrl",
                        controllerAs: "$mdContactChipsCtrl",
                        bindToController: !0,
                        compile: function(element, attr) {
                            return function(scope, element, attrs, controllers) {
                                var contactChipsController = controllers;
                                $mdUtil.initOptionalProperties(scope, attr), $mdTheming(element), element.attr("tabindex", "-1"), 
                                attrs.$observe("mdChipAppendDelay", (function(newValue) {
                                    contactChipsController.chipAppendDelay = newValue;
                                }));
                            };
                        },
                        scope: {
                            contactQuery: "&mdContacts",
                            placeholder: "@?",
                            secondaryPlaceholder: "@?",
                            contactName: "@mdContactName",
                            contactImage: "@mdContactImage",
                            contactEmail: "@mdContactEmail",
                            contacts: "=ngModel",
                            ngChange: "&?",
                            requireMatch: "=?mdRequireMatch",
                            minLength: "=?mdMinLength",
                            maxChips: "=?mdMaxChips",
                            highlightFlags: "@?mdHighlightFlags",
                            chipAppendDelay: "@?mdChipAppendDelay",
                            separatorKeys: "=?mdSeparatorKeys",
                            removedMessage: "@?mdRemovedMessage",
                            inputClass: "@?mdInputClass",
                            inputAriaDescribedBy: "@?inputAriaDescribedby",
                            inputAriaLabelledBy: "@?inputAriaLabelledby",
                            inputAriaLabel: "@?",
                            containerHint: "@?",
                            containerEmptyHint: "@?",
                            deleteHint: "@?"
                        }
                    };
                }
            }(), function() {
                MdColorsDirective.$inject = [ "$mdColors", "$mdUtil", "$log", "$parse" ], MdColorsService.$inject = [ "$mdTheming", "$mdUtil", "$log" ];
                var STATIC_COLOR_EXPRESSION = /^{((\s|,)*?["'a-zA-Z-]+?\s*?:\s*?(['"])[a-zA-Z0-9-.]*(['"]))+\s*}$/, colorPalettes = null;
                function MdColorsService($mdTheming, $mdUtil, $log) {
                    return colorPalettes = colorPalettes || Object.keys($mdTheming.PALETTES), {
                        applyThemeColors: function(element, colorExpression) {
                            try {
                                colorExpression && element.css((rgbColors = {}, hasColorProperty = (themeColors = colorExpression).hasOwnProperty("color"), 
                                angular.forEach(themeColors, (function(value, key) {
                                    var color = extractColorOptions(value), hasBackground = key.indexOf("background") > -1;
                                    rgbColors[key] = parseColor(color), hasBackground && !hasColorProperty && (rgbColors.color = parseColor(color, !0));
                                })), rgbColors));
                            } catch (e) {
                                $log.error(e.message);
                            }
                            var themeColors, rgbColors, hasColorProperty;
                        },
                        getThemeColor: function(expression) {
                            return parseColor(extractColorOptions(expression));
                        },
                        hasTheme: function(expression) {
                            return angular.isDefined($mdTheming.THEMES[expression.split("-")[0]]);
                        }
                    };
                    function parseColor(color, contrast) {
                        contrast = contrast || !1;
                        var rgbValues = $mdTheming.PALETTES[color.palette][color.hue];
                        return rgbValues = contrast ? rgbValues.contrast : rgbValues.value, $mdUtil.supplant("rgba({0}, {1}, {2}, {3})", [ rgbValues[0], rgbValues[1], rgbValues[2], rgbValues[3] || color.opacity ]);
                    }
                    function extractColorOptions(expression) {
                        var parts = expression.split("-"), theme = angular.isDefined($mdTheming.THEMES[parts[0]]) ? parts.splice(0, 1)[0] : $mdTheming.defaultTheme();
                        return {
                            theme,
                            palette: extractPalette(parts, theme),
                            hue: extractHue(parts, theme),
                            opacity: parts[2] || 1
                        };
                    }
                    function extractPalette(parts, theme) {
                        var isTwoWord = parts.length > 1 && -1 !== colorPalettes.indexOf(parts[1]), palette = parts[0].replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
                        if (isTwoWord && (palette = parts[0] + "-" + parts.splice(1, 1)), -1 === colorPalettes.indexOf(palette)) {
                            var scheme = $mdTheming.THEMES[theme].colors[palette];
                            if (!scheme) throw new Error($mdUtil.supplant("mdColors: couldn't find '{palette}' in the palettes.", {
                                palette
                            }));
                            palette = scheme.name;
                        }
                        return palette;
                    }
                    function extractHue(parts, theme) {
                        var themeColors = $mdTheming.THEMES[theme].colors;
                        if ("hue" === parts[1]) {
                            var hueNumber = parseInt(parts.splice(2, 1)[0], 10);
                            if (hueNumber < 1 || hueNumber > 3) throw new Error($mdUtil.supplant("mdColors: 'hue-{hueNumber}' is not a valid hue, can be only 'hue-1', 'hue-2' and 'hue-3'", {
                                hueNumber
                            }));
                            if (parts[1] = "hue-" + hueNumber, !(parts[0] in themeColors)) throw new Error($mdUtil.supplant("mdColors: 'hue-x' can only be used with [{availableThemes}], but was used with '{usedTheme}'", {
                                availableThemes: Object.keys(themeColors).join(", "),
                                usedTheme: parts[0]
                            }));
                            return themeColors[parts[0]].hues[parts[1]];
                        }
                        return parts[1] || themeColors[parts[0] in themeColors ? parts[0] : "primary"].hues.default;
                    }
                }
                function MdColorsDirective($mdColors, $mdUtil, $log, $parse) {
                    return {
                        restrict: "A",
                        require: [ "^?mdTheme" ],
                        compile: function(tElem, tAttrs) {
                            var shouldWatch = function() {
                                var rawColorExpression = tAttrs.mdColors, bindOnce = rawColorExpression.indexOf("::") > -1, isStatic = !!bindOnce || STATIC_COLOR_EXPRESSION.test(tAttrs.mdColors);
                                tAttrs.mdColors = rawColorExpression.replace("::", "");
                                var hasWatchAttr = angular.isDefined(tAttrs.mdColorsWatch);
                                return !bindOnce && !isStatic && (!hasWatchAttr || $mdUtil.parseAttributeBoolean(tAttrs.mdColorsWatch));
                            }();
                            return function(scope, element, attrs, ctrl) {
                                var mdThemeController = ctrl[0], lastColors = {}, parseColors = function(theme) {
                                    "string" != typeof theme && (theme = ""), attrs.mdColors || (attrs.mdColors = "{}");
                                    var colors = $parse(attrs.mdColors)(scope);
                                    return mdThemeController && Object.keys(colors).forEach((function(prop) {
                                        var color = colors[prop];
                                        $mdColors.hasTheme(color) || (colors[prop] = (theme || mdThemeController.$mdTheme) + "-" + color);
                                    })), cleanElement(colors), colors;
                                }, cleanElement = function(colors) {
                                    if (!angular.equals(colors, lastColors)) {
                                        var keys = Object.keys(lastColors);
                                        lastColors.background && !keys.color && keys.push("color"), keys.forEach((function(key) {
                                            element.css(key, "");
                                        }));
                                    }
                                    lastColors = colors;
                                }, unregisterChanges = angular.noop;
                                mdThemeController && (unregisterChanges = mdThemeController.registerChanges((function(theme) {
                                    $mdColors.applyThemeColors(element, parseColors(theme));
                                }))), scope.$on("$destroy", (function() {
                                    unregisterChanges();
                                }));
                                try {
                                    shouldWatch ? scope.$watch(parseColors, angular.bind(this, $mdColors.applyThemeColors, element), !0) : $mdColors.applyThemeColors(element, parseColors());
                                } catch (e) {
                                    $log.error(e.message);
                                }
                            };
                        }
                    };
                }
                angular.module("material.components.colors", [ "material.core" ]).directive("mdColors", MdColorsDirective).service("$mdColors", MdColorsService);
            }(), function() {
                function mdContentDirective($mdTheming) {
                    return {
                        restrict: "E",
                        controller: [ "$scope", "$element", function($scope, $element) {
                            this.$scope = $scope, this.$element = $element;
                        } ],
                        link: function(scope, element) {
                            var node;
                            element.addClass("_md"), $mdTheming(element), scope.$broadcast("$mdContentLoaded", element), 
                            node = element[0], angular.element(node).on("$md.pressdown", (function(ev) {
                                "t" === ev.pointer.type && (ev.$materialScrollFixed || (ev.$materialScrollFixed = !0, 
                                0 === node.scrollTop ? node.scrollTop = 1 : node.scrollHeight === node.scrollTop + node.offsetHeight && (node.scrollTop -= 1)));
                            }));
                        }
                    };
                }
                mdContentDirective.$inject = [ "$mdTheming" ], angular.module("material.components.content", [ "material.core" ]).directive("mdContent", mdContentDirective);
            }(), angular.module("material.components.datepicker", [ "material.core", "material.components.icon", "material.components.virtualRepeat" ]), 
            function() {
                function calendarDirective(inputDirective) {
                    return {
                        template: function(tElement, tAttr) {
                            return '<div ng-switch="calendarCtrl.currentView" ' + (tAttr.hasOwnProperty("ngIf") ? "" : 'ng-if="calendarCtrl.isInitialized"') + '><md-calendar-year ng-switch-when="year"></md-calendar-year><md-calendar-month ng-switch-default></md-calendar-month></div>';
                        },
                        scope: {
                            minDate: "=mdMinDate",
                            maxDate: "=mdMaxDate",
                            dateFilter: "=mdDateFilter",
                            monthFilter: "=mdMonthFilter",
                            _mode: "@mdMode",
                            _currentView: "@mdCurrentView"
                        },
                        require: [ "ngModel", "mdCalendar" ],
                        controller: CalendarCtrl,
                        controllerAs: "calendarCtrl",
                        bindToController: !0,
                        link: function(scope, element, attrs, controllers) {
                            var ngModelCtrl = controllers[0];
                            controllers[1].configureNgModel(ngModelCtrl, inputDirective);
                        }
                    };
                }
                CalendarCtrl.$inject = [ "$element", "$scope", "$$mdDateUtil", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$attrs", "$mdDateLocale", "$filter", "$document" ], 
                calendarDirective.$inject = [ "inputDirective" ], angular.module("material.components.datepicker").directive("mdCalendar", calendarDirective);
                var nextUniqueId = 0, MODE_MAP = {
                    day: "month",
                    month: "year"
                };
                function CalendarCtrl($element, $scope, $$mdDateUtil, $mdUtil, $mdConstant, $mdTheming, $$rAF, $attrs, $mdDateLocale, $filter, $document) {
                    $mdTheming($element), this.$element = $element, this.$scope = $scope, this.$attrs = $attrs, 
                    this.dateUtil = $$mdDateUtil, this.$mdUtil = $mdUtil, this.keyCode = $mdConstant.KEY_CODE, 
                    this.$$rAF = $$rAF, this.$mdDateLocale = $mdDateLocale, this.ngDateFilter = $filter("date"), 
                    this.today = this.dateUtil.createDateAtMidnight(), this.ngModelCtrl = void 0, this.SELECTED_DATE_CLASS = "md-calendar-selected-date", 
                    this.TODAY_CLASS = "md-calendar-date-today", this.FOCUSED_DATE_CLASS = "md-focus", 
                    this.id = nextUniqueId++, this.displayDate = null, this.mode = null, this.selectedDate = null, 
                    this.firstRenderableDate = null, this.lastRenderableDate = null, this.isInitialized = !1, 
                    this.width = 0, this.scrollbarWidth = 0, this.standaloneMode = !1, $attrs.tabindex || $element.attr("tabindex", "-1");
                    var handleKeyElement, boundKeyHandler = angular.bind(this, this.handleKeyEvent);
                    $element.parent().hasClass("md-datepicker-calendar") ? handleKeyElement = angular.element($document[0].body) : (this.standaloneMode = !0, 
                    handleKeyElement = $element), handleKeyElement.on("keydown", boundKeyHandler), $scope.$on("$destroy", (function() {
                        handleKeyElement.off("keydown", boundKeyHandler);
                    })), 1 === angular.version.major && angular.version.minor <= 4 && this.$onInit();
                }
                CalendarCtrl.prototype.$onInit = function() {
                    this._mode && MODE_MAP.hasOwnProperty(this._mode) ? (this.currentView = MODE_MAP[this._mode], 
                    this.mode = this._mode) : (this.currentView = this._currentView || "month", this.mode = null), 
                    this.minDate && this.minDate > this.$mdDateLocale.firstRenderableDate ? this.firstRenderableDate = this.minDate : this.firstRenderableDate = this.$mdDateLocale.firstRenderableDate, 
                    this.maxDate && this.maxDate < this.$mdDateLocale.lastRenderableDate ? this.lastRenderableDate = this.maxDate : this.lastRenderableDate = this.$mdDateLocale.lastRenderableDate;
                }, CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl, inputDirective) {
                    var self = this;
                    self.ngModelCtrl = ngModelCtrl, this.$attrs.$set("type", "date"), inputDirective[0].link.pre(this.$scope, {
                        on: angular.noop,
                        val: angular.noop,
                        0: {}
                    }, this.$attrs, [ ngModelCtrl ]), ngModelCtrl.$render = function() {
                        var convertedDate, value = this.$viewValue;
                        self.dateUtil.isValidDate(value) || (convertedDate = self.dateUtil.removeLocalTzAndReparseDate(new Date(value)), 
                        self.dateUtil.isValidDate(convertedDate) && (value = convertedDate)), self.$scope.$broadcast("md-calendar-parent-changed", value), 
                        self.selectedDate || (self.selectedDate = value), self.displayDate || (self.displayDate = self.selectedDate || self.today);
                    }, self.$mdUtil.nextTick((function() {
                        self.isInitialized = !0;
                    }));
                }, CalendarCtrl.prototype.setNgModelValue = function(date) {
                    var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone"), value = this.dateUtil.createDateAtMidnight(date);
                    return this.focusDate(value), this.$scope.$emit("md-calendar-change", value), null == timezone || value.getTimezoneOffset() < 0 ? this.ngModelCtrl.$setViewValue(this.ngDateFilter(value, "yyyy-MM-dd"), "default") : this.ngModelCtrl.$setViewValue(this.ngDateFilter(value, "yyyy-MM-dd", timezone), "default"), 
                    this.ngModelCtrl.$render(), value;
                }, CalendarCtrl.prototype.setCurrentView = function(newView, time) {
                    var self = this;
                    self.$mdUtil.nextTick((function() {
                        self.currentView = newView, time && (self.displayDate = angular.isDate(time) ? time : new Date(time));
                    }));
                }, CalendarCtrl.prototype.focusDate = function(date) {
                    if (this.dateUtil.isValidDate(date)) {
                        var previousFocus = this.$element[0].querySelector("." + this.FOCUSED_DATE_CLASS);
                        previousFocus && previousFocus.classList.remove(this.FOCUSED_DATE_CLASS);
                        var cellId = this.getDateId(date, this.currentView), cell = document.getElementById(cellId);
                        cell && (cell.classList.add(this.FOCUSED_DATE_CLASS), cell.focus(), this.displayDate = date);
                    } else {
                        var rootElement = this.$element[0].querySelector("[ng-switch]");
                        rootElement && rootElement.focus();
                    }
                }, CalendarCtrl.prototype.changeSelectedDate = function(date) {
                    var selectedDateClass = this.SELECTED_DATE_CLASS, prevDateCell = this.$element[0].querySelector("." + selectedDateClass);
                    if (prevDateCell && (prevDateCell.classList.remove(selectedDateClass), prevDateCell.setAttribute("aria-selected", "false")), 
                    date) {
                        var dateCell = document.getElementById(this.getDateId(date, this.currentView));
                        dateCell && (dateCell.classList.add(selectedDateClass), dateCell.setAttribute("aria-selected", "true"));
                    }
                    this.selectedDate = date;
                }, CalendarCtrl.prototype.getActionFromKeyEvent = function(event) {
                    var keyCode = this.keyCode;
                    switch (event.which) {
                      case keyCode.ENTER:
                        return "select";

                      case keyCode.RIGHT_ARROW:
                        return "move-right";

                      case keyCode.LEFT_ARROW:
                        return "move-left";

                      case keyCode.DOWN_ARROW:
                        return event.metaKey ? "move-page-down" : "move-row-down";

                      case keyCode.UP_ARROW:
                        return event.metaKey ? "move-page-up" : "move-row-up";

                      case keyCode.PAGE_DOWN:
                        return "move-page-down";

                      case keyCode.PAGE_UP:
                        return "move-page-up";

                      case keyCode.HOME:
                        return "start";

                      case keyCode.END:
                        return "end";

                      default:
                        return null;
                    }
                }, CalendarCtrl.prototype.handleKeyEvent = function(event) {
                    var self = this;
                    this.$scope.$apply((function() {
                        if (event.which === self.keyCode.ESCAPE || event.which === self.keyCode.TAB && !self.standaloneMode) return self.$scope.$emit("md-calendar-close"), 
                        void (event.which === self.keyCode.TAB && event.preventDefault());
                        if (event.which !== self.keyCode.TAB || !self.standaloneMode) {
                            var action = self.getActionFromKeyEvent(event);
                            action && (event.preventDefault(), event.stopPropagation(), self.$scope.$broadcast("md-calendar-parent-action", action));
                        }
                    }));
                }, CalendarCtrl.prototype.hideVerticalScrollbar = function(childCtrl) {
                    var self = this, element = childCtrl.$element[0], scrollMask = element.querySelector(".md-calendar-scroll-mask");
                    function setWidth() {
                        var width = self.width || 340, scrollbarWidth = self.scrollbarWidth, scroller = childCtrl.calendarScroller;
                        scrollMask.style.width = width + "px", scroller.style.width = width + scrollbarWidth + "px", 
                        scroller.style.paddingRight = scrollbarWidth + "px";
                    }
                    self.width > 0 ? setWidth() : self.$$rAF((function() {
                        var scroller = childCtrl.calendarScroller;
                        self.scrollbarWidth = scroller.offsetWidth - scroller.clientWidth, self.width = element.querySelector("table").offsetWidth, 
                        setWidth();
                    }));
                }, CalendarCtrl.prototype.getDateId = function(date, namespace) {
                    if (!namespace) throw new Error("A namespace for the date id has to be specified.");
                    return [ "md", this.id, namespace, date.getFullYear(), date.getMonth(), date.getDate() ].join("-");
                }, CalendarCtrl.prototype.updateVirtualRepeat = function() {
                    var scope = this.$scope, virtualRepeatResizeListener = scope.$on("$md-resize-enable", (function() {
                        scope.$$phase || scope.$apply(), virtualRepeatResizeListener();
                    }));
                };
            }(), function() {
                CalendarMonthCtrl.$inject = [ "$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdDateLocale" ], 
                angular.module("material.components.datepicker").directive("mdCalendarMonth", (function() {
                    return {
                        template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table><div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container" md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-month-body role="rowgroup" md-virtual-repeat="i in monthCtrl.items" md-month-offset="$index" class="md-calendar-month" md-start-index="monthCtrl.getSelectedMonthIndex()" md-item-size="' + TBODY_HEIGHT + '"><tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + "px'\"></tr></tbody></table></md-virtual-repeat-container></div>",
                        require: [ "^^mdCalendar", "mdCalendarMonth" ],
                        controller: CalendarMonthCtrl,
                        controllerAs: "monthCtrl",
                        bindToController: !0,
                        link: function(scope, element, attrs, controllers) {
                            var calendarCtrl = controllers[0];
                            controllers[1].initialize(calendarCtrl);
                        }
                    };
                }));
                var TBODY_HEIGHT = 265, TBODY_SINGLE_ROW_HEIGHT = 45;
                function CalendarMonthCtrl($element, $scope, $animate, $q, $$mdDateUtil, $mdDateLocale) {
                    this.$element = $element, this.$scope = $scope, this.$animate = $animate, this.$q = $q, 
                    this.dateUtil = $$mdDateUtil, this.dateLocale = $mdDateLocale, this.calendarScroller = $element[0].querySelector(".md-virtual-repeat-scroller"), 
                    this.isInitialized = !1, this.isMonthTransitionInProgress = !1;
                    var self = this;
                    this.cellClickHandler = function() {
                        var timestamp = $$mdDateUtil.getTimestampFromNode(this);
                        self.$scope.$apply((function() {
                            self.calendarCtrl.setNgModelValue(new Date(timestamp));
                        }));
                    }, this.headerClickHandler = function() {
                        self.calendarCtrl.setCurrentView("year", $$mdDateUtil.getTimestampFromNode(this));
                    };
                }
                CalendarMonthCtrl.prototype.initialize = function(calendarCtrl) {
                    this.items = {
                        length: this.dateUtil.getMonthDistance(calendarCtrl.firstRenderableDate, calendarCtrl.lastRenderableDate) + 2
                    }, this.calendarCtrl = calendarCtrl, this.attachScopeListeners(), calendarCtrl.updateVirtualRepeat(), 
                    calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();
                }, CalendarMonthCtrl.prototype.getSelectedMonthIndex = function() {
                    var calendarCtrl = this.calendarCtrl;
                    return this.dateUtil.getMonthDistance(calendarCtrl.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today);
                }, CalendarMonthCtrl.prototype.changeDisplayDate = function(date) {
                    if (!this.isInitialized) return this.buildWeekHeader(), this.calendarCtrl.hideVerticalScrollbar(this), 
                    this.isInitialized = !0, this.$q.when();
                    if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) return this.$q.when();
                    this.isMonthTransitionInProgress = !0;
                    var animationPromise = this.animateDateChange(date);
                    this.calendarCtrl.displayDate = date;
                    var self = this;
                    return animationPromise.then((function() {
                        self.isMonthTransitionInProgress = !1;
                    })), animationPromise;
                }, CalendarMonthCtrl.prototype.animateDateChange = function(date) {
                    if (this.dateUtil.isValidDate(date)) {
                        var monthDistance = this.dateUtil.getMonthDistance(this.calendarCtrl.firstRenderableDate, date);
                        this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
                    }
                    return this.$q.when();
                }, CalendarMonthCtrl.prototype.buildWeekHeader = function() {
                    for (var firstDayOfWeek = this.dateLocale.firstDayOfWeek, shortDays = this.dateLocale.shortDays, row = document.createElement("tr"), i = 0; i < 7; i++) {
                        var th = document.createElement("th");
                        th.textContent = shortDays[(i + firstDayOfWeek) % 7], row.appendChild(th);
                    }
                    this.$element.find("thead").append(row);
                }, CalendarMonthCtrl.prototype.attachScopeListeners = function() {
                    var self = this;
                    self.$scope.$on("md-calendar-parent-changed", (function(event, value) {
                        self.calendarCtrl.changeSelectedDate(value), self.changeDisplayDate(value);
                    })), self.$scope.$on("md-calendar-parent-action", angular.bind(this, this.handleKeyEvent));
                }, CalendarMonthCtrl.prototype.handleKeyEvent = function(event, action) {
                    var calendarCtrl = this.calendarCtrl, displayDate = calendarCtrl.displayDate;
                    if ("select" === action) calendarCtrl.setNgModelValue(displayDate); else {
                        var date = null, dateUtil = this.dateUtil;
                        switch (action) {
                          case "move-right":
                            date = dateUtil.incrementDays(displayDate, 1);
                            break;

                          case "move-left":
                            date = dateUtil.incrementDays(displayDate, -1);
                            break;

                          case "move-page-down":
                            date = dateUtil.incrementMonths(displayDate, 1);
                            break;

                          case "move-page-up":
                            date = dateUtil.incrementMonths(displayDate, -1);
                            break;

                          case "move-row-down":
                            date = dateUtil.incrementDays(displayDate, 7);
                            break;

                          case "move-row-up":
                            date = dateUtil.incrementDays(displayDate, -7);
                            break;

                          case "start":
                            date = dateUtil.getFirstDateOfMonth(displayDate);
                            break;

                          case "end":
                            date = dateUtil.getLastDateOfMonth(displayDate);
                        }
                        date && (date = this.dateUtil.clampDate(date, calendarCtrl.minDate, calendarCtrl.maxDate), 
                        this.changeDisplayDate(date).then((function() {
                            calendarCtrl.focusDate(date);
                        })));
                    }
                };
            }(), function() {
                function mdCalendarMonthBodyDirective($compile, $$mdSvgRegistry) {
                    var ARROW_ICON = $compile('<md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon>')({})[0];
                    return {
                        require: [ "^^mdCalendar", "^^mdCalendarMonth", "mdCalendarMonthBody" ],
                        scope: {
                            offset: "=mdMonthOffset"
                        },
                        controller: CalendarMonthBodyCtrl,
                        controllerAs: "mdMonthBodyCtrl",
                        bindToController: !0,
                        link: function(scope, element, attrs, controllers) {
                            var calendarCtrl = controllers[0], monthCtrl = controllers[1], monthBodyCtrl = controllers[2];
                            monthBodyCtrl.calendarCtrl = calendarCtrl, monthBodyCtrl.monthCtrl = monthCtrl, 
                            monthBodyCtrl.arrowIcon = ARROW_ICON.cloneNode(!0), scope.$watch((function() {
                                return monthBodyCtrl.offset;
                            }), (function(offset) {
                                angular.isNumber(offset) && monthBodyCtrl.generateContent();
                            }));
                        }
                    };
                }
                function CalendarMonthBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {
                    this.$element = $element, this.dateUtil = $$mdDateUtil, this.dateLocale = $mdDateLocale, 
                    this.monthCtrl = null, this.calendarCtrl = null, this.offset = null, this.focusAfterAppend = null;
                }
                mdCalendarMonthBodyDirective.$inject = [ "$compile", "$$mdSvgRegistry" ], CalendarMonthBodyCtrl.$inject = [ "$element", "$$mdDateUtil", "$mdDateLocale" ], 
                angular.module("material.components.datepicker").directive("mdCalendarMonthBody", mdCalendarMonthBodyDirective), 
                CalendarMonthBodyCtrl.prototype.generateContent = function() {
                    var date = this.dateUtil.incrementMonths(this.calendarCtrl.firstRenderableDate, this.offset);
                    this.$element.empty().append(this.buildCalendarForMonth(date)), this.focusAfterAppend && (this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS), 
                    this.focusAfterAppend = null);
                }, CalendarMonthBodyCtrl.prototype.buildDateCell = function(opt_date) {
                    var monthCtrl = this.monthCtrl, calendarCtrl = this.calendarCtrl, cell = document.createElement("td");
                    if (cell.tabIndex = -1, cell.classList.add("md-calendar-date"), cell.setAttribute("role", "gridcell"), 
                    opt_date) {
                        cell.setAttribute("tabindex", "-1"), cell.setAttribute("aria-label", this.dateLocale.longDateFormatter(opt_date)), 
                        cell.id = calendarCtrl.getDateId(opt_date, "month"), cell.setAttribute("data-timestamp", opt_date.getTime()), 
                        this.dateUtil.isSameDay(opt_date, calendarCtrl.today) && cell.classList.add(calendarCtrl.TODAY_CLASS), 
                        this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate) && (cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS), 
                        cell.setAttribute("aria-selected", "true"));
                        var cellText = this.dateLocale.dates[opt_date.getDate()];
                        if (this.isDateEnabled(opt_date)) {
                            var selectionIndicator = document.createElement("span");
                            selectionIndicator.classList.add("md-calendar-date-selection-indicator"), selectionIndicator.textContent = cellText, 
                            cell.appendChild(selectionIndicator), cell.addEventListener("click", monthCtrl.cellClickHandler), 
                            calendarCtrl.displayDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.displayDate) && (this.focusAfterAppend = cell);
                        } else cell.classList.add("md-calendar-date-disabled"), cell.textContent = cellText;
                    }
                    return cell;
                }, CalendarMonthBodyCtrl.prototype.isDateEnabled = function(opt_date) {
                    return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date));
                }, CalendarMonthBodyCtrl.prototype.buildDateRow = function(rowNumber) {
                    var row = document.createElement("tr");
                    return row.setAttribute("role", "row"), row.setAttribute("aria-label", this.dateLocale.weekNumberFormatter(rowNumber)), 
                    row;
                }, CalendarMonthBodyCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
                    var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date, firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date), firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth), numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date), monthBody = document.createDocumentFragment(), rowNumber = 1, row = this.buildDateRow(rowNumber);
                    monthBody.appendChild(row);
                    var isFinalMonth = this.offset === this.monthCtrl.items.length - 1, blankCellOffset = 0, monthLabelCell = document.createElement("td"), monthLabelCellContent = document.createElement("span"), calendarCtrl = this.calendarCtrl;
                    if (monthLabelCellContent.textContent = this.dateLocale.monthHeaderFormatter(date), 
                    monthLabelCell.appendChild(monthLabelCellContent), monthLabelCell.classList.add("md-calendar-month-label"), 
                    calendarCtrl.maxDate && firstDayOfMonth > calendarCtrl.maxDate ? monthLabelCell.classList.add("md-calendar-month-label-disabled") : calendarCtrl.mode || (monthLabelCell.addEventListener("click", this.monthCtrl.headerClickHandler), 
                    monthLabelCell.setAttribute("data-timestamp", firstDayOfMonth.getTime()), monthLabelCell.setAttribute("aria-label", this.dateLocale.monthFormatter(date)), 
                    monthLabelCell.classList.add("md-calendar-label-clickable"), monthLabelCell.appendChild(this.arrowIcon.cloneNode(!0))), 
                    firstDayOfTheWeek <= 2) {
                        monthLabelCell.setAttribute("colspan", "7");
                        var monthLabelRow = this.buildDateRow();
                        if (monthLabelRow.appendChild(monthLabelCell), monthBody.insertBefore(monthLabelRow, row), 
                        isFinalMonth) return monthBody;
                    } else blankCellOffset = 3, monthLabelCell.setAttribute("colspan", "3"), row.appendChild(monthLabelCell);
                    for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) row.appendChild(this.buildDateCell());
                    for (var dayOfWeek = firstDayOfTheWeek, iterationDate = firstDayOfMonth, d = 1; d <= numberOfDaysInMonth; d++) {
                        if (7 === dayOfWeek) {
                            if (isFinalMonth) return monthBody;
                            dayOfWeek = 0, rowNumber++, row = this.buildDateRow(rowNumber), monthBody.appendChild(row);
                        }
                        iterationDate.setDate(d);
                        var cell = this.buildDateCell(iterationDate);
                        row.appendChild(cell), dayOfWeek++;
                    }
                    for (;row.childNodes.length < 7; ) row.appendChild(this.buildDateCell());
                    for (;monthBody.childNodes.length < 6; ) {
                        for (var whitespaceRow = this.buildDateRow(), j = 0; j < 7; j++) whitespaceRow.appendChild(this.buildDateCell());
                        monthBody.appendChild(whitespaceRow);
                    }
                    return monthBody;
                }, CalendarMonthBodyCtrl.prototype.getLocaleDay_ = function(date) {
                    return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
                };
            }(), function() {
                CalendarYearCtrl.$inject = [ "$element", "$scope", "$animate", "$q", "$$mdDateUtil", "$mdUtil" ], 
                angular.module("material.components.datepicker").directive("mdCalendarYear", (function() {
                    return {
                        template: '<div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody md-calendar-year-body role="rowgroup" md-virtual-repeat="i in yearCtrl.items" md-year-offset="$index" class="md-calendar-year" md-start-index="yearCtrl.getFocusedYearIndex()" md-item-size="' + TBODY_HEIGHT + '"><tr aria-hidden="true" md-force-height="\'' + TBODY_HEIGHT + "px'\"></tr></tbody></table></md-virtual-repeat-container></div>",
                        require: [ "^^mdCalendar", "mdCalendarYear" ],
                        controller: CalendarYearCtrl,
                        controllerAs: "yearCtrl",
                        bindToController: !0,
                        link: function(scope, element, attrs, controllers) {
                            var calendarCtrl = controllers[0];
                            controllers[1].initialize(calendarCtrl);
                        }
                    };
                }));
                var TBODY_HEIGHT = 88;
                function CalendarYearCtrl($element, $scope, $animate, $q, $$mdDateUtil, $mdUtil) {
                    this.$element = $element, this.$scope = $scope, this.$animate = $animate, this.$q = $q, 
                    this.dateUtil = $$mdDateUtil, this.calendarScroller = $element[0].querySelector(".md-virtual-repeat-scroller"), 
                    this.isInitialized = !1, this.isMonthTransitionInProgress = !1, this.$mdUtil = $mdUtil;
                    var self = this;
                    this.cellClickHandler = function() {
                        self.onTimestampSelected($$mdDateUtil.getTimestampFromNode(this));
                    };
                }
                CalendarYearCtrl.prototype.initialize = function(calendarCtrl) {
                    this.items = {
                        length: this.dateUtil.getYearDistance(calendarCtrl.firstRenderableDate, calendarCtrl.lastRenderableDate) + 1
                    }, this.calendarCtrl = calendarCtrl, this.attachScopeListeners(), calendarCtrl.updateVirtualRepeat(), 
                    calendarCtrl.ngModelCtrl && calendarCtrl.ngModelCtrl.$render();
                }, CalendarYearCtrl.prototype.getFocusedYearIndex = function() {
                    var calendarCtrl = this.calendarCtrl;
                    return this.dateUtil.getYearDistance(calendarCtrl.firstRenderableDate, calendarCtrl.displayDate || calendarCtrl.selectedDate || calendarCtrl.today);
                }, CalendarYearCtrl.prototype.changeDate = function(date) {
                    if (!this.isInitialized) return this.calendarCtrl.hideVerticalScrollbar(this), this.isInitialized = !0, 
                    this.$q.when();
                    if (this.dateUtil.isValidDate(date) && !this.isMonthTransitionInProgress) {
                        var self = this, animationPromise = this.animateDateChange(date);
                        return self.isMonthTransitionInProgress = !0, self.calendarCtrl.displayDate = date, 
                        animationPromise.then((function() {
                            self.isMonthTransitionInProgress = !1;
                        }));
                    }
                }, CalendarYearCtrl.prototype.animateDateChange = function(date) {
                    if (this.dateUtil.isValidDate(date)) {
                        var monthDistance = this.dateUtil.getYearDistance(this.calendarCtrl.firstRenderableDate, date);
                        this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
                    }
                    return this.$q.when();
                }, CalendarYearCtrl.prototype.handleKeyEvent = function(event, action) {
                    var self = this, calendarCtrl = self.calendarCtrl, displayDate = calendarCtrl.displayDate;
                    if ("select" === action) self.changeDate(displayDate).then((function() {
                        self.onTimestampSelected(displayDate);
                    })); else {
                        var date = null, dateUtil = self.dateUtil;
                        switch (action) {
                          case "move-right":
                            date = dateUtil.incrementMonths(displayDate, 1);
                            break;

                          case "move-left":
                            date = dateUtil.incrementMonths(displayDate, -1);
                            break;

                          case "move-row-down":
                            date = dateUtil.incrementMonths(displayDate, 6);
                            break;

                          case "move-row-up":
                            date = dateUtil.incrementMonths(displayDate, -6);
                        }
                        if (date) {
                            var min = calendarCtrl.minDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.minDate) : null, max = calendarCtrl.maxDate ? dateUtil.getFirstDateOfMonth(calendarCtrl.maxDate) : null;
                            date = dateUtil.getFirstDateOfMonth(self.dateUtil.clampDate(date, min, max)), self.changeDate(date).then((function() {
                                calendarCtrl.focusDate(date);
                            }));
                        }
                    }
                }, CalendarYearCtrl.prototype.attachScopeListeners = function() {
                    var self = this;
                    self.$scope.$on("md-calendar-parent-changed", (function(event, value) {
                        self.calendarCtrl.changeSelectedDate(value ? self.dateUtil.getFirstDateOfMonth(value) : value), 
                        self.changeDate(value);
                    })), self.$scope.$on("md-calendar-parent-action", angular.bind(self, self.handleKeyEvent));
                }, CalendarYearCtrl.prototype.onTimestampSelected = function(timestamp) {
                    var calendarCtrl = this.calendarCtrl;
                    calendarCtrl.mode ? this.$mdUtil.nextTick((function() {
                        calendarCtrl.setNgModelValue(new Date(timestamp));
                    })) : calendarCtrl.setCurrentView("month", timestamp);
                };
            }(), function() {
                function CalendarYearBodyCtrl($element, $$mdDateUtil, $mdDateLocale) {
                    this.$element = $element, this.dateUtil = $$mdDateUtil, this.dateLocale = $mdDateLocale, 
                    this.calendarCtrl = null, this.yearCtrl = null, this.offset = null, this.focusAfterAppend = null;
                }
                CalendarYearBodyCtrl.$inject = [ "$element", "$$mdDateUtil", "$mdDateLocale" ], 
                angular.module("material.components.datepicker").directive("mdCalendarYearBody", (function() {
                    return {
                        require: [ "^^mdCalendar", "^^mdCalendarYear", "mdCalendarYearBody" ],
                        scope: {
                            offset: "=mdYearOffset"
                        },
                        controller: CalendarYearBodyCtrl,
                        controllerAs: "mdYearBodyCtrl",
                        bindToController: !0,
                        link: function(scope, element, attrs, controllers) {
                            var calendarCtrl = controllers[0], yearCtrl = controllers[1], yearBodyCtrl = controllers[2];
                            yearBodyCtrl.calendarCtrl = calendarCtrl, yearBodyCtrl.yearCtrl = yearCtrl, scope.$watch((function() {
                                return yearBodyCtrl.offset;
                            }), (function(offset) {
                                angular.isNumber(offset) && yearBodyCtrl.generateContent();
                            }));
                        }
                    };
                })), CalendarYearBodyCtrl.prototype.generateContent = function() {
                    var date = this.dateUtil.incrementYears(this.calendarCtrl.firstRenderableDate, this.offset);
                    this.$element.empty().append(this.buildCalendarForYear(date)), this.focusAfterAppend && (this.focusAfterAppend.classList.add(this.calendarCtrl.FOCUSED_DATE_CLASS), 
                    this.focusAfterAppend = null);
                }, CalendarYearBodyCtrl.prototype.buildMonthCell = function(year, month) {
                    var calendarCtrl = this.calendarCtrl, yearCtrl = this.yearCtrl, cell = this.buildBlankCell(), firstOfMonth = new Date(year, month, 1);
                    cell.setAttribute("aria-label", this.dateLocale.monthFormatter(firstOfMonth)), cell.id = calendarCtrl.getDateId(firstOfMonth, "year"), 
                    cell.setAttribute("data-timestamp", String(firstOfMonth.getTime())), this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.today) && cell.classList.add(calendarCtrl.TODAY_CLASS), 
                    this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.selectedDate) && (cell.classList.add(calendarCtrl.SELECTED_DATE_CLASS), 
                    cell.setAttribute("aria-selected", "true"));
                    var cellText = this.dateLocale.shortMonths[month];
                    if (!this.dateUtil.isMonthWithinRange(firstOfMonth, calendarCtrl.minDate, calendarCtrl.maxDate) || angular.isFunction(calendarCtrl.monthFilter) && !calendarCtrl.monthFilter(firstOfMonth)) cell.classList.add("md-calendar-date-disabled"), 
                    cell.textContent = cellText; else {
                        var selectionIndicator = document.createElement("span");
                        selectionIndicator.classList.add("md-calendar-date-selection-indicator"), selectionIndicator.textContent = cellText, 
                        cell.appendChild(selectionIndicator), cell.addEventListener("click", yearCtrl.cellClickHandler), 
                        calendarCtrl.displayDate && this.dateUtil.isSameMonthAndYear(firstOfMonth, calendarCtrl.displayDate) && (this.focusAfterAppend = cell);
                    }
                    return cell;
                }, CalendarYearBodyCtrl.prototype.buildBlankCell = function() {
                    var cell = document.createElement("td");
                    return cell.tabIndex = -1, cell.classList.add("md-calendar-date"), cell.setAttribute("role", "gridcell"), 
                    cell.setAttribute("tabindex", "-1"), cell;
                }, CalendarYearBodyCtrl.prototype.buildCalendarForYear = function(date) {
                    var i, year = date.getFullYear(), yearBody = document.createDocumentFragment(), firstRow = document.createElement("tr"), labelCell = document.createElement("td");
                    for (labelCell.className = "md-calendar-month-label", labelCell.textContent = String(year), 
                    firstRow.appendChild(labelCell), i = 0; i < 6; i++) firstRow.appendChild(this.buildMonthCell(year, i));
                    yearBody.appendChild(firstRow);
                    var secondRow = document.createElement("tr");
                    for (secondRow.appendChild(this.buildBlankCell()), i = 6; i < 12; i++) secondRow.appendChild(this.buildMonthCell(year, i));
                    return yearBody.appendChild(secondRow), yearBody;
                };
            }(), angular.module("material.components.datepicker").config([ "$provide", function($provide) {
                function DateLocaleProvider() {
                    this.months = null, this.shortMonths = null, this.days = null, this.shortDays = null, 
                    this.dates = null, this.firstDayOfWeek = 0, this.formatDate = null, this.parseDate = null, 
                    this.monthHeaderFormatter = null, this.weekNumberFormatter = null, this.longDateFormatter = null, 
                    this.isDateComplete = null, this.msgCalendar = "", this.msgOpenCalendar = "";
                }
                DateLocaleProvider.prototype.$get = function($locale, $filter) {
                    for (var defaultShortDays = $locale.DATETIME_FORMATS.SHORTDAY.map((function(day) {
                        return day.substring(0, 1);
                    })), defaultDates = Array(32), i = 1; i <= 31; i++) defaultDates[i] = i;
                    var defaultFirstRenderableDate = new Date(1880, 0, 1), defaultLastRendereableDate = new Date(defaultFirstRenderableDate.getFullYear() + 250, 0, 1), service = {
                        months: this.months || $locale.DATETIME_FORMATS.MONTH,
                        shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
                        days: this.days || $locale.DATETIME_FORMATS.DAY,
                        shortDays: this.shortDays || defaultShortDays,
                        dates: this.dates || defaultDates,
                        firstDayOfWeek: this.firstDayOfWeek || 0,
                        formatDate: this.formatDate || function(date, timezone) {
                            if (!date) return "";
                            var localeTime = date.toLocaleTimeString(), formatDate = date;
                            return 0 !== date.getHours() || -1 === localeTime.indexOf("11:") && -1 === localeTime.indexOf("23:") || (formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0)), 
                            $filter("date")(formatDate, "M/d/yyyy", timezone);
                        },
                        parseDate: this.parseDate || function(dateString) {
                            return new Date(dateString);
                        },
                        isDateComplete: this.isDateComplete || function(dateString) {
                            return dateString = dateString.trim(), /^(([a-zA-Z]{3,}|[0-9]{1,4})([ .,]+|[/-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/.test(dateString);
                        },
                        monthHeaderFormatter: this.monthHeaderFormatter || function(date) {
                            return service.shortMonths[date.getMonth()] + " " + date.getFullYear();
                        },
                        monthFormatter: this.monthFormatter || function(date) {
                            return service.months[date.getMonth()] + " " + date.getFullYear();
                        },
                        weekNumberFormatter: this.weekNumberFormatter || function(number) {
                            return "Week " + number;
                        },
                        longDateFormatter: this.longDateFormatter || function(date) {
                            return [ service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear() ].join(" ");
                        },
                        msgCalendar: this.msgCalendar || "Calendar",
                        msgOpenCalendar: this.msgOpenCalendar || "Open calendar",
                        firstRenderableDate: this.firstRenderableDate || defaultFirstRenderableDate,
                        lastRenderableDate: this.lastRenderableDate || defaultLastRendereableDate
                    };
                    return service;
                }, DateLocaleProvider.prototype.$get.$inject = [ "$locale", "$filter" ], $provide.provider("$mdDateLocale", new DateLocaleProvider);
            } ]), angular.module("material.components.datepicker").factory("$$mdDateUtil", [ "$mdDateLocale", function($mdDateLocale) {
                return {
                    getFirstDateOfMonth,
                    getNumberOfDaysInMonth,
                    getDateInNextMonth,
                    getDateInPreviousMonth,
                    isInNextMonth: function(startDate, endDate) {
                        return isSameMonthAndYear(getDateInNextMonth(startDate), endDate);
                    },
                    isInPreviousMonth: function(startDate, endDate) {
                        var previousMonth = getDateInPreviousMonth(startDate);
                        return isSameMonthAndYear(endDate, previousMonth);
                    },
                    getDateMidpoint: function(d1, d2) {
                        return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
                    },
                    isSameMonthAndYear,
                    getWeekOfMonth: function(date) {
                        var firstDayOfMonth = getFirstDateOfMonth(date);
                        return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
                    },
                    incrementDays: function(date, numberOfDays) {
                        return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
                    },
                    incrementMonths,
                    getLastDateOfMonth: function(date) {
                        return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
                    },
                    isSameDay: function(d1, d2) {
                        return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
                    },
                    getMonthDistance: function(start, end) {
                        return 12 * (end.getFullYear() - start.getFullYear()) + (end.getMonth() - start.getMonth());
                    },
                    isValidDate,
                    setDateTimeToMidnight,
                    createDateAtMidnight,
                    isDateWithinRange: function(date, minDate, maxDate) {
                        var dateAtMidnight = createDateAtMidnight(date), minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null, maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
                        return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
                    },
                    incrementYears: function(date, numberOfYears) {
                        return incrementMonths(date, 12 * numberOfYears);
                    },
                    getYearDistance: function(start, end) {
                        return end.getFullYear() - start.getFullYear();
                    },
                    clampDate: function(date, minDate, maxDate) {
                        var boundDate = date;
                        return minDate && date < minDate && (boundDate = new Date(minDate.getTime())), maxDate && date > maxDate && (boundDate = new Date(maxDate.getTime())), 
                        boundDate;
                    },
                    getTimestampFromNode: function(node) {
                        if (node && node.hasAttribute("data-timestamp")) return Number(node.getAttribute("data-timestamp"));
                    },
                    isMonthWithinRange: function(date, minDate, maxDate) {
                        var month = date.getMonth(), year = date.getFullYear();
                        return (!minDate || minDate.getFullYear() < year || minDate.getMonth() <= month) && (!maxDate || maxDate.getFullYear() > year || maxDate.getMonth() >= month);
                    },
                    removeLocalTzAndReparseDate: function(value) {
                        var dateValue, formattedDate;
                        return dateValue = new Date(value.getTime() + 6e4 * value.getTimezoneOffset()), 
                        formattedDate = $mdDateLocale.formatDate(dateValue), $mdDateLocale.parseDate(formattedDate);
                    }
                };
                function getFirstDateOfMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth(), 1);
                }
                function getNumberOfDaysInMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                }
                function getDateInNextMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() + 1, 1);
                }
                function getDateInPreviousMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() - 1, 1);
                }
                function isSameMonthAndYear(d1, d2) {
                    return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
                }
                function incrementMonths(date, numberOfMonths) {
                    var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1), numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
                    return numberOfDaysInMonth < date.getDate() ? dateInTargetMonth.setDate(numberOfDaysInMonth) : dateInTargetMonth.setDate(date.getDate()), 
                    dateInTargetMonth;
                }
                function isValidDate(date) {
                    return date && date.getTime && !isNaN(date.getTime());
                }
                function setDateTimeToMidnight(date) {
                    isValidDate(date) && date.setHours(0, 0, 0, 0);
                }
                function createDateAtMidnight(opt_value) {
                    var date;
                    return setDateTimeToMidnight(date = angular.isDate(opt_value) ? opt_value : angular.isNumber(opt_value) ? new Date(opt_value) : new Date), 
                    date;
                }
            } ]), function() {
                function datePickerDirective($$mdSvgRegistry, $mdUtil, $mdAria, inputDirective) {
                    return {
                        template: function(tElement, tAttrs) {
                            var hiddenIcons = tAttrs.mdHideIcons, inputAriaDescribedby = tAttrs.inputAriaDescribedby, inputAriaLabelledby = tAttrs.inputAriaLabelledby, ariaLabelValue = tAttrs.ariaLabel || tAttrs.mdPlaceholder, ngModelOptions = tAttrs.ngModelOptions, calendarButton = "all" === hiddenIcons || "calendar" === hiddenIcons ? "" : '<md-button class="md-datepicker-button md-icon-button" type="button" tabindex="-1" aria-hidden="true" ng-click="ctrl.openCalendarPane($event)"><md-icon class="md-datepicker-calendar-icon" aria-label="md-calendar" md-svg-src="' + $$mdSvgRegistry.mdCalendar + '"></md-icon></md-button>', triangleButton = "";
                            return "all" !== hiddenIcons && "triangle" !== hiddenIcons && (triangleButton = '<md-button type="button" md-no-ink class="md-datepicker-triangle-button md-icon-button" ng-click="ctrl.openCalendarPane($event)" aria-label="{{::ctrl.locale.msgOpenCalendar}}"><div class="md-datepicker-expand-triangle"></div></md-button>', 
                            tElement.addClass(HAS_TRIANGLE_ICON_CLASS)), calendarButton + '<div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}"><input ' + (ariaLabelValue ? 'aria-label="' + ariaLabelValue + '" ' : "") + (inputAriaDescribedby ? 'aria-describedby="' + inputAriaDescribedby + '" ' : "") + (inputAriaLabelledby ? 'aria-labelledby="' + inputAriaLabelledby + '" ' : "") + 'class="md-datepicker-input" aria-haspopup="dialog" ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)"> ' + triangleButton + '</div><div class="md-datepicker-calendar-pane md-whiteframe-z1" id="{{::ctrl.calendarPaneId}}"><div class="md-datepicker-input-mask"><div class="md-datepicker-input-mask-opaque"></div></div><div class="md-datepicker-calendar"><md-calendar role="dialog" aria-label="{{::ctrl.locale.msgCalendar}}" md-current-view="{{::ctrl.currentView}}" md-mode="{{::ctrl.mode}}" md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate" md-date-filter="ctrl.dateFilter" md-month-filter="ctrl.monthFilter" ' + (ngModelOptions ? 'ng-model-options="' + ngModelOptions + '" ' : "") + 'ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen"></md-calendar></div></div>';
                        },
                        require: [ "ngModel", "mdDatepicker", "?^mdInputContainer", "?^form" ],
                        scope: {
                            minDate: "=mdMinDate",
                            maxDate: "=mdMaxDate",
                            placeholder: "@mdPlaceholder",
                            currentView: "@mdCurrentView",
                            mode: "@mdMode",
                            dateFilter: "=mdDateFilter",
                            monthFilter: "=mdMonthFilter",
                            isOpen: "=?mdIsOpen",
                            debounceInterval: "=mdDebounceInterval",
                            dateLocale: "=mdDateLocale"
                        },
                        controller: DatePickerCtrl,
                        controllerAs: "ctrl",
                        bindToController: !0,
                        link: function(scope, element, attr, controllers) {
                            var ngModelCtrl = controllers[0], mdDatePickerCtrl = controllers[1], mdInputContainer = controllers[2], parentForm = controllers[3], mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk);
                            if (mdDatePickerCtrl.configureNgModel(ngModelCtrl, mdInputContainer, inputDirective), 
                            mdInputContainer) {
                                var spacer = element[0].querySelector(".md-errors-spacer");
                                spacer && element.after(angular.element("<div>").append(spacer)), mdInputContainer.setHasPlaceholder(attr.mdPlaceholder), 
                                mdInputContainer.input = element, mdInputContainer.element.addClass(INPUT_CONTAINER_CLASS).toggleClass(HAS_CALENDAR_ICON_CLASS, "calendar" !== attr.mdHideIcons && "all" !== attr.mdHideIcons), 
                                mdInputContainer.label ? mdNoAsterisk || attr.$observe("required", (function(value) {
                                    mdInputContainer.label.toggleClass("md-required", !!value);
                                })) : $mdAria.expect(element, "aria-label", attr.mdPlaceholder), scope.$watch(mdInputContainer.isErrorGetter || function() {
                                    return ngModelCtrl.$invalid && (ngModelCtrl.$touched || parentForm && parentForm.$submitted);
                                }, mdInputContainer.setInvalid);
                            } else if (parentForm) var parentSubmittedWatcher = scope.$watch((function() {
                                return parentForm.$submitted;
                            }), (function(isSubmitted) {
                                isSubmitted && (mdDatePickerCtrl.updateErrorState(), parentSubmittedWatcher());
                            }));
                        }
                    };
                }
                DatePickerCtrl.$inject = [ "$scope", "$element", "$attrs", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF", "$filter", "$timeout" ], 
                datePickerDirective.$inject = [ "$$mdSvgRegistry", "$mdUtil", "$mdAria", "inputDirective" ], 
                angular.module("material.components.datepicker").directive("mdDatepicker", datePickerDirective);
                var OPEN_CLASS = "md-datepicker-open", INPUT_CONTAINER_CLASS = "_md-datepicker-floating-label", HAS_CALENDAR_ICON_CLASS = "_md-datepicker-has-calendar-icon", HAS_TRIANGLE_ICON_CLASS = "_md-datepicker-has-triangle-icon", IS_MOBILE_REGEX = /ipad|iphone|ipod|android/i;
                function DatePickerCtrl($scope, $element, $attrs, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF, $filter, $timeout) {
                    this.$window = $window, this.dateUtil = $$mdDateUtil, this.$mdConstant = $mdConstant, 
                    this.$mdUtil = $mdUtil, this.$$rAF = $$rAF, this.$mdDateLocale = $mdDateLocale, 
                    this.$timeout = $timeout, this.documentElement = angular.element(document.documentElement), 
                    this.ngModelCtrl = null, this.inputElement = $element[0].querySelector("input"), 
                    this.ngInputElement = angular.element(this.inputElement), this.inputContainer = $element[0].querySelector(".md-datepicker-input-container"), 
                    this.calendarPane = $element[0].querySelector(".md-datepicker-calendar-pane"), this.calendarButton = $element[0].querySelector(".md-datepicker-button"), 
                    this.inputMask = angular.element($element[0].querySelector(".md-datepicker-input-mask-opaque")), 
                    this.$element = $element, this.$attrs = $attrs, this.$scope = $scope, this.date = null, 
                    this.isFocused = !1, this.isDisabled = void 0, this.setDisabled($element[0].disabled || angular.isString($attrs.disabled)), 
                    this.isCalendarOpen = !1, this.openOnFocus = $attrs.hasOwnProperty("mdOpenOnFocus"), 
                    this.mdInputContainer = null, this.calendarPaneOpenedFrom = null, this.calendarPaneId = "md-date-pane-" + $mdUtil.nextUid(), 
                    this.bodyClickHandler = angular.bind(this, this.handleBodyClick), this.windowEventName = IS_MOBILE_REGEX.test(navigator.userAgent || navigator.vendor || window.opera) ? "orientationchange" : "resize", 
                    this.windowEventHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100), 
                    this.windowBlurHandler = angular.bind(this, this.handleWindowBlur), this.ngDateFilter = $filter("date"), 
                    this.leftMargin = 20, this.topMargin = null, $attrs.tabindex ? (this.ngInputElement.attr("tabindex", $attrs.tabindex), 
                    $attrs.$set("tabindex", null)) : $attrs.$set("tabindex", "-1"), $attrs.$set("aria-owns", this.calendarPaneId), 
                    $mdTheming($element), $mdTheming(angular.element(this.calendarPane));
                    var self = this;
                    $scope.$on("$destroy", (function() {
                        self.detachCalendarPane();
                    })), $attrs.mdIsOpen && $scope.$watch("ctrl.isOpen", (function(shouldBeOpen) {
                        shouldBeOpen ? self.openCalendarPane({
                            target: self.inputElement
                        }) : self.closeCalendarPane();
                    })), 1 === angular.version.major && angular.version.minor <= 4 && this.$onInit();
                }
                DatePickerCtrl.prototype.$onInit = function() {
                    this.locale = this.dateLocale ? angular.extend({}, this.$mdDateLocale, this.dateLocale) : this.$mdDateLocale, 
                    this.installPropertyInterceptors(), this.attachChangeListeners(), this.attachInteractionListeners();
                }, DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl, mdInputContainer, inputDirective) {
                    this.ngModelCtrl = ngModelCtrl, this.mdInputContainer = mdInputContainer, this.$attrs.$set("type", "date"), 
                    inputDirective[0].link.pre(this.$scope, {
                        on: angular.noop,
                        val: angular.noop,
                        0: {}
                    }, this.$attrs, [ ngModelCtrl ]);
                    var self = this;
                    self.ngModelCtrl.$formatters.push((function(value) {
                        var parsedValue = angular.isDefined(value) ? value : null;
                        if (!(value instanceof Date) && (parsedValue = Date.parse(value), !isNaN(parsedValue) && angular.isNumber(parsedValue) && (value = new Date(parsedValue)), 
                        value && !(value instanceof Date))) throw Error("The ng-model for md-datepicker must be a Date instance or a value that can be parsed into a date. Currently the model is of type: " + typeof value);
                        return self.onExternalChange(value), value;
                    })), ngModelCtrl.$viewChangeListeners.unshift(angular.bind(this, this.updateErrorState));
                    var updateOn = self.$mdUtil.getModelOption(ngModelCtrl, "updateOn");
                    updateOn && this.ngInputElement.on(updateOn, angular.bind(this.$element, this.$element.triggerHandler, updateOn));
                }, DatePickerCtrl.prototype.attachChangeListeners = function() {
                    var self = this;
                    self.$scope.$on("md-calendar-change", (function(event, date) {
                        self.setModelValue(date), self.onExternalChange(date), self.closeCalendarPane();
                    })), self.ngInputElement.on("input", angular.bind(self, self.resizeInputElement));
                    var debounceInterval = angular.isDefined(this.debounceInterval) ? this.debounceInterval : 500;
                    self.ngInputElement.on("input", self.$mdUtil.debounce(self.handleInputEvent, debounceInterval, self));
                }, DatePickerCtrl.prototype.attachInteractionListeners = function() {
                    var self = this, $scope = this.$scope, keyCodes = this.$mdConstant.KEY_CODE;
                    self.ngInputElement.on("keydown", (function(event) {
                        event.altKey && event.keyCode === keyCodes.DOWN_ARROW && (self.openCalendarPane(event), 
                        $scope.$digest());
                    })), self.openOnFocus && (self.ngInputElement.on("focus", angular.bind(self, self.openCalendarPane)), 
                    self.ngInputElement.on("click", (function(event) {
                        event.stopPropagation();
                    })), self.ngInputElement.on("pointerdown", (function(event) {
                        event.target && event.target.setPointerCapture && event.target.setPointerCapture(event.pointerId);
                    })), angular.element(self.$window).on("blur", self.windowBlurHandler), $scope.$on("$destroy", (function() {
                        angular.element(self.$window).off("blur", self.windowBlurHandler);
                    }))), $scope.$on("md-calendar-close", (function() {
                        self.closeCalendarPane();
                    }));
                }, DatePickerCtrl.prototype.installPropertyInterceptors = function() {
                    var self = this;
                    if (this.$attrs.ngDisabled) {
                        var scope = this.$scope.$parent;
                        scope && scope.$watch(this.$attrs.ngDisabled, (function(isDisabled) {
                            self.setDisabled(isDisabled);
                        }));
                    }
                    Object.defineProperty(this, "placeholder", {
                        get: function() {
                            return self.inputElement.placeholder;
                        },
                        set: function(value) {
                            self.inputElement.placeholder = value || "";
                        }
                    });
                }, DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
                    this.isDisabled = isDisabled, this.inputElement.disabled = isDisabled, this.calendarButton && (this.calendarButton.disabled = isDisabled);
                }, DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
                    var date;
                    if (date = opt_date ? new Date(opt_date.valueOf()) : angular.isString(this.ngModelCtrl.$modelValue) ? new Date(this.ngModelCtrl.$modelValue) : angular.copy(this.ngModelCtrl.$modelValue), 
                    this.clearErrorState(), this.dateUtil.isValidDate(date)) {
                        if (date = this.dateUtil.createDateAtMidnight(date), this.dateUtil.isValidDate(this.minDate)) {
                            var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
                            this.ngModelCtrl.$setValidity("mindate", date >= minDate);
                        }
                        if (this.dateUtil.isValidDate(this.maxDate)) {
                            var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
                            this.ngModelCtrl.$setValidity("maxdate", date <= maxDate);
                        }
                        angular.isFunction(this.dateFilter) && this.ngModelCtrl.$setValidity("filtered", this.dateFilter(date)), 
                        angular.isFunction(this.monthFilter) && this.ngModelCtrl.$setValidity("filtered", this.monthFilter(date));
                    } else this.ngModelCtrl.$setValidity("valid", null == date);
                    var input = this.inputElement.value, parsedDate = this.locale.parseDate(input);
                    !this.isInputValid(input, parsedDate) && this.ngModelCtrl.$valid && this.ngModelCtrl.$setValidity("valid", null == date), 
                    angular.element(this.inputContainer).toggleClass("md-datepicker-invalid", this.ngModelCtrl.$invalid && (this.ngModelCtrl.$touched || this.ngModelCtrl.$submitted));
                }, DatePickerCtrl.prototype.isInputValid = function(inputString, parsedDate) {
                    return "" === inputString || this.dateUtil.isValidDate(parsedDate) && this.locale.isDateComplete(inputString) && this.isDateEnabled(parsedDate);
                }, DatePickerCtrl.prototype.clearErrorState = function() {
                    this.inputContainer.classList.remove("md-datepicker-invalid"), [ "mindate", "maxdate", "filtered", "valid" ].forEach((function(field) {
                        this.ngModelCtrl.$setValidity(field, !0);
                    }), this);
                }, DatePickerCtrl.prototype.resizeInputElement = function() {
                    this.inputElement.size = this.inputElement.value.length + 3;
                }, DatePickerCtrl.prototype.handleInputEvent = function() {
                    var inputString = this.inputElement.value, parsedDate = inputString ? this.locale.parseDate(inputString) : null;
                    this.dateUtil.setDateTimeToMidnight(parsedDate), this.isInputValid(inputString, parsedDate) && (this.setModelValue(parsedDate), 
                    this.date = parsedDate), this.updateErrorState(parsedDate);
                }, DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
                    return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date)) && (!angular.isFunction(this.monthFilter) || this.monthFilter(opt_date));
                }, DatePickerCtrl.prototype.attachCalendarPane = function() {
                    var calendarPane = this.calendarPane, body = document.body;
                    calendarPane.style.transform = "", this.$element.addClass(OPEN_CLASS), this.mdInputContainer && this.mdInputContainer.element.addClass(OPEN_CLASS), 
                    angular.element(body).addClass("md-datepicker-is-showing");
                    var elementRect = this.inputContainer.getBoundingClientRect(), bodyRect = body.getBoundingClientRect();
                    (!this.topMargin || this.topMargin < 0) && (this.topMargin = (this.inputMask.parent().prop("clientHeight") - this.ngInputElement.prop("clientHeight")) / 2);
                    var paneTop = elementRect.top - bodyRect.top - this.topMargin, paneLeft = elementRect.left - bodyRect.left - this.leftMargin, viewportTop = bodyRect.top < 0 && 0 === document.body.scrollTop ? -bodyRect.top : document.body.scrollTop, viewportLeft = bodyRect.left < 0 && 0 === document.body.scrollLeft ? -bodyRect.left : document.body.scrollLeft, viewportBottom = viewportTop + this.$window.innerHeight, viewportRight = viewportLeft + this.$window.innerWidth;
                    if (this.inputMask.css({
                        position: "absolute",
                        left: this.leftMargin + "px",
                        top: this.topMargin + "px",
                        width: elementRect.width - 1 + "px",
                        height: elementRect.height - 2 + "px"
                    }), paneLeft + 360 > viewportRight) {
                        if (viewportRight - 360 > 0) paneLeft = viewportRight - 360; else {
                            paneLeft = viewportLeft;
                            var scale = this.$window.innerWidth / 360;
                            calendarPane.style.transform = "scale(" + scale + ")";
                        }
                        calendarPane.classList.add("md-datepicker-pos-adjusted");
                    }
                    paneTop + 368 > viewportBottom && viewportBottom - 368 > viewportTop && (paneTop = viewportBottom - 368, 
                    calendarPane.classList.add("md-datepicker-pos-adjusted")), calendarPane.style.left = paneLeft + "px", 
                    calendarPane.style.top = paneTop + "px", document.body.appendChild(calendarPane), 
                    this.$$rAF((function() {
                        calendarPane.classList.add("md-pane-open");
                    }));
                }, DatePickerCtrl.prototype.detachCalendarPane = function() {
                    this.$element.removeClass(OPEN_CLASS), this.mdInputContainer && this.mdInputContainer.element.removeClass(OPEN_CLASS), 
                    angular.element(document.body).removeClass("md-datepicker-is-showing"), this.calendarPane.classList.remove("md-pane-open"), 
                    this.calendarPane.classList.remove("md-datepicker-pos-adjusted"), this.isCalendarOpen && this.$mdUtil.enableScrolling(), 
                    this.calendarPane.parentNode && this.calendarPane.parentNode.removeChild(this.calendarPane);
                }, DatePickerCtrl.prototype.openCalendarPane = function(event) {
                    if (this.isCalendarOpen || this.isDisabled || this.inputFocusedOnWindowBlur) this.inputFocusedOnWindowBlur && this.resetInputFocused(); else {
                        this.isCalendarOpen = this.isOpen = !0, this.calendarPaneOpenedFrom = event.target, 
                        this.$mdUtil.disableScrollAround(this.calendarPane), this.attachCalendarPane(), 
                        this.focusCalendar(), this.evalAttr("ngFocus");
                        var self = this;
                        this.$mdUtil.nextTick((function() {
                            self.documentElement.on("click touchstart", self.bodyClickHandler);
                        }), !1), window.addEventListener(this.windowEventName, this.windowEventHandler);
                    }
                }, DatePickerCtrl.prototype.closeCalendarPane = function() {
                    if (this.isCalendarOpen) {
                        var self = this;
                        self.detachCalendarPane(), self.ngModelCtrl.$setTouched(), self.evalAttr("ngBlur"), 
                        self.documentElement.off("click touchstart", self.bodyClickHandler), window.removeEventListener(self.windowEventName, self.windowEventHandler), 
                        self.calendarPaneOpenedFrom.focus(), self.calendarPaneOpenedFrom = null, self.openOnFocus ? self.$timeout(reset) : reset();
                    }
                    function reset() {
                        self.isCalendarOpen = self.isOpen = !1;
                    }
                }, DatePickerCtrl.prototype.getCalendarCtrl = function() {
                    return angular.element(this.calendarPane.querySelector("md-calendar")).controller("mdCalendar");
                }, DatePickerCtrl.prototype.focusCalendar = function() {
                    var self = this;
                    this.$mdUtil.nextTick((function() {
                        self.getCalendarCtrl().focusDate(self.date);
                    }), !1);
                }, DatePickerCtrl.prototype.setFocused = function(isFocused) {
                    isFocused || this.ngModelCtrl.$setTouched(), this.openOnFocus || this.evalAttr(isFocused ? "ngFocus" : "ngBlur"), 
                    this.isFocused = isFocused;
                }, DatePickerCtrl.prototype.handleBodyClick = function(event) {
                    this.isCalendarOpen && (this.$mdUtil.getClosest(event.target, "md-calendar") || this.closeCalendarPane(), 
                    this.$scope.$digest());
                }, DatePickerCtrl.prototype.handleWindowBlur = function() {
                    this.inputFocusedOnWindowBlur = document.activeElement === this.inputElement;
                }, DatePickerCtrl.prototype.resetInputFocused = function() {
                    this.inputFocusedOnWindowBlur = !1;
                }, DatePickerCtrl.prototype.evalAttr = function(attr) {
                    this.$attrs[attr] && this.$scope.$parent.$eval(this.$attrs[attr]);
                }, DatePickerCtrl.prototype.setModelValue = function(value) {
                    var timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
                    null == timezone || null == value || value.getTimezoneOffset() < 0 ? this.ngModelCtrl.$setViewValue(this.ngDateFilter(value, "yyyy-MM-dd"), "default") : this.ngModelCtrl.$setViewValue(this.ngDateFilter(value, "yyyy-MM-dd", timezone), "default");
                }, DatePickerCtrl.prototype.onExternalChange = function(value) {
                    var self = this, timezone = this.$mdUtil.getModelOption(this.ngModelCtrl, "timezone");
                    this.dateUtil.isValidDate(value) && null != timezone && value.getTimezoneOffset() >= 0 ? this.date = this.dateUtil.removeLocalTzAndReparseDate(value) : this.date = value, 
                    null == timezone || null == value || value.getTimezoneOffset() < 0 ? this.inputElement.value = this.locale.formatDate(value) : this.inputElement.value = this.locale.formatDate(value, timezone), 
                    this.mdInputContainer && this.mdInputContainer.setHasValue(!!value), this.resizeInputElement(), 
                    this.$mdUtil.nextTick((function() {
                        self.updateErrorState();
                    }), !1, self.$scope);
                };
            }(), function() {
                function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
                    return {
                        restrict: "E",
                        link: function(scope, element) {
                            element.addClass("_md"), $mdTheming(element), $$rAF((function() {
                                var images, content = element[0].querySelector("md-dialog-content");
                                function addOverflowClass() {
                                    element.toggleClass("md-content-overflow", content.scrollHeight > content.clientHeight);
                                }
                                content && (images = content.getElementsByTagName("img"), addOverflowClass(), angular.element(images).on("load", addOverflowClass)), 
                                scope.$on("$destroy", (function() {
                                    $mdDialog.destroy(element);
                                }));
                            }));
                        }
                    };
                }
                function MdDialogProvider($$interimElementProvider) {
                    var topFocusTrap, bottomFocusTrap, removeFocusTrap;
                    return MdDialogController.$inject = [ "$mdDialog", "$mdConstant" ], dialogDefaultOptions.$inject = [ "$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector", "$mdTheming", "$interpolate", "$mdInteraction" ], 
                    $$interimElementProvider("$mdDialog").setDefaults({
                        methods: [ "disableParentScroll", "hasBackdrop", "clickOutsideToClose", "escapeToClose", "targetEvent", "closeTo", "openFrom", "parent", "fullscreen", "multiple" ],
                        options: dialogDefaultOptions
                    }).addPreset("alert", {
                        methods: [ "title", "htmlContent", "textContent", "ariaLabel", "ok", "theme", "css" ],
                        options: advancedDialogOptions
                    }).addPreset("confirm", {
                        methods: [ "title", "htmlContent", "textContent", "ariaLabel", "ok", "cancel", "theme", "css" ],
                        options: advancedDialogOptions
                    }).addPreset("prompt", {
                        methods: [ "title", "htmlContent", "textContent", "initialValue", "placeholder", "ariaLabel", "ok", "cancel", "theme", "css", "required" ],
                        options: advancedDialogOptions
                    });
                    function advancedDialogOptions() {
                        return {
                            template: [ '<md-dialog md-theme="{{ dialog.theme || dialog.defaultTheme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', "      <p>{{::dialog.mdTextContent}}</p>", "    </div>", '    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">', '      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result"              placeholder="{{::dialog.placeholder}}" ng-required="dialog.required">', "    </md-input-container>", "  </md-dialog-content>", "  <md-dialog-actions>", '    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"               ng-click="dialog.abort()" class="md-primary md-cancel-button">', "      {{ dialog.cancel }}", "    </md-button>", '    <md-button ng-click="dialog.hide()" class="md-primary md-confirm-button" md-autofocus="dialog.$type===\'alert\'"               ng-disabled="dialog.required && !dialog.result">', "      {{ dialog.ok }}", "    </md-button>", "  </md-dialog-actions>", "</md-dialog>" ].join("").replace(/\s\s+/g, ""),
                            controller: MdDialogController,
                            controllerAs: "dialog",
                            bindToController: !0
                        };
                    }
                    function MdDialogController($mdDialog, $mdConstant) {
                        this.$onInit = function() {
                            var isPrompt = "prompt" === this.$type;
                            isPrompt && this.initialValue && (this.result = this.initialValue), this.hide = function() {
                                $mdDialog.hide(!isPrompt || this.result);
                            }, this.abort = function() {
                                $mdDialog.cancel();
                            }, this.keypress = function($event) {
                                var invalidPrompt = isPrompt && this.required && !angular.isDefined(this.result);
                                $event.keyCode !== $mdConstant.KEY_CODE.ENTER || invalidPrompt || $mdDialog.hide(this.result);
                            };
                        };
                    }
                    function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector, $mdTheming, $interpolate, $mdInteraction) {
                        return {
                            hasBackdrop: !0,
                            isolateScope: !0,
                            onCompiling: function(options) {
                                options.defaultTheme = $mdTheming.defaultTheme(), function(options) {
                                    var targetEl;
                                    options.targetEvent && options.targetEvent.target && (targetEl = angular.element(options.targetEvent.target));
                                    var themeCtrl = targetEl && targetEl.controller("mdTheme");
                                    if (options.hasTheme = !!themeCtrl, !options.hasTheme) return;
                                    options.themeWatch = themeCtrl.$shouldWatch;
                                    var theme = options.theme || themeCtrl.$mdTheme;
                                    theme && (options.scope.theme = theme);
                                    var unwatch = themeCtrl.registerChanges((function(newTheme) {
                                        options.scope.theme = newTheme, options.themeWatch || unwatch();
                                    }));
                                }(options);
                            },
                            onShow: function(scope, element, options) {
                                angular.element($document[0].body).addClass("md-dialog-is-showing");
                                var dialogElement = element.find("md-dialog");
                                if (dialogElement.hasClass("ng-cloak")) {
                                    $log.warn("$mdDialog: using `<md-dialog ng-cloak>` will affect the dialog opening animations.", element[0]);
                                }
                                return captureParentAndFromToElements(options), configureAria(dialogElement, options), 
                                showBackdrop(scope, element, options), activateListeners(element, options), dialogPopIn(element, options).then((function() {
                                    !function(element, options) {
                                        var isHidden = !0;
                                        function getParents(element) {
                                            for (var parents = []; element.parentNode; ) {
                                                if (element === document.body) return parents;
                                                for (var children = element.parentNode.children, i = 0; i < children.length; i++) element === children[i] || isNodeOneOf(children[i], [ "SCRIPT", "STYLE" ]) || children[i].hasAttribute("aria-live") || parents.push(children[i]);
                                                element = element.parentNode;
                                            }
                                            return parents;
                                        }
                                        function walkDOM(element) {
                                            for (var elements = getParents(element), i = 0; i < elements.length; i++) elements[i].setAttribute("aria-hidden", isHidden);
                                        }
                                        walkDOM(element[0]), options.unlockScreenReader = function() {
                                            isHidden = !1, walkDOM(element[0]), options.unlockScreenReader = null;
                                        };
                                    }(element, options), function() {
                                        if (options.focusOnOpen) {
                                            ($mdUtil.findFocusTarget(element) || findCloseButton() || dialogElement).focus();
                                        }
                                        function findCloseButton() {
                                            return element[0].querySelector(".dialog-close, md-dialog-actions button:last-child");
                                        }
                                    }();
                                }));
                            },
                            onShowing: function(scope, element, options, controller) {
                                if (controller) {
                                    var mdHtmlContent = controller.htmlContent || options.htmlContent || "", mdTextContent = controller.textContent || options.textContent || "";
                                    if (mdHtmlContent && !$injector.has("$sanitize")) throw Error("The ngSanitize module must be loaded in order to use htmlContent.");
                                    if (mdHtmlContent && mdTextContent) throw Error("md-dialog cannot have both `htmlContent` and `textContent`");
                                    controller.mdHtmlContent = mdHtmlContent, controller.mdTextContent = mdTextContent;
                                }
                            },
                            onRemove: function(scope, element, options) {
                                options.deactivateListeners(), options.unlockScreenReader(), options.hideBackdrop(options.$destroy), 
                                removeFocusTrap && (removeFocusTrap(), removeFocusTrap = null);
                                return options.$destroy ? detachAndClean() : function(container, options) {
                                    return options.reverseAnimate().then((function() {
                                        options.contentElement && options.clearAnimate();
                                    }));
                                }(0, options).then(detachAndClean);
                                function detachAndClean() {
                                    angular.element($document[0].body).removeClass("md-dialog-is-showing"), options.contentElement && options.reverseContainerStretch(), 
                                    options.cleanupElement(), options.$destroy || "keyboard" !== options.originInteraction || options.origin.focus();
                                }
                            },
                            clickOutsideToClose: !1,
                            escapeToClose: !0,
                            targetEvent: null,
                            closeTo: null,
                            openFrom: null,
                            focusOnOpen: !0,
                            disableParentScroll: !0,
                            autoWrap: !0,
                            fullscreen: !1,
                            transformTemplate: function(template, options) {
                                var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), theme = startSymbol + (options.themeWatch ? "" : "::") + "theme" + endSymbol;
                                return '<div class="md-dialog-container" tabindex="-1" ' + (options.hasTheme ? 'md-theme="' + theme + '"' : "") + ">" + function(template) {
                                    return options.autoWrap && !/<\/md-dialog>/g.test(template) ? "<md-dialog>" + (template || "") + "</md-dialog>" : template || "";
                                }(template) + "</div>";
                            }
                        };
                        function captureParentAndFromToElements(options) {
                            function getBoundingClientRect(element, orig) {
                                var source = angular.element(element || {});
                                if (source && source.length) {
                                    var hasFn = angular.isFunction(source[0].getBoundingClientRect);
                                    return angular.extend(orig || {}, {
                                        element: hasFn ? source : undefined,
                                        bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, {
                                            top: 0,
                                            left: 0,
                                            height: 0,
                                            width: 0
                                        }, source[0]),
                                        focus: angular.bind(source, source.focus)
                                    });
                                }
                            }
                            function getDomElement(element, defaultElement) {
                                return angular.isString(element) && (element = $document[0].querySelector(element)), 
                                angular.element(element || defaultElement);
                            }
                            options.origin = angular.extend({
                                element: null,
                                bounds: null,
                                focus: angular.noop
                            }, options.origin || {}), options.parent = getDomElement(options.parent, $rootElement), 
                            options.closeTo = getBoundingClientRect(getDomElement(options.closeTo)), options.openFrom = getBoundingClientRect(getDomElement(options.openFrom)), 
                            options.targetEvent && (options.origin = getBoundingClientRect(options.targetEvent.target, options.origin), 
                            options.originInteraction = $mdInteraction.getLastInteractionType());
                        }
                        function activateListeners(element, options) {
                            var window = angular.element($window), onWindowResize = $mdUtil.debounce((function() {
                                stretchDialogContainerToViewport(element, options);
                            }), 60), removeListeners = [], smartClose = function() {
                                var closeFn = "alert" === options.$type ? $mdDialog.hide : $mdDialog.cancel;
                                $mdUtil.nextTick(closeFn, !0);
                            };
                            if (options.escapeToClose) {
                                var parentTarget = options.parent, keyHandlerFn = function(ev) {
                                    ev.keyCode === $mdConstant.KEY_CODE.ESCAPE && (ev.stopImmediatePropagation(), ev.preventDefault(), 
                                    smartClose());
                                };
                                element.on("keydown", keyHandlerFn), parentTarget.on("keydown", keyHandlerFn), removeListeners.push((function() {
                                    element.off("keydown", keyHandlerFn), parentTarget.off("keydown", keyHandlerFn);
                                }));
                            }
                            if (window.on("resize", onWindowResize), removeListeners.push((function() {
                                window.off("resize", onWindowResize);
                            })), options.clickOutsideToClose) {
                                var sourceElem, target = element, mousedownHandler = function(ev) {
                                    sourceElem = ev.target;
                                }, mouseupHandler = function(ev) {
                                    sourceElem === target[0] && ev.target === target[0] && (ev.stopPropagation(), ev.preventDefault(), 
                                    smartClose());
                                };
                                target.on("mousedown", mousedownHandler), target.on("mouseup", mouseupHandler), 
                                removeListeners.push((function() {
                                    target.off("mousedown", mousedownHandler), target.off("mouseup", mouseupHandler);
                                }));
                            }
                            options.deactivateListeners = function() {
                                removeListeners.forEach((function(removeFn) {
                                    removeFn();
                                })), options.deactivateListeners = null;
                            };
                        }
                        function showBackdrop(scope, element, options) {
                            options.disableParentScroll && (options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent)), 
                            options.hasBackdrop && (options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque"), 
                            $animate.enter(options.backdrop, options.parent)), options.hideBackdrop = function($destroy) {
                                options.backdrop && ($destroy ? options.backdrop.remove() : $animate.leave(options.backdrop)), 
                                options.disableParentScroll && (options.restoreScroll && options.restoreScroll(), 
                                delete options.restoreScroll), options.hideBackdrop = null;
                            };
                        }
                        function configureAria(element, options) {
                            var role = "alert" === options.$type ? "alertdialog" : "dialog", dialogContent = element.find("md-dialog-content"), existingDialogId = element.attr("id"), dialogContentId = "dialogContent_" + (existingDialogId || $mdUtil.nextUid());
                            element.attr({
                                role,
                                tabIndex: "-1"
                            }), 0 === dialogContent.length && (dialogContent = element, existingDialogId && (dialogContentId = existingDialogId)), 
                            dialogContent.attr("id", dialogContentId), element.attr("aria-describedby", dialogContentId), 
                            options.ariaLabel ? $mdAria.expect(element, "aria-label", options.ariaLabel) : $mdAria.expectAsync(element, "aria-label", (function() {
                                if (options.title) return options.title;
                                var words = dialogContent.text().split(/\s+/);
                                return words.length > 3 && (words = words.slice(0, 3).concat("...")), words.join(" ");
                            })), (topFocusTrap = document.createElement("div")).classList.add("md-dialog-focus-trap"), 
                            topFocusTrap.tabIndex = 0, bottomFocusTrap = topFocusTrap.cloneNode(!1);
                            var focusHandler = function(event) {
                                if (event.target && event.target.nextSibling && "MD-DIALOG" === event.target.nextSibling.nodeName) {
                                    var lastFocusableElement = $mdUtil.getLastTabbableElement(element[0]);
                                    angular.isElement(lastFocusableElement) && lastFocusableElement.focus();
                                } else element.focus();
                            };
                            topFocusTrap.addEventListener("focus", focusHandler), bottomFocusTrap.addEventListener("focus", focusHandler), 
                            removeFocusTrap = function() {
                                topFocusTrap.removeEventListener("focus", focusHandler), bottomFocusTrap.removeEventListener("focus", focusHandler), 
                                topFocusTrap && topFocusTrap.parentNode && topFocusTrap.parentNode.removeChild(topFocusTrap), 
                                bottomFocusTrap && bottomFocusTrap.parentNode && bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
                            }, element[0].parentNode.insertBefore(topFocusTrap, element[0]), element.after(bottomFocusTrap);
                        }
                        function stretchDialogContainerToViewport(container, options) {
                            var isFixed = "fixed" === $window.getComputedStyle($document[0].body).position, backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null, height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0, previousStyles = {
                                top: container.css("top"),
                                height: container.css("height")
                            }, parentTop = Math.abs(options.parent[0].getBoundingClientRect().top);
                            return container.css({
                                top: (isFixed ? parentTop : 0) + "px",
                                height: height ? height + "px" : "100%"
                            }), function() {
                                container.css(previousStyles);
                            };
                        }
                        function dialogPopIn(container, options) {
                            options.parent.append(container), options.reverseContainerStretch = stretchDialogContainerToViewport(container, options);
                            var dialogEl = container.find("md-dialog"), animator = $mdUtil.dom.animator, buildTranslateToOrigin = animator.calculateZoomToOrigin, translateOptions = {
                                transitionInClass: "md-transition-in",
                                transitionOutClass: "md-transition-out"
                            }, from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin)), to = animator.toTransformCss("");
                            return dialogEl.toggleClass("md-dialog-fullscreen", !!options.fullscreen), animator.translate3d(dialogEl, from, to, translateOptions).then((function(animateReversal) {
                                return options.reverseAnimate = function() {
                                    return delete options.reverseAnimate, options.closeTo ? (translateOptions = {
                                        transitionInClass: "md-transition-out",
                                        transitionOutClass: "md-transition-in"
                                    }, from = to, to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo)), 
                                    animator.translate3d(dialogEl, from, to, translateOptions)) : animateReversal(to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)));
                                }, options.clearAnimate = function() {
                                    return delete options.clearAnimate, dialogEl.removeClass([ translateOptions.transitionOutClass, translateOptions.transitionInClass ].join(" ")), 
                                    animator.translate3d(dialogEl, to, animator.toTransformCss(""), {});
                                }, !0;
                            }));
                        }
                        function isNodeOneOf(elem, nodeTypeArray) {
                            return -1 !== nodeTypeArray.indexOf(elem.nodeName);
                        }
                    }
                }
                MdDialogDirective.$inject = [ "$$rAF", "$mdTheming", "$mdDialog" ], MdDialogProvider.$inject = [ "$$interimElementProvider" ], 
                angular.module("material.components.dialog", [ "material.core", "material.components.backdrop" ]).directive("mdDialog", MdDialogDirective).provider("$mdDialog", MdDialogProvider);
            }(), function() {
                function MdDividerDirective($mdTheming) {
                    return {
                        restrict: "E",
                        link: $mdTheming
                    };
                }
                MdDividerDirective.$inject = [ "$mdTheming" ], angular.module("material.components.divider", [ "material.core" ]).directive("mdDivider", MdDividerDirective);
            }(), function() {
                function MdFabActionsDirective($mdUtil) {
                    return {
                        restrict: "E",
                        require: [ "^?mdFabSpeedDial", "^?mdFabToolbar" ],
                        compile: function(element, attributes) {
                            var actionItemButtons, children = element.children(), hasNgRepeat = $mdUtil.prefixer().hasAttribute(children, "ng-repeat");
                            actionItemButtons = element.find("md-button"), angular.forEach(actionItemButtons, (function(button) {
                                button.setAttribute("tabindex", -1);
                            })), hasNgRepeat ? children.addClass("md-fab-action-item") : children.wrap('<div class="md-fab-action-item">');
                        }
                    };
                }
                MdFabActionsDirective.$inject = [ "$mdUtil" ], angular.module("material.components.fabActions", [ "material.core" ]).directive("mdFabActions", MdFabActionsDirective);
            }(), function() {
                function MdFabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
                    var closeTimeout, ctrl = this, initialAnimationAttempts = 0;
                    function parseEvents(event) {
                        "click" == event.type && function(event) {
                            var element, closestButton = event.target ? (element = event.target, $mdUtil.getClosest(element, "button") || $mdUtil.getClosest(element, "md-button")) : null;
                            closestButton && !closestButton.disabled && function(element) {
                                return $mdUtil.getClosest(element, "md-fab-trigger");
                            }(event.target) && ctrl.toggle(), function(element) {
                                return $mdUtil.getClosest(element, "md-fab-actions");
                            }(event.target) && ctrl.close();
                        }(event), "focusout" != event.type || closeTimeout || (closeTimeout = $timeout((function() {
                            ctrl.close();
                        }), 100, !1)), "focusin" == event.type && closeTimeout && ($timeout.cancel(closeTimeout), 
                        closeTimeout = null);
                    }
                    function resetActionIndex() {
                        ctrl.currentActionIndex = -1;
                    }
                    function fireInitialAnimations() {
                        $element[0].scrollHeight > 0 ? $animate.addClass($element, "_md-animations-ready").then((function() {
                            $element.removeClass("md-animations-waiting");
                        })) : initialAnimationAttempts < 10 && ($timeout(fireInitialAnimations, 100), initialAnimationAttempts += 1);
                    }
                    function disableKeyboard() {
                        $element.off("keydown", keyPressed), angular.element(document).off("click touchend", checkForOutsideClick);
                    }
                    function checkForOutsideClick(event) {
                        if (event.target) {
                            var closestTrigger = $mdUtil.getClosest(event.target, "md-fab-trigger"), closestActions = $mdUtil.getClosest(event.target, "md-fab-actions");
                            closestTrigger || closestActions || ctrl.close();
                        }
                    }
                    function keyPressed(event) {
                        switch (event.which) {
                          case $mdConstant.KEY_CODE.ESCAPE:
                            return ctrl.close(), event.preventDefault(), !1;

                          case $mdConstant.KEY_CODE.LEFT_ARROW:
                            return function(event) {
                                "left" === ctrl.direction ? doActionNext(event) : doActionPrev(event);
                            }(event), !1;

                          case $mdConstant.KEY_CODE.UP_ARROW:
                            return function(event) {
                                "down" === ctrl.direction ? doActionPrev(event) : doActionNext(event);
                            }(event), !1;

                          case $mdConstant.KEY_CODE.RIGHT_ARROW:
                            return function(event) {
                                "left" === ctrl.direction ? doActionPrev(event) : doActionNext(event);
                            }(event), !1;

                          case $mdConstant.KEY_CODE.DOWN_ARROW:
                            return function(event) {
                                "up" === ctrl.direction ? doActionPrev(event) : doActionNext(event);
                            }(event), !1;

                          case $mdConstant.KEY_CODE.TAB:
                            return function(event) {
                                event.shiftKey ? doActionPrev(event) : doActionNext(event);
                            }(event), !1;
                        }
                    }
                    function doActionPrev(event) {
                        focusAction(event, -1);
                    }
                    function doActionNext(event) {
                        focusAction(event, 1);
                    }
                    function focusAction(event, direction) {
                        var actions = getActionsElement()[0].querySelectorAll(".md-fab-action-item"), previousActionIndex = ctrl.currentActionIndex;
                        ctrl.currentActionIndex = ctrl.currentActionIndex + direction, ctrl.currentActionIndex = Math.min(actions.length - 1, ctrl.currentActionIndex), 
                        ctrl.currentActionIndex = Math.max(0, ctrl.currentActionIndex), (event.which !== $mdConstant.KEY_CODE.TAB || previousActionIndex !== ctrl.currentActionIndex) && (angular.element(actions[ctrl.currentActionIndex]).children()[0].focus(), 
                        event.preventDefault(), event.stopImmediatePropagation());
                    }
                    function getActionsElement() {
                        return $element.find("md-fab-actions");
                    }
                    ctrl.open = function() {
                        $scope.$evalAsync("ctrl.isOpen = true");
                    }, ctrl.close = function() {
                        $scope.$evalAsync("ctrl.isOpen = false"), $element.find("md-fab-trigger")[0].focus();
                    }, ctrl.toggle = function() {
                        $scope.$evalAsync("ctrl.isOpen = !ctrl.isOpen");
                    }, ctrl.$onInit = function() {
                        var eventTypes, trigger, actions;
                        ctrl.direction = ctrl.direction || "down", ctrl.isOpen = ctrl.isOpen || !1, resetActionIndex(), 
                        $element.addClass("md-animations-waiting"), eventTypes = [ "click", "focusin", "focusout" ], 
                        angular.forEach(eventTypes, (function(eventType) {
                            $element.on(eventType, parseEvents);
                        })), $scope.$on("$destroy", (function() {
                            angular.forEach(eventTypes, (function(eventType) {
                                $element.off(eventType, parseEvents);
                            })), disableKeyboard();
                        })), $scope.$watch("ctrl.direction", (function(newDir, oldDir) {
                            $animate.removeClass($element, "md-" + oldDir), $animate.addClass($element, "md-" + newDir), 
                            resetActionIndex();
                        })), $scope.$watch("ctrl.isOpen", (function(isOpen) {
                            resetActionIndex(), trigger && actions || (trigger = $element.find("md-fab-trigger"), 
                            actions = getActionsElement()), isOpen ? ($element.on("keydown", keyPressed), $mdUtil.nextTick((function() {
                                angular.element(document).on("click touchend", checkForOutsideClick);
                            }))) : disableKeyboard();
                            var toAdd = isOpen ? "md-is-open" : "", toRemove = isOpen ? "" : "md-is-open";
                            trigger.attr("aria-haspopup", !0), trigger.attr("aria-expanded", isOpen), actions.attr("aria-hidden", !isOpen), 
                            $animate.setClass($element, toAdd, toRemove);
                        })), fireInitialAnimations();
                    }, 1 === angular.version.major && angular.version.minor <= 4 && this.$onInit();
                }
                MdFabController.$inject = [ "$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout" ], 
                angular.module("material.components.fabShared", [ "material.core" ]).controller("MdFabController", MdFabController);
            }(), function() {
                MdFabSpeedDialFlingAnimation.$inject = [ "$timeout" ], MdFabSpeedDialScaleAnimation.$inject = [ "$timeout" ];
                var cssAnimationDuration = 300;
                function MdFabSpeedDialFlingAnimation($timeout) {
                    function delayDone(done) {
                        $timeout(done, cssAnimationDuration, !1);
                    }
                    function runAnimation(element) {
                        if (!element.hasClass("md-animations-waiting") || element.hasClass("_md-animations-ready")) {
                            var el = element[0], ctrl = element.controller("mdFabSpeedDial"), items = el.querySelectorAll(".md-fab-action-item"), triggerElement = el.querySelector("md-fab-trigger"), variablesElement = el.querySelector("._md-css-variables"), startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
                            angular.forEach(items, (function(item, index) {
                                var styles = item.style;
                                styles.transform = styles.webkitTransform = "", styles.transitionDelay = "", styles.opacity = ctrl.isOpen ? 1 : 0, 
                                styles.zIndex = items.length - index + startZIndex;
                            })), triggerElement.style.zIndex = startZIndex + items.length + 1, ctrl.isOpen || angular.forEach(items, (function(item, index) {
                                var newPosition, axis, styles = item.style, triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2, triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
                                switch (ctrl.direction) {
                                  case "up":
                                    newPosition = item.scrollHeight * (index + 1) + triggerItemHeightOffset, axis = "Y";
                                    break;

                                  case "down":
                                    newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset), axis = "Y";
                                    break;

                                  case "left":
                                    newPosition = item.scrollWidth * (index + 1) + triggerItemWidthOffset, axis = "X";
                                    break;

                                  case "right":
                                    newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset), axis = "X";
                                }
                                var newTranslate = "translate" + axis + "(" + newPosition + "px)";
                                styles.transform = styles.webkitTransform = newTranslate;
                            }));
                        }
                    }
                    return {
                        addClass: function(element, className, done) {
                            element.hasClass("md-fling") ? (runAnimation(element), delayDone(done)) : done();
                        },
                        removeClass: function(element, className, done) {
                            runAnimation(element), delayDone(done);
                        }
                    };
                }
                function MdFabSpeedDialScaleAnimation($timeout) {
                    function delayDone(done) {
                        $timeout(done, cssAnimationDuration, !1);
                    }
                    function runAnimation(element) {
                        var el = element[0], ctrl = element.controller("mdFabSpeedDial"), items = el.querySelectorAll(".md-fab-action-item"), variablesElement = el.querySelector("._md-css-variables"), startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
                        angular.forEach(items, (function(item, index) {
                            var styles = item.style, offsetDelay = 65 * index;
                            styles.opacity = ctrl.isOpen ? 1 : 0, styles.transform = styles.webkitTransform = ctrl.isOpen ? "scale(1)" : "scale(0)", 
                            styles.transitionDelay = (ctrl.isOpen ? offsetDelay : items.length - offsetDelay) + "ms", 
                            styles.zIndex = items.length - index + startZIndex;
                        }));
                    }
                    return {
                        addClass: function(element, className, done) {
                            runAnimation(element), delayDone(done);
                        },
                        removeClass: function(element, className, done) {
                            runAnimation(element), delayDone(done);
                        }
                    };
                }
                angular.module("material.components.fabSpeedDial", [ "material.core", "material.components.fabShared", "material.components.fabActions" ]).directive("mdFabSpeedDial", (function() {
                    return {
                        restrict: "E",
                        scope: {
                            direction: "@?mdDirection",
                            isOpen: "=?mdOpen"
                        },
                        bindToController: !0,
                        controller: "MdFabController",
                        controllerAs: "ctrl",
                        link: function(scope, element) {
                            element.prepend('<div class="_md-css-variables"></div>');
                        }
                    };
                })).animation(".md-fling", MdFabSpeedDialFlingAnimation).animation(".md-scale", MdFabSpeedDialScaleAnimation).service("mdFabSpeedDialFlingAnimation", MdFabSpeedDialFlingAnimation).service("mdFabSpeedDialScaleAnimation", MdFabSpeedDialScaleAnimation);
            }(), function() {
                function MdFabToolbarAnimation() {
                    function runAnimation(element, className, done) {
                        if (className) {
                            var el = element[0], ctrl = element.controller("mdFabToolbar"), backgroundElement = el.querySelector(".md-fab-toolbar-background"), triggerElement = el.querySelector("md-fab-trigger button"), toolbarElement = el.querySelector("md-toolbar"), iconElement = el.querySelector("md-fab-trigger button md-icon"), actions = element.find("md-fab-actions").children();
                            if (triggerElement && backgroundElement) {
                                var color = window.getComputedStyle(triggerElement).getPropertyValue("background-color"), width = el.offsetWidth, scale = (el.offsetHeight, 
                                width / triggerElement.offsetWidth * 2);
                                backgroundElement.style.backgroundColor = color, backgroundElement.style.borderRadius = width + "px", 
                                ctrl.isOpen ? (toolbarElement.style.pointerEvents = "inherit", backgroundElement.style.width = triggerElement.offsetWidth + "px", 
                                backgroundElement.style.height = triggerElement.offsetHeight + "px", backgroundElement.style.transform = "scale(" + scale + ")", 
                                backgroundElement.style.transitionDelay = "0ms", iconElement && (iconElement.style.transitionDelay = ".3s"), 
                                angular.forEach(actions, (function(action, index) {
                                    action.style.transitionDelay = 25 * (actions.length - index) + "ms";
                                }))) : (toolbarElement.style.pointerEvents = "none", backgroundElement.style.transform = "scale(1)", 
                                backgroundElement.style.top = "0", element.hasClass("md-right") && (backgroundElement.style.left = "0", 
                                backgroundElement.style.right = null), element.hasClass("md-left") && (backgroundElement.style.right = "0", 
                                backgroundElement.style.left = null), backgroundElement.style.transitionDelay = "200ms", 
                                iconElement && (iconElement.style.transitionDelay = "0ms"), angular.forEach(actions, (function(action, index) {
                                    action.style.transitionDelay = 200 + 25 * index + "ms";
                                })));
                            }
                        }
                    }
                    return {
                        addClass: function(element, className, done) {
                            runAnimation(element, className), done();
                        },
                        removeClass: function(element, className, done) {
                            runAnimation(element, className), done();
                        }
                    };
                }
                angular.module("material.components.fabToolbar", [ "material.core", "material.components.fabShared", "material.components.fabActions" ]).directive("mdFabToolbar", (function() {
                    return {
                        restrict: "E",
                        transclude: !0,
                        template: '<div class="md-fab-toolbar-wrapper">  <div class="md-fab-toolbar-content" ng-transclude></div></div>',
                        scope: {
                            direction: "@?mdDirection",
                            isOpen: "=?mdOpen"
                        },
                        bindToController: !0,
                        controller: "MdFabController",
                        controllerAs: "ctrl",
                        link: function(scope, element, attributes) {
                            element.addClass("md-fab-toolbar"), element.find("md-fab-trigger").find("button").prepend('<div class="md-fab-toolbar-background"></div>');
                        }
                    };
                })).animation(".md-fab-toolbar", MdFabToolbarAnimation).service("mdFabToolbarAnimation", MdFabToolbarAnimation);
            }(), function() {
                function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia, $mdUtil) {
                    return {
                        restrict: "E",
                        controller: GridListController,
                        scope: {
                            mdOnLayout: "&"
                        },
                        link: function(scope, element, attrs, ctrl) {
                            element.addClass("_md"), element.attr("role", "list"), ctrl.layoutDelegate = function(tilesInvalidated) {
                                var tiles = [].filter.call(element.children(), (function(ele) {
                                    return "MD-GRID-TILE" == ele.tagName && !ele.$$mdDestroyed;
                                })), props = {
                                    tileSpans: getTileSpans(tiles),
                                    colCount: getColumnCount(),
                                    rowMode: getRowMode(),
                                    rowHeight: getRowHeight(),
                                    gutter: getGutter()
                                };
                                if (!tilesInvalidated && angular.equals(props, lastLayoutProps)) return;
                                var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map((function(tilePositions, rowCount) {
                                    return {
                                        grid: {
                                            element,
                                            style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                                        },
                                        tiles: tilePositions.map((function(ps, i) {
                                            return {
                                                element: angular.element(tiles[i]),
                                                style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                                            };
                                        }))
                                    };
                                })).reflow().performance();
                                scope.mdOnLayout({
                                    $event: {
                                        performance
                                    }
                                }), lastLayoutProps = props;
                            };
                            var lastLayoutProps, invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout), unwatchAttrs = function() {
                                for (var mediaName in $mdConstant.MEDIA) $mdMedia(mediaName), $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
                                return $mdMedia.watchResponsiveAttributes([ "md-cols", "md-row-height", "md-gutter" ], attrs, layoutIfMediaMatch);
                            }();
                            function layoutIfMediaMatch(mediaName) {
                                (null == mediaName || $mdMedia(mediaName)) && ctrl.invalidateLayout();
                            }
                            scope.$on("$destroy", (function() {
                                for (var mediaName in ctrl.layoutDelegate = angular.noop, unwatchAttrs(), $mdConstant.MEDIA) $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
                            }));
                            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol();
                            function expr(exprStr) {
                                return startSymbol + exprStr + endSymbol;
                            }
                            var UNIT = $interpolate(expr("share") + "% - (" + expr("gutter") + " * " + expr("gutterShare") + ")"), POSITION = $interpolate("calc((" + expr("unit") + " + " + expr("gutter") + ") * " + expr("offset") + ")"), DIMENSION = $interpolate("calc((" + expr("unit") + ") * " + expr("span") + " + (" + expr("span") + " - 1) * " + expr("gutter") + ")");
                            function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
                                var hShare = 1 / colCount * 100, hGutterShare = (colCount - 1) / colCount, hUnit = UNIT({
                                    share: hShare,
                                    gutterShare: hGutterShare,
                                    gutter
                                }), style = $mdUtil.isRtl(attrs) ? {
                                    right: POSITION({
                                        unit: hUnit,
                                        offset: position.col,
                                        gutter
                                    }),
                                    width: DIMENSION({
                                        unit: hUnit,
                                        span: spans.col,
                                        gutter
                                    }),
                                    paddingTop: "",
                                    marginTop: "",
                                    top: "",
                                    height: ""
                                } : {
                                    left: POSITION({
                                        unit: hUnit,
                                        offset: position.col,
                                        gutter
                                    }),
                                    width: DIMENSION({
                                        unit: hUnit,
                                        span: spans.col,
                                        gutter
                                    }),
                                    paddingTop: "",
                                    marginTop: "",
                                    top: "",
                                    height: ""
                                };
                                switch (rowMode) {
                                  case "fixed":
                                    style.top = POSITION({
                                        unit: rowHeight,
                                        offset: position.row,
                                        gutter
                                    }), style.height = DIMENSION({
                                        unit: rowHeight,
                                        span: spans.row,
                                        gutter
                                    });
                                    break;

                                  case "ratio":
                                    var vShare = hShare / rowHeight, vUnit = UNIT({
                                        share: vShare,
                                        gutterShare: hGutterShare,
                                        gutter
                                    });
                                    style.paddingTop = DIMENSION({
                                        unit: vUnit,
                                        span: spans.row,
                                        gutter
                                    }), style.marginTop = POSITION({
                                        unit: vUnit,
                                        offset: position.row,
                                        gutter
                                    });
                                    break;

                                  case "fit":
                                    vUnit = UNIT({
                                        share: vShare = 1 / rowCount * 100,
                                        gutterShare: (rowCount - 1) / rowCount,
                                        gutter
                                    }), style.top = POSITION({
                                        unit: vUnit,
                                        offset: position.row,
                                        gutter
                                    }), style.height = DIMENSION({
                                        unit: vUnit,
                                        span: spans.row,
                                        gutter
                                    });
                                }
                                return style;
                            }
                            function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
                                var style = {};
                                switch (rowMode) {
                                  case "fixed":
                                    style.height = DIMENSION({
                                        unit: rowHeight,
                                        span: rowCount,
                                        gutter
                                    }), style.paddingBottom = "";
                                    break;

                                  case "ratio":
                                    var vUnit = UNIT({
                                        share: 1 / colCount * 100 * (1 / rowHeight),
                                        gutterShare: 1 === colCount ? 0 : (colCount - 1) / colCount,
                                        gutter
                                    });
                                    style.height = "", style.paddingBottom = DIMENSION({
                                        unit: vUnit,
                                        span: rowCount,
                                        gutter
                                    });
                                }
                                return style;
                            }
                            function getTileSpans(tileElements) {
                                return [].map.call(tileElements, (function(ele) {
                                    var ctrl = angular.element(ele).controller("mdGridTile");
                                    return {
                                        row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-rowspan"), 10) || 1,
                                        col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-colspan"), 10) || 1
                                    };
                                }));
                            }
                            function getColumnCount() {
                                var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, "md-cols"), 10);
                                if (isNaN(colCount)) throw "md-grid-list: md-cols attribute was not found, or contained a non-numeric value";
                                return colCount;
                            }
                            function getGutter() {
                                return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, "md-gutter") || 1);
                            }
                            function getRowHeight() {
                                var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                                if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
                                switch (getRowMode()) {
                                  case "fixed":
                                    return applyDefaultUnit(rowHeight);

                                  case "ratio":
                                    var whRatio = rowHeight.split(":");
                                    return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);

                                  case "fit":
                                    return 0;
                                }
                            }
                            function getRowMode() {
                                var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                                if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
                                return "fit" == rowHeight ? "fit" : -1 !== rowHeight.indexOf(":") ? "ratio" : "fixed";
                            }
                            function applyDefaultUnit(val) {
                                return /\D$/.test(val) ? val : val + "px";
                            }
                        }
                    };
                }
                function GridListController($mdUtil) {
                    this.layoutInvalidated = !1, this.tilesInvalidated = !1, this.$timeout_ = $mdUtil.nextTick, 
                    this.layoutDelegate = angular.noop;
                }
                function GridLayoutFactory($mdUtil) {
                    var defaultAnimator = GridTileAnimator;
                    return GridLayout.animateWith = function(customAnimator) {
                        defaultAnimator = angular.isFunction(customAnimator) ? customAnimator : GridTileAnimator;
                    }, GridLayout;
                    function GridLayout(colCount, tileSpans) {
                        var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;
                        return layoutTime = $mdUtil.time((function() {
                            layoutInfo = function(colCount, tileSpans) {
                                var curCol = 0, curRow = 0, spaceTracker = newSpaceTracker();
                                return {
                                    positioning: tileSpans.map((function(spans, i) {
                                        return {
                                            spans,
                                            position: reserveSpace(spans, i)
                                        };
                                    })),
                                    rowCount: curRow + Math.max.apply(Math, spaceTracker)
                                };
                                function reserveSpace(spans, i) {
                                    if (spans.col > colCount) throw "md-grid-list: Tile at position " + i + " has a colspan (" + spans.col + ") that exceeds the column count (" + colCount + ")";
                                    for (var start = 0, end = 0; end - start < spans.col; ) curCol >= colCount ? nextRow() : -1 !== (start = spaceTracker.indexOf(0, curCol)) && -1 !== (end = findEnd(start + 1)) ? curCol = end + 1 : (start = end = 0, 
                                    nextRow());
                                    return adjustRow(start, spans.col, spans.row), curCol = start + spans.col, {
                                        col: start,
                                        row: curRow
                                    };
                                }
                                function nextRow() {
                                    curCol = 0, curRow++, adjustRow(0, colCount, -1);
                                }
                                function adjustRow(from, cols, by) {
                                    for (var i = from; i < from + cols; i++) spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
                                }
                                function findEnd(start) {
                                    var i;
                                    for (i = start; i < spaceTracker.length; i++) if (0 !== spaceTracker[i]) return i;
                                    if (i === spaceTracker.length) return i;
                                }
                                function newSpaceTracker() {
                                    for (var tracker = [], i = 0; i < colCount; i++) tracker.push(0);
                                    return tracker;
                                }
                            }(colCount, tileSpans);
                        })), self = {
                            layoutInfo: function() {
                                return layoutInfo;
                            },
                            map: function(updateFn) {
                                return mapTime = $mdUtil.time((function() {
                                    var info = self.layoutInfo();
                                    gridStyles = updateFn(info.positioning, info.rowCount);
                                })), self;
                            },
                            reflow: function(animatorFn) {
                                return reflowTime = $mdUtil.time((function() {
                                    (animatorFn || defaultAnimator)(gridStyles.grid, gridStyles.tiles);
                                })), self;
                            },
                            performance: function() {
                                return {
                                    tileCount: tileSpans.length,
                                    layoutTime,
                                    mapTime,
                                    reflowTime,
                                    totalTime: layoutTime + mapTime + reflowTime
                                };
                            }
                        };
                    }
                    function GridTileAnimator(grid, tiles) {
                        grid.element.css(grid.style), tiles.forEach((function(t) {
                            t.element.css(t.style);
                        }));
                    }
                }
                function GridTileDirective($mdMedia) {
                    return {
                        restrict: "E",
                        require: "^mdGridList",
                        template: "<figure ng-transclude></figure>",
                        transclude: !0,
                        scope: {},
                        controller: [ "$attrs", function($attrs) {
                            this.$attrs = $attrs;
                        } ],
                        link: function(scope, element, attrs, gridCtrl) {
                            element.attr("role", "listitem");
                            var unwatchAttrs = $mdMedia.watchResponsiveAttributes([ "md-colspan", "md-rowspan" ], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
                            gridCtrl.invalidateTiles(), scope.$on("$destroy", (function() {
                                element[0].$$mdDestroyed = !0, unwatchAttrs(), gridCtrl.invalidateLayout();
                            })), angular.isDefined(scope.$parent.$index) && scope.$watch((function() {
                                return scope.$parent.$index;
                            }), (function(newIdx, oldIdx) {
                                newIdx !== oldIdx && gridCtrl.invalidateTiles();
                            }));
                        }
                    };
                }
                function GridTileCaptionDirective() {
                    return {
                        template: "<figcaption ng-transclude></figcaption>",
                        transclude: !0
                    };
                }
                GridListController.$inject = [ "$mdUtil" ], GridLayoutFactory.$inject = [ "$mdUtil" ], 
                GridListDirective.$inject = [ "$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia", "$mdUtil" ], 
                GridTileDirective.$inject = [ "$mdMedia" ], angular.module("material.components.gridList", [ "material.core" ]).directive("mdGridList", GridListDirective).directive("mdGridTile", GridTileDirective).directive("mdGridTileFooter", GridTileCaptionDirective).directive("mdGridTileHeader", GridTileCaptionDirective).factory("$mdGridLayout", GridLayoutFactory), 
                GridListController.prototype = {
                    invalidateTiles: function() {
                        this.tilesInvalidated = !0, this.invalidateLayout();
                    },
                    invalidateLayout: function() {
                        this.layoutInvalidated || (this.layoutInvalidated = !0, this.$timeout_(angular.bind(this, this.layout)));
                    },
                    layout: function() {
                        try {
                            this.layoutDelegate(this.tilesInvalidated);
                        } finally {
                            this.layoutInvalidated = !1, this.tilesInvalidated = !1;
                        }
                    }
                };
            }(), angular.module("material.components.icon", [ "material.core" ]), angular.module("material.components.icon").directive("mdIcon", [ "$mdIcon", "$mdTheming", "$mdAria", "$sce", function($mdIcon, $mdTheming, $mdAria, $sce) {
                return {
                    restrict: "E",
                    link: function(scope, element, attr) {
                        $mdTheming(element);
                        var lastFontIcon = attr.mdFontIcon, lastFontSet = $mdIcon.fontSet(attr.mdFontSet);
                        prepareForFontIcon(), attr.$observe("mdFontIcon", fontIconChanged), attr.$observe("mdFontSet", fontIconChanged), 
                        attr.role || ($mdAria.expect(element, "role", "img"), attr.role = "img"), element[0].hasAttribute("aria-label") && "" === attr.ariaLabel && element.attr("aria-hidden", !0), 
                        "img" !== attr.role || attr.ariaHidden || $mdAria.hasAriaLabel(element) || (element[0].hasAttribute("alt") && "" === attr.alt ? element.attr("aria-hidden", !0) : attr.alt ? $mdAria.expect(element, "aria-label", attr.alt) : $mdAria.parentHasAriaLabel(element, 2) ? $mdAria.expect(element, "aria-hidden", "true") : attr.mdFontIcon || attr.mdSvgIcon || element.text() ? $mdAria.expect(element, "aria-label", attr.mdFontIcon || attr.mdSvgIcon || element.text()) : $mdAria.expect(element, "aria-hidden", "true"));
                        var attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || "");
                        function prepareForFontIcon() {
                            attr.mdSvgIcon || attr.mdSvgSrc || (attr.mdFontIcon && element.addClass("md-font " + attr.mdFontIcon), 
                            element.addClass(lastFontSet));
                        }
                        function fontIconChanged() {
                            if (!attr.mdSvgIcon && !attr.mdSvgSrc) {
                                attr.mdFontIcon && (element.removeClass(lastFontIcon), element.addClass(attr.mdFontIcon), 
                                lastFontIcon = attr.mdFontIcon);
                                var fontSet = $mdIcon.fontSet(attr.mdFontSet);
                                lastFontSet !== fontSet && (element.removeClass(lastFontSet), element.addClass(fontSet), 
                                lastFontSet = fontSet);
                            }
                        }
                        attrName && attr.$observe(attrName, (function(attrVal) {
                            element.empty(), attrVal && $mdIcon(attrVal).then((function(svg) {
                                element.empty(), element.append(svg);
                            }));
                        }));
                    }
                };
            } ]), function() {
                MdIconService.$inject = [ "config", "$templateRequest", "$q", "$log", "$mdUtil", "$sce" ], 
                angular.module("material.components.icon").constant("$$mdSvgRegistry", {
                    mdTabsArrow: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwb2x5Z29uIHBvaW50cz0iMTUuNCw3LjQgMTQsNiA4LDEyIDE0LDE4IDE1LjQsMTYuNiAxMC44LDEyICIvPjwvZz48L3N2Zz4=",
                    mdClose: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xOSA2LjQxbC0xLjQxLTEuNDEtNS41OSA1LjU5LTUuNTktNS41OS0xLjQxIDEuNDEgNS41OSA1LjU5LTUuNTkgNS41OSAxLjQxIDEuNDEgNS41OS01LjU5IDUuNTkgNS41OSAxLjQxLTEuNDEtNS41OS01LjU5eiIvPjwvZz48L3N2Zz4=",
                    mdCancel: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik0xMiAyYy01LjUzIDAtMTAgNC40Ny0xMCAxMHM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTAtNC40Ny0xMC0xMC0xMHptNSAxMy41OWwtMS40MSAxLjQxLTMuNTktMy41OS0zLjU5IDMuNTktMS40MS0xLjQxIDMuNTktMy41OS0zLjU5LTMuNTkgMS40MS0xLjQxIDMuNTkgMy41OSAzLjU5LTMuNTkgMS40MSAxLjQxLTMuNTkgMy41OSAzLjU5IDMuNTl6Ii8+PC9nPjwvc3ZnPg==",
                    mdMenu: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0zLDZIMjFWOEgzVjZNMywxMUgyMVYxM0gzVjExTTMsMTZIMjFWMThIM1YxNloiIC8+PC9zdmc+",
                    mdToggleArrow: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNDggNDgiPjxwYXRoIGQ9Ik0yNCAxNmwtMTIgMTIgMi44MyAyLjgzIDkuMTctOS4xNyA5LjE3IDkuMTcgMi44My0yLjgzeiIvPjxwYXRoIGQ9Ik0wIDBoNDh2NDhoLTQ4eiIgZmlsbD0ibm9uZSIvPjwvc3ZnPg==",
                    mdCalendar: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTkgM2gtMVYxaC0ydjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bTAgMTZINVY4aDE0djExek03IDEwaDV2NUg3eiIvPjwvc3ZnPg==",
                    mdChecked: "data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxnPjxwYXRoIGQ9Ik05IDE2LjE3TDQuODMgMTJsLTEuNDIgMS40MUw5IDE5IDIxIDdsLTEuNDEtMS40MXoiLz48L2c+PC9zdmc+"
                }).provider("$mdIcon", MdIconProvider);
                var config = {
                    defaultViewBoxSize: 24,
                    defaultFontSet: "material-icons",
                    fontSets: []
                };
                function MdIconProvider() {}
                function ConfigurationItem(url, viewBoxSize) {
                    this.url = url, this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
                }
                function MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce) {
                    var iconCache = {}, svgCache = {}, urlRegex = /[-\w@:%+.~#?&//=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%+.~#?&//=]*)?/i, dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-=]*?(base64)?,(.*)$/i;
                    return Icon.prototype = {
                        clone: function() {
                            return this.element.cloneNode(!0);
                        },
                        prepare: function() {
                            var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
                            angular.forEach({
                                fit: "",
                                height: "100%",
                                width: "100%",
                                preserveAspectRatio: "xMidYMid meet",
                                viewBox: this.element.getAttribute("viewBox") || "0 0 " + viewBoxSize + " " + viewBoxSize,
                                focusable: !1
                            }, (function(val, attr) {
                                this.element.setAttribute(attr, val);
                            }), this);
                        }
                    }, getIcon.fontSet = function(alias) {
                        if (angular.isUndefined(alias) || !alias || !alias.length) return config.defaultFontSet;
                        var result = alias;
                        return angular.forEach(config.fontSets, (function(fontSet) {
                            fontSet.alias === alias && (result = fontSet.fontSet || result);
                        })), result;
                    }, getIcon;
                    function getIcon(id) {
                        return id = id || "", angular.isString(id) || (id = $sce.getTrustedUrl(id)), iconCache[id] ? $q.when(transformClone(iconCache[id])) : urlRegex.test(id) || dataUrlRegex.test(id) ? loadByURL(id).then(cacheIcon(id)) : (-1 === id.indexOf(":") && (id = "$default:" + id), 
                        (config[id] ? loadByID : loadFromIconSet)(id).then(cacheIcon(id)));
                    }
                    function transformClone(cacheElement) {
                        var cacheSuffix, svgUrlQuerySelector, i, xlinkHrefValue, clone = cacheElement.clone(), newUid = $mdUtil.nextUid(), svgUrlAttributes = [ "clip-path", "color-profile", "cursor", "fill", "filter", "href", "marker-start", "marker-mid", "marker-end", "mask", "stroke", "style", "vector-effect" ], isIeSvg = undefined === clone.innerHTML;
                        if (!isFinite(Number(newUid))) throw new Error("Unsafe and unexpected non-number result from $mdUtil.nextUid().");
                        return cacheSuffix = "_cache" + newUid, clone.id && (clone.id += cacheSuffix), angular.forEach(clone.querySelectorAll("[id]"), (function(descendantElem) {
                            for (svgUrlQuerySelector = "", i = 0; i < svgUrlAttributes.length; i++) svgUrlQuerySelector += "[" + svgUrlAttributes[i] + '="url(#' + descendantElem.id + ')"]', 
                            i + 1 < svgUrlAttributes.length && (svgUrlQuerySelector += ", ");
                            angular.forEach(clone.querySelectorAll(svgUrlQuerySelector), (function(refItem) {
                                updateSvgIdReferences(descendantElem, refItem, isIeSvg, newUid);
                            })), angular.forEach(clone.querySelectorAll("style"), (function(refItem) {
                                updateSvgIdReferences(descendantElem, refItem, isIeSvg, newUid);
                            })), angular.forEach(clone.querySelectorAll("[*|href]:not([href])"), (function(refItem) {
                                (xlinkHrefValue = refItem.getAttribute("xlink:href")) && (xlinkHrefValue = xlinkHrefValue.replace("#" + descendantElem.id, "#" + descendantElem.id + cacheSuffix), 
                                refItem.setAttribute("xlink:href", xlinkHrefValue));
                            })), descendantElem.id += cacheSuffix;
                        })), clone;
                    }
                    function updateSvgIdReferences(referencedElement, referencingElement, isIeSvg, newUid) {
                        var svgElement, cacheSuffix;
                        if (!isFinite(Number(newUid))) throw new Error("Unsafe and unexpected non-number result for newUid.");
                        cacheSuffix = "_cache" + newUid, isIeSvg ? (svgElement = (svgElement = $mdUtil.getOuterHTML(referencingElement)).replace("url(#" + referencedElement.id + ")", "url(#" + referencedElement.id + cacheSuffix + ")"), 
                        referencingElement.textContent = angular.element(svgElement)[0].innerHTML) : referencingElement.outerHTML = referencingElement.outerHTML.replace("url(#" + referencedElement.id + ")", "url(#" + referencedElement.id + cacheSuffix + ")");
                    }
                    function cacheIcon(id) {
                        return function(icon) {
                            var target;
                            return iconCache[id] = (target = icon, angular.isDefined(target.element) && angular.isDefined(target.config) ? icon : new Icon(icon, config[id])), 
                            transformClone(iconCache[id]);
                        };
                    }
                    function loadByID(id) {
                        var iconConfig = config[id];
                        return loadByURL(iconConfig.url).then((function(icon) {
                            return new Icon(icon, iconConfig);
                        }));
                    }
                    function loadFromIconSet(id) {
                        var setName = id.substring(0, id.lastIndexOf(":")) || "$default", iconSetConfig = config[setName];
                        return iconSetConfig ? loadByURL(iconSetConfig.url).then((function(set) {
                            var iconName = id.slice(id.lastIndexOf(":") + 1), icon = set.querySelector("#" + iconName);
                            return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id);
                        })) : announceIdNotFound(id);
                        function announceIdNotFound(id) {
                            var msg = "icon " + id + " not found";
                            return $log.warn(msg), $q.reject(msg || id);
                        }
                    }
                    function loadByURL(url) {
                        return dataUrlRegex.test(url) ? function(url) {
                            var results = dataUrlRegex.exec(url), data = /base64/i.test(url) ? window.atob(results[2]) : results[2];
                            return $q.when(angular.element(data)[0]);
                        }(url) : function(url) {
                            return $q((function(resolve, reject) {
                                $templateRequest(url, !0).then((function(response) {
                                    svgCache[url] || (svgCache[url] = angular.element("<div>").append(response)[0].querySelector("svg")), 
                                    resolve(svgCache[url]);
                                }), (function(err) {
                                    var msg = angular.isString(err) ? err : err.message || err.data || err.statusText;
                                    $log.warn(msg), reject(err);
                                }));
                            }));
                        }(url);
                    }
                    function Icon(el, config) {
                        if (el && "symbol" === el.tagName.toLowerCase()) {
                            var viewbox = el.getAttribute("viewBox");
                            el = el.innerHTML ? angular.element('<svg xmlns="http://www.w3.org/2000/svg">').html(el.innerHTML)[0] : angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append($mdUtil.getInnerHTML(el))[0], 
                            viewbox && el.setAttribute("viewBox", viewbox);
                        }
                        el && "svg" !== el.tagName.toLowerCase() && (el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el.cloneNode(!0))[0]), 
                        el.getAttribute("xmlns") || el.setAttribute("xmlns", "http://www.w3.org/2000/svg"), 
                        this.element = el, this.config = config, this.prepare();
                    }
                }
                MdIconProvider.prototype = {
                    icon: function(id, url, viewBoxSize) {
                        return -1 == id.indexOf(":") && (id = "$default:" + id), config[id] = new ConfigurationItem(url, viewBoxSize), 
                        this;
                    },
                    iconSet: function(id, url, viewBoxSize) {
                        return config[id] = new ConfigurationItem(url, viewBoxSize), this;
                    },
                    defaultIconSet: function(url, viewBoxSize) {
                        return config.$default || (config.$default = new ConfigurationItem(url, viewBoxSize)), 
                        config.$default.viewBoxSize = viewBoxSize || config.defaultViewBoxSize, this;
                    },
                    defaultViewBoxSize: function(viewBoxSize) {
                        return config.defaultViewBoxSize = viewBoxSize, this;
                    },
                    fontSet: function(alias, className) {
                        return config.fontSets.push({
                            alias,
                            fontSet: className || alias
                        }), this;
                    },
                    defaultFontSet: function(className) {
                        return config.defaultFontSet = className || "", this;
                    },
                    defaultIconSize: function(iconSize) {
                        return config.defaultIconSize = iconSize, this;
                    },
                    $get: [ "$templateRequest", "$q", "$log", "$mdUtil", "$sce", function($templateRequest, $q, $log, $mdUtil, $sce) {
                        return MdIconService(config, $templateRequest, $q, $log, $mdUtil, $sce);
                    } ]
                };
            }(), function() {
                mdInputContainerDirective.$inject = [ "$mdTheming", "$parse", "$$rAF" ], inputTextareaDirective.$inject = [ "$mdUtil", "$window", "$mdAria", "$timeout", "$mdGesture" ], 
                mdMaxlengthDirective.$inject = [ "$animate", "$mdUtil" ], placeholderDirective.$inject = [ "$compile" ], 
                ngMessageDirective.$inject = [ "$mdUtil" ], mdSelectOnFocusDirective.$inject = [ "$document", "$timeout" ], 
                mdInputInvalidMessagesAnimation.$inject = [ "$$AnimateRunner", "$animateCss", "$mdUtil" ], 
                ngMessagesAnimation.$inject = [ "$$AnimateRunner", "$animateCss", "$mdUtil" ], ngMessageAnimation.$inject = [ "$$AnimateRunner", "$animateCss", "$mdUtil", "$log" ];
                var inputModule = angular.module("material.components.input", [ "material.core" ]).directive("mdInputContainer", mdInputContainerDirective).directive("label", (function() {
                    return {
                        restrict: "E",
                        require: "^?mdInputContainer",
                        link: function(scope, element, attr, containerCtrl) {
                            !containerCtrl || attr.mdNoFloat || element.hasClass("md-container-ignore") || (containerCtrl.label = element, 
                            scope.$on("$destroy", (function() {
                                containerCtrl.label = null;
                            })));
                        }
                    };
                })).directive("input", inputTextareaDirective).directive("textarea", inputTextareaDirective).directive("mdMaxlength", mdMaxlengthDirective).directive("placeholder", placeholderDirective).directive("ngMessages", (function() {
                    return {
                        restrict: "EA",
                        link: function(scope, element, attrs, inputContainer) {
                            if (!inputContainer) return;
                            element.toggleClass("md-input-messages-animation", !0), element.toggleClass("md-auto-hide", !0), 
                            ("false" == attrs.mdAutoHide || hasVisibiltyDirective(attrs)) && element.toggleClass("md-auto-hide", !1);
                        },
                        require: "^^?mdInputContainer"
                    };
                    function hasVisibiltyDirective(attrs) {
                        return visibilityDirectives.some((function(attr) {
                            return attrs[attr];
                        }));
                    }
                })).directive("ngMessage", ngMessageDirective).directive("ngMessageExp", ngMessageDirective).directive("mdSelectOnFocus", mdSelectOnFocusDirective).animation(".md-input-invalid", mdInputInvalidMessagesAnimation).animation(".md-input-messages-animation", ngMessagesAnimation).animation(".md-input-message-animation", ngMessageAnimation);
                function mdInputContainerDirective($mdTheming, $parse, $$rAF) {
                    ContainerCtrl.$inject = [ "$scope", "$element", "$attrs", "$animate" ];
                    var INPUT_TAGS = [ "INPUT", "TEXTAREA", "SELECT", "MD-SELECT" ], LEFT_SELECTORS = INPUT_TAGS.reduce((function(selectors, isel) {
                        return selectors.concat([ "md-icon ~ " + isel, ".md-icon ~ " + isel ]);
                    }), []).join(","), RIGHT_SELECTORS = INPUT_TAGS.reduce((function(selectors, isel) {
                        return selectors.concat([ isel + " ~ md-icon", isel + " ~ .md-icon" ]);
                    }), []).join(",");
                    return {
                        restrict: "E",
                        compile: function(tElement) {
                            var hasLeftIcon = tElement[0].querySelector(LEFT_SELECTORS), hasRightIcon = tElement[0].querySelector(RIGHT_SELECTORS);
                            return function(scope, element) {
                                $mdTheming(element), (hasLeftIcon || hasRightIcon) && $$rAF((function() {
                                    var iconNotRemoved = element[0].querySelector("md-icon") || element[0].querySelector(".md-icon");
                                    hasLeftIcon && iconNotRemoved && element.addClass("md-icon-left"), hasRightIcon && iconNotRemoved && element.addClass("md-icon-right");
                                }));
                            };
                        },
                        controller: ContainerCtrl
                    };
                    function ContainerCtrl($scope, $element, $attrs, $animate) {
                        var self = this;
                        $element.addClass("md-auto-horizontal-margin"), self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError), 
                        self.delegateClick = function() {
                            self.input.focus();
                        }, self.element = $element, self.setFocused = function(isFocused) {
                            $element.toggleClass("md-input-focused", !!isFocused);
                        }, self.setHasValue = function(hasValue) {
                            $element.toggleClass("md-input-has-value", !!hasValue);
                        }, self.setHasPlaceholder = function(hasPlaceholder) {
                            $element.toggleClass("md-input-has-placeholder", !!hasPlaceholder);
                        }, self.setInvalid = function(isInvalid) {
                            isInvalid ? $animate.addClass($element, "md-input-invalid") : $animate.removeClass($element, "md-input-invalid");
                        }, $scope.$watch((function() {
                            return self.label && self.input;
                        }), (function(hasLabelAndInput) {
                            hasLabelAndInput && !self.label.attr("for") && self.label.attr("for", self.input.attr("id"));
                        }));
                    }
                }
                function inputTextareaDirective($mdUtil, $window, $mdAria, $timeout, $mdGesture) {
                    return {
                        restrict: "E",
                        require: [ "^?mdInputContainer", "?ngModel", "?^form" ],
                        link: function(scope, element, attr, ctrls) {
                            var containerCtrl = ctrls[0], hasNgModel = !!ctrls[1], ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel(), parentForm = ctrls[2], isReadonly = angular.isDefined(attr.readonly), mdNoAsterisk = $mdUtil.parseAttributeBoolean(attr.mdNoAsterisk), tagName = element[0].tagName.toLowerCase();
                            if (!containerCtrl) return;
                            if ("hidden" === attr.type) return void element.attr("aria-hidden", "true");
                            if (containerCtrl.input) {
                                if (containerCtrl.input[0].contains(element[0])) return;
                                throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
                            }
                            containerCtrl.input = element, containerCtrl.label && attr.$observe("required", (function(value) {
                                containerCtrl.label && containerCtrl.label.toggleClass("md-required", value && !mdNoAsterisk);
                            }));
                            var errorsSpacer = angular.element('<div class="md-errors-spacer">');
                            element.after(errorsSpacer);
                            var placeholderText = angular.isString(attr.placeholder) ? attr.placeholder.trim() : "";
                            containerCtrl.label || placeholderText.length || $mdAria.expect(element, "aria-label");
                            element.addClass("md-input"), element.attr("id") || element.attr("id", "input_" + $mdUtil.nextUid());
                            "input" === tagName && "number" === attr.type && attr.min && attr.max && !attr.step ? element.attr("step", "any") : "textarea" === tagName && function() {
                                var isAutogrowing = !attr.hasOwnProperty("mdNoAutogrow");
                                if (attachResizeHandle(), !isAutogrowing) return;
                                var minRows = attr.hasOwnProperty("rows") ? parseInt(attr.rows) : NaN, maxRows = attr.hasOwnProperty("maxRows") ? parseInt(attr.maxRows) : NaN, scopeResizeListener = scope.$on("md-resize-textarea", growTextarea), lineHeight = null, node = element[0];
                                $timeout((function() {
                                    $mdUtil.nextTick(growTextarea);
                                }), 10, !1), element.on("input", growTextarea), hasNgModel && ngModelCtrl.$formatters.push(formattersListener);
                                minRows || element.attr("rows", 1);
                                function growTextarea() {
                                    element.attr("rows", 1).css("height", "auto").addClass("md-no-flex");
                                    var height = getHeight();
                                    if (!lineHeight) {
                                        var originalPadding = element[0].style.padding || "";
                                        lineHeight = element.css("padding", 0).prop("offsetHeight"), element[0].style.padding = originalPadding;
                                    }
                                    if (minRows && lineHeight && (height = Math.max(height, lineHeight * minRows)), 
                                    maxRows && lineHeight) {
                                        var maxHeight = lineHeight * maxRows;
                                        maxHeight < height ? (element.attr("md-no-autogrow", ""), height = maxHeight) : element.removeAttr("md-no-autogrow");
                                    }
                                    lineHeight && element.attr("rows", Math.round(height / lineHeight)), element.css("height", height + "px").removeClass("md-no-flex");
                                }
                                function getHeight() {
                                    var offsetHeight = node.offsetHeight, line = node.scrollHeight - offsetHeight;
                                    return offsetHeight + Math.max(line, 0);
                                }
                                function formattersListener(value) {
                                    return $mdUtil.nextTick(growTextarea), value;
                                }
                                function disableAutogrow() {
                                    if (isAutogrowing && (isAutogrowing = !1, angular.element($window).off("resize", growTextarea), 
                                    scopeResizeListener && scopeResizeListener(), element.attr("md-no-autogrow", "").off("input", growTextarea), 
                                    hasNgModel)) {
                                        var listenerIndex = ngModelCtrl.$formatters.indexOf(formattersListener);
                                        listenerIndex > -1 && ngModelCtrl.$formatters.splice(listenerIndex, 1);
                                    }
                                }
                                function attachResizeHandle() {
                                    if (!attr.hasOwnProperty("mdNoResize")) {
                                        var handle = angular.element('<div class="md-resize-handle"></div>'), isDragging = !1, startHeight = 0, container = containerCtrl.element, dragGestureHandler = $mdGesture.register(handle, "drag", {
                                            horizontal: !1
                                        });
                                        element.wrap('<div class="md-resize-wrapper">').after(handle), handle.on("mousedown", onMouseDown), 
                                        container.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd), 
                                        scope.$on("$destroy", (function() {
                                            handle.off("mousedown", onMouseDown).remove(), container.off("$md.dragstart", onDragStart).off("$md.drag", onDrag).off("$md.dragend", onDragEnd), 
                                            dragGestureHandler(), handle = null, container = null, dragGestureHandler = null;
                                        }));
                                    }
                                    function onMouseDown(ev) {
                                        ev.preventDefault(), isDragging = !0, ev.clientY, startHeight = parseFloat(element.css("height")) || element.prop("offsetHeight");
                                    }
                                    function onDragStart(ev) {
                                        isDragging && (ev.preventDefault(), disableAutogrow(), container.addClass("md-input-resized"));
                                    }
                                    function onDrag(ev) {
                                        isDragging && element.css("height", startHeight + ev.pointer.distanceY + "px");
                                    }
                                    function onDragEnd(ev) {
                                        isDragging && (isDragging = !1, container.removeClass("md-input-resized"));
                                    }
                                }
                                if (angular.element($window).on("resize", growTextarea), scope.$on("$destroy", disableAutogrow), 
                                attr.hasOwnProperty("mdDetectHidden")) {
                                    var handleHiddenChange = (wasHidden = !1, function() {
                                        var isHidden = 0 === node.offsetHeight;
                                        !1 === isHidden && !0 === wasHidden && growTextarea(), wasHidden = isHidden;
                                    });
                                    scope.$watch((function() {
                                        return $mdUtil.nextTick(handleHiddenChange, !1), !0;
                                    }));
                                }
                                var wasHidden;
                            }();
                            hasNgModel || inputCheckValue();
                            var isErrorGetter = containerCtrl.isErrorGetter || function() {
                                return ngModelCtrl.$invalid && (ngModelCtrl.$touched || parentForm && parentForm.$submitted);
                            };
                            scope.$watch(isErrorGetter, containerCtrl.setInvalid), attr.ngValue && attr.$observe("value", inputCheckValue);
                            ngModelCtrl.$parsers.push(ngModelPipelineCheckValue), ngModelCtrl.$formatters.push(ngModelPipelineCheckValue), 
                            element.on("input", inputCheckValue), isReadonly || element.on("focus", (function(ev) {
                                $mdUtil.nextTick((function() {
                                    containerCtrl.setFocused(!0);
                                }));
                            })).on("blur", (function(ev) {
                                $mdUtil.nextTick((function() {
                                    containerCtrl.setFocused(!1), inputCheckValue();
                                }));
                            }));
                            function ngModelPipelineCheckValue(arg) {
                                return containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg)), arg;
                            }
                            function inputCheckValue() {
                                containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
                            }
                            scope.$on("$destroy", (function() {
                                containerCtrl.setFocused(!1), containerCtrl.setHasValue(!1), containerCtrl.input = null;
                            }));
                        }
                    };
                }
                function mdMaxlengthDirective($animate, $mdUtil) {
                    return {
                        restrict: "A",
                        require: [ "ngModel", "^mdInputContainer" ],
                        link: function(scope, element, attr, ctrls) {
                            var maxlength = parseInt(attr.mdMaxlength);
                            isNaN(maxlength) && (maxlength = -1);
                            var charCountEl, errorsSpacer, ngModelCtrl = ctrls[0], containerCtrl = ctrls[1], ngTrim = !angular.isDefined(attr.ngTrim) || $mdUtil.parseAttributeBoolean(attr.ngTrim), isPasswordInput = "password" === attr.type;
                            function calculateInputValueLength(value) {
                                return null == (value = ngTrim && !isPasswordInput && angular.isString(value) ? value.trim() : value) && (value = ""), 
                                String(value).length;
                            }
                            function renderCharCount() {
                                charCountEl && charCountEl.parent() && charCountEl.text(calculateInputValueLength(element.val()) + " / " + maxlength);
                            }
                            scope.$watch(attr.mdMaxlength, (function(value) {
                                maxlength = value;
                            })), ngModelCtrl.$validators["md-maxlength"] = function(modelValue, viewValue) {
                                if (!angular.isNumber(maxlength) || maxlength < 0) return !0;
                                renderCharCount();
                                var elementVal = element.val() || viewValue;
                                return null == elementVal && (elementVal = ""), elementVal = ngTrim && !isPasswordInput && angular.isString(elementVal) ? elementVal.trim() : elementVal, 
                                String(elementVal).length <= maxlength;
                            }, ngModelCtrl.$isEmpty = function(value) {
                                return 0 === calculateInputValueLength(value);
                            }, $mdUtil.nextTick((function() {
                                errorsSpacer = angular.element(containerCtrl.element[0].querySelector(".md-errors-spacer")), 
                                charCountEl = angular.element('<div class="md-char-counter">'), errorsSpacer.append(charCountEl), 
                                attr.$observe("ngTrim", (function(value) {
                                    ngTrim = !angular.isDefined(value) || $mdUtil.parseAttributeBoolean(value);
                                })), scope.$watch(attr.mdMaxlength, (function(value) {
                                    angular.isNumber(value) && value > 0 ? (charCountEl.parent().length || $animate.enter(charCountEl, errorsSpacer), 
                                    renderCharCount()) : $animate.leave(charCountEl);
                                }));
                            }));
                        }
                    };
                }
                function placeholderDirective($compile) {
                    return {
                        restrict: "A",
                        require: "^^?mdInputContainer",
                        priority: 200,
                        link: {
                            pre: function(scope, element, attr, inputContainer) {
                                if (!inputContainer) return;
                                var label = inputContainer.element.find("label"), noFloat = inputContainer.element.attr("md-no-float");
                                if (label && label.length || "" === noFloat || scope.$eval(noFloat)) return void inputContainer.setHasPlaceholder(!0);
                                if ("MD-SELECT" !== element[0].nodeName) {
                                    var newLabel = angular.element('<label ng-click="delegateClick()" tabindex="-1" aria-hidden="true">' + attr.placeholder + "</label>");
                                    attr.$set("placeholder", null), inputContainer.element.addClass("md-icon-float").prepend(newLabel), 
                                    $compile(newLabel)(scope);
                                }
                            }
                        }
                    };
                }
                function mdSelectOnFocusDirective($document, $timeout) {
                    return {
                        restrict: "A",
                        link: function(scope, element, attr) {
                            if ("INPUT" !== element[0].nodeName && "TEXTAREA" !== element[0].nodeName) return;
                            var preventMouseUp = !1;
                            function onFocus() {
                                preventMouseUp = !0, $timeout((function() {
                                    $document[0].activeElement === element[0] && element[0].select(), preventMouseUp = !1;
                                }), 1, !1);
                            }
                            function onMouseUp(event) {
                                preventMouseUp && event.preventDefault();
                            }
                            element.on("focus", onFocus).on("mouseup", onMouseUp), scope.$on("$destroy", (function() {
                                element.off("focus", onFocus).off("mouseup", onMouseUp);
                            }));
                        }
                    };
                }
                window._mdMocksIncluded && inputModule.service("$$mdInput", (function() {
                    return {
                        messages: {
                            getElement: getMessagesElement
                        }
                    };
                })).service("mdInputInvalidAnimation", mdInputInvalidMessagesAnimation).service("mdInputMessagesAnimation", ngMessagesAnimation).service("mdInputMessageAnimation", ngMessageAnimation);
                var $$AnimateRunner, $animateCss, $mdUtil, visibilityDirectives = [ "ngIf", "ngShow", "ngHide", "ngSwitchWhen", "ngSwitchDefault" ];
                function ngMessageDirective($mdUtil) {
                    return {
                        restrict: "EA",
                        compile: function(tElement) {
                            if (isInsideInputContainer(tElement)) initMessageElement(tElement); else if (function() {
                                var nextNode = tElement[0];
                                for (;nextNode = nextNode.parentNode; ) if (nextNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return !0;
                                return !1;
                            }()) return function(scope, element) {
                                isInsideInputContainer(element) && initMessageElement(tElement);
                            };
                            function isInsideInputContainer(element) {
                                return !!$mdUtil.getClosest(element, "md-input-container");
                            }
                            function initMessageElement(element) {
                                element.toggleClass("md-input-message-animation", !0);
                            }
                        },
                        priority: 100
                    };
                }
                function mdInputInvalidMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil) {
                    return saveSharedServices($$AnimateRunner, $animateCss, $mdUtil), {
                        addClass: function(element, className, done) {
                            showInputMessages(element, done);
                        }
                    };
                }
                function ngMessagesAnimation($$AnimateRunner, $animateCss, $mdUtil) {
                    return saveSharedServices($$AnimateRunner, $animateCss, $mdUtil), {
                        enter: function(element, done) {
                            showInputMessages(element, done);
                        },
                        leave: function(element, done) {
                            hideInputMessages(element, done);
                        },
                        addClass: function(element, className, done) {
                            "ng-hide" == className ? hideInputMessages(element, done) : done();
                        },
                        removeClass: function(element, className, done) {
                            "ng-hide" == className ? showInputMessages(element, done) : done();
                        }
                    };
                }
                function ngMessageAnimation($$AnimateRunner, $animateCss, $mdUtil, $log) {
                    return saveSharedServices($$AnimateRunner, $animateCss, $mdUtil), {
                        enter: function(element, done) {
                            showMessage(element).start().done(done);
                        },
                        leave: function(element, done) {
                            hideMessage(element).start().done(done);
                        }
                    };
                }
                function showInputMessages(element, done) {
                    var animator, animators = [], messages = getMessagesElement(element), children = messages.children();
                    0 != messages.length && 0 != children.length ? (angular.forEach(children, (function(child) {
                        animator = showMessage(angular.element(child)), animators.push(animator.start());
                    })), $$AnimateRunner.all(animators, done)) : done();
                }
                function hideInputMessages(element, done) {
                    var animator, animators = [], messages = getMessagesElement(element), children = messages.children();
                    0 != messages.length && 0 != children.length ? (angular.forEach(children, (function(child) {
                        animator = hideMessage(angular.element(child)), animators.push(animator.start());
                    })), $$AnimateRunner.all(animators, done)) : done();
                }
                function showMessage(element) {
                    var height = parseInt(window.getComputedStyle(element[0]).height), topMargin = parseInt(window.getComputedStyle(element[0]).marginTop), messages = getMessagesElement(element), container = function(element) {
                        var inputContainer = element.controller("mdInputContainer");
                        return inputContainer.element;
                    }(element);
                    return topMargin > -height || messages.hasClass("md-auto-hide") && !container.hasClass("md-input-invalid") ? $animateCss(element, {}) : $animateCss(element, {
                        event: "enter",
                        structural: !0,
                        from: {
                            opacity: 0,
                            "margin-top": -height + "px"
                        },
                        to: {
                            opacity: 1,
                            "margin-top": "0"
                        },
                        duration: .3
                    });
                }
                function hideMessage(element) {
                    var height = element[0].offsetHeight, styles = window.getComputedStyle(element[0]);
                    return 0 === parseInt(styles.opacity) ? $animateCss(element, {}) : $animateCss(element, {
                        event: "leave",
                        structural: !0,
                        from: {
                            opacity: 1,
                            "margin-top": 0
                        },
                        to: {
                            opacity: 0,
                            "margin-top": -height + "px"
                        },
                        duration: .3
                    });
                }
                function getMessagesElement(element) {
                    return element.hasClass("md-input-messages-animation") ? element : element.hasClass("md-input-message-animation") ? angular.element($mdUtil.getClosest(element, (function(node) {
                        return node.classList.contains("md-input-messages-animation");
                    }))) : angular.element(element[0].querySelector(".md-input-messages-animation"));
                }
                function saveSharedServices(_$$AnimateRunner_, _$animateCss_, _$mdUtil_) {
                    $$AnimateRunner = _$$AnimateRunner_, $animateCss = _$animateCss_, $mdUtil = _$mdUtil_;
                }
            }(), function() {
                function mdListDirective($mdTheming) {
                    return {
                        restrict: "E",
                        compile: function(tEl) {
                            return tEl[0].setAttribute("role", "list"), $mdTheming;
                        }
                    };
                }
                function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
                    var proxiedTypes = [ "md-checkbox", "md-switch", "md-menu" ];
                    return {
                        restrict: "E",
                        controller: "MdListController",
                        compile: function(tElement, tAttrs) {
                            var hasProxiedElement, proxyElement, secondaryItemsWrapper, secondaryItems = tElement[0].querySelectorAll(".md-secondary"), itemContainer = tElement;
                            if (tElement[0].setAttribute("role", "listitem"), tAttrs.ngClick || tAttrs.ngDblclick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) wrapIn("button"); else if (!tElement.hasClass("md-no-proxy")) {
                                for (var i = 0; i < proxiedTypes.length; ++i) if (null !== (proxyElement = tElement[0].querySelector(proxiedTypes[i]))) {
                                    hasProxiedElement = !0;
                                    break;
                                }
                                hasProxiedElement ? wrapIn("div") : tElement.addClass("md-no-proxy");
                            }
                            function wrapIn(type) {
                                if ("div" === type) (itemContainer = angular.element('<div class="md-no-style md-list-item-inner">')).append(tElement.contents()), 
                                tElement.addClass("md-proxy-focus"); else {
                                    itemContainer = angular.element('<div class="md-button md-no-style">   <div class="md-list-item-inner"></div></div>');
                                    var buttonWrap = angular.element('<md-button class="md-no-style"></md-button>');
                                    if (moveAttributes(tElement[0], buttonWrap[0]), !buttonWrap.attr("aria-label")) {
                                        buttonWrap.attr("aria-label", $mdAria.getText(tElement));
                                        var listItemInner = itemContainer[0].querySelector(".md-list-item-inner");
                                        listItemInner && listItemInner.setAttribute("aria-hidden", "true");
                                    }
                                    tElement.hasClass("md-no-focus") && buttonWrap.addClass("md-no-focus"), itemContainer.prepend(buttonWrap), 
                                    itemContainer.children().eq(1).append(tElement.contents()), tElement.addClass("_md-button-wrap");
                                }
                                tElement[0].setAttribute("tabindex", "-1"), tElement.append(itemContainer);
                            }
                            function moveAttributes(source, destination, extraAttrs) {
                                var copiedAttrs = $mdUtil.prefixer([ "ng-if", "ng-click", "ng-dblclick", "aria-label", "ng-disabled", "ui-sref", "href", "ng-href", "rel", "target", "ng-attr-ui-sref", "ui-sref-opts", "download" ]);
                                extraAttrs && (copiedAttrs = copiedAttrs.concat($mdUtil.prefixer(extraAttrs))), 
                                angular.forEach(copiedAttrs, (function(attr) {
                                    source.hasAttribute(attr) && (destination.setAttribute(attr, source.getAttribute(attr)), 
                                    source.removeAttribute(attr));
                                }));
                            }
                            function hasClickEvent(element) {
                                for (var attr = element.attributes, i = 0; i < attr.length; i++) if ("ngClick" === tAttrs.$normalize(attr[i].name)) return !0;
                                return !1;
                            }
                            return secondaryItemsWrapper = angular.element('<div class="md-secondary-container">'), 
                            angular.forEach(secondaryItems, (function(secondaryItem) {
                                !function(secondaryItem, container) {
                                    if (secondaryItem && ("MD-BUTTON" !== (nodeName = secondaryItem.nodeName.toUpperCase()) && "BUTTON" !== nodeName) && secondaryItem.hasAttribute("ng-click")) {
                                        $mdAria.expect(secondaryItem, "aria-label");
                                        var buttonWrapper = angular.element('<md-button class="md-secondary md-icon-button">');
                                        moveAttributes(secondaryItem, buttonWrapper[0], [ "ng-if", "ng-hide", "ng-show" ]), 
                                        secondaryItem.setAttribute("tabindex", "-1"), buttonWrapper.append(secondaryItem), 
                                        secondaryItem = buttonWrapper[0];
                                    }
                                    var nodeName;
                                    secondaryItem && (!hasClickEvent(secondaryItem) || !tAttrs.ngClick && function(element) {
                                        return -1 !== proxiedTypes.indexOf(element.nodeName.toLowerCase());
                                    }(secondaryItem)) && angular.element(secondaryItem).removeClass("md-secondary"), 
                                    tElement.addClass("md-with-secondary"), container.append(secondaryItem);
                                }(secondaryItem, secondaryItemsWrapper);
                            })), itemContainer.append(secondaryItemsWrapper), function() {
                                for (var toggle, toggleTypes = [ "md-switch", "md-checkbox" ], i = 0; i < toggleTypes.length; ++i) if ((toggle = tElement.find(toggleTypes[i])[0]) && !toggle.hasAttribute("aria-label")) {
                                    var labelElement = tElement.find("p")[0];
                                    if (labelElement || (labelElement = tElement.find("span")[0]), !labelElement) return;
                                    toggle.setAttribute("aria-label", "Toggle " + labelElement.textContent);
                                }
                            }(), hasProxiedElement && "MD-MENU" === proxyElement.nodeName && function() {
                                var menuEl = angular.element(proxyElement), isEndAligned = menuEl.parent().hasClass("md-secondary-container") || proxyElement.parentNode.firstElementChild !== proxyElement, xAxisPosition = "left";
                                isEndAligned && (xAxisPosition = "right");
                                menuEl.attr("md-position-mode") || menuEl.attr("md-position-mode", xAxisPosition + " target");
                                var menuOpenButton = menuEl.children().eq(0);
                                hasClickEvent(menuOpenButton[0]) || menuOpenButton.attr("ng-click", "$mdMenu.open($event)");
                                menuOpenButton.attr("aria-label") || menuOpenButton.attr("aria-label", "Open List Menu");
                            }(), function($scope, $element, $attr, ctrl) {
                                $element.addClass("_md");
                                var proxies = [], firstElement = $element[0].firstElementChild, clickChild = $element.hasClass("_md-button-wrap") ? firstElement.firstElementChild : firstElement, hasClick = clickChild && hasClickEvent(clickChild), noProxies = $element.hasClass("md-no-proxy");
                                void (firstElement && firstElement.children && !hasClick && !noProxies && angular.forEach(proxiedTypes, (function(type) {
                                    angular.forEach(firstElement.querySelectorAll(type + ":not(.md-secondary)"), (function(child) {
                                        proxies.push(child);
                                    }));
                                }))), void ((1 === proxies.length || hasClick) && ($element.addClass("md-clickable"), 
                                hasClick || ctrl.attachRipple($scope, angular.element($element[0].querySelector(".md-no-style"))))), 
                                proxies.length && angular.forEach(proxies, (function(proxy) {
                                    proxy = angular.element(proxy), $scope.mouseActive = !1, proxy.on("mousedown", (function() {
                                        $scope.mouseActive = !0, $timeout((function() {
                                            $scope.mouseActive = !1;
                                        }), 100);
                                    })).on("focus", (function() {
                                        !1 === $scope.mouseActive && $element.addClass("md-focused"), proxy.on("blur", (function proxyOnBlur() {
                                            $element.removeClass("md-focused"), proxy.off("blur", proxyOnBlur);
                                        }));
                                    }));
                                }));
                                var clickChildKeypressListener = function(keypressEvent) {
                                    "INPUT" === keypressEvent.target.nodeName || "TEXTAREA" === keypressEvent.target.nodeName || keypressEvent.target.isContentEditable || (keypressEvent.which || keypressEvent.keyCode) === $mdConstant.KEY_CODE.SPACE && clickChild && (clickChild.click(), 
                                    keypressEvent.preventDefault(), keypressEvent.stopPropagation());
                                };
                                hasClick || proxies.length || clickChild && clickChild.addEventListener("keypress", clickChildKeypressListener);
                                $element.off("click"), $element.off("keypress"), $element.off("keydown"), 1 === proxies.length && clickChild && $element.children().eq(0).on("click", (function(clickEvent) {
                                    (function(event) {
                                        var forbiddenControls = [ "md-slider" ], eventBubblePath = $mdUtil.getEventPath(event);
                                        if (!eventBubblePath || 0 === eventBubblePath.length) return -1 !== forbiddenControls.indexOf(event.target.tagName.toLowerCase());
                                        for (var maxPath = eventBubblePath.indexOf($element.children()[0]), i = 0; i < maxPath; i++) if (-1 !== forbiddenControls.indexOf(eventBubblePath[i].tagName.toLowerCase())) return !0;
                                        return !1;
                                    })(clickEvent) || !$mdUtil.getClosest(clickEvent.target, "BUTTON") && clickChild.contains(clickEvent.target) && angular.forEach(proxies, (function(proxy) {
                                        clickEvent.target === proxy || proxy.contains(clickEvent.target) || ("MD-MENU" === proxy.nodeName && (proxy = proxy.children[0]), 
                                        angular.element(proxy).triggerHandler("click"));
                                    }));
                                }));
                                $scope.$on("$destroy", (function() {
                                    clickChild && clickChild.removeEventListener("keypress", clickChildKeypressListener);
                                }));
                            };
                        }
                    };
                }
                function MdListController($scope, $element, $mdListInkRipple) {
                    this.attachRipple = function(scope, element) {
                        $mdListInkRipple.attach(scope, element, {});
                    };
                }
                MdListController.$inject = [ "$scope", "$element", "$mdListInkRipple" ], mdListDirective.$inject = [ "$mdTheming" ], 
                mdListItemDirective.$inject = [ "$mdAria", "$mdConstant", "$mdUtil", "$timeout" ], 
                angular.module("material.components.list", [ "material.core" ]).controller("MdListController", MdListController).directive("mdList", mdListDirective).directive("mdListItem", mdListItemDirective);
            }(), angular.module("material.components.menu", [ "material.core", "material.components.backdrop" ]), 
            function() {
                function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q, $log) {
                    var menuContainer, triggerElement, prefixer = $mdUtil.prefixer(), self = this;
                    this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0, this.init = function(setMenuContainer, opts) {
                        opts = opts || {}, menuContainer = setMenuContainer, (triggerElement = $element[0].querySelector(prefixer.buildSelector([ "ng-click", "ng-mouseenter" ]))).setAttribute("aria-expanded", "false"), 
                        this.isInMenuBar = opts.isInMenuBar, this.mdMenuBarCtrl = opts.mdMenuBarCtrl, this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll(".md-nested-menu")), 
                        menuContainer.on("$mdInterimElementRemove", (function() {
                            self.isOpen = !1, $mdUtil.nextTick((function() {
                                self.onIsOpenChanged(self.isOpen);
                            }));
                        })), $mdUtil.nextTick((function() {
                            self.onIsOpenChanged(self.isOpen);
                        }));
                        var menuContainerId = "menu_container_" + $mdUtil.nextUid();
                        menuContainer.attr("id", menuContainerId), angular.element(triggerElement).attr({
                            "aria-owns": menuContainerId,
                            "aria-haspopup": "true"
                        }), $scope.$on("$destroy", angular.bind(this, (function() {
                            this.disableHoverListener(), $mdMenu.destroy();
                        }))), menuContainer.on("$destroy", (function() {
                            $mdMenu.destroy();
                        }));
                    };
                    var openMenuTimeout, menuItems, deregisterScopeListeners = [];
                    this.enableHoverListener = function() {
                        deregisterScopeListeners.push($rootScope.$on("$mdMenuOpen", (function(event, el) {
                            menuContainer[0].contains(el[0]) && (self.currentlyOpenMenu = el.controller("mdMenu"), 
                            self.isAlreadyOpening = !1, self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self)));
                        }))), deregisterScopeListeners.push($rootScope.$on("$mdMenuClose", (function(event, el) {
                            menuContainer[0].contains(el[0]) && (self.currentlyOpenMenu = undefined);
                        }))), (menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children))).on("mouseenter", self.handleMenuItemHover), 
                        menuItems.on("mouseleave", self.handleMenuItemMouseLeave);
                    }, this.disableHoverListener = function() {
                        for (;deregisterScopeListeners.length; ) deregisterScopeListeners.shift()();
                        menuItems && menuItems.off("mouseenter", self.handleMenuItemHover), menuItems && menuItems.off("mouseleave", self.handleMenuItemMouseLeave);
                    }, this.handleMenuItemHover = function(event) {
                        if (!self.isAlreadyOpening) {
                            var nestedMenu = event.target.querySelector("md-menu") || $mdUtil.getClosest(event.target, "MD-MENU");
                            openMenuTimeout = $timeout((function() {
                                if (nestedMenu && (nestedMenu = angular.element(nestedMenu).controller("mdMenu")), 
                                self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
                                    var closeTo = self.nestLevel + 1;
                                    self.currentlyOpenMenu.close(!0, {
                                        closeTo
                                    }), self.isAlreadyOpening = !!nestedMenu, nestedMenu && nestedMenu.open();
                                } else nestedMenu && !nestedMenu.isOpen && nestedMenu.open && (self.isAlreadyOpening = !!nestedMenu, 
                                nestedMenu && nestedMenu.open());
                            }), nestedMenu ? 100 : 250);
                            var focusableTarget = event.currentTarget.querySelector(".md-button:not([disabled])");
                            focusableTarget && focusableTarget.focus();
                        }
                    }, this.handleMenuItemMouseLeave = function() {
                        openMenuTimeout && ($timeout.cancel(openMenuTimeout), openMenuTimeout = undefined);
                    }, this.open = function(ev) {
                        ev && ev.stopPropagation(), ev && ev.preventDefault(), self.isOpen || (self.enableHoverListener(), 
                        self.isOpen = !0, $mdUtil.nextTick((function() {
                            self.onIsOpenChanged(self.isOpen);
                        })), (triggerElement = triggerElement || (ev ? ev.target : $element[0])).setAttribute("aria-expanded", "true"), 
                        $scope.$emit("$mdMenuOpen", $element), $mdMenu.show({
                            scope: $scope,
                            mdMenuCtrl: self,
                            nestLevel: self.nestLevel,
                            element: menuContainer,
                            target: triggerElement,
                            preserveElement: !0,
                            parent: "body"
                        }).finally((function() {
                            triggerElement.setAttribute("aria-expanded", "false"), self.disableHoverListener();
                        })));
                    }, this.onIsOpenChanged = function(isOpen) {
                        isOpen ? (menuContainer.attr("aria-hidden", "false"), $element[0].classList.add("md-open"), 
                        angular.forEach(self.nestedMenus, (function(el) {
                            el.classList.remove("md-open");
                        }))) : (menuContainer.attr("aria-hidden", "true"), $element[0].classList.remove("md-open")), 
                        $scope.$mdMenuIsOpen = self.isOpen;
                    }, this.focusMenuContainer = function() {
                        var focusTarget = menuContainer[0].querySelector(prefixer.buildSelector([ "md-menu-focus-target", "md-autofocus" ]));
                        focusTarget || (focusTarget = menuContainer[0].querySelector(".md-button:not([disabled])")), 
                        focusTarget.focus();
                    }, this.registerContainerProxy = function(handler) {
                        this.containerProxy = handler;
                    }, this.triggerContainerProxy = function(ev) {
                        this.containerProxy && this.containerProxy(ev);
                    }, this.destroy = function() {
                        return self.isOpen ? $mdMenu.destroy() : $q.when(!1);
                    }, this.close = function(skipFocus, closeOpts) {
                        if (self.isOpen) {
                            self.isOpen = !1, $mdUtil.nextTick((function() {
                                self.onIsOpenChanged(self.isOpen);
                            }));
                            var eventDetails = angular.extend({}, closeOpts, {
                                skipFocus
                            });
                            if ($scope.$emit("$mdMenuClose", $element, eventDetails), $mdMenu.hide(null, closeOpts), 
                            !skipFocus) {
                                var el = self.restoreFocusTo || $element.find("button")[0];
                                el instanceof angular.element && (el = el[0]), el && el.focus();
                            }
                        }
                    }, this.positionMode = function() {
                        var attachment = ($attrs.mdPositionMode || "target").split(" ");
                        return 1 === attachment.length && attachment.push(attachment[0]), {
                            left: attachment[0],
                            top: attachment[1]
                        };
                    }, this.offsets = function() {
                        var position = ($attrs.mdOffset || "0 0").split(" ").map(parseFloat);
                        if (2 === position.length) return {
                            left: position[0],
                            top: position[1]
                        };
                        if (1 === position.length) return {
                            top: position[0],
                            left: position[0]
                        };
                        throw Error("Invalid offsets specified. Please follow format <x, y> or <n>");
                    }, $scope.$mdMenu = {
                        open: this.open,
                        close: this.close
                    };
                }
                MenuController.$inject = [ "$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q", "$log" ], 
                angular.module("material.components.menu").controller("mdMenuCtrl", MenuController);
            }(), function() {
                function MenuDirective($mdUtil) {
                    return {
                        restrict: "E",
                        require: [ "mdMenu", "?^mdMenuBar" ],
                        controller: "mdMenuCtrl",
                        scope: !0,
                        compile: function(templateElement) {
                            templateElement.addClass("md-menu");
                            var triggerEl = templateElement.children()[0], prefixer = $mdUtil.prefixer();
                            prefixer.hasAttribute(triggerEl, "ng-click") || (triggerEl = triggerEl.querySelector(prefixer.buildSelector([ "ng-click", "ng-mouseenter" ])) || triggerEl);
                            var isButtonTrigger = "MD-BUTTON" === triggerEl.nodeName || "BUTTON" === triggerEl.nodeName;
                            triggerEl && isButtonTrigger && !triggerEl.hasAttribute("type") && triggerEl.setAttribute("type", "button");
                            if (!triggerEl) throw Error("Invalid HTML for md-menu: Expected the menu to have a trigger element.");
                            if (2 !== templateElement.children().length) throw Error("Invalid HTML for md-menu: Expected two children elements. The second element must have a `md-menu-content` element.");
                            triggerEl && triggerEl.setAttribute("aria-haspopup", "true");
                            var nestedMenus = templateElement[0].querySelectorAll("md-menu"), nestingDepth = parseInt(templateElement[0].getAttribute("md-nest-level"), 10) || 0;
                            nestedMenus && angular.forEach($mdUtil.nodesToArray(nestedMenus), (function(menuEl) {
                                menuEl.hasAttribute("md-position-mode") || menuEl.setAttribute("md-position-mode", "cascade"), 
                                menuEl.classList.add("_md-nested-menu"), menuEl.setAttribute("md-nest-level", nestingDepth + 1);
                            }));
                            return link;
                        }
                    };
                    function link(scope, element, attr, ctrls) {
                        var mdMenuCtrl = ctrls[0], isInMenuBar = !!ctrls[1], mdMenuBarCtrl = ctrls[1], menuContainer = angular.element('<div class="_md md-open-menu-container md-whiteframe-z2"></div>'), menuContents = element.children()[1];
                        element.addClass("_md"), menuContents.hasAttribute("role") || menuContents.setAttribute("role", "menu"), 
                        menuContainer.append(menuContents), element.on("$destroy", (function() {
                            menuContainer.remove();
                        })), element.append(menuContainer), menuContainer[0].style.display = "none", mdMenuCtrl.init(menuContainer, {
                            isInMenuBar,
                            mdMenuBarCtrl
                        });
                    }
                }
                MenuDirective.$inject = [ "$mdUtil" ], angular.module("material.components.menu").directive("mdMenu", MenuDirective);
            }(), function() {
                function MenuProvider($$interimElementProvider) {
                    menuDefaultOptions.$inject = [ "$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$log" ];
                    var MENU_EDGE_MARGIN = 8;
                    return $$interimElementProvider("$mdMenu").setDefaults({
                        methods: [ "target" ],
                        options: menuDefaultOptions
                    });
                    function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate, $log) {
                        var prefixer = $mdUtil.prefixer(), animator = $mdUtil.dom.animator;
                        return {
                            parent: "body",
                            onShow: function(scope, element, opts) {
                                (function() {
                                    if (!opts.target) throw Error("$mdMenu.show() expected a target to animate from in options.target");
                                    angular.extend(opts, {
                                        alreadyOpen: !1,
                                        isRemoved: !1,
                                        target: angular.element(opts.target),
                                        parent: angular.element(opts.parent),
                                        menuContentEl: angular.element(element[0].querySelector("md-menu-content"))
                                    });
                                })(), opts.menuContentEl[0] ? $mdTheming.inherit(opts.menuContentEl, opts.target) : $log.warn("$mdMenu: Menu elements should always contain a `md-menu-content` element,otherwise interactivity features will not work properly.", element);
                                return opts.cleanupResizing = function() {
                                    var repositionMenu = (target = element, options = opts, $$rAF.throttle((function() {
                                        if (!opts.isRemoved) {
                                            var position = calculateMenuPosition(target, options);
                                            target.css(animator.toCss(position));
                                        }
                                    })));
                                    var target, options;
                                    return $window.addEventListener("resize", repositionMenu), $window.addEventListener("orientationchange", repositionMenu), 
                                    function() {
                                        $window.removeEventListener("resize", repositionMenu), $window.removeEventListener("orientationchange", repositionMenu);
                                    };
                                }(), opts.hideBackdrop = showBackdrop(scope, element, opts), function() {
                                    return opts.parent.append(element), element[0].style.display = "", $q((function(resolve) {
                                        var position = calculateMenuPosition(element, opts);
                                        element.removeClass("md-leave"), $animateCss(element, {
                                            addClass: "md-active",
                                            from: animator.toCss(position),
                                            to: animator.toCss({
                                                transform: ""
                                            })
                                        }).start().then(resolve);
                                    }));
                                }().then((function(response) {
                                    return opts.alreadyOpen = !0, opts.cleanupInteraction = function() {
                                        if (!opts.menuContentEl[0]) return angular.noop;
                                        opts.menuContentEl.on("keydown", onMenuKeyDown), opts.menuContentEl[0].addEventListener("click", captureClickListener, !0);
                                        var focusTarget = opts.menuContentEl[0].querySelector(prefixer.buildSelector([ "md-menu-focus-target", "md-autofocus" ]));
                                        if (!focusTarget) for (var childrenLen = opts.menuContentEl[0].children.length, childIndex = 0; childIndex < childrenLen; childIndex++) {
                                            var child = opts.menuContentEl[0].children[childIndex];
                                            if (focusTarget = child.querySelector(".md-button:not([disabled])")) break;
                                            if (child.firstElementChild && !child.firstElementChild.disabled && !child.firstElementChild.getAttribute("disabled")) {
                                                focusTarget = child.firstElementChild;
                                                break;
                                            }
                                        }
                                        return focusTarget && focusTarget.focus(), function() {
                                            opts.menuContentEl.off("keydown", onMenuKeyDown), opts.menuContentEl[0].removeEventListener("click", captureClickListener, !0);
                                        };
                                        function onMenuKeyDown(ev) {
                                            var handled;
                                            switch (ev.keyCode) {
                                              case $mdConstant.KEY_CODE.ESCAPE:
                                                opts.nestLevel ? opts.mdMenuCtrl.close() : opts.mdMenuCtrl.close(!1, {
                                                    closeAll: !0
                                                }), handled = !0;
                                                break;

                                              case $mdConstant.KEY_CODE.TAB:
                                                opts.mdMenuCtrl.close(!1, {
                                                    closeAll: !0
                                                }), handled = !1;
                                                break;

                                              case $mdConstant.KEY_CODE.UP_ARROW:
                                                focusMenuItem(ev, opts.menuContentEl, opts, -1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev), 
                                                handled = !0;
                                                break;

                                              case $mdConstant.KEY_CODE.DOWN_ARROW:
                                                focusMenuItem(ev, opts.menuContentEl, opts, 1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev), 
                                                handled = !0;
                                                break;

                                              case $mdConstant.KEY_CODE.LEFT_ARROW:
                                                opts.nestLevel ? opts.mdMenuCtrl.close() : opts.mdMenuCtrl.triggerContainerProxy(ev), 
                                                handled = !0;
                                                break;

                                              case $mdConstant.KEY_CODE.RIGHT_ARROW:
                                                var parentMenu = $mdUtil.getClosest(ev.target, "MD-MENU");
                                                parentMenu && parentMenu != opts.parent[0] ? ev.target.click() : opts.mdMenuCtrl.triggerContainerProxy(ev), 
                                                handled = !0;
                                            }
                                            handled && (ev.preventDefault(), ev.stopImmediatePropagation());
                                        }
                                        function captureClickListener(e) {
                                            var target = e.target;
                                            do {
                                                if (target == opts.menuContentEl[0]) return;
                                                if ((hasAnyAttribute(target, [ "ng-click", "ng-href", "ui-sref" ]) || "BUTTON" == target.nodeName || "MD-BUTTON" == target.nodeName) && !hasAnyAttribute(target, [ "md-prevent-menu-close" ])) {
                                                    var closestMenu = $mdUtil.getClosest(target, "MD-MENU");
                                                    target.hasAttribute("disabled") || closestMenu && closestMenu != opts.parent[0] || close();
                                                    break;
                                                }
                                            } while (target = target.parentNode);
                                            function close() {
                                                scope.$apply((function() {
                                                    opts.mdMenuCtrl.close(!0, {
                                                        closeAll: !0
                                                    });
                                                }));
                                            }
                                            function hasAnyAttribute(target, attrs) {
                                                if (!target) return !1;
                                                for (var attr, i = 0; attr = attrs[i]; ++i) if (prefixer.hasAttribute(target, attr)) return !0;
                                                return !1;
                                            }
                                        }
                                    }(), opts.cleanupBackdrop = opts.backdrop ? (opts.backdrop.on("click", onBackdropClick), 
                                    function() {
                                        opts.backdrop.off("click", onBackdropClick);
                                    }) : angular.noop, element.addClass("md-clickable"), response;
                                }));
                                function onBackdropClick(event) {
                                    event.preventDefault(), event.stopPropagation(), scope.$apply((function() {
                                        opts.mdMenuCtrl.close(!0, {
                                            closeAll: !0
                                        });
                                    }));
                                }
                            },
                            onRemove: function(scope, element, opts) {
                                return opts.cleanupInteraction(), opts.cleanupBackdrop(), opts.cleanupResizing(), 
                                opts.hideBackdrop(), element.removeClass("md-clickable"), !0 === opts.$destroy ? detachAndClean() : function() {
                                    return $animateCss(element, {
                                        addClass: "md-leave"
                                    }).start();
                                }().then(detachAndClean);
                                function detachAndClean() {
                                    element.removeClass("md-active"), function(element, opts) {
                                        opts.preserveElement ? toNode(element).style.display = "none" : toNode(element).parentNode === toNode(opts.parent) && toNode(opts.parent).removeChild(toNode(element));
                                    }(element, opts), opts.alreadyOpen = !1;
                                }
                            },
                            hasBackdrop: !0,
                            disableParentScroll: !0,
                            skipCompile: !0,
                            preserveScope: !0,
                            multiple: !0,
                            themable: !0
                        };
                        function showBackdrop(scope, element, options) {
                            return options.nestLevel ? angular.noop : (options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = !1, 
                            options.hasBackdrop && (options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher"), 
                            $animate.enter(options.backdrop, options.backdropParent || $document[0].body)), 
                            function() {
                                options.backdrop && options.backdrop.remove(), options.disableParentScroll && options.restoreScroll();
                            });
                        }
                        function focusMenuItem(e, menuEl, opts, direction) {
                            for (var didFocus, currentItem = $mdUtil.getClosest(e.target, "MD-MENU-ITEM"), items = $mdUtil.nodesToArray(menuEl[0].children), i = items.indexOf(currentItem) + direction; i >= 0 && i < items.length; i += direction) {
                                if (didFocus = attemptFocus(items[i].querySelector(".md-button"))) break;
                            }
                            return didFocus;
                        }
                        function attemptFocus(el) {
                            if (el && -1 != el.getAttribute("tabindex")) return el.focus(), $document[0].activeElement == el;
                        }
                        function calculateMenuPosition(el, opts) {
                            var alignTarget, containerNode = el[0], openMenuNode = el[0].firstElementChild, openMenuNodeRect = openMenuNode.getBoundingClientRect(), boundryNodeRect = $document[0].body.getBoundingClientRect(), menuStyle = $window.getComputedStyle(openMenuNode), originNode = opts.target[0].querySelector(prefixer.buildSelector("md-menu-origin")) || opts.target[0], originNodeRect = originNode.getBoundingClientRect(), bounds = {
                                left: boundryNodeRect.left + MENU_EDGE_MARGIN,
                                top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
                                bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
                                right: boundryNodeRect.right - MENU_EDGE_MARGIN
                            }, alignTargetRect = {
                                top: 0,
                                left: 0,
                                right: 0,
                                bottom: 0
                            }, existingOffsets = {
                                top: 0,
                                left: 0,
                                right: 0,
                                bottom: 0
                            }, positionMode = opts.mdMenuCtrl.positionMode();
                            "target" !== positionMode.top && "target" !== positionMode.left && "target-right" !== positionMode.left || (alignTarget = function() {
                                for (var i = 0; i < openMenuNode.children.length; ++i) if ("none" != $window.getComputedStyle(openMenuNode.children[i]).display) return openMenuNode.children[i];
                            }()) && (alignTargetRect = (alignTarget = (alignTarget = alignTarget.firstElementChild || alignTarget).querySelector(prefixer.buildSelector("md-menu-align-target")) || alignTarget).getBoundingClientRect(), 
                            existingOffsets = {
                                top: parseFloat(containerNode.style.top || 0),
                                left: parseFloat(containerNode.style.left || 0)
                            });
                            var position = {}, transformOrigin = "top ";
                            switch (positionMode.top) {
                              case "target":
                                position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
                                break;

                              case "cascade":
                                position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
                                break;

                              case "bottom":
                                position.top = originNodeRect.top + originNodeRect.height;
                                break;

                              default:
                                throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
                            }
                            var rtl = $mdUtil.isRtl(el);
                            switch (positionMode.left) {
                              case "target":
                                position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left, 
                                transformOrigin += rtl ? "right" : "left";
                                break;

                              case "target-left":
                                position.left = originNodeRect.left, transformOrigin += "left";
                                break;

                              case "target-right":
                                position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right), 
                                transformOrigin += "right";
                                break;

                              case "cascade":
                                var willFitRight = rtl ? originNodeRect.left - openMenuNodeRect.width < bounds.left : originNodeRect.right + openMenuNodeRect.width < bounds.right;
                                position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width, 
                                transformOrigin += willFitRight ? "left" : "right";
                                break;

                              case "right":
                                rtl ? (position.left = originNodeRect.right - originNodeRect.width, transformOrigin += "left") : (position.left = originNodeRect.right - openMenuNodeRect.width, 
                                transformOrigin += "right");
                                break;

                              case "left":
                                rtl ? (position.left = originNodeRect.right - openMenuNodeRect.width, transformOrigin += "right") : (position.left = originNodeRect.left, 
                                transformOrigin += "left");
                                break;

                              default:
                                throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
                            }
                            var pos, offsets = opts.mdMenuCtrl.offsets();
                            position.top += offsets.top, position.left += offsets.left, (pos = position).top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top), 
                            pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
                            var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1)) / 100, scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1)) / 100;
                            return {
                                top: Math.round(position.top),
                                left: Math.round(position.left),
                                transform: opts.alreadyOpen ? undefined : $mdUtil.supplant("scale({0},{1})", [ scaleX, scaleY ]),
                                transformOrigin
                            };
                        }
                    }
                    function toNode(el) {
                        return el instanceof angular.element && (el = el[0]), el;
                    }
                }
                MenuProvider.$inject = [ "$$interimElementProvider" ], angular.module("material.components.menu").provider("$mdMenu", MenuProvider);
            }(), angular.module("material.components.menuBar", [ "material.core", "material.components.icon", "material.components.menu" ]), 
            function() {
                MenuBarController.$inject = [ "$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout" ], 
                angular.module("material.components.menuBar").controller("MenuBarController", MenuBarController);
                var BOUND_MENU_METHODS = [ "handleKeyDown", "handleMenuHover", "scheduleOpenHoveredMenu", "cancelScheduledOpen" ];
                function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
                    this.$element = $element, this.$attrs = $attrs, this.$mdConstant = $mdConstant, 
                    this.$mdUtil = $mdUtil, this.$document = $document, this.$scope = $scope, this.$rootScope = $rootScope, 
                    this.$timeout = $timeout;
                    var self = this;
                    angular.forEach(BOUND_MENU_METHODS, (function(methodName) {
                        self[methodName] = angular.bind(self, self[methodName]);
                    }));
                }
                MenuBarController.prototype.init = function() {
                    var $element = this.$element, $mdUtil = this.$mdUtil, $scope = this.$scope, self = this, deregisterFns = [];
                    $element.on("keydown", this.handleKeyDown), this.parentToolbar = $mdUtil.getClosest($element, "MD-TOOLBAR"), 
                    deregisterFns.push(this.$rootScope.$on("$mdMenuOpen", (function(event, el) {
                        -1 != self.getMenus().indexOf(el[0]) && ($element[0].classList.add("md-open"), el[0].classList.add("md-open"), 
                        self.currentlyOpenMenu = el.controller("mdMenu"), self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown), 
                        self.enableOpenOnHover());
                    }))), deregisterFns.push(this.$rootScope.$on("$mdMenuClose", (function(event, el, opts) {
                        var rootMenus = self.getMenus();
                        -1 != rootMenus.indexOf(el[0]) && ($element[0].classList.remove("md-open"), el[0].classList.remove("md-open"));
                        var ctrl = angular.element(el[0]).controller("mdMenu");
                        if (ctrl.isInMenuBar && ctrl.mdMenuBarCtrl === self) {
                            for (var parentMenu = el[0]; parentMenu && -1 == rootMenus.indexOf(parentMenu); ) parentMenu = $mdUtil.getClosest(parentMenu, "MD-MENU", !0);
                            parentMenu && (opts.skipFocus || parentMenu.querySelector("button:not([disabled])").focus(), 
                            self.currentlyOpenMenu = undefined), self.disableOpenOnHover(), self.setKeyboardMode(!0);
                        }
                    }))), $scope.$on("$destroy", (function() {
                        for (self.disableOpenOnHover(); deregisterFns.length; ) deregisterFns.shift()();
                    })), this.setKeyboardMode(!0);
                }, MenuBarController.prototype.setKeyboardMode = function(enabled) {
                    enabled ? this.$element[0].classList.add("md-keyboard-mode") : this.$element[0].classList.remove("md-keyboard-mode");
                }, MenuBarController.prototype.enableOpenOnHover = function() {
                    if (!this.openOnHoverEnabled) {
                        var self = this;
                        self.openOnHoverEnabled = !0, self.parentToolbar && (self.parentToolbar.classList.add("md-has-open-menu"), 
                        self.$mdUtil.nextTick((function() {
                            angular.element(self.parentToolbar).on("click", self.handleParentClick);
                        }), !1)), angular.element(self.getMenus()).on("mouseenter", self.handleMenuHover);
                    }
                }, MenuBarController.prototype.handleMenuHover = function(e) {
                    this.setKeyboardMode(!1), this.openOnHoverEnabled && this.scheduleOpenHoveredMenu(e);
                }, MenuBarController.prototype.disableOpenOnHover = function() {
                    this.openOnHoverEnabled && (this.openOnHoverEnabled = !1, this.parentToolbar && (this.parentToolbar.classList.remove("md-has-open-menu"), 
                    angular.element(this.parentToolbar).off("click", this.handleParentClick)), angular.element(this.getMenus()).off("mouseenter", this.handleMenuHover));
                }, MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
                    var menuCtrl = angular.element(e.currentTarget).controller("mdMenu");
                    this.setKeyboardMode(!1), this.scheduleOpenMenu(menuCtrl);
                }, MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
                    var self = this, $timeout = this.$timeout;
                    menuCtrl != self.currentlyOpenMenu && ($timeout.cancel(self.pendingMenuOpen), self.pendingMenuOpen = $timeout((function() {
                        self.pendingMenuOpen = undefined, self.currentlyOpenMenu && self.currentlyOpenMenu.close(!0, {
                            closeAll: !0
                        }), menuCtrl.open();
                    }), 200, !1));
                }, MenuBarController.prototype.handleKeyDown = function(e) {
                    var handled, newMenu, newMenuCtrl, keyCodes = this.$mdConstant.KEY_CODE, currentMenu = this.currentlyOpenMenu, wasOpen = currentMenu && currentMenu.isOpen;
                    switch (this.setKeyboardMode(!0), e.keyCode) {
                      case keyCodes.DOWN_ARROW:
                        currentMenu ? currentMenu.focusMenuContainer() : this.openFocusedMenu(), handled = !0;
                        break;

                      case keyCodes.UP_ARROW:
                        currentMenu && currentMenu.close(), handled = !0;
                        break;

                      case keyCodes.LEFT_ARROW:
                        newMenu = this.focusMenu(-1), wasOpen && (newMenuCtrl = angular.element(newMenu).controller("mdMenu"), 
                        this.scheduleOpenMenu(newMenuCtrl)), handled = !0;
                        break;

                      case keyCodes.RIGHT_ARROW:
                        newMenu = this.focusMenu(1), wasOpen && (newMenuCtrl = angular.element(newMenu).controller("mdMenu"), 
                        this.scheduleOpenMenu(newMenuCtrl)), handled = !0;
                    }
                    handled && (e && e.preventDefault && e.preventDefault(), e && e.stopImmediatePropagation && e.stopImmediatePropagation());
                }, MenuBarController.prototype.focusMenu = function(direction) {
                    var menus = this.getMenus(), focusedIndex = this.getFocusedMenuIndex();
                    -1 == focusedIndex && (focusedIndex = this.getOpenMenuIndex());
                    var changed = !1;
                    if (-1 == focusedIndex ? (focusedIndex = 0, changed = !0) : (direction < 0 && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction) && (focusedIndex += direction, 
                    changed = !0), changed) return menus[focusedIndex].querySelector("button").focus(), 
                    menus[focusedIndex];
                }, MenuBarController.prototype.openFocusedMenu = function() {
                    var menu = this.getFocusedMenu();
                    menu && angular.element(menu).controller("mdMenu").open();
                }, MenuBarController.prototype.getMenus = function() {
                    var $element = this.$element;
                    return this.$mdUtil.nodesToArray($element[0].children).filter((function(el) {
                        return "MD-MENU" == el.nodeName;
                    }));
                }, MenuBarController.prototype.getFocusedMenu = function() {
                    return this.getMenus()[this.getFocusedMenuIndex()];
                }, MenuBarController.prototype.getFocusedMenuIndex = function() {
                    var focusedEl = this.$mdUtil.getClosest(this.$document[0].activeElement, "MD-MENU");
                    return focusedEl ? this.getMenus().indexOf(focusedEl) : -1;
                }, MenuBarController.prototype.getOpenMenuIndex = function() {
                    for (var menus = this.getMenus(), i = 0; i < menus.length; ++i) if (menus[i].classList.contains("md-open")) return i;
                    return -1;
                }, MenuBarController.prototype.handleParentClick = function(event) {
                    var openMenu = this.querySelector("md-menu.md-open");
                    openMenu && !openMenu.contains(event.target) && angular.element(openMenu).controller("mdMenu").close(!0, {
                        closeAll: !0
                    });
                };
            }(), function() {
                function MenuBarDirective($mdUtil, $mdTheming) {
                    return {
                        restrict: "E",
                        require: "mdMenuBar",
                        controller: "MenuBarController",
                        compile: function(templateEl, templateAttrs) {
                            return templateAttrs.ariaRole || templateEl[0].setAttribute("role", "menubar"), 
                            angular.forEach(templateEl[0].children, (function(menuEl) {
                                if ("MD-MENU" == menuEl.nodeName) {
                                    menuEl.hasAttribute("md-position-mode") || (menuEl.setAttribute("md-position-mode", "left bottom"), 
                                    menuEl.querySelector("button, a, md-button").setAttribute("role", "menuitem"));
                                    var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll("md-menu-content"));
                                    angular.forEach(contentEls, (function(contentEl) {
                                        contentEl.classList.add("md-menu-bar-menu"), contentEl.classList.add("md-dense"), 
                                        contentEl.hasAttribute("width") || contentEl.setAttribute("width", 5);
                                    }));
                                }
                            })), templateEl.find("md-menu-item").addClass("md-in-menu-bar"), function(scope, el, attr, ctrl) {
                                el.addClass("_md"), $mdTheming(scope, el), ctrl.init();
                            };
                        }
                    };
                }
                MenuBarDirective.$inject = [ "$mdUtil", "$mdTheming" ], angular.module("material.components.menuBar").directive("mdMenuBar", MenuBarDirective);
            }(), angular.module("material.components.menuBar").directive("mdMenuDivider", (function() {
                return {
                    restrict: "E",
                    compile: function(templateEl, templateAttrs) {
                        templateAttrs.role || templateEl[0].setAttribute("role", "separator");
                    }
                };
            })), function() {
                function MenuItemController($scope, $element, $attrs) {
                    this.$element = $element, this.$attrs = $attrs, this.$scope = $scope;
                }
                MenuItemController.$inject = [ "$scope", "$element", "$attrs" ], angular.module("material.components.menuBar").controller("MenuItemController", MenuItemController), 
                MenuItemController.prototype.init = function(ngModel) {
                    var $element = this.$element, $attrs = this.$attrs;
                    this.ngModel = ngModel, "checkbox" != $attrs.type && "radio" != $attrs.type || (this.mode = $attrs.type, 
                    this.iconEl = $element[0].children[0], this.buttonEl = $element[0].children[1], 
                    ngModel && this.initClickListeners());
                }, MenuItemController.prototype.clearNgAria = function() {
                    var el = this.$element[0];
                    angular.forEach([ "role", "tabindex", "aria-invalid", "aria-checked" ], (function(attr) {
                        el.removeAttribute(attr);
                    }));
                }, MenuItemController.prototype.initClickListeners = function() {
                    var self = this, ngModel = this.ngModel, $scope = this.$scope, $attrs = this.$attrs, mode = (this.$element, 
                    this.mode);
                    this.handleClick = angular.bind(this, this.handleClick);
                    var icon = this.iconEl, button = angular.element(this.buttonEl), handleClick = this.handleClick;
                    function setDisabled(disabled) {
                        disabled ? button.off("click", handleClick) : button.on("click", handleClick);
                    }
                    $attrs.$observe("disabled", setDisabled), setDisabled($attrs.disabled), ngModel.$render = function() {
                        self.clearNgAria(), !function() {
                            if ("radio" == mode) {
                                var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
                                return ngModel.$modelValue == val;
                            }
                            return ngModel.$modelValue;
                        }() ? (icon.style.display = "none", button.attr("aria-checked", "false")) : (icon.style.display = "", 
                        button.attr("aria-checked", "true"));
                    }, $scope.$$postDigest(ngModel.$render);
                }, MenuItemController.prototype.handleClick = function(e) {
                    var newVal, mode = this.mode, ngModel = this.ngModel, $attrs = this.$attrs;
                    "checkbox" == mode ? newVal = !ngModel.$modelValue : "radio" == mode && (newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value), 
                    ngModel.$setViewValue(newVal), ngModel.$render();
                };
            }(), function() {
                function MenuItemDirective($mdUtil, $mdConstant, $$mdSvgRegistry) {
                    return {
                        controller: "MenuItemController",
                        require: [ "mdMenuItem", "?ngModel" ],
                        priority: $mdConstant.BEFORE_NG_ARIA,
                        compile: function(templateEl, templateAttrs) {
                            var attribute, attributes, type = templateAttrs.type;
                            if ("checkbox" !== type && "radio" !== type || !templateEl.hasClass("md-in-menu-bar")) setDefault("role", "menuitem", templateEl[0].querySelector("md-button, button, a")); else {
                                var text = templateEl[0].textContent, buttonEl = angular.element('<md-button type="button"></md-button>'), iconTemplate = '<md-icon md-svg-src="' + $$mdSvgRegistry.mdChecked + '"></md-icon>';
                                buttonEl.html(text), buttonEl.attr("tabindex", "0"), angular.isDefined(templateAttrs.mdPreventMenuClose) && buttonEl.attr("md-prevent-menu-close", templateAttrs.mdPreventMenuClose), 
                                templateEl.html(""), templateEl.append(angular.element(iconTemplate)), templateEl.append(buttonEl), 
                                templateEl.addClass("md-indent").removeClass("md-in-menu-bar"), setDefault("role", "checkbox" === type ? "menuitemcheckbox" : "menuitemradio", buttonEl), 
                                attribute = "ng-disabled", attributes = $mdUtil.prefixer(attribute), angular.forEach(attributes, (function(attr) {
                                    if (templateEl[0].hasAttribute(attr)) {
                                        var val = templateEl[0].getAttribute(attr);
                                        buttonEl[0].setAttribute(attr, val), templateEl[0].removeAttribute(attr);
                                    }
                                }));
                            }
                            return function(scope, el, attrs, ctrls) {
                                var ctrl = ctrls[0], ngModel = ctrls[1];
                                ctrl.init(ngModel);
                            };
                            function setDefault(attr, val, el) {
                                (el = el || templateEl) instanceof angular.element && (el = el[0]), el.hasAttribute(attr) || el.setAttribute(attr, val);
                            }
                        }
                    };
                }
                MenuItemDirective.$inject = [ "$mdUtil", "$mdConstant", "$$mdSvgRegistry" ], angular.module("material.components.menuBar").directive("mdMenuItem", MenuItemDirective);
            }(), function() {
                function MdNavBar($mdAria, $mdTheming, $window, $mdUtil) {
                    return {
                        restrict: "E",
                        transclude: !0,
                        controller: MdNavBarController,
                        controllerAs: "ctrl",
                        bindToController: !0,
                        scope: {
                            mdSelectedNavItem: "=?",
                            mdNoInkBar: "=?",
                            navBarAriaLabel: "@?"
                        },
                        template: '<div class="md-nav-bar"><nav role="navigation"><ul class="_md-nav-bar-list" ng-transclude role="tablist" ng-focus="ctrl.onFocus()" aria-label="{{ctrl.navBarAriaLabel}}"></ul></nav><md-nav-ink-bar ng-hide="ctrl.mdNoInkBar"></md-nav-ink-bar></div>',
                        link: function(scope, element, attrs, ctrl) {
                            function onResize() {
                                ctrl.width !== $window.innerWidth && (ctrl.updateSelectedTabInkBar(), ctrl.width = $window.innerWidth, 
                                scope.$digest());
                            }
                            ctrl.width = $window.innerWidth, angular.element($window).on("resize", $mdUtil.debounce(onResize, 300)), 
                            scope.$on("$destroy", (function() {
                                angular.element($window).off("resize", onResize);
                            })), $mdTheming(element), ctrl.navBarAriaLabel || $mdAria.expectAsync(element, "aria-label", angular.noop);
                        }
                    };
                }
                function MdNavBarController($element, $scope, $timeout, $mdConstant) {
                    this._$timeout = $timeout, this._$scope = $scope, this._$mdConstant = $mdConstant, 
                    this.mdSelectedNavItem, this.navBarAriaLabel, this._navBarEl = $element[0], this._inkbar;
                    var self = this, deregisterTabWatch = this._$scope.$watch((function() {
                        return self._navBarEl.querySelectorAll("._md-nav-button").length;
                    }), (function(newLength) {
                        newLength > 0 && (self._initTabs(), deregisterTabWatch());
                    }));
                }
                function MdNavItem($mdAria, $$rAF, $mdUtil, $window) {
                    return {
                        restrict: "E",
                        require: [ "mdNavItem", "^mdNavBar" ],
                        controller: MdNavItemController,
                        bindToController: !0,
                        controllerAs: "ctrl",
                        replace: !0,
                        transclude: !0,
                        template: function(tElement, tAttrs) {
                            var navigationAttribute, buttonTemplate, hasNavClick = tAttrs.mdNavClick, hasNavHref = tAttrs.mdNavHref, hasNavSref = tAttrs.mdNavSref, hasSrefOpts = tAttrs.srefOpts;
                            if ((hasNavClick ? 1 : 0) + (hasNavHref ? 1 : 0) + (hasNavSref ? 1 : 0) > 1) throw Error("Please do not specify more than one of the md-nav-click, md-nav-href, or md-nav-sref attributes per nav-item directive.");
                            if (null != hasNavClick) navigationAttribute = 'ng-click="ctrl.mdNavClick()"'; else if (null != hasNavHref) navigationAttribute = 'ng-href="{{ctrl.mdNavHref}}"'; else {
                                if (null == hasNavSref) throw Error("Please specify at least one of the md-nav-click, md-nav-href, or md-nav-sref attributes per nav-item directive.");
                                navigationAttribute = 'ui-sref="{{ctrl.mdNavSref}}"';
                            }
                            return navigationAttribute && (buttonTemplate = '<md-button class="_md-nav-button md-accent" ng-class="ctrl.getNgClassMap()" ng-blur="ctrl.setFocused(false)" ng-disabled="ctrl.disabled" tabindex="-1" role="tab" ng-attr-aria-label="{{ctrl.navItemAriaLabel ? ctrl.navItemAriaLabel : undefined}}" aria-selected="{{ctrl.isSelected()}}" ' + (hasSrefOpts ? 'ui-sref-opts="{{ctrl.srefOpts}}" ' : "") + navigationAttribute + '><span ng-transclude class="_md-nav-button-text"></span></md-button>'), 
                            '<li class="md-nav-item" role="presentation">' + (buttonTemplate || "") + "</li>";
                        },
                        scope: {
                            mdNavClick: "&?",
                            mdNavHref: "@?",
                            mdNavSref: "@?",
                            srefOpts: "=?",
                            name: "@",
                            navItemAriaLabel: "@?"
                        },
                        link: function(scope, element, attrs, controllers) {
                            var disconnect, mdNavItem, mdNavBar, navButton;
                            $$rAF((function() {
                                if (mdNavItem = controllers[0], mdNavBar = controllers[1], navButton = angular.element(element[0].querySelector("._md-nav-button")), 
                                mdNavItem.name || (mdNavItem.name = angular.element(element[0].querySelector("._md-nav-button-text")).text().trim()), 
                                navButton.on("keydown", (function($event) {
                                    mdNavBar.onKeydown($event);
                                })), navButton.on("focus", (function() {
                                    mdNavItem._focused = !0;
                                })), navButton.on("click", (function() {
                                    mdNavBar.mdSelectedNavItem = mdNavItem.name, scope.$apply();
                                })), mdNavItem.disabled = $mdUtil.parseAttributeBoolean(attrs.disabled, !1), "MutationObserver" in $window) {
                                    var targetNode = element[0], observer = new MutationObserver((function(mutationList) {
                                        $mdUtil.nextTick((function() {
                                            mdNavItem.disabled = $mdUtil.parseAttributeBoolean(attrs[mutationList[0].attributeName], !1);
                                        }));
                                    }));
                                    observer.observe(targetNode, {
                                        attributes: !0,
                                        attributeFilter: [ "disabled" ]
                                    }), disconnect = observer.disconnect.bind(observer);
                                } else attrs.$observe("disabled", (function(value) {
                                    mdNavItem.disabled = $mdUtil.parseAttributeBoolean(value, !1);
                                }));
                                mdNavItem.navItemAriaLabel || $mdAria.expectWithText(navButton, "aria-label");
                            })), scope.$on("destroy", (function() {
                                navButton.off("keydown"), navButton.off("focus"), navButton.off("click"), disconnect();
                            }));
                        }
                    };
                }
                function MdNavItemController($element) {
                    this._$element = $element, this.mdNavClick, this.mdNavHref, this.mdNavSref, this.srefOpts, 
                    this.name, this.navItemAriaLabel, this._selected = !1, this.isFocused = !1;
                }
                MdNavBar.$inject = [ "$mdAria", "$mdTheming", "$window", "$mdUtil" ], MdNavBarController.$inject = [ "$element", "$scope", "$timeout", "$mdConstant" ], 
                MdNavItem.$inject = [ "$mdAria", "$$rAF", "$mdUtil", "$window" ], MdNavItemController.$inject = [ "$element" ], 
                angular.module("material.components.navBar", [ "material.core" ]).controller("MdNavBarController", MdNavBarController).directive("mdNavBar", MdNavBar).controller("MdNavItemController", MdNavItemController).directive("mdNavItem", MdNavItem), 
                MdNavBarController.prototype._initTabs = function() {
                    this._inkbar = angular.element(this._navBarEl.querySelector("md-nav-ink-bar"));
                    var self = this;
                    this._$timeout((function() {
                        self._updateTabs(self.mdSelectedNavItem, null);
                    })), this._$scope.$watch("ctrl.mdSelectedNavItem", (function(newValue, oldValue) {
                        self._$timeout((function() {
                            self._updateTabs(newValue, oldValue);
                        }));
                    }));
                }, MdNavBarController.prototype._updateTabs = function(newValue, oldValue) {
                    var self = this, tabs = this._getTabs(), sameTab = newValue === oldValue;
                    if (tabs) {
                        var newIndex = -1, newTab = this._getTabByName(newValue), oldTab = this._getTabByName(oldValue);
                        oldTab && oldTab.setSelected(!1), newTab && (newTab.setSelected(!0), newIndex = tabs.indexOf(newTab)), 
                        this._$timeout((function() {
                            self._updateInkBarStyles(newTab, newIndex), newTab && oldTab && !sameTab && self._moveFocus(oldTab, newTab);
                        }));
                    }
                }, MdNavBarController.prototype._updateInkBarStyles = function(tab, newIndex) {
                    if (this._inkbar.css({
                        display: newIndex < 0 ? "none" : ""
                    }), tab) {
                        var tabEl = tab.getButtonEl(), left = tabEl.offsetLeft, tabWidth = tabEl.offsetWidth, navBarWidth = this._navBarEl.getBoundingClientRect().width, scale = tabWidth / navBarWidth, translate = left / navBarWidth * 100;
                        this._inkbar.css({
                            transform: "translateX(" + translate + "%) scaleX(" + scale + ")"
                        });
                    }
                }, MdNavBarController.prototype.updateSelectedTabInkBar = function() {
                    this._updateInkBarStyles(this._getSelectedTab());
                }, MdNavBarController.prototype._getTabs = function() {
                    var controllers = Array.prototype.slice.call(this._navBarEl.querySelectorAll(".md-nav-item")).map((function(el) {
                        return angular.element(el).controller("mdNavItem");
                    }));
                    return controllers.indexOf(undefined) ? controllers : [];
                }, MdNavBarController.prototype._getTabByName = function(name) {
                    return this._findTab((function(tab) {
                        return tab.getName() === name;
                    }));
                }, MdNavBarController.prototype._getSelectedTab = function() {
                    return this._findTab((function(tab) {
                        return tab.isSelected();
                    }));
                }, MdNavBarController.prototype.getFocusedTab = function() {
                    return this._findTab((function(tab) {
                        return tab.hasFocus();
                    }));
                }, MdNavBarController.prototype._findTab = function(fn, startIndex) {
                    var i, tabs = this._getTabs();
                    for (null == startIndex && (startIndex = 0), i = startIndex; i < tabs.length; i++) if (fn(tabs[i])) return tabs[i];
                    return null;
                }, MdNavBarController.prototype._findTabReverse = function(fn, startIndex) {
                    var tabs = this._getTabs();
                    null == startIndex && (startIndex = tabs.length - 1);
                    for (var i = startIndex; i >= 0; i--) if (fn(tabs[i])) return tabs[i];
                    return null;
                }, MdNavBarController.prototype.onFocus = function() {
                    var tab = this._getSelectedTab();
                    tab && !tab.isFocused && tab.setFocused(!0);
                }, MdNavBarController.prototype._moveFocus = function(oldTab, newTab) {
                    oldTab.setFocused(!1), newTab.setFocused(!0);
                }, MdNavBarController.prototype._focusFirstTab = function() {
                    if (this._getTabs()) {
                        var tabToFocus = this._findTab((function(tab) {
                            return tab._isEnabled();
                        }));
                        tabToFocus && this._moveFocus(this.getFocusedTab(), tabToFocus);
                    }
                }, MdNavBarController.prototype._focusLastTab = function() {
                    if (this._getTabs()) {
                        var tabToFocus = this._findTabReverse((function(tab) {
                            return tab._isEnabled();
                        }));
                        tabToFocus && this._moveFocus(this.getFocusedTab(), tabToFocus);
                    }
                }, MdNavBarController.prototype._focusNextTab = function(focusedTabIndex) {
                    if (this._getTabs()) {
                        var tabToFocus = this._findTab((function(tab) {
                            return tab._isEnabled();
                        }), focusedTabIndex + 1);
                        tabToFocus ? this._moveFocus(this.getFocusedTab(), tabToFocus) : this._focusFirstTab();
                    }
                }, MdNavBarController.prototype._focusPreviousTab = function(focusedTabIndex) {
                    if (this._getTabs()) {
                        var tabToFocus = this._findTabReverse((function(tab) {
                            return tab._isEnabled();
                        }), focusedTabIndex - 1);
                        tabToFocus ? this._moveFocus(this.getFocusedTab(), tabToFocus) : this._focusLastTab();
                    }
                }, MdNavBarController.prototype.onKeydown = function(e) {
                    var keyCodes = this._$mdConstant.KEY_CODE, tabs = this._getTabs(), focusedTab = this.getFocusedTab();
                    if (focusedTab && tabs) {
                        var focusedTabIndex = tabs.indexOf(focusedTab);
                        switch (e.keyCode) {
                          case keyCodes.UP_ARROW:
                          case keyCodes.LEFT_ARROW:
                            e.preventDefault(), this._focusPreviousTab(focusedTabIndex);
                            break;

                          case keyCodes.DOWN_ARROW:
                          case keyCodes.RIGHT_ARROW:
                            e.preventDefault(), this._focusNextTab(focusedTabIndex);
                            break;

                          case keyCodes.SPACE:
                          case keyCodes.ENTER:
                            this._$timeout((function() {
                                focusedTab.getButtonEl().click();
                            }));
                            break;

                          case keyCodes.HOME:
                            e.preventDefault(), this._focusFirstTab();
                            break;

                          case keyCodes.END:
                            e.preventDefault(), this._focusLastTab();
                        }
                    }
                }, MdNavItemController.prototype.getNgClassMap = function() {
                    return {
                        "md-active": this._selected,
                        "md-primary": this._selected,
                        "md-unselected": !this._selected,
                        "md-focused": this.isFocused
                    };
                }, MdNavItemController.prototype.getName = function() {
                    return this.name;
                }, MdNavItemController.prototype.getButtonEl = function() {
                    return this._$element[0].querySelector("._md-nav-button");
                }, MdNavItemController.prototype.setSelected = function(isSelected) {
                    this._selected = isSelected, isSelected ? this.getButtonEl().setAttribute("tabindex", "0") : this.getButtonEl().setAttribute("tabindex", "-1");
                }, MdNavItemController.prototype.isSelected = function() {
                    return this._selected;
                }, MdNavItemController.prototype.setFocused = function(isFocused) {
                    this.isFocused = isFocused, isFocused && this.getButtonEl().focus();
                }, MdNavItemController.prototype.hasFocus = function() {
                    return this.isFocused;
                }, MdNavItemController.prototype._isEnabled = function() {
                    return !this._$element.attr("disabled");
                };
            }(), function() {
                MdPanelService.$inject = [ "presets", "$rootElement", "$rootScope", "$injector", "$window" ], 
                angular.module("material.components.panel", [ "material.core", "material.components.backdrop" ]).provider("$mdPanel", (function() {
                    return {
                        definePreset,
                        getAllPresets,
                        clearPresets,
                        $get: [ "$rootElement", "$rootScope", "$injector", "$window", function($rootElement, $rootScope, $injector, $window) {
                            return new MdPanelService(_presets, $rootElement, $rootScope, $injector, $window);
                        } ]
                    };
                }));
                var FOCUS_TRAP_TEMPLATE, MD_PANEL_Z_INDEX = 80, _presets = {};
                function definePreset(name, preset) {
                    if (!name || !preset) throw new Error("mdPanelProvider: The panel preset definition is malformed. The name and preset object are required.");
                    if (_presets.hasOwnProperty(name)) throw new Error("mdPanelProvider: The panel preset you have requested has already been defined.");
                    delete preset.id, delete preset.position, delete preset.animation, _presets[name] = preset;
                }
                function getAllPresets() {
                    return angular.copy(_presets);
                }
                function clearPresets() {
                    _presets = {};
                }
                function coerceToArray(value) {
                    return angular.isString(value) && (value = [ value ]), value;
                }
                function MdPanelService(presets, $rootElement, $rootScope, $injector, $window) {
                    this._defaultConfigOptions = {
                        bindToController: !0,
                        clickOutsideToClose: !1,
                        disableParentScroll: !1,
                        escapeToClose: !1,
                        focusOnOpen: !0,
                        fullscreen: !1,
                        hasBackdrop: !1,
                        propagateContainerEvents: !1,
                        transformTemplate: angular.bind(this, this._wrapTemplate),
                        trapFocus: !1,
                        zIndex: MD_PANEL_Z_INDEX
                    }, this._config = {}, this._presets = presets, this._$rootElement = $rootElement, 
                    this._$rootScope = $rootScope, this._$injector = $injector, this._$window = $window, 
                    this._$mdUtil = this._$injector.get("$mdUtil"), this._trackedPanels = {}, this._groups = Object.create(null), 
                    this.animation = MdPanelAnimation.animation, this.xPosition = MdPanelPosition.xPosition, 
                    this.yPosition = MdPanelPosition.yPosition, this.interceptorTypes = MdPanelRef.interceptorTypes, 
                    this.closeReasons = MdPanelRef.closeReasons, this.absPosition = MdPanelPosition.absPosition;
                }
                function MdPanelRef(config, $injector) {
                    this._$q = $injector.get("$q"), this._$mdCompiler = $injector.get("$mdCompiler"), 
                    this._$mdConstant = $injector.get("$mdConstant"), this._$mdUtil = $injector.get("$mdUtil"), 
                    this._$mdTheming = $injector.get("$mdTheming"), this._$rootScope = $injector.get("$rootScope"), 
                    this._$animate = $injector.get("$animate"), this._$mdPanel = $injector.get("$mdPanel"), 
                    this._$log = $injector.get("$log"), this._$window = $injector.get("$window"), this._$$rAF = $injector.get("$$rAF"), 
                    this.id = config.id, this.config = config, this.panelContainer = undefined, this.panelEl = undefined, 
                    this.innerWrapper = undefined, this.isAttached = !1, this._removeListeners = [], 
                    this._topFocusTrap = undefined, this._bottomFocusTrap = undefined, this._backdropRef = undefined, 
                    this._restoreScroll = null, this._interceptors = Object.create(null), this._compilerCleanup = null, 
                    this._restoreCache = {
                        styles: "",
                        classes: ""
                    };
                }
                function MdPanelPosition($injector) {
                    this._$window = $injector.get("$window"), this._isRTL = $injector.get("$mdUtil").isRtl(), 
                    this._$mdConstant = $injector.get("$mdConstant"), this._absolute = !1, this._relativeToEl = undefined, 
                    this._top = "", this._bottom = "", this._left = "", this._right = "", this._translateX = [], 
                    this._translateY = [], this._positions = [], this._actualPosition = undefined;
                }
                function MdPanelAnimation($injector) {
                    this._$mdUtil = $injector.get("$mdUtil"), this._openFrom, this._closeTo, this._animationClass = "", 
                    this._openDuration, this._closeDuration, this._rawDuration;
                }
                function getElement(el) {
                    var queryResult = angular.isString(el) ? document.querySelector(el) : el;
                    return angular.element(queryResult);
                }
                function validatePosition(positionMap, value) {
                    if (null !== value && !angular.isUndefined(value)) {
                        for (var key, positionKeys = Object.keys(positionMap), positionValues = [], i = 0; key = positionKeys[i]; i++) {
                            var position = positionMap[key];
                            if (positionValues.push(position), position === value) return;
                        }
                        throw new Error("Panel position only accepts the following values:\n" + positionValues.join(" | "));
                    }
                }
                function addUnits(value) {
                    return angular.isNumber(value) ? value + "px" : value;
                }
                MdPanelService.prototype.create = function(preset, config) {
                    if ("string" == typeof preset ? preset = this._getPresetByName(preset) : "object" != typeof preset || !angular.isUndefined(config) && config || (config = preset, 
                    preset = {}), preset = preset || {}, config = config || {}, angular.isDefined(config.id) && this._trackedPanels[config.id]) {
                        var trackedPanel = this._trackedPanels[config.id];
                        return angular.extend(trackedPanel.config, config), trackedPanel;
                    }
                    this._config = angular.extend({
                        id: config.id || "panel_" + this._$mdUtil.nextUid(),
                        scope: this._$rootScope.$new(!0),
                        attachTo: this._$rootElement
                    }, this._defaultConfigOptions, config, preset);
                    var panelRef = new MdPanelRef(this._config, this._$injector);
                    return this._trackedPanels[this._config.id] = panelRef, this._config.groupName && (this._config.groupName = coerceToArray(this._config.groupName), 
                    angular.forEach(this._config.groupName, (function(group) {
                        panelRef.addToGroup(group);
                    }))), this._config.scope.$on("$destroy", angular.bind(panelRef, panelRef.detach)), 
                    panelRef;
                }, MdPanelService.prototype.open = function(preset, config) {
                    var panelRef = this.create(preset, config);
                    return panelRef.open().then((function() {
                        return panelRef;
                    }));
                }, MdPanelService.prototype._getPresetByName = function(preset) {
                    if (!this._presets[preset]) throw new Error("mdPanel: The panel preset configuration that you requested does not exist. Use the $mdPanelProvider to create a preset before requesting one.");
                    return this._presets[preset];
                }, MdPanelService.prototype.newPanelPosition = function() {
                    return new MdPanelPosition(this._$injector);
                }, MdPanelService.prototype.newPanelAnimation = function() {
                    return new MdPanelAnimation(this._$injector);
                }, MdPanelService.prototype.newPanelGroup = function(groupName, config) {
                    return this._groups[groupName] || (config = config || {}, this._groups[groupName] = {
                        panels: [],
                        openPanels: [],
                        maxOpen: config.maxOpen > 0 ? config.maxOpen : 1 / 0
                    }), this._groups[groupName];
                }, MdPanelService.prototype.setGroupMaxOpen = function(groupName, maxOpen) {
                    if (!this._groups[groupName]) throw new Error("mdPanel: Group does not exist yet. Call newPanelGroup().");
                    this._groups[groupName].maxOpen = maxOpen;
                }, MdPanelService.prototype._openCountExceedsMaxOpen = function(groupName) {
                    if (this._groups[groupName]) {
                        var group = this._groups[groupName];
                        return group.maxOpen > 0 && group.openPanels.length > group.maxOpen;
                    }
                    return !1;
                }, MdPanelService.prototype._closeFirstOpenedPanel = function(groupName) {
                    var group = this._groups[groupName];
                    group && group.openPanels.length && group.openPanels[0].close();
                }, MdPanelService.prototype._wrapTemplate = function(origTemplate) {
                    return '<div class="md-panel-outer-wrapper"><div class="md-panel-inner-wrapper _md-panel-offscreen"><div class="md-panel _md-panel-offscreen">' + (origTemplate || "") + "</div></div></div>";
                }, MdPanelService.prototype._wrapContentElement = function(contentElement) {
                    var outerWrapper = angular.element('<div class="md-panel-outer-wrapper"><div class="md-panel-inner-wrapper _md-panel-offscreen"></div></div>');
                    return contentElement.addClass("md-panel _md-panel-offscreen"), outerWrapper.children().eq(0).append(contentElement), 
                    outerWrapper;
                }, MdPanelRef.interceptorTypes = {
                    CLOSE: "onClose"
                }, MdPanelRef.prototype.open = function() {
                    var self = this;
                    return this._$q((function(resolve, reject) {
                        var done = self._done(resolve, self), show = self._simpleBind(self.show, self);
                        self.attach().then(show).then((function() {
                            self.config.groupName && (self.config.groupName = coerceToArray(self.config.groupName), 
                            angular.forEach(self.config.groupName, (function(group) {
                                self._$mdPanel._openCountExceedsMaxOpen(group) && self._$mdPanel._closeFirstOpenedPanel(group);
                            })));
                        })).then(done).catch(reject);
                    }));
                }, MdPanelRef.prototype.close = function(closeReason) {
                    var self = this;
                    return this._$q((function(resolve, reject) {
                        self._callInterceptors(MdPanelRef.interceptorTypes.CLOSE).then((function() {
                            var done = self._done(resolve, self), detach = self._simpleBind(self.detach, self), onCloseSuccess = self.config.onCloseSuccess || angular.noop;
                            onCloseSuccess = angular.bind(self, onCloseSuccess, self, closeReason), self.hide().then(detach).then(done).then(onCloseSuccess).catch(reject);
                        }), reject);
                    }));
                }, MdPanelRef.prototype.attach = function() {
                    if (this.isAttached && this.panelEl) return this._$q.when(this);
                    var self = this;
                    return this._$q((function(resolve, reject) {
                        var done = self._done(resolve, self), onDomAdded = self.config.onDomAdded || angular.noop;
                        self._$q.all([ self._createBackdrop(), self._createPanel().then((function(response) {
                            return self.isAttached = !0, self._addEventListeners(), response;
                        })).catch(reject) ]).then(onDomAdded).then(done).catch(reject);
                    }));
                }, MdPanelRef.prototype.detach = function() {
                    if (!this.isAttached) return this._$q.when(this);
                    var self = this, onDomRemoved = self.config.onDomRemoved || angular.noop;
                    return this._restoreScroll && (this._restoreScroll(), this._restoreScroll = null), 
                    this._$q((function(resolve, reject) {
                        var done = self._done(resolve, self);
                        self._$q.all([ (self._removeEventListeners(), self._topFocusTrap && self._topFocusTrap.parentNode && self._topFocusTrap.parentNode.removeChild(self._topFocusTrap), 
                        self._bottomFocusTrap && self._bottomFocusTrap.parentNode && self._bottomFocusTrap.parentNode.removeChild(self._bottomFocusTrap), 
                        self._restoreCache.classes && (self.panelEl[0].className = self._restoreCache.classes), 
                        self.panelEl[0].style.cssText = self._restoreCache.styles || "", self._compilerCleanup(), 
                        self.panelContainer.remove(), self.isAttached = !1, self._$q.when(self)), !self._backdropRef || self._backdropRef.detach() ]).then(onDomRemoved).then(done).catch(reject);
                    }));
                }, MdPanelRef.prototype.destroy = function() {
                    var self = this;
                    this.config.groupName && (this.config.groupName = coerceToArray(this.config.groupName), 
                    angular.forEach(this.config.groupName, (function(group) {
                        self.removeFromGroup(group);
                    }))), this.config.scope.$destroy(), this.config.locals = null, this.config.onDomAdded = null, 
                    this.config.onDomRemoved = null, this.config.onRemoving = null, this.config.onOpenComplete = null, 
                    this._interceptors = undefined;
                }, MdPanelRef.prototype.show = function() {
                    if (!this.panelContainer) return this._$q((function(resolve, reject) {
                        reject("mdPanel: Panel does not exist yet. Call open() or attach().");
                    }));
                    if (!this.panelContainer.hasClass("_md-panel-hidden")) return this._$q.when(this);
                    var self = this;
                    return this._$q((function(resolve, reject) {
                        var done = self._done(resolve, self), onOpenComplete = self.config.onOpenComplete || angular.noop;
                        self._$q.all([ self._backdropRef ? self._backdropRef.show() : self, (self.panelContainer.removeClass("_md-panel-hidden"), 
                        self._animateOpen()).then((function() {
                            self._focusOnOpen();
                        }), reject) ]).then(onOpenComplete).then((function() {
                            self.config.groupName && (self.config.groupName = coerceToArray(self.config.groupName), 
                            angular.forEach(self.config.groupName, (function(group) {
                                (group = self._$mdPanel._groups[group]) && group.openPanels.push(self);
                            })));
                        })).then(done).catch(reject);
                    }));
                }, MdPanelRef.prototype.hide = function() {
                    if (!this.panelContainer) return this._$q((function(resolve, reject) {
                        reject("mdPanel: Panel does not exist yet. Call open() or attach().");
                    }));
                    if (this.panelContainer.hasClass("_md-panel-hidden")) return this._$q.when(this);
                    var self = this;
                    return this._$q((function(resolve, reject) {
                        var done = self._done(resolve, self), onRemoving = self.config.onRemoving || angular.noop;
                        self._$q.all([ self._backdropRef ? self._backdropRef.hide() : self, self._animateClose().then(onRemoving).then((function() {
                            self.panelContainer.addClass("_md-panel-hidden");
                        })).then((function() {
                            var index;
                            self.config.groupName && (self.config.groupName = coerceToArray(self.config.groupName), 
                            angular.forEach(self.config.groupName, (function(group) {
                                group = self._$mdPanel._groups[group], (index = group.openPanels.indexOf(self)) > -1 && group.openPanels.splice(index, 1);
                            })));
                        })).then((function() {
                            var origin = self.config.origin;
                            origin && getElement(origin).focus();
                        })).catch(reject) ]).then(done, reject);
                    }));
                }, MdPanelRef.prototype._compile = function() {
                    var self = this;
                    return self._$mdCompiler.compile(self.config).then((function(compileData) {
                        var config = self.config;
                        if (config.contentElement) {
                            var panelEl = compileData.element;
                            self._restoreCache.styles = panelEl[0].style.cssText, self._restoreCache.classes = panelEl[0].className, 
                            self.panelContainer = self._$mdPanel._wrapContentElement(panelEl), self.panelEl = panelEl;
                        } else self.panelContainer = compileData.link(config.scope), self.panelEl = angular.element(self.panelContainer[0].querySelector(".md-panel"));
                        return self.innerWrapper = angular.element(self.panelContainer[0].querySelector(".md-panel-inner-wrapper")), 
                        self._compilerCleanup = compileData.cleanup, getElement(self.config.attachTo).append(self.panelContainer), 
                        self;
                    }));
                }, MdPanelRef.prototype._createPanel = function() {
                    var self = this;
                    return this._$q((function(resolve, reject) {
                        self.config.locals || (self.config.locals = {}), self.config.locals.mdPanelRef = self, 
                        self._compile().then((function() {
                            self.config.disableParentScroll && (self._restoreScroll = self._$mdUtil.disableScrollAround(null, self.panelContainer, {
                                disableScrollMask: !0
                            })), self.config.panelClass && self.panelEl.addClass(self.config.panelClass), self.config.propagateContainerEvents && (self.panelContainer.css("pointer-events", "none"), 
                            self.panelEl.css("pointer-events", "all")), self._$animate.pin && self._$animate.pin(self.panelContainer, getElement(self.config.attachTo)), 
                            self._configureTrapFocus(), self._addStyles().then((function() {
                                resolve(self);
                            }), reject);
                        }), reject);
                    }));
                }, MdPanelRef.prototype._addStyles = function() {
                    var self = this;
                    return this._$q((function(resolve) {
                        self.panelContainer.css("z-index", self.config.zIndex), self.innerWrapper.css("z-index", self.config.zIndex + 1);
                        var hideAndResolve = function() {
                            self._setTheming(), self.panelEl.removeClass("_md-panel-offscreen"), self.innerWrapper.removeClass("_md-panel-offscreen"), 
                            self.panelContainer.addClass("_md-panel-hidden"), resolve(self);
                        };
                        if (self.config.fullscreen) return self.panelEl.addClass("_md-panel-fullscreen"), 
                        void hideAndResolve();
                        self.config.position ? self._$rootScope.$$postDigest((function() {
                            self._updatePosition(!0), self._setTheming(), resolve(self);
                        })) : hideAndResolve();
                    }));
                }, MdPanelRef.prototype._setTheming = function() {
                    this._$mdTheming(this.panelEl), this._$mdTheming(this.panelContainer);
                }, MdPanelRef.prototype.updatePosition = function(position) {
                    if (!this.panelContainer) throw new Error("mdPanel: Panel does not exist yet. Call open() or attach().");
                    this.config.position = position, this._updatePosition();
                }, MdPanelRef.prototype._updatePosition = function(init) {
                    var positionConfig = this.config.position;
                    positionConfig && (positionConfig._setPanelPosition(this.innerWrapper), init && (this.panelEl.removeClass("_md-panel-offscreen"), 
                    this.innerWrapper.removeClass("_md-panel-offscreen"), this.panelContainer.addClass("_md-panel-hidden")), 
                    this.innerWrapper.css(MdPanelPosition.absPosition.TOP, positionConfig.getTop()), 
                    this.innerWrapper.css(MdPanelPosition.absPosition.BOTTOM, positionConfig.getBottom()), 
                    this.innerWrapper.css(MdPanelPosition.absPosition.LEFT, positionConfig.getLeft()), 
                    this.innerWrapper.css(MdPanelPosition.absPosition.RIGHT, positionConfig.getRight()));
                }, MdPanelRef.prototype._focusOnOpen = function() {
                    if (this.config.focusOnOpen) {
                        var self = this;
                        this._$rootScope.$$postDigest((function() {
                            (self._$mdUtil.findFocusTarget(self.panelEl) || self.panelEl).focus();
                        }));
                    }
                }, MdPanelRef.prototype._createBackdrop = function() {
                    if (this.config.hasBackdrop) {
                        if (!this._backdropRef) {
                            var backdropAnimation = this._$mdPanel.newPanelAnimation().openFrom(this.config.attachTo).withAnimation({
                                open: "_md-opaque-enter",
                                close: "_md-opaque-leave"
                            });
                            this.config.animation && backdropAnimation.duration(this.config.animation._rawDuration);
                            var backdropConfig = {
                                animation: backdropAnimation,
                                attachTo: this.config.attachTo,
                                focusOnOpen: !1,
                                panelClass: "_md-panel-backdrop",
                                zIndex: this.config.zIndex - 1
                            };
                            this._backdropRef = this._$mdPanel.create(backdropConfig);
                        }
                        if (!this._backdropRef.isAttached) return this._backdropRef.attach();
                    }
                }, MdPanelRef.prototype._addEventListeners = function() {
                    this._configureEscapeToClose(), this._configureClickOutsideToClose(), this._configureScrollListener();
                }, MdPanelRef.prototype._removeEventListeners = function() {
                    this._removeListeners && this._removeListeners.forEach((function(removeFn) {
                        removeFn();
                    })), this._removeListeners = [];
                }, MdPanelRef.prototype._configureEscapeToClose = function() {
                    if (this.config.escapeToClose) {
                        var parentTarget = getElement(this.config.attachTo), self = this, keyHandlerFn = function(ev) {
                            ev.keyCode === self._$mdConstant.KEY_CODE.ESCAPE && (ev.stopPropagation(), ev.preventDefault(), 
                            self.close(MdPanelRef.closeReasons.ESCAPE));
                        };
                        this.panelContainer.on("keydown", keyHandlerFn), parentTarget.on("keydown", keyHandlerFn), 
                        this._removeListeners.push((function() {
                            self.panelContainer.off("keydown", keyHandlerFn), parentTarget.off("keydown", keyHandlerFn);
                        }));
                    }
                }, MdPanelRef.prototype._configureClickOutsideToClose = function() {
                    if (this.config.clickOutsideToClose) {
                        var sourceEl, target = this.config.propagateContainerEvents ? angular.element(document.body) : this.panelContainer, mousedownHandler = function(ev) {
                            sourceEl = ev.target;
                        }, self = this, mouseupHandler = function(ev) {
                            self.config.propagateContainerEvents ? sourceEl === self.panelEl[0] || self.panelEl[0].contains(sourceEl) || self.close() : sourceEl === target[0] && ev.target === target[0] && (ev.stopPropagation(), 
                            ev.preventDefault(), self.close(MdPanelRef.closeReasons.CLICK_OUTSIDE));
                        };
                        target.on("mousedown", mousedownHandler), target.on("mouseup", mouseupHandler), 
                        this._removeListeners.push((function() {
                            target.off("mousedown", mousedownHandler), target.off("mouseup", mouseupHandler);
                        }));
                    }
                }, MdPanelRef.prototype._configureScrollListener = function() {
                    if (!this.config.disableParentScroll) {
                        var updatePosition = angular.bind(this, this._updatePosition), debouncedUpdatePosition = this._$$rAF.throttle(updatePosition), self = this, onScroll = function() {
                            debouncedUpdatePosition();
                        };
                        this._$window.addEventListener("scroll", onScroll, !0), this._removeListeners.push((function() {
                            self._$window.removeEventListener("scroll", onScroll, !0);
                        }));
                    }
                }, MdPanelRef.prototype._configureTrapFocus = function() {
                    if (this.panelEl.attr("tabIndex", "-1"), this.config.trapFocus) {
                        var element = this.panelEl;
                        if (!FOCUS_TRAP_TEMPLATE) {
                            var template = document.createElement("div");
                            template.className = "_md-panel-focus-trap", template.tabIndex = 0, FOCUS_TRAP_TEMPLATE = angular.element(template);
                        }
                        this._topFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0], this._bottomFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
                        var focusHandler = function() {
                            element.focus();
                        };
                        this._topFocusTrap.addEventListener("focus", focusHandler), this._bottomFocusTrap.addEventListener("focus", focusHandler), 
                        this._removeListeners.push(this._simpleBind((function() {
                            this._topFocusTrap.removeEventListener("focus", focusHandler), this._bottomFocusTrap.removeEventListener("focus", focusHandler);
                        }), this)), element[0].parentNode.insertBefore(this._topFocusTrap, element[0]), 
                        element.after(this._bottomFocusTrap);
                    }
                }, MdPanelRef.prototype.updateAnimation = function(animation) {
                    this.config.animation = animation, this._backdropRef && this._backdropRef.config.animation.duration(animation._rawDuration);
                }, MdPanelRef.prototype._animateOpen = function() {
                    this.panelContainer.addClass("md-panel-is-showing");
                    var animationConfig = this.config.animation;
                    if (!animationConfig) return this.panelContainer.addClass("_md-panel-shown"), this._$q.when(this);
                    var self = this;
                    return this._$q((function(resolve) {
                        var done = self._done(resolve, self);
                        animationConfig.animateOpen(self.panelEl).then(done, (function() {
                            self._$log.warn("mdPanel: MdPanel Animations failed. Showing panel without animating."), 
                            done();
                        }));
                    }));
                }, MdPanelRef.prototype._animateClose = function() {
                    var self = this, animationConfig = this.config.animation;
                    return animationConfig ? this._$q((function(resolve) {
                        var done = function() {
                            self.panelContainer.removeClass("md-panel-is-showing"), self.panelEl.css("transform", ""), 
                            resolve(self);
                        };
                        animationConfig.animateClose(self.panelEl).then(done, (function() {
                            self._$log.warn("mdPanel: MdPanel Animations failed. Hiding panel without animating."), 
                            done();
                        }));
                    })) : (this.panelContainer.removeClass("md-panel-is-showing"), this.panelContainer.removeClass("_md-panel-shown"), 
                    this._$q.when(this));
                }, MdPanelRef.prototype.registerInterceptor = function(type, callback) {
                    var error = null;
                    if (angular.isString(type) ? angular.isFunction(callback) || (error = "Interceptor callback must be a function, instead got " + typeof callback) : error = "Interceptor type must be a string, instead got " + typeof type, 
                    error) throw new Error("MdPanel: " + error);
                    var interceptors = this._interceptors[type] = this._interceptors[type] || [];
                    return -1 === interceptors.indexOf(callback) && interceptors.push(callback), this;
                }, MdPanelRef.prototype.removeInterceptor = function(type, callback) {
                    var index = this._interceptors[type] ? this._interceptors[type].indexOf(callback) : -1;
                    return index > -1 && this._interceptors[type].splice(index, 1), this;
                }, MdPanelRef.prototype.removeAllInterceptors = function(type) {
                    return type ? this._interceptors[type] = [] : this._interceptors = Object.create(null), 
                    this;
                }, MdPanelRef.prototype._callInterceptors = function(type) {
                    var self = this, $q = self._$q;
                    return (self._interceptors && self._interceptors[type] || []).reduceRight((function(promise, interceptor) {
                        var response = interceptor && angular.isFunction(interceptor.then) ? interceptor : null;
                        return promise.then((function() {
                            if (!response) try {
                                response = interceptor(self);
                            } catch (e) {
                                response = $q.reject(e);
                            }
                            return response;
                        }));
                    }), $q.resolve(self));
                }, MdPanelRef.prototype._simpleBind = function(callback, self) {
                    return function(value) {
                        return callback.apply(self, value);
                    };
                }, MdPanelRef.prototype._done = function(callback, self) {
                    return function() {
                        callback(self);
                    };
                }, MdPanelRef.prototype.addToGroup = function(groupName) {
                    this._$mdPanel._groups[groupName] || this._$mdPanel.newPanelGroup(groupName);
                    var group = this._$mdPanel._groups[groupName];
                    group.panels.indexOf(this) < 0 && group.panels.push(this);
                }, MdPanelRef.prototype.removeFromGroup = function(groupName) {
                    if (!this._$mdPanel._groups[groupName]) throw new Error("mdPanel: The group " + groupName + " does not exist.");
                    var group = this._$mdPanel._groups[groupName], index = group.panels.indexOf(this);
                    index > -1 && group.panels.splice(index, 1);
                }, MdPanelRef.closeReasons = {
                    CLICK_OUTSIDE: "clickOutsideToClose",
                    ESCAPE: "escapeToClose"
                }, MdPanelPosition.xPosition = {
                    CENTER: "center",
                    ALIGN_START: "align-start",
                    ALIGN_END: "align-end",
                    OFFSET_START: "offset-start",
                    OFFSET_END: "offset-end"
                }, MdPanelPosition.yPosition = {
                    CENTER: "center",
                    ALIGN_TOPS: "align-tops",
                    ALIGN_BOTTOMS: "align-bottoms",
                    ABOVE: "above",
                    BELOW: "below"
                }, MdPanelPosition.absPosition = {
                    TOP: "top",
                    RIGHT: "right",
                    BOTTOM: "bottom",
                    LEFT: "left"
                }, MdPanelPosition.viewportMargin = 8, MdPanelPosition.prototype.absolute = function() {
                    return this._absolute = !0, this;
                }, MdPanelPosition.prototype._setPosition = function(position, value) {
                    if (position === MdPanelPosition.absPosition.RIGHT || position === MdPanelPosition.absPosition.LEFT) this._left = this._right = ""; else {
                        if (position !== MdPanelPosition.absPosition.BOTTOM && position !== MdPanelPosition.absPosition.TOP) {
                            var positions = Object.keys(MdPanelPosition.absPosition).join().toLowerCase();
                            throw new Error("mdPanel: Position must be one of " + positions + ".");
                        }
                        this._top = this._bottom = "";
                    }
                    return this["_" + position] = angular.isString(value) ? value : "0", this;
                }, MdPanelPosition.prototype.top = function(top) {
                    return this._setPosition(MdPanelPosition.absPosition.TOP, top);
                }, MdPanelPosition.prototype.bottom = function(bottom) {
                    return this._setPosition(MdPanelPosition.absPosition.BOTTOM, bottom);
                }, MdPanelPosition.prototype.start = function(start) {
                    var position = this._isRTL ? MdPanelPosition.absPosition.RIGHT : MdPanelPosition.absPosition.LEFT;
                    return this._setPosition(position, start);
                }, MdPanelPosition.prototype.end = function(end) {
                    var position = this._isRTL ? MdPanelPosition.absPosition.LEFT : MdPanelPosition.absPosition.RIGHT;
                    return this._setPosition(position, end);
                }, MdPanelPosition.prototype.left = function(left) {
                    return this._setPosition(MdPanelPosition.absPosition.LEFT, left);
                }, MdPanelPosition.prototype.right = function(right) {
                    return this._setPosition(MdPanelPosition.absPosition.RIGHT, right);
                }, MdPanelPosition.prototype.centerHorizontally = function() {
                    return this._left = "50%", this._right = "", this._translateX = [ "-50%" ], this;
                }, MdPanelPosition.prototype.centerVertically = function() {
                    return this._top = "50%", this._bottom = "", this._translateY = [ "-50%" ], this;
                }, MdPanelPosition.prototype.center = function() {
                    return this.centerHorizontally().centerVertically();
                }, MdPanelPosition.prototype.relativeTo = function(element) {
                    return this._absolute = !1, this._relativeToEl = getElement(element), this;
                }, MdPanelPosition.prototype.addPanelPosition = function(xPosition, yPosition) {
                    if (!this._relativeToEl) throw new Error("mdPanel: addPanelPosition can only be used with relative positioning. Set relativeTo first.");
                    return validatePosition(MdPanelPosition.xPosition, xPosition), validatePosition(MdPanelPosition.yPosition, yPosition), 
                    this._positions.push({
                        x: xPosition,
                        y: yPosition
                    }), this;
                }, MdPanelPosition.prototype.withOffsetX = function(offsetX) {
                    return this._translateX.push(addUnits(offsetX)), this;
                }, MdPanelPosition.prototype.withOffsetY = function(offsetY) {
                    return this._translateY.push(addUnits(offsetY)), this;
                }, MdPanelPosition.prototype.getTop = function() {
                    return this._top;
                }, MdPanelPosition.prototype.getBottom = function() {
                    return this._bottom;
                }, MdPanelPosition.prototype.getLeft = function() {
                    return this._left;
                }, MdPanelPosition.prototype.getRight = function() {
                    return this._right;
                }, MdPanelPosition.prototype.getTransform = function() {
                    return (this._reduceTranslateValues("translateX", this._translateX) + " " + this._reduceTranslateValues("translateY", this._translateY)).trim();
                }, MdPanelPosition.prototype._setTransform = function(el) {
                    return el.css(this._$mdConstant.CSS.TRANSFORM, this.getTransform());
                }, MdPanelPosition.prototype._isOnscreen = function(el) {
                    var left = parseInt(this.getLeft()), top = parseInt(this.getTop());
                    if (this._translateX.length || this._translateY.length) {
                        var offsets = function(el, property) {
                            var transform = getComputedStyle(el[0] || el)[property], openIndex = transform.indexOf("("), closeIndex = transform.lastIndexOf(")"), output = {
                                x: 0,
                                y: 0
                            };
                            if (openIndex > -1 && closeIndex > -1) {
                                var parsedValues = transform.substring(openIndex + 1, closeIndex).split(", ").slice(-2);
                                output.x = parseInt(parsedValues[0]), output.y = parseInt(parsedValues[1]);
                            }
                            return output;
                        }(el, this._$mdConstant.CSS.TRANSFORM);
                        left += offsets.x, top += offsets.y;
                    }
                    var right = left + el[0].offsetWidth, bottom = top + el[0].offsetHeight;
                    return left >= 0 && top >= 0 && bottom <= this._$window.innerHeight && right <= this._$window.innerWidth;
                }, MdPanelPosition.prototype.getActualPosition = function() {
                    return this._actualPosition;
                }, MdPanelPosition.prototype._reduceTranslateValues = function(translateFn, values) {
                    return values.map((function(translation) {
                        var translationValue = angular.isFunction(translation) ? addUnits(translation(this)) : translation;
                        return translateFn + "(" + translationValue + ")";
                    }), this).join(" ");
                }, MdPanelPosition.prototype._setPanelPosition = function(el) {
                    if (el.removeClass("_md-panel-position-adjusted"), this._absolute) this._setTransform(el); else {
                        if (this._actualPosition) return this._calculatePanelPosition(el, this._actualPosition), 
                        this._setTransform(el), void this._constrainToViewport(el);
                        for (var i = 0; i < this._positions.length; i++) if (this._actualPosition = this._positions[i], 
                        this._calculatePanelPosition(el, this._actualPosition), this._setTransform(el), 
                        this._isOnscreen(el)) return;
                        this._constrainToViewport(el);
                    }
                }, MdPanelPosition.prototype._constrainToViewport = function(el) {
                    var margin = MdPanelPosition.viewportMargin, initialTop = this._top, initialLeft = this._left;
                    if (this.getTop()) {
                        var top = parseInt(this.getTop()), bottom = el[0].offsetHeight + top, viewportHeight = this._$window.innerHeight;
                        top < margin ? this._top = margin + "px" : bottom > viewportHeight && (this._top = top - (bottom - viewportHeight + margin) + "px");
                    }
                    if (this.getLeft()) {
                        var left = parseInt(this.getLeft()), right = el[0].offsetWidth + left, viewportWidth = this._$window.innerWidth;
                        left < margin ? this._left = margin + "px" : right > viewportWidth && (this._left = left - (right - viewportWidth + margin) + "px");
                    }
                    el.toggleClass("_md-panel-position-adjusted", this._top !== initialTop || this._left !== initialLeft);
                }, MdPanelPosition.prototype._reverseXPosition = function(position) {
                    if (position === MdPanelPosition.xPosition.CENTER) return position;
                    return position.indexOf("start") > -1 ? position.replace("start", "end") : position.replace("end", "start");
                }, MdPanelPosition.prototype._bidi = function(position) {
                    return this._isRTL ? this._reverseXPosition(position) : position;
                }, MdPanelPosition.prototype._calculatePanelPosition = function(el, position) {
                    var panelBounds = el[0].getBoundingClientRect(), panelWidth = Math.max(panelBounds.width, el[0].clientWidth), panelHeight = Math.max(panelBounds.height, el[0].clientHeight), targetBounds = this._relativeToEl[0].getBoundingClientRect(), targetLeft = targetBounds.left, targetRight = targetBounds.right, targetWidth = targetBounds.width;
                    switch (this._bidi(position.x)) {
                      case MdPanelPosition.xPosition.OFFSET_START:
                        this._left = targetLeft - panelWidth + "px";
                        break;

                      case MdPanelPosition.xPosition.ALIGN_END:
                        this._left = targetRight - panelWidth + "px";
                        break;

                      case MdPanelPosition.xPosition.CENTER:
                        var left = targetLeft + .5 * targetWidth - .5 * panelWidth;
                        this._left = left + "px";
                        break;

                      case MdPanelPosition.xPosition.ALIGN_START:
                        this._left = targetLeft + "px";
                        break;

                      case MdPanelPosition.xPosition.OFFSET_END:
                        this._left = targetRight + "px";
                    }
                    var targetTop = targetBounds.top, targetBottom = targetBounds.bottom, targetHeight = targetBounds.height;
                    switch (position.y) {
                      case MdPanelPosition.yPosition.ABOVE:
                        this._top = targetTop - panelHeight + "px";
                        break;

                      case MdPanelPosition.yPosition.ALIGN_BOTTOMS:
                        this._top = targetBottom - panelHeight + "px";
                        break;

                      case MdPanelPosition.yPosition.CENTER:
                        var top = targetTop + .5 * targetHeight - .5 * panelHeight;
                        this._top = top + "px";
                        break;

                      case MdPanelPosition.yPosition.ALIGN_TOPS:
                        this._top = targetTop + "px";
                        break;

                      case MdPanelPosition.yPosition.BELOW:
                        this._top = targetBottom + "px";
                    }
                }, MdPanelAnimation.animation = {
                    SLIDE: "md-panel-animate-slide",
                    SCALE: "md-panel-animate-scale",
                    FADE: "md-panel-animate-fade"
                }, MdPanelAnimation.prototype.openFrom = function(openFrom) {
                    return openFrom = openFrom.target ? openFrom.target : openFrom, this._openFrom = this._getPanelAnimationTarget(openFrom), 
                    this._closeTo || (this._closeTo = this._openFrom), this;
                }, MdPanelAnimation.prototype.closeTo = function(closeTo) {
                    return this._closeTo = this._getPanelAnimationTarget(closeTo), this;
                }, MdPanelAnimation.prototype.duration = function(duration) {
                    return duration && (angular.isNumber(duration) ? this._openDuration = this._closeDuration = toSeconds(duration) : angular.isObject(duration) && (this._openDuration = toSeconds(duration.open), 
                    this._closeDuration = toSeconds(duration.close))), this._rawDuration = duration, 
                    this;
                    function toSeconds(value) {
                        if (angular.isNumber(value)) return value / 1e3;
                    }
                }, MdPanelAnimation.prototype._getPanelAnimationTarget = function(location) {
                    return angular.isDefined(location.top) || angular.isDefined(location.left) ? {
                        element: undefined,
                        bounds: {
                            top: location.top || 0,
                            left: location.left || 0
                        }
                    } : this._getBoundingClientRect(getElement(location));
                }, MdPanelAnimation.prototype.withAnimation = function(cssClass) {
                    return this._animationClass = cssClass, this;
                }, MdPanelAnimation.prototype.animateOpen = function(panelEl) {
                    var animator = this._$mdUtil.dom.animator;
                    this._fixBounds(panelEl);
                    var animationOptions = {}, panelTransform = panelEl[0].style.transform || "", openFrom = animator.toTransformCss(panelTransform), openTo = animator.toTransformCss(panelTransform);
                    switch (this._animationClass) {
                      case MdPanelAnimation.animation.SLIDE:
                        panelEl.css("opacity", "1"), animationOptions = {
                            transitionInClass: "_md-panel-animate-enter",
                            transitionOutClass: "_md-panel-animate-leave"
                        };
                        var openSlide = animator.calculateSlideToOrigin(panelEl, this._openFrom) || "";
                        openFrom = animator.toTransformCss(openSlide + " " + panelTransform);
                        break;

                      case MdPanelAnimation.animation.SCALE:
                        animationOptions = {
                            transitionInClass: "_md-panel-animate-enter"
                        };
                        var openScale = animator.calculateZoomToOrigin(panelEl, this._openFrom) || "";
                        openFrom = animator.toTransformCss(panelTransform + " " + openScale);
                        break;

                      case MdPanelAnimation.animation.FADE:
                        animationOptions = {
                            transitionInClass: "_md-panel-animate-enter"
                        };
                        break;

                      default:
                        animationOptions = angular.isString(this._animationClass) ? {
                            transitionInClass: this._animationClass
                        } : {
                            transitionInClass: this._animationClass.open,
                            transitionOutClass: this._animationClass.close
                        };
                    }
                    return animationOptions.duration = this._openDuration, animator.translate3d(panelEl, openFrom, openTo, animationOptions);
                }, MdPanelAnimation.prototype.animateClose = function(panelEl) {
                    var animator = this._$mdUtil.dom.animator, reverseAnimationOptions = {}, panelTransform = panelEl[0].style.transform || "", closeFrom = animator.toTransformCss(panelTransform), closeTo = animator.toTransformCss(panelTransform);
                    switch (this._animationClass) {
                      case MdPanelAnimation.animation.SLIDE:
                        panelEl.css("opacity", "1"), reverseAnimationOptions = {
                            transitionInClass: "_md-panel-animate-leave",
                            transitionOutClass: "_md-panel-animate-enter _md-panel-animate-leave"
                        };
                        var closeSlide = animator.calculateSlideToOrigin(panelEl, this._closeTo) || "";
                        closeTo = animator.toTransformCss(closeSlide + " " + panelTransform);
                        break;

                      case MdPanelAnimation.animation.SCALE:
                        reverseAnimationOptions = {
                            transitionInClass: "_md-panel-animate-scale-out _md-panel-animate-leave",
                            transitionOutClass: "_md-panel-animate-scale-out _md-panel-animate-enter _md-panel-animate-leave"
                        };
                        var closeScale = animator.calculateZoomToOrigin(panelEl, this._closeTo) || "";
                        closeTo = animator.toTransformCss(panelTransform + " " + closeScale);
                        break;

                      case MdPanelAnimation.animation.FADE:
                        reverseAnimationOptions = {
                            transitionInClass: "_md-panel-animate-fade-out _md-panel-animate-leave",
                            transitionOutClass: "_md-panel-animate-fade-out _md-panel-animate-enter _md-panel-animate-leave"
                        };
                        break;

                      default:
                        reverseAnimationOptions = angular.isString(this._animationClass) ? {
                            transitionOutClass: this._animationClass
                        } : {
                            transitionInClass: this._animationClass.close,
                            transitionOutClass: this._animationClass.open
                        };
                    }
                    return reverseAnimationOptions.duration = this._closeDuration, animator.translate3d(panelEl, closeFrom, closeTo, reverseAnimationOptions);
                }, MdPanelAnimation.prototype._fixBounds = function(panelEl) {
                    var panelWidth = panelEl[0].offsetWidth, panelHeight = panelEl[0].offsetHeight;
                    this._openFrom && null == this._openFrom.bounds.height && (this._openFrom.bounds.height = panelHeight), 
                    this._openFrom && null == this._openFrom.bounds.width && (this._openFrom.bounds.width = panelWidth), 
                    this._closeTo && null == this._closeTo.bounds.height && (this._closeTo.bounds.height = panelHeight), 
                    this._closeTo && null == this._closeTo.bounds.width && (this._closeTo.bounds.width = panelWidth);
                }, MdPanelAnimation.prototype._getBoundingClientRect = function(element) {
                    if (element instanceof angular.element) return {
                        element,
                        bounds: element[0].getBoundingClientRect()
                    };
                };
            }(), angular.module("material.components.progressCircular", [ "material.core" ]), 
            function() {
                function MdProgressCircularDirective($window, $mdProgressCircular, $mdTheming, $mdUtil, $interval, $log) {
                    var rAF = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || angular.noop, cAF = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame || angular.noop;
                    return {
                        restrict: "E",
                        scope: {
                            value: "@",
                            mdDiameter: "@",
                            mdMode: "@"
                        },
                        template: '<svg xmlns="http://www.w3.org/2000/svg"><path fill="none"/></svg>',
                        compile: function(element, attrs) {
                            if (element.attr({
                                "aria-valuemin": 0,
                                "aria-valuemax": 100,
                                role: "progressbar"
                            }), angular.isUndefined(attrs.mdMode)) {
                                var mode = attrs.hasOwnProperty("value") ? "determinate" : "indeterminate";
                                attrs.$set("mdMode", mode);
                            } else attrs.$set("mdMode", attrs.mdMode.trim());
                            return MdProgressCircularLink;
                        }
                    };
                    function MdProgressCircularLink(scope, element, attrs) {
                        var lastDrawFrame, interval, node = element[0], svg = angular.element(node.querySelector("svg")), path = angular.element(node.querySelector("path")), startIndeterminate = $mdProgressCircular.startIndeterminate, endIndeterminate = $mdProgressCircular.endIndeterminate, iterationCount = 0, lastAnimationId = 0;
                        function renderCircle(animateFrom, animateTo, easing, duration, iterationCount, maxValue) {
                            var id = ++lastAnimationId, startTime = $mdUtil.now(), changeInValue = animateTo - animateFrom, diameter = getSize(scope.mdDiameter), strokeWidth = getStroke(diameter), ease = easing || $mdProgressCircular.easeFn, animationDuration = duration || $mdProgressCircular.duration, rotation = -90 * (iterationCount || 0), dashLimit = maxValue || 100;
                            function renderFrame(value) {
                                path.attr("stroke-dashoffset", getDashOffset(diameter, strokeWidth, value, dashLimit)), 
                                path.attr("transform", "rotate(" + rotation + " " + diameter / 2 + " " + diameter / 2 + ")");
                            }
                            animateTo === animateFrom ? renderFrame(animateTo) : lastDrawFrame = rAF((function animation() {
                                var currentTime = $window.Math.max(0, $window.Math.min($mdUtil.now() - startTime, animationDuration));
                                renderFrame(ease(currentTime, animateFrom, changeInValue, animationDuration)), id === lastAnimationId && currentTime < animationDuration && (lastDrawFrame = rAF(animation));
                            }));
                        }
                        function animateIndeterminate() {
                            renderCircle(startIndeterminate, endIndeterminate, $mdProgressCircular.easeFnIndeterminate, $mdProgressCircular.durationIndeterminate, iterationCount, 75), 
                            iterationCount = ++iterationCount % 4;
                        }
                        function startIndeterminateAnimation() {
                            interval || (interval = $interval(animateIndeterminate, $mdProgressCircular.durationIndeterminate, 0, !1), 
                            animateIndeterminate(), element.addClass("md-mode-indeterminate").removeAttr("aria-valuenow"));
                        }
                        function cleanupIndeterminateAnimation() {
                            interval && ($interval.cancel(interval), interval = null, element.removeClass("md-mode-indeterminate"));
                        }
                        $mdTheming(element), element.toggleClass("_md-progress-circular-disabled", attrs.hasOwnProperty("disabled")), 
                        "indeterminate" === scope.mdMode && startIndeterminateAnimation(), scope.$on("$destroy", (function() {
                            cleanupIndeterminateAnimation(), lastDrawFrame && cAF(lastDrawFrame);
                        })), scope.$watchGroup([ "value", "mdMode", function() {
                            var isDisabled = node.disabled;
                            return !0 === isDisabled || !1 === isDisabled ? isDisabled : angular.isDefined(element.attr("disabled"));
                        } ], (function(newValues, oldValues) {
                            var mode = newValues[1], isDisabled = newValues[2], diameter = 0, strokeWidth = 0;
                            if (isDisabled !== oldValues[2] && element.toggleClass("_md-progress-circular-disabled", !!isDisabled), 
                            isDisabled) cleanupIndeterminateAnimation(); else if ("determinate" !== mode && "indeterminate" !== mode && (mode = "indeterminate", 
                            attrs.$set("mdMode", mode)), "indeterminate" === mode) "determinate" === oldValues[1] && (strokeWidth = getStroke(diameter = getSize(scope.mdDiameter)), 
                            path.attr("d", getSvgArc(diameter, strokeWidth, !0)), path.attr("stroke-dasharray", getDashLength(diameter, strokeWidth, 75))), 
                            startIndeterminateAnimation(); else {
                                var newValue = clamp(newValues[0]), oldValue = clamp(oldValues[0]);
                                cleanupIndeterminateAnimation(), "indeterminate" === oldValues[1] && (strokeWidth = getStroke(diameter = getSize(scope.mdDiameter)), 
                                path.attr("d", getSvgArc(diameter, strokeWidth, !1)), path.attr("stroke-dasharray", getDashLength(diameter, strokeWidth, 100))), 
                                element.attr("aria-valuenow", newValue), renderCircle(oldValue, newValue);
                            }
                        })), scope.$watch("mdDiameter", (function(newValue) {
                            var diameter = getSize(newValue), strokeWidth = getStroke(diameter), value = clamp(scope.value), transformOrigin = diameter / 2 + "px", dimensions = {
                                width: diameter + "px",
                                height: diameter + "px"
                            };
                            svg[0].setAttribute("viewBox", "0 0 " + diameter + " " + diameter), svg.css(dimensions).css("transform-origin", transformOrigin + " " + transformOrigin + " " + transformOrigin), 
                            element.css(dimensions), path.attr("stroke-width", strokeWidth), path.attr("stroke-linecap", "square"), 
                            "indeterminate" == scope.mdMode ? (path.attr("d", getSvgArc(diameter, strokeWidth, !0)), 
                            path.attr("stroke-dasharray", getDashLength(diameter, strokeWidth, 75)), path.attr("stroke-dashoffset", getDashOffset(diameter, strokeWidth, 1, 75))) : (path.attr("d", getSvgArc(diameter, strokeWidth, !1)), 
                            path.attr("stroke-dasharray", getDashLength(diameter, strokeWidth, 100)), path.attr("stroke-dashoffset", getDashOffset(diameter, strokeWidth, 0, 100)), 
                            renderCircle(value, value));
                        }));
                    }
                    function getSvgArc(diameter, strokeWidth, indeterminate) {
                        var radius = diameter / 2, offset = strokeWidth / 2, start = radius + "," + offset, arcRadius = radius - offset;
                        return "M" + start + "A" + arcRadius + "," + arcRadius + " 0 1 1 " + (offset + "," + radius) + (indeterminate ? "" : "A" + arcRadius + "," + arcRadius + " 0 0 1 " + start);
                    }
                    function getDashOffset(diameter, strokeWidth, value, maxArcLength) {
                        return getSpinnerCircumference(diameter, strokeWidth) * ((maxArcLength - value) / 100);
                    }
                    function clamp(value) {
                        return $window.Math.max(0, $window.Math.min(value || 0, 100));
                    }
                    function getSize(value) {
                        var defaultValue = $mdProgressCircular.progressSize;
                        if (value) {
                            var parsed = parseFloat(value);
                            return value.lastIndexOf("%") === value.length - 1 && (parsed = parsed / 100 * defaultValue), 
                            parsed;
                        }
                        return defaultValue;
                    }
                    function getStroke(diameter) {
                        return $mdProgressCircular.strokeWidth / 100 * diameter;
                    }
                    function getDashLength(diameter, strokeWidth, value) {
                        return getSpinnerCircumference(diameter, strokeWidth) * (value / 100);
                    }
                    function getSpinnerCircumference(diameter, strokeWidth) {
                        return (diameter - strokeWidth) * $window.Math.PI;
                    }
                }
                MdProgressCircularDirective.$inject = [ "$window", "$mdProgressCircular", "$mdTheming", "$mdUtil", "$interval", "$log" ], 
                angular.module("material.components.progressCircular").directive("mdProgressCircular", MdProgressCircularDirective);
            }(), angular.module("material.components.progressCircular").provider("$mdProgressCircular", (function() {
                var progressConfig = {
                    progressSize: 50,
                    strokeWidth: 10,
                    duration: 100,
                    easeFn: linearEase,
                    durationIndeterminate: 1333,
                    startIndeterminate: 1,
                    endIndeterminate: 149,
                    easeFnIndeterminate: materialEase,
                    easingPresets: {
                        linearEase,
                        materialEase
                    }
                };
                return {
                    configure: function(options) {
                        return progressConfig = angular.extend(progressConfig, options || {});
                    },
                    $get: function() {
                        return progressConfig;
                    }
                };
                function linearEase(t, b, c, d) {
                    return c * t / d + b;
                }
                function materialEase(t, b, c, d) {
                    var ts = (t /= d) * t, tc = ts * t;
                    return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc);
                }
            })), function() {
                function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
                    var MODE_DETERMINATE = "determinate", MODE_INDETERMINATE = "indeterminate", MODE_BUFFER = "buffer", MODE_QUERY = "query", DISABLED_CLASS = "_md-progress-linear-disabled";
                    return {
                        restrict: "E",
                        template: '<div class="md-container"><div class="md-dashed"></div><div class="md-bar md-bar1"></div><div class="md-bar md-bar2"></div></div>',
                        compile: function(tElement, tAttrs, transclude) {
                            return tElement.attr("aria-valuemin", 0), tElement.attr("aria-valuemax", 100), tElement.attr("role", "progressbar"), 
                            postLink;
                        }
                    };
                    function postLink(scope, element, attr) {
                        var lastMode;
                        $mdTheming(element);
                        var isDisabled = attr.hasOwnProperty("disabled"), toVendorCSS = $mdUtil.dom.animator.toCss, bar1 = angular.element(element[0].querySelector(".md-bar1")), bar2 = angular.element(element[0].querySelector(".md-bar2")), container = angular.element(element[0].querySelector(".md-container"));
                        function mode() {
                            var value = (attr.mdMode || "").trim();
                            if (value) switch (value) {
                              case MODE_DETERMINATE:
                              case MODE_INDETERMINATE:
                              case MODE_BUFFER:
                              case MODE_QUERY:
                                break;

                              default:
                                value = MODE_INDETERMINATE;
                            }
                            return value;
                        }
                        function animateIndicator(target, value) {
                            if (!isDisabled && mode()) {
                                var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [ (value - 100) / 2, value / 100 ]), styles = toVendorCSS({
                                    transform: to
                                });
                                angular.element(target).css(styles);
                            }
                        }
                        element.attr("md-mode", mode()).toggleClass(DISABLED_CLASS, isDisabled), function() {
                            if (angular.isUndefined(attr.mdMode)) {
                                var mode = angular.isDefined(attr.value) ? MODE_DETERMINATE : MODE_INDETERMINATE;
                                element.attr("md-mode", mode), attr.mdMode = mode;
                            }
                        }(), attr.$observe("value", (function(value) {
                            var percentValue = clamp(value);
                            element.attr("aria-valuenow", percentValue), mode() != MODE_QUERY && animateIndicator(bar2, percentValue);
                        })), attr.$observe("mdBufferValue", (function(value) {
                            animateIndicator(bar1, clamp(value));
                        })), attr.$observe("disabled", (function(value) {
                            isDisabled = !0 === value || !1 === value ? !!value : angular.isDefined(value), 
                            element.toggleClass(DISABLED_CLASS, isDisabled), container.toggleClass(lastMode, !isDisabled);
                        })), attr.$observe("mdMode", (function(mode) {
                            switch (lastMode && container.removeClass(lastMode), mode) {
                              case MODE_QUERY:
                              case MODE_BUFFER:
                              case MODE_DETERMINATE:
                              case MODE_INDETERMINATE:
                                container.addClass(lastMode = "md-mode-" + mode);
                                break;

                              default:
                                container.addClass(lastMode = "md-mode-" + MODE_INDETERMINATE);
                            }
                        }));
                    }
                    function clamp(value) {
                        return Math.max(0, Math.min(value || 0, 100));
                    }
                }
                MdProgressLinearDirective.$inject = [ "$mdTheming", "$mdUtil", "$log" ], angular.module("material.components.progressLinear", [ "material.core" ]).directive("mdProgressLinear", MdProgressLinearDirective);
            }(), function() {
                mdRadioGroupDirective.$inject = [ "$mdUtil", "$mdConstant", "$mdTheming", "$timeout" ], 
                mdRadioButtonDirective.$inject = [ "$mdAria", "$mdUtil", "$mdTheming" ], angular.module("material.components.radioButton", [ "material.core" ]).directive("mdRadioGroup", mdRadioGroupDirective).directive("mdRadioButton", mdRadioButtonDirective);
                var incrementSelection = Object.freeze({
                    PREVIOUS: -1,
                    CURRENT: 0,
                    NEXT: 1
                });
                function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
                    return RadioGroupController.prototype = {
                        init: function(ngModelCtrl) {
                            this._ngModelCtrl = ngModelCtrl, this._ngModelCtrl.$render = angular.bind(this, this.render);
                        },
                        add: function(rbRender) {
                            this._radioButtonRenderFns.push(rbRender);
                        },
                        remove: function(rbRender) {
                            var index = this._radioButtonRenderFns.indexOf(rbRender);
                            -1 !== index && this._radioButtonRenderFns.splice(index, 1);
                        },
                        render: function() {
                            this._radioButtonRenderFns.forEach((function(rbRender) {
                                rbRender();
                            }));
                        },
                        setViewValue: function(value, eventType) {
                            this._ngModelCtrl.$setViewValue(value, eventType), this.render();
                        },
                        getViewValue: function() {
                            return this._ngModelCtrl.$viewValue;
                        },
                        selectCurrent: function() {
                            return changeSelectedButton(this.$element, incrementSelection.CURRENT);
                        },
                        selectNext: function() {
                            return changeSelectedButton(this.$element, incrementSelection.NEXT);
                        },
                        selectPrevious: function() {
                            return changeSelectedButton(this.$element, incrementSelection.PREVIOUS);
                        },
                        setActiveDescendant: function(radioId) {
                            this.$element.attr("aria-activedescendant", radioId);
                        },
                        isDisabled: function() {
                            return this.$element[0].hasAttribute("disabled");
                        }
                    }, {
                        restrict: "E",
                        controller: [ "$element", RadioGroupController ],
                        require: [ "mdRadioGroup", "?ngModel" ],
                        link: {
                            pre: function(scope, element, attr, controllers) {
                                element.addClass("_md"), $mdTheming(element);
                                var radioGroupController = controllers[0], ngModelCtrl = controllers[1] || $mdUtil.fakeNgModel();
                                function setFocus() {
                                    element.hasClass("md-focused") || element.addClass("md-focused");
                                }
                                radioGroupController.init(ngModelCtrl), scope.mouseActive = !1, element.attr({
                                    role: "radiogroup",
                                    tabIndex: element.attr("tabindex") || "0"
                                }).on("keydown", (function(keyboardEvent) {
                                    var keyCode = keyboardEvent.which || keyboardEvent.keyCode;
                                    if (keyCode === $mdConstant.KEY_CODE.ENTER || keyboardEvent.currentTarget === keyboardEvent.target) switch (keyCode) {
                                      case $mdConstant.KEY_CODE.LEFT_ARROW:
                                      case $mdConstant.KEY_CODE.UP_ARROW:
                                        keyboardEvent.preventDefault(), radioGroupController.selectPrevious(), setFocus();
                                        break;

                                      case $mdConstant.KEY_CODE.RIGHT_ARROW:
                                      case $mdConstant.KEY_CODE.DOWN_ARROW:
                                        keyboardEvent.preventDefault(), radioGroupController.selectNext(), setFocus();
                                        break;

                                      case $mdConstant.KEY_CODE.SPACE:
                                        keyboardEvent.preventDefault(), radioGroupController.selectCurrent();
                                        break;

                                      case $mdConstant.KEY_CODE.ENTER:
                                        var form = angular.element($mdUtil.getClosest(element[0], "form"));
                                        form.length > 0 && form.triggerHandler("submit");
                                    }
                                })).on("mousedown", (function() {
                                    scope.mouseActive = !0, $timeout((function() {
                                        scope.mouseActive = !1;
                                    }), 100);
                                })).on("focus", (function() {
                                    !1 === scope.mouseActive && radioGroupController.$element.addClass("md-focused");
                                })).on("blur", (function() {
                                    radioGroupController.$element.removeClass("md-focused");
                                })), $mdUtil.nextTick((function() {
                                    var radioButtons = getRadioButtons(radioGroupController.$element);
                                    radioButtons.count() && !radioGroupController.$element[0].hasAttribute("aria-activedescendant") && radioGroupController.setActiveDescendant(radioButtons.first().id);
                                }));
                            }
                        }
                    };
                    function RadioGroupController($element) {
                        this._radioButtonRenderFns = [], this.$element = $element;
                    }
                    function getRadioButtons(parent) {
                        return $mdUtil.iterator(parent[0].querySelectorAll("md-radio-button"), !0);
                    }
                    function changeSelectedButton(parent, increment) {
                        var target, buttons = getRadioButtons(parent);
                        if (buttons.count()) {
                            var selected = parent[0].querySelector("md-radio-button.md-checked");
                            selected ? increment !== incrementSelection.PREVIOUS && increment !== incrementSelection.NEXT || (target = buttons[increment === incrementSelection.PREVIOUS ? "previous" : "next"](selected, (function(button) {
                                return !angular.element(button).attr("disabled");
                            }))) : target = buttons.first(), target && angular.element(target).triggerHandler("click");
                        }
                    }
                }
                function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
                    return {
                        restrict: "E",
                        require: "^mdRadioGroup",
                        transclude: !0,
                        template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-off"></div><div class="md-on"></div></div><div ng-transclude class="md-label"></div>',
                        link: function(scope, element, attr, radioGroupController) {
                            var lastChecked;
                            $mdTheming(element), function(element) {
                                element.attr({
                                    id: attr.id || "radio_" + $mdUtil.nextUid(),
                                    role: "radio",
                                    "aria-checked": "false"
                                }), $mdAria.expectWithText(element, "aria-label");
                            }(element), element.addClass("md-auto-horizontal-margin"), attr.ngValue ? $mdUtil.nextTick(initialize, !1) : initialize();
                            function initialize() {
                                if (!radioGroupController) throw "RadioButton: No RadioGroupController could be found.";
                                radioGroupController.add(render), attr.$observe("value", render), element.on("click", listener).on("$destroy", (function() {
                                    radioGroupController.remove(render);
                                }));
                            }
                            function listener(ev) {
                                element[0].hasAttribute("disabled") || radioGroupController.isDisabled() || scope.$apply((function() {
                                    radioGroupController.setViewValue(attr.value, ev && ev.type);
                                }));
                            }
                            function render() {
                                var checked = radioGroupController.getViewValue() == attr.value;
                                checked !== lastChecked && (element[0] && element[0].parentNode && "md-radio-group" !== element[0].parentNode.nodeName.toLowerCase() && element.parent().toggleClass("md-checked", checked), 
                                checked && radioGroupController.setActiveDescendant(element.attr("id")), lastChecked = checked, 
                                element.attr("aria-checked", checked).toggleClass("md-checked", checked));
                            }
                        }
                    };
                }
            }(), function() {
                SelectDirective.$inject = [ "$mdSelect", "$mdUtil", "$mdConstant", "$mdTheming", "$mdAria", "$parse", "$sce" ], 
                SelectMenuDirective.$inject = [ "$parse", "$mdUtil", "$mdConstant", "$mdTheming" ], 
                OptionDirective.$inject = [ "$mdButtonInkRipple", "$mdUtil", "$mdTheming" ], SelectProvider.$inject = [ "$$interimElementProvider" ], 
                OptionController.$inject = [ "$element" ];
                var CHECKBOX_SELECTION_INDICATOR, SELECT_EDGE_MARGIN = 8, selectNextId = 0;
                function SelectDirective($mdSelect, $mdUtil, $mdConstant, $mdTheming, $mdAria, $parse, $sce) {
                    return {
                        restrict: "E",
                        require: [ "^?mdInputContainer", "mdSelect", "ngModel", "?^form" ],
                        compile: function(tElement, tAttrs) {
                            var isMultiple = $mdUtil.parseAttributeBoolean(tAttrs.multiple);
                            tElement.addClass("md-auto-horizontal-margin");
                            var valueEl = angular.element("<md-select-value><span></span></md-select-value>");
                            valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>'), valueEl.addClass("md-select-value"), 
                            valueEl[0].hasAttribute("id") || valueEl.attr("id", "select_value_label_" + $mdUtil.nextUid());
                            var mdContentEl = tElement.find("md-content");
                            mdContentEl.length || (tElement.append(angular.element("<md-content>").append(tElement.contents())), 
                            mdContentEl = tElement.find("md-content"));
                            mdContentEl.attr("role", "listbox"), mdContentEl.attr("tabindex", "-1"), isMultiple ? mdContentEl.attr("aria-multiselectable", "true") : mdContentEl.attr("aria-multiselectable", "false");
                            tAttrs.mdOnOpen && (tElement.find("md-content").prepend(angular.element('<div> <md-progress-circular md-mode="indeterminate" ng-if="$$loadingAsyncDone === false" md-diameter="25px"></md-progress-circular></div>')), 
                            tElement.find("md-option").attr("ng-show", "$$loadingAsyncDone"));
                            if (tAttrs.name) {
                                var autofillClone = angular.element('<select class="md-visually-hidden"></select>');
                                autofillClone.attr({
                                    name: tAttrs.name,
                                    "aria-hidden": "true",
                                    tabindex: "-1"
                                });
                                var opts = tElement.find("md-option");
                                angular.forEach(opts, (function(el) {
                                    var newEl = angular.element("<option>" + el.innerHTML + "</option>");
                                    el.hasAttribute("ng-value") ? newEl.attr("ng-value", el.getAttribute("ng-value")) : el.hasAttribute("value") && newEl.attr("value", el.getAttribute("value")), 
                                    autofillClone.append(newEl);
                                })), autofillClone.append('<option ng-value="' + tAttrs.ngModel + '" selected></option>'), 
                                tElement.parent().append(autofillClone);
                            }
                            var multipleContent = isMultiple ? "multiple" : "", ngModelOptions = tAttrs.ngModelOptions ? $mdUtil.supplant('ng-model-options="{0}"', [ tAttrs.ngModelOptions ]) : "", selectTemplate = '<div class="md-select-menu-container" aria-hidden="true" role="presentation">  <md-select-menu role="presentation" {0} {1}>{2}</md-select-menu></div>';
                            selectTemplate = $mdUtil.supplant(selectTemplate, [ multipleContent, ngModelOptions, tElement.html() ]), 
                            tElement.empty().append(valueEl), tElement.append(selectTemplate), tAttrs.tabindex || tAttrs.$set("tabindex", 0);
                            return function(scope, element, attrs, ctrls) {
                                var isDisabled, stopMdMultipleWatch, selectContainer, selectScope, selectMenuCtrl, untouched = !0, containerCtrl = ctrls[0], mdSelectCtrl = ctrls[1], ngModelCtrl = ctrls[2], formCtrl = ctrls[3], selectValueElement = element.find("md-select-value"), isReadonly = angular.isDefined(attrs.readonly), disableAsterisk = $mdUtil.parseAttributeBoolean(attrs.mdNoAsterisk), userDefinedLabelledby = angular.isDefined(attrs.ariaLabelledby), listboxContentElement = element.find("md-content"), initialPlaceholder = element.attr("placeholder");
                                if (disableAsterisk && element.addClass("md-no-asterisk"), containerCtrl) {
                                    var isErrorGetter = containerCtrl.isErrorGetter || function() {
                                        return ngModelCtrl.$invalid && (ngModelCtrl.$touched || formCtrl && formCtrl.$submitted);
                                    };
                                    if (containerCtrl.input && element.find("md-select-header").find("input")[0] !== containerCtrl.input[0]) throw new Error("<md-input-container> can only have *one* child <input>, <textarea>, or <select> element!");
                                    if (containerCtrl.input = element, containerCtrl.label) containerCtrl.label.attr("aria-hidden", "true"), 
                                    listboxContentElement.attr("aria-label", containerCtrl.label.text()), containerCtrl.setHasPlaceholder(!!initialPlaceholder); else {
                                        $mdAria.expect(element, "aria-label", initialPlaceholder);
                                        var selectLabel = element.attr("aria-label");
                                        selectLabel || (selectLabel = initialPlaceholder), listboxContentElement.attr("aria-label", selectLabel);
                                    }
                                    var stopInvalidWatch = scope.$watch(isErrorGetter, containerCtrl.setInvalid);
                                }
                                selectContainer = function() {
                                    var selectContainer = angular.element(element[0].querySelector(".md-select-menu-container"));
                                    return selectScope = scope, attrs.mdContainerClass && selectContainer.addClass(attrs.mdContainerClass), 
                                    selectMenuCtrl = selectContainer.find("md-select-menu").controller("mdSelectMenu"), 
                                    selectMenuCtrl.init(ngModelCtrl, attrs), element.on("$destroy", (function() {
                                        selectContainer.remove();
                                    })), selectContainer;
                                }(), $mdTheming(element);
                                var originalRender = ngModelCtrl.$render;
                                ngModelCtrl.$render = function() {
                                    originalRender(), syncSelectValueText(), inputCheckValue();
                                };
                                var stopPlaceholderObserver = attrs.$observe("placeholder", ngModelCtrl.$render), stopRequiredObserver = attrs.$observe("required", (function(value) {
                                    containerCtrl && containerCtrl.label && containerCtrl.label.toggleClass("md-required", value && !disableAsterisk), 
                                    element.removeAttr("aria-required"), value ? listboxContentElement.attr("aria-required", "true") : listboxContentElement.removeAttr("aria-required");
                                }));
                                if (mdSelectCtrl.setSelectValueText = function(text) {
                                    var useDefaultText = undefined === text || "" === text, isSelectLabelFromUser = !1;
                                    if (mdSelectCtrl.setIsPlaceholder(!text), attrs.mdSelectedText && attrs.mdSelectedHtml) throw Error("md-select cannot have both `md-selected-text` and `md-selected-html`");
                                    if (attrs.mdSelectedText || attrs.mdSelectedHtml) text = $parse(attrs.mdSelectedText || attrs.mdSelectedHtml)(scope), 
                                    isSelectLabelFromUser = !0; else if (useDefaultText) {
                                        text = attrs.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : "") || "", 
                                        isSelectLabelFromUser = !0;
                                    }
                                    var target = selectValueElement.children().eq(0);
                                    attrs.mdSelectedHtml ? target.html($sce.getTrustedHtml(text)) : isSelectLabelFromUser ? target.text(text) : target.html(text), 
                                    useDefaultText ? (selectValueElement.attr("aria-hidden", "true"), userDefinedLabelledby || element.removeAttr("aria-labelledby")) : (selectValueElement.removeAttr("aria-hidden"), 
                                    userDefinedLabelledby || element.attr("aria-labelledby", element[0].id + " " + selectValueElement[0].id));
                                }, mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
                                    isPlaceholder ? (selectValueElement.addClass("md-select-placeholder"), containerCtrl && containerCtrl.label && !element.attr("placeholder") && containerCtrl.label.addClass("md-placeholder")) : (selectValueElement.removeClass("md-select-placeholder"), 
                                    containerCtrl && containerCtrl.label && !element.attr("placeholder") && containerCtrl.label.removeClass("md-placeholder"));
                                }, !isReadonly) {
                                    element.on("focus", (function() {
                                        containerCtrl && containerCtrl.setFocused(!0);
                                    })), element.on("blur", (function(event) {
                                        untouched && (untouched = !1, selectScope._mdSelectIsOpen && event.stopImmediatePropagation()), 
                                        containerCtrl && containerCtrl.setFocused(!1), inputCheckValue();
                                    }));
                                }
                                mdSelectCtrl.triggerClose = function() {
                                    $parse(attrs.mdOnClose)(scope);
                                }, scope.$$postDigest((function() {
                                    !function() {
                                        var labelText = element.attr("aria-label") || element.attr("placeholder");
                                        !labelText && containerCtrl && containerCtrl.label && (labelText = containerCtrl.label.text());
                                        $mdAria.expect(element, "aria-label", labelText);
                                    }(), syncSelectValueText();
                                }));
                                var stopSelectedLabelsWatcher = scope.$watch((function() {
                                    return selectMenuCtrl.getSelectedLabels();
                                }), syncSelectValueText);
                                function syncSelectValueText() {
                                    selectMenuCtrl = selectMenuCtrl || selectContainer.find("md-select-menu").controller("mdSelectMenu"), 
                                    mdSelectCtrl.setSelectValueText(selectMenuCtrl.getSelectedLabels());
                                }
                                var stopMdMultipleObserver = attrs.$observe("mdMultiple", (function(val) {
                                    stopMdMultipleWatch && stopMdMultipleWatch();
                                    var parser = $parse(val);
                                    stopMdMultipleWatch = scope.$watch((function() {
                                        return parser(scope);
                                    }), (function(multiple, prevVal) {
                                        var selectMenu = selectContainer.find("md-select-menu");
                                        if (undefined !== multiple || undefined !== prevVal) {
                                            if (multiple) {
                                                var setMultipleAttrs = {
                                                    multiple: "multiple"
                                                };
                                                element.attr(setMultipleAttrs), selectMenu.attr(setMultipleAttrs);
                                            } else element.removeAttr("multiple"), selectMenu.removeAttr("multiple");
                                            element.find("md-content").attr("aria-multiselectable", multiple ? "true" : "false"), 
                                            selectContainer && (selectMenuCtrl.setMultiple(Boolean(multiple)), originalRender = ngModelCtrl.$render, 
                                            ngModelCtrl.$render = function() {
                                                originalRender(), syncSelectValueText(), inputCheckValue();
                                            }, ngModelCtrl.$render());
                                        }
                                    }));
                                })), stopDisabledObserver = attrs.$observe("disabled", (function(disabled) {
                                    angular.isString(disabled) && (disabled = !0), undefined !== isDisabled && isDisabled === disabled || (isDisabled = disabled, 
                                    disabled ? element.attr({
                                        "aria-disabled": "true"
                                    }).removeAttr("tabindex").removeAttr("aria-expanded").removeAttr("aria-haspopup").off("click", openSelect).off("keydown", handleKeypress) : element.attr({
                                        tabindex: attrs.tabindex,
                                        "aria-haspopup": "listbox"
                                    }).removeAttr("aria-disabled").on("click", openSelect).on("keydown", handleKeypress));
                                }));
                                attrs.hasOwnProperty("disabled") || attrs.hasOwnProperty("ngDisabled") || (element.attr({
                                    "aria-disabled": "false"
                                }), element.on("click", openSelect), element.on("keydown", handleKeypress));
                                var ariaAttrs = {
                                    role: "button",
                                    "aria-haspopup": "listbox"
                                };
                                element[0].hasAttribute("id") || (ariaAttrs.id = "select_" + $mdUtil.nextUid());
                                var containerId = "select_container_" + $mdUtil.nextUid();
                                selectContainer.attr("id", containerId);
                                var listboxContentId = "select_listbox_" + $mdUtil.nextUid();
                                function inputCheckValue() {
                                    $mdUtil.nextTick((function() {
                                        containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.getSelectedLabels().length > 0 || (element[0].validity || {}).badInput);
                                    }));
                                }
                                function handleKeypress(e) {
                                    if ($mdConstant.isNavigationKey(e)) e.preventDefault(), openSelect(); else if (shouldHandleKey(e, $mdConstant)) {
                                        e.preventDefault();
                                        var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
                                        if (!node || node.hasAttribute("disabled")) return;
                                        var optionCtrl = angular.element(node).controller("mdOption");
                                        selectMenuCtrl.isMultiple || angular.forEach(Object.keys(selectMenuCtrl.selected), (function(key) {
                                            selectMenuCtrl.deselect(key);
                                        })), selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value), selectMenuCtrl.refreshViewValue();
                                    }
                                }
                                function openSelect() {
                                    selectScope._mdSelectIsOpen = !0, element.attr("aria-expanded", "true"), $mdSelect.show({
                                        scope: selectScope,
                                        preserveScope: !0,
                                        skipCompile: !0,
                                        element: selectContainer,
                                        target: element[0],
                                        selectCtrl: mdSelectCtrl,
                                        preserveElement: !0,
                                        hasBackdrop: !0,
                                        loadingAsync: !!attrs.mdOnOpen && (scope.$eval(attrs.mdOnOpen) || !0)
                                    }).finally((function() {
                                        selectScope._mdSelectIsOpen = !1, element.removeAttr("aria-expanded"), element.removeAttr("aria-activedescendant"), 
                                        ngModelCtrl.$setTouched();
                                    }));
                                }
                                selectContainer.find("md-content").attr("id", listboxContentId), element.find("md-select-menu").length || (ariaAttrs["aria-owns"] = listboxContentId), 
                                element.attr(ariaAttrs), scope.$on("$destroy", (function() {
                                    stopRequiredObserver && stopRequiredObserver(), stopDisabledObserver && stopDisabledObserver(), 
                                    stopMdMultipleWatch && stopMdMultipleWatch(), stopMdMultipleObserver && stopMdMultipleObserver(), 
                                    stopSelectedLabelsWatcher && stopSelectedLabelsWatcher(), stopPlaceholderObserver && stopPlaceholderObserver(), 
                                    stopInvalidWatch && stopInvalidWatch(), element.off("focus"), element.off("blur"), 
                                    $mdSelect.destroy().finally((function() {
                                        containerCtrl && (containerCtrl.setFocused(!1), containerCtrl.setHasValue(!1), containerCtrl.input = null), 
                                        ngModelCtrl.$setTouched();
                                    }));
                                }));
                            };
                        },
                        controller: function() {}
                    };
                }
                function SelectMenuDirective($parse, $mdUtil, $mdConstant, $mdTheming) {
                    return SelectMenuController.$inject = [ "$scope", "$attrs", "$element" ], {
                        restrict: "E",
                        require: [ "mdSelectMenu" ],
                        scope: !1,
                        controller: SelectMenuController,
                        link: {
                            pre: function(scope, element, attrs, ctrls) {
                                var selectMenuCtrl = ctrls[0];
                                function clickListener(mouseEvent) {
                                    var option = $mdUtil.getClosest(mouseEvent.target, "md-option"), optionCtrl = option && angular.element(option).data("$mdOptionController");
                                    if (option && optionCtrl) if (option.hasAttribute("disabled")) mouseEvent.stopImmediatePropagation(); else {
                                        var optionHashKey = selectMenuCtrl.hashGetter(optionCtrl.value), isSelected = angular.isDefined(selectMenuCtrl.selected[optionHashKey]);
                                        scope.$apply((function() {
                                            selectMenuCtrl.isMultiple ? isSelected ? selectMenuCtrl.deselect(optionHashKey) : selectMenuCtrl.select(optionHashKey, optionCtrl.value) : isSelected || (angular.forEach(Object.keys(selectMenuCtrl.selected), (function(key) {
                                                selectMenuCtrl.deselect(key);
                                            })), selectMenuCtrl.select(optionHashKey, optionCtrl.value)), selectMenuCtrl.refreshViewValue();
                                        }));
                                    } else mouseEvent.target && mouseEvent.target.parentNode && "MD-SELECT-HEADER" === mouseEvent.target.parentNode.tagName && mouseEvent.stopImmediatePropagation();
                                }
                                element.addClass("_md"), $mdTheming(element), element.on("click", clickListener), 
                                element.on("keypress", (function(keyboardEvent) {
                                    13 !== keyboardEvent.keyCode && 32 !== keyboardEvent.keyCode || clickListener(keyboardEvent);
                                }));
                            }
                        }
                    };
                    function SelectMenuController($scope, $attrs, $element) {
                        var defaultIsEmpty, clearSearchTimeout, optNodes, optText, self = this, searchStr = "";
                        function renderMultiple() {
                            var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
                            if (angular.isArray(newSelectedValues)) {
                                var oldSelected = Object.keys(self.selected), newSelectedHashes = newSelectedValues.map(self.hashGetter);
                                oldSelected.filter((function(hash) {
                                    return -1 === newSelectedHashes.indexOf(hash);
                                })).forEach(self.deselect), newSelectedHashes.forEach((function(hashKey, i) {
                                    self.select(hashKey, newSelectedValues[i]);
                                }));
                            }
                        }
                        function renderSingular() {
                            var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
                            Object.keys(self.selected).forEach(self.deselect), self.select(self.hashGetter(value), value);
                        }
                        self.isMultiple = angular.isDefined($attrs.multiple), self.selected = {}, self.options = {}, 
                        $scope.$watchCollection((function() {
                            return self.options;
                        }), (function() {
                            self.ngModel.$render(), function() {
                                var i, options;
                                if (!$element.find("md-optgroup").length) return;
                                for (options = $element.find("md-option"), i = 0; i < options.length; i++) options[i].setAttribute("aria-setsize", options.length), 
                                options[i].setAttribute("aria-posinset", i + 1);
                            }();
                        })), self.setMultiple = function(isMultiple) {
                            var ngModel = self.ngModel;
                            if (defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty, self.isMultiple = isMultiple, 
                            self.isMultiple) {
                                var loaded = !1, delayedRender = function(val) {
                                    loaded ? renderMultiple() : $mdUtil.nextTick((function() {
                                        renderMultiple(), loaded = !0;
                                    }));
                                };
                                ngModel.$validators["md-multiple"] = validateArray, ngModel.$render = delayedRender, 
                                $scope.$watchCollection(self.modelBinding, (function(value) {
                                    validateArray(value) && delayedRender();
                                })), ngModel.$isEmpty = function(value) {
                                    return !value || 0 === value.length;
                                };
                            } else delete ngModel.$validators["md-multiple"], ngModel.$render = renderSingular;
                            function validateArray(modelValue, viewValue) {
                                return angular.isArray(modelValue || viewValue || []);
                            }
                        }, self.optNodeForKeyboardSearch = function(keyboardEvent) {
                            var search, i;
                            for (clearSearchTimeout && clearTimeout(clearSearchTimeout), clearSearchTimeout = setTimeout((function() {
                                clearSearchTimeout = undefined, searchStr = "", optText = undefined, optNodes = undefined;
                            }), 300), searchStr += keyboardEvent.key, search = new RegExp("^" + $mdUtil.sanitize(searchStr), "i"), 
                            optNodes || (optNodes = $element.find("md-option"), optText = new Array(optNodes.length), 
                            angular.forEach(optNodes, (function(el, i) {
                                optText[i] = el.textContent.trim();
                            }))), i = 0; i < optText.length; ++i) if (search.test(optText[i])) return optNodes[i];
                        }, self.init = function(ngModel, parentAttrs) {
                            function getId(value) {
                                return angular.isObject(value) && !angular.isArray(value) ? "object_" + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId)) : value + "";
                            }
                            self.ngModel = ngModel, self.modelBinding = parentAttrs.ngModel, self.ngModel.$isEmpty = function($viewValue) {
                                var hashedValue = self.options[self.hashGetter($viewValue)] ? self.options[self.hashGetter($viewValue)].value : null;
                                return !angular.isDefined(hashedValue) || null === hashedValue || "" === hashedValue || hashedValue != hashedValue;
                            }, $attrs.ngModelOptions ? self.hashGetter = function(value) {
                                var ngModelOptions = $parse($attrs.ngModelOptions)($scope), trackByOption = ngModelOptions && ngModelOptions.trackBy;
                                return trackByOption ? $parse(trackByOption)($scope, {
                                    $value: value
                                }) : angular.isObject(value) ? getId(value) : value;
                            } : self.hashGetter = getId, self.setMultiple(self.isMultiple), parentAttrs.hasOwnProperty("mdSelectOnlyOption") && $mdUtil.nextTick((function() {
                                var optionKeys = Object.keys(self.options);
                                if (1 === optionKeys.length) {
                                    var option = self.options[optionKeys[0]];
                                    self.deselect(Object.keys(self.selected)[0]), self.select(self.hashGetter(option.value), option.value), 
                                    self.refreshViewValue(), self.ngModel.$setPristine();
                                }
                            }), !1);
                        }, self.setActiveDescendant = function(id) {
                            angular.isDefined(id) ? $element.find("md-content").attr("aria-activedescendant", id) : $element.find("md-content").removeAttr("aria-activedescendant");
                        }, self.getSelectedLabels = function(opts) {
                            var mapFn, mode = (opts = opts || {}).mode || "html", selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll("md-option[selected]"));
                            return selectedOptionEls.length ? ("html" === mode ? mapFn = function(el) {
                                if (el.hasAttribute("md-option-empty")) return "";
                                var html = el.innerHTML, rippleContainer = el.querySelector(".md-ripple-container");
                                rippleContainer && (html = html.replace(rippleContainer.outerHTML, ""));
                                var checkboxContainer = el.querySelector(".md-container");
                                return checkboxContainer && (html = html.replace(checkboxContainer.outerHTML, "")), 
                                html;
                            } : "aria" === mode && (mapFn = function(el) {
                                return el.hasAttribute("aria-label") ? el.getAttribute("aria-label") : el.textContent;
                            }), $mdUtil.uniq(selectedOptionEls.map(mapFn)).join(", ")) : "";
                        }, self.select = function(hashKey, hashedValue) {
                            var option = self.options[hashKey];
                            option && option.setSelected(!0, self.isMultiple), self.selected[hashKey] = hashedValue;
                        }, self.deselect = function(hashKey) {
                            var option = self.options[hashKey];
                            option && option.setSelected(!1, self.isMultiple), delete self.selected[hashKey];
                        }, self.addOption = function(hashKey, optionCtrl) {
                            if (angular.isDefined(self.options[hashKey])) throw new Error('Duplicate md-option values are not allowed in a select. Duplicate value "' + optionCtrl.value + '" found.');
                            self.options[hashKey] = optionCtrl, angular.isDefined(self.selected[hashKey]) && (self.select(hashKey, optionCtrl.value), 
                            angular.isDefined(self.ngModel.$$rawModelValue) && self.hashGetter(self.ngModel.$$rawModelValue) === hashKey && self.ngModel.$validate(), 
                            self.refreshViewValue());
                        }, self.removeOption = function(hashKey) {
                            delete self.options[hashKey];
                        }, self.refreshViewValue = function() {
                            var option, values = [];
                            for (var hashKey in self.selected) (option = self.options[hashKey]) ? values.push(option.value) : values.push(self.selected[hashKey]);
                            var newVal = self.isMultiple ? values : values[0];
                            (function(prevVal, newVal) {
                                if (self.isMultiple) {
                                    if (angular.isArray(prevVal)) {
                                        if (prevVal.length !== newVal.length) return !1;
                                        var prevValHashes = prevVal.map((function(prevValItem) {
                                            return self.hashGetter(prevValItem);
                                        }));
                                        return newVal.every((function(newValItem) {
                                            var newValItemHash = self.hashGetter(newValItem);
                                            return prevValHashes.some((function(prevValHash) {
                                                return prevValHash === newValItemHash;
                                            }));
                                        }));
                                    }
                                    return !1;
                                }
                                return self.hashGetter(prevVal) === self.hashGetter(newVal);
                            })(self.ngModel.$modelValue, newVal) || (self.ngModel.$setViewValue(newVal), self.ngModel.$render());
                        };
                    }
                }
                function OptionDirective($mdButtonInkRipple, $mdUtil, $mdTheming) {
                    return {
                        restrict: "E",
                        require: [ "mdOption", "^^mdSelectMenu" ],
                        controller: OptionController,
                        compile: function(element, attrs) {
                            element.append(angular.element('<div class="md-text">').append(element.contents())), 
                            element.attr("tabindex", attrs.tabindex || "0"), hasDefinedValue(attrs) || element.attr("md-option-empty", "");
                            return postLink;
                        }
                    };
                    function hasDefinedValue(attrs) {
                        var value = attrs.value, ngValue = attrs.ngValue;
                        return value || ngValue;
                    }
                    function postLink(scope, element, attrs, ctrls) {
                        var optionCtrl = ctrls[0], selectMenuCtrl = ctrls[1];
                        if ($mdTheming(element), selectMenuCtrl.isMultiple) {
                            if (element.addClass("md-checkbox-enabled"), !CHECKBOX_SELECTION_INDICATOR) {
                                var indicator = document.createElement("div");
                                indicator.className = "md-container", indicator.appendChild(document.createElement("div")), 
                                indicator.firstChild.className = "md-icon", CHECKBOX_SELECTION_INDICATOR = angular.element(indicator);
                            }
                            element.prepend(CHECKBOX_SELECTION_INDICATOR.clone());
                        }
                        function setOptionValue(newValue, oldValue, prevAttempt) {
                            if (selectMenuCtrl.hashGetter) {
                                var oldHashKey = selectMenuCtrl.hashGetter(oldValue, scope), newHashKey = selectMenuCtrl.hashGetter(newValue, scope);
                                optionCtrl.hashKey = newHashKey, optionCtrl.value = newValue, selectMenuCtrl.removeOption(oldHashKey, optionCtrl), 
                                selectMenuCtrl.addOption(newHashKey, optionCtrl);
                            } else prevAttempt || scope.$$postDigest((function() {
                                setOptionValue(newValue, oldValue, !0);
                            }));
                        }
                        angular.isDefined(attrs.ngValue) ? scope.$watch(attrs.ngValue, (function(newValue, oldValue) {
                            setOptionValue(newValue, oldValue), element.removeAttr("aria-checked");
                        })) : angular.isDefined(attrs.value) ? setOptionValue(attrs.value) : scope.$watch((function() {
                            return element.text().trim();
                        }), setOptionValue), attrs.$observe("disabled", (function(disabled) {
                            disabled ? element.attr("tabindex", "-1") : element.attr("tabindex", "0");
                        })), scope.$$postDigest((function() {
                            attrs.$observe("selected", (function(selected) {
                                angular.isDefined(selected) && ("string" == typeof selected && (selected = !0), 
                                selected ? (selectMenuCtrl.isMultiple || selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]), 
                                selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value)) : selectMenuCtrl.deselect(optionCtrl.hashKey), 
                                selectMenuCtrl.refreshViewValue());
                            }));
                        })), $mdButtonInkRipple.attach(scope, element), function() {
                            var ariaAttrs = {
                                role: "option"
                            };
                            selectMenuCtrl.isMultiple && (ariaAttrs["aria-selected"] = "false");
                            element[0].hasAttribute("id") || (ariaAttrs.id = "select_option_" + $mdUtil.nextUid());
                            element.attr(ariaAttrs);
                        }(), scope.$on("$destroy", (function() {
                            selectMenuCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
                        }));
                    }
                }
                function OptionController($element) {
                    this.setSelected = function(isSelected, isMultiple) {
                        isSelected ? $element.attr({
                            selected: "true",
                            "aria-selected": "true"
                        }) : isSelected || ($element.removeAttr("selected"), isMultiple ? $element.attr("aria-selected", "false") : $element.removeAttr("aria-selected"));
                    };
                }
                function SelectProvider($$interimElementProvider) {
                    return selectDefaultOptions.$inject = [ "$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document" ], 
                    $$interimElementProvider("$mdSelect").setDefaults({
                        methods: [ "target" ],
                        options: selectDefaultOptions
                    });
                    function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
                        var ERROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!", animator = $mdUtil.dom.animator, keyCodes = $mdConstant.KEY_CODE;
                        return {
                            parent: "body",
                            themable: !0,
                            onShow: function(scope, element, opts) {
                                return function() {
                                    opts.loadingAsync && !opts.isRemoved && (scope.$$loadingAsyncDone = !1, $q.when(opts.loadingAsync).then((function() {
                                        scope.$$loadingAsyncDone = !0, delete opts.loadingAsync;
                                    })).then((function() {
                                        $$rAF(positionAndFocusMenu);
                                    })));
                                }(), function(scope, options) {
                                    var selectMenuElement = element.find("md-select-menu");
                                    if (!options.target) throw new Error($mdUtil.supplant(ERROR_TARGET_EXPECTED, [ options.target ]));
                                    angular.extend(options, {
                                        isRemoved: !1,
                                        target: angular.element(options.target),
                                        parent: angular.element(options.parent),
                                        selectEl: selectMenuElement,
                                        contentEl: element.find("md-content"),
                                        optionNodes: selectMenuElement[0].getElementsByTagName("md-option")
                                    });
                                }(0, opts), opts.hideBackdrop = function(scope, element, options) {
                                    options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = !1;
                                    options.hasBackdrop && (options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher"), 
                                    $animate.enter(options.backdrop, $document[0].body, null, {
                                        duration: 0
                                    }));
                                    return function() {
                                        options.backdrop && options.backdrop.remove(), options.disableParentScroll && options.restoreScroll(), 
                                        delete options.restoreScroll;
                                    };
                                }(scope, 0, opts), function(scope, element, opts) {
                                    opts.parent !== element.parent() && element.parent().attr("aria-owns", element.find("md-content").attr("id"));
                                    return opts.parent.append(element), $q((function(resolve, reject) {
                                        try {
                                            $animateCss(element, {
                                                removeClass: "md-leave",
                                                duration: 0
                                            }).start().then(positionAndFocusMenu).then(resolve);
                                        } catch (e) {
                                            reject(e);
                                        }
                                    }));
                                }(0, element, opts).then((function(response) {
                                    return element.attr("aria-hidden", "false"), opts.alreadyOpen = !0, opts.cleanupInteraction = function() {
                                        if (opts.isRemoved) return;
                                        var dropDown = opts.selectEl, selectMenuController = dropDown.controller("mdSelectMenu") || {};
                                        return element.addClass("md-clickable"), opts.backdrop && opts.backdrop.on("click", onBackdropClick), 
                                        dropDown.on("keydown", onMenuKeyDown), dropDown.on("click", checkCloseMenu), function() {
                                            opts.backdrop && opts.backdrop.off("click", onBackdropClick), dropDown.off("keydown", onMenuKeyDown), 
                                            dropDown.off("click", checkCloseMenu), element.removeClass("md-clickable"), opts.isRemoved = !0;
                                        };
                                        function onBackdropClick(e) {
                                            e.preventDefault(), e.stopPropagation(), opts.restoreFocus = !1, $mdUtil.nextTick($mdSelect.hide, !0);
                                        }
                                        function onMenuKeyDown(ev) {
                                            switch (ev.preventDefault(), ev.stopPropagation(), ev.keyCode) {
                                              case keyCodes.UP_ARROW:
                                                return focusPrevOption();

                                              case keyCodes.DOWN_ARROW:
                                                return focusNextOption();

                                              case keyCodes.SPACE:
                                              case keyCodes.ENTER:
                                                opts.focusedNode && (dropDown.triggerHandler({
                                                    type: "click",
                                                    target: opts.focusedNode
                                                }), ev.preventDefault()), checkCloseMenu(ev);
                                                break;

                                              case keyCodes.TAB:
                                              case keyCodes.ESCAPE:
                                                ev.stopPropagation(), ev.preventDefault(), opts.restoreFocus = !0, $mdUtil.nextTick($mdSelect.hide, !0);
                                                break;

                                              default:
                                                if (shouldHandleKey(ev, $mdConstant)) {
                                                    var optNode = selectMenuController.optNodeForKeyboardSearch(ev);
                                                    optNode && !optNode.hasAttribute("disabled") && focusOptionNode(opts.focusedNode, optNode, selectMenuController);
                                                }
                                            }
                                        }
                                        function focusOption(direction) {
                                            var newOption, optionsArray = $mdUtil.nodesToArray(opts.optionNodes), index = optionsArray.indexOf(opts.focusedNode), prevOption = optionsArray[index];
                                            do {
                                                -1 === index ? index = 0 : "next" === direction && index < optionsArray.length - 1 ? index++ : "prev" === direction && index > 0 && index--, 
                                                (newOption = optionsArray[index]).hasAttribute("disabled") && (newOption = null);
                                            } while (!newOption && index < optionsArray.length - 1 && index > 0);
                                            focusOptionNode(prevOption, newOption, selectMenuController);
                                        }
                                        function focusNextOption() {
                                            focusOption("next");
                                        }
                                        function focusPrevOption() {
                                            focusOption("prev");
                                        }
                                        function checkCloseMenu(event) {
                                            function mouseOnScrollbar() {
                                                var clickOnScrollbar = !1;
                                                if (event && event.currentTarget.children.length > 0) {
                                                    var child = event.currentTarget.children[0];
                                                    if (child.scrollHeight > child.clientHeight && child.children.length > 0) event.pageX - event.currentTarget.getBoundingClientRect().left > child.querySelector("md-option").offsetWidth && (clickOnScrollbar = !0);
                                                }
                                                return clickOnScrollbar;
                                            }
                                            event && "click" === event.type && event.currentTarget !== dropDown[0] || mouseOnScrollbar() || opts.focusedNode && opts.focusedNode.hasAttribute && !opts.focusedNode.hasAttribute("disabled") && (event.preventDefault(), 
                                            event.stopPropagation(), selectMenuController.isMultiple || (opts.restoreFocus = !0, 
                                            $mdUtil.nextTick((function() {
                                                $mdSelect.hide(selectMenuController.ngModel.$viewValue), opts.focusedNode.classList.remove("md-focused");
                                            }), !0)));
                                        }
                                    }(), opts.cleanupResizing = function() {
                                        var debouncedOnResize = function(scope, target, options) {
                                            return function() {
                                                if (!options.isRemoved) {
                                                    var updates = calculateMenuPositions(scope, target, options), container = updates.container, dropDown = updates.dropDown;
                                                    container.element.css(animator.toCss(container.styles)), dropDown.element.css(animator.toCss(dropDown.styles));
                                                }
                                            };
                                        }(scope, element, opts), window = angular.element($window);
                                        return window.on("resize", debouncedOnResize), window.on("orientationchange", debouncedOnResize), 
                                        function() {
                                            window.off("resize", debouncedOnResize), window.off("orientationchange", debouncedOnResize);
                                        };
                                    }(), opts.contentEl[0].focus(), response;
                                }), opts.hideBackdrop);
                                function positionAndFocusMenu() {
                                    return $q((function(resolve) {
                                        if (opts.isRemoved) return $q.reject(!1);
                                        var info = calculateMenuPositions(scope, element, opts);
                                        info.container.element.css(animator.toCss(info.container.styles)), info.dropDown.element.css(animator.toCss(info.dropDown.styles)), 
                                        $$rAF((function() {
                                            var nodeToFocus;
                                            element.addClass("md-active"), info.dropDown.element.css(animator.toCss({
                                                transform: ""
                                            })), (nodeToFocus = opts.focusedNode) && !nodeToFocus.hasAttribute("disabled") && focusOptionNode(null, nodeToFocus, opts.selectEl.controller("mdSelectMenu")), 
                                            resolve();
                                        }));
                                    }));
                                }
                                function focusOptionNode(previousNode, node, menuController) {
                                    var listboxContentNode = opts.contentEl[0];
                                    if (node) {
                                        if (previousNode && previousNode.classList.remove("md-focused"), node.classList.add("md-focused"), 
                                        menuController && menuController.setActiveDescendant && menuController.setActiveDescendant(node.id), 
                                        listboxContentNode.scrollHeight > listboxContentNode.clientHeight) {
                                            var scrollBottom = listboxContentNode.clientHeight + listboxContentNode.scrollTop, nodeBottom = node.offsetTop + node.offsetHeight;
                                            nodeBottom > scrollBottom ? listboxContentNode.scrollTop = nodeBottom - listboxContentNode.clientHeight : node.offsetTop < listboxContentNode.scrollTop && (listboxContentNode.scrollTop = node.offsetTop);
                                        }
                                        opts.focusedNode = node, menuController && menuController.refreshViewValue && menuController.refreshViewValue();
                                    }
                                }
                            },
                            onRemove: function(scope, element, opts) {
                                var animationRunner = null, destroyListener = scope.$on("$destroy", (function() {
                                    animationRunner.end();
                                }));
                                return (opts = opts || {}).cleanupInteraction(), opts.cleanupResizing(), opts.hideBackdrop(), 
                                !0 === opts.$destroy ? cleanElement() : function() {
                                    return (animationRunner = $animateCss(element, {
                                        addClass: "md-leave"
                                    })).start();
                                }().then(cleanElement);
                                function cleanElement() {
                                    destroyListener(), element.removeClass("md-active").attr("aria-hidden", "true").css({
                                        display: "none",
                                        top: "",
                                        right: "",
                                        bottom: "",
                                        left: "",
                                        "font-size": "",
                                        "min-width": ""
                                    }), function(opts) {
                                        var mdSelect = opts.selectCtrl;
                                        if (mdSelect) {
                                            var menuController = opts.selectEl.controller("mdSelectMenu");
                                            mdSelect.setSelectValueText(menuController ? menuController.getSelectedLabels() : ""), 
                                            mdSelect.triggerClose();
                                        }
                                    }(opts), opts.$destroy || (opts.restoreFocus ? opts.target.focus() : $mdUtil.nextTick((function() {
                                        opts.target.triggerHandler("blur");
                                    }), !0));
                                }
                            },
                            hasBackdrop: !0,
                            disableParentScroll: !0
                        };
                        function calculateMenuPositions(scope, element, opts) {
                            var centeredNode, obj, containerNode = element[0], targetNode = opts.target[0].children[0], parentNode = $document[0].body, selectNode = opts.selectEl[0], contentNode = opts.contentEl[0], parentRect = parentNode.getBoundingClientRect(), targetRect = targetNode.getBoundingClientRect(), bounds = {
                                left: parentRect.left + SELECT_EDGE_MARGIN,
                                top: SELECT_EDGE_MARGIN,
                                bottom: parentRect.height - SELECT_EDGE_MARGIN,
                                right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
                            }, spaceAvailable_top = targetRect.top - bounds.top, spaceAvailable_bottom = (targetRect.left, 
                            targetRect.left, targetRect.width, bounds.bottom - (targetRect.top + targetRect.height)), maxWidth = parentRect.width - 2 * SELECT_EDGE_MARGIN, selectedNode = selectNode.querySelector("md-option[selected]"), optionNodes = selectNode.getElementsByTagName("md-option"), optgroupNodes = selectNode.getElementsByTagName("md-optgroup"), isScrollable = function(element, contentNode) {
                                var isScrollable = !1;
                                try {
                                    var oldDisplay = element[0].style.display;
                                    element[0].style.display = "block", isScrollable = contentNode.scrollHeight > contentNode.offsetHeight, 
                                    element[0].style.display = oldDisplay;
                                } finally {}
                                return isScrollable;
                            }(element, contentNode);
                            centeredNode = (obj = opts.loadingAsync) && angular.isFunction(obj.then) ? contentNode.firstElementChild || contentNode : selectedNode || (optgroupNodes.length ? optgroupNodes[0] : optionNodes.length ? optionNodes[0] : contentNode.firstElementChild || contentNode), 
                            contentNode.offsetWidth > maxWidth ? contentNode.style["max-width"] = maxWidth + "px" : contentNode.style.maxWidth = null, 
                            isScrollable && selectNode.classList.add("md-overflow");
                            var focusedNode = centeredNode;
                            "MD-OPTGROUP" === (focusedNode.tagName || "").toUpperCase() && (centeredNode = focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode), 
                            opts.focusedNode = focusedNode, containerNode.style.display = "block";
                            var node, left, top, transformOrigin, minWidth, fontSize, selectMenuRect = selectNode.getBoundingClientRect(), centeredRect = (node = centeredNode) ? {
                                left: node.offsetLeft,
                                top: node.offsetTop,
                                width: node.offsetWidth,
                                height: node.offsetHeight
                            } : {
                                left: 0,
                                top: 0,
                                width: 0,
                                height: 0
                            };
                            if (centeredNode) {
                                var centeredStyle = $window.getComputedStyle(centeredNode);
                                centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0, centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
                            }
                            if (isScrollable) {
                                var scrollBuffer = contentNode.offsetHeight / 2;
                                contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer, 
                                spaceAvailable_top < scrollBuffer ? contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable_top) : spaceAvailable_bottom < scrollBuffer && (contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable_bottom));
                            }
                            left = targetRect.left + centeredRect.left - centeredRect.paddingLeft, top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2, 
                            transformOrigin = centeredRect.left + targetRect.width / 2 + "px " + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + "px 0px", 
                            minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth), 
                            fontSize = window.getComputedStyle(targetNode)["font-size"];
                            var containerRect = containerNode.getBoundingClientRect(), scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1)) / 100, scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1)) / 100;
                            return {
                                container: {
                                    element: angular.element(containerNode),
                                    styles: {
                                        left: Math.floor(clamp(bounds.left, left, bounds.right - minWidth)),
                                        top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
                                        "min-width": minWidth,
                                        "font-size": fontSize
                                    }
                                },
                                dropDown: {
                                    element: angular.element(selectNode),
                                    styles: {
                                        transformOrigin,
                                        transform: opts.alreadyOpen ? "" : $mdUtil.supplant("scale({0},{1})", [ scaleX, scaleY ])
                                    }
                                }
                            };
                        }
                    }
                    function clamp(min, n, max) {
                        return Math.max(min, Math.min(n, max));
                    }
                }
                function shouldHandleKey(ev, $mdConstant) {
                    var char = String.fromCharCode(ev.keyCode), isNonUsefulKey = ev.keyCode <= 31;
                    return char && char.length && !isNonUsefulKey && !$mdConstant.isMetaKey(ev) && !$mdConstant.isFnLockKey(ev) && !$mdConstant.hasModifierKey(ev);
                }
                angular.module("material.components.select", [ "material.core", "material.components.backdrop" ]).directive("mdSelect", SelectDirective).directive("mdSelectMenu", SelectMenuDirective).directive("mdOption", OptionDirective).directive("mdOptgroup", (function() {
                    return {
                        restrict: "E",
                        compile: function(element, attrs) {
                            hasSelectHeader() || setupLabelElement();
                            function hasSelectHeader() {
                                return element.parent().find("md-select-header").length;
                            }
                            function setupLabelElement() {
                                var labelElement = element.find("label");
                                labelElement.length || (labelElement = angular.element("<label>"), element.prepend(labelElement)), 
                                labelElement.addClass("md-container-ignore"), labelElement.attr("aria-hidden", "true"), 
                                attrs.label && labelElement.text(attrs.label), element.attr("aria-label", labelElement.text());
                            }
                            element.attr("role", "group");
                        }
                    };
                })).directive("mdSelectHeader", (function() {
                    return {
                        restrict: "E"
                    };
                })).provider("$mdSelect", SelectProvider);
            }(), function() {
                function createDirective(name, targetValue) {
                    return [ "$mdUtil", "$window", function($mdUtil, $window) {
                        return {
                            restrict: "A",
                            multiElement: !0,
                            link: function($scope, $element, $attr) {
                                var unregister = $scope.$on("$md-resize-enable", (function() {
                                    unregister();
                                    var node = $element[0], cachedTransitionStyles = node.nodeType === $window.Node.ELEMENT_NODE ? $window.getComputedStyle(node) : {};
                                    $scope.$watch($attr[name], (function(value) {
                                        if (!!value === targetValue) {
                                            $mdUtil.nextTick((function() {
                                                $scope.$broadcast("$md-resize");
                                            }));
                                            var opts = {
                                                cachedTransitionStyles
                                            };
                                            $mdUtil.dom.animator.waitTransitionEnd($element, opts).then((function() {
                                                $scope.$broadcast("$md-resize");
                                            }));
                                        }
                                    }));
                                }));
                            }
                        };
                    } ];
                }
                angular.module("material.components.showHide", [ "material.core" ]).directive("ngShow", createDirective("ngShow", !0)).directive("ngHide", createDirective("ngHide", !1));
            }(), function() {
                function SidenavService($mdComponentRegistry, $mdUtil, $q, $log) {
                    var errorMsg = "SideNav '{0}' is not available! Did you use md-component-id='{0}'?", service = {
                        find: function(handle, shouldWait) {
                            var instance = $mdComponentRegistry.get(handle);
                            if (!instance && !shouldWait) return void $log.error($mdUtil.supplant(errorMsg, [ handle || "" ]));
                            return instance;
                        },
                        waitFor: waitForInstance
                    };
                    return function(handle, enableWait) {
                        if (angular.isUndefined(handle)) return service;
                        var shouldWait = !0 === enableWait, instance = service.find(handle, shouldWait);
                        return !instance && shouldWait ? service.waitFor(handle) : !instance && angular.isUndefined(enableWait) ? function(service, handle) {
                            var falseFn = function() {
                                return !1;
                            }, rejectFn = function() {
                                return $q.when($mdUtil.supplant(errorMsg, [ handle || "" ]));
                            };
                            return angular.extend({
                                isLockedOpen: falseFn,
                                isOpen: falseFn,
                                toggle: rejectFn,
                                open: rejectFn,
                                close: rejectFn,
                                onClose: angular.noop,
                                then: function(callback) {
                                    return waitForInstance(handle).then(callback || angular.noop);
                                }
                            }, service);
                        }(service, handle) : instance;
                    };
                    function waitForInstance(handle) {
                        return $mdComponentRegistry.when(handle).catch($log.error);
                    }
                }
                function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $mdInteraction, $animate, $compile, $parse, $log, $q, $document, $window, $$rAF) {
                    return {
                        restrict: "E",
                        scope: {
                            isOpen: "=?mdIsOpen"
                        },
                        controller: "$mdSidenavController",
                        compile: function(element) {
                            return element.addClass("md-closed").attr("tabIndex", "-1"), postLink;
                        }
                    };
                    function postLink(scope, element, attr, sidenavCtrl) {
                        var lastParentOverFlow, backdrop, disableCloseEvents, triggeringInteractionType, previousContainerStyles, disableScrollTarget = null, triggeringElement = null, promise = $q.when(!0), isLockedOpenParsed = $parse(attr.mdIsLockedOpen), ngWindow = angular.element($window);
                        function onKeyDown(ev) {
                            return ev.keyCode === $mdConstant.KEY_CODE.ESCAPE ? close(ev) : $q.when(!0);
                        }
                        function close(ev) {
                            return ev.preventDefault(), sidenavCtrl.close();
                        }
                        attr.mdDisableScrollTarget && ((disableScrollTarget = $document[0].querySelector(attr.mdDisableScrollTarget)) ? disableScrollTarget = angular.element(disableScrollTarget) : $log.warn($mdUtil.supplant('mdSidenav: couldn\'t find element matching selector "{selector}". Falling back to parent.', {
                            selector: attr.mdDisableScrollTarget
                        }))), disableScrollTarget || (disableScrollTarget = element.parent()), attr.hasOwnProperty("mdDisableBackdrop") || (backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter")), 
                        attr.hasOwnProperty("mdDisableCloseEvents") && (disableCloseEvents = !0), element.addClass("_md"), 
                        $mdTheming(element), backdrop && $mdTheming.inherit(backdrop, element), element.on("$destroy", (function() {
                            backdrop && backdrop.remove(), sidenavCtrl.destroy();
                        })), scope.$on("$destroy", (function() {
                            backdrop && backdrop.remove();
                        })), scope.$watch((function() {
                            return isLockedOpenParsed(scope.$parent, {
                                $mdMedia
                            });
                        }), (function(isLocked, oldValue) {
                            scope.isLockedOpen = isLocked, isLocked === oldValue ? element.toggleClass("md-locked-open", !!isLocked) : $animate[isLocked ? "addClass" : "removeClass"](element, "md-locked-open");
                            backdrop && backdrop.toggleClass("md-locked-open", !!isLocked);
                        })), scope.$watch("isOpen", (function(isOpen) {
                            var restorePositioning, focusEl = $mdUtil.findFocusTarget(element) || element, parent = element.parent();
                            disableCloseEvents || (parent[isOpen ? "on" : "off"]("keydown", onKeyDown), backdrop && backdrop[isOpen ? "on" : "off"]("click", close));
                            restorePositioning = function(parent, willOpen) {
                                var drawerEl = element[0], scrollTop = parent[0].scrollTop;
                                if (willOpen && scrollTop) {
                                    previousContainerStyles = {
                                        top: drawerEl.style.top,
                                        bottom: drawerEl.style.bottom,
                                        height: drawerEl.style.height
                                    };
                                    var positionStyle = {
                                        top: scrollTop + "px",
                                        bottom: "auto",
                                        height: parent[0].clientHeight + "px"
                                    };
                                    element.css(positionStyle), backdrop.css(positionStyle);
                                }
                                if (!willOpen && previousContainerStyles) return function() {
                                    drawerEl.style.top = previousContainerStyles.top, drawerEl.style.bottom = previousContainerStyles.bottom, 
                                    drawerEl.style.height = previousContainerStyles.height, backdrop[0].style.top = null, 
                                    backdrop[0].style.bottom = null, backdrop[0].style.height = null, previousContainerStyles = null;
                                };
                            }(parent, isOpen), isOpen && (triggeringElement = $document[0].activeElement, triggeringInteractionType = $mdInteraction.getLastInteractionType());
                            return function(disabled) {
                                disabled && !lastParentOverFlow ? (lastParentOverFlow = disableScrollTarget.css("overflow"), 
                                disableScrollTarget.css("overflow", "hidden")) : angular.isDefined(lastParentOverFlow) && (disableScrollTarget.css("overflow", lastParentOverFlow), 
                                lastParentOverFlow = undefined);
                            }(isOpen), promise = $q.all([ isOpen && backdrop ? $animate.enter(backdrop, parent) : backdrop ? $animate.leave(backdrop) : $q.when(!0), $animate[isOpen ? "removeClass" : "addClass"](element, "md-closed") ]).then((function() {
                                scope.isOpen && ($$rAF((function() {
                                    ngWindow.triggerHandler("resize");
                                })), focusEl && focusEl.focus()), restorePositioning && restorePositioning();
                            }));
                        })), sidenavCtrl.$toggleOpen = function(isOpen) {
                            return scope.isOpen === isOpen ? $q.when(!0) : (scope.isOpen && sidenavCtrl.onCloseCb && sidenavCtrl.onCloseCb(), 
                            $q((function(resolve) {
                                scope.isOpen = isOpen, $mdUtil.nextTick((function() {
                                    promise.then((function(result) {
                                        !scope.isOpen && triggeringElement && "keyboard" === triggeringInteractionType && (triggeringElement.focus(), 
                                        triggeringElement = null), resolve(result);
                                    }));
                                }));
                            })));
                        };
                    }
                }
                function SidenavController($scope, $attrs, $mdComponentRegistry, $q, $interpolate) {
                    var self = this;
                    self.isOpen = function() {
                        return !!$scope.isOpen;
                    }, self.isLockedOpen = function() {
                        return !!$scope.isLockedOpen;
                    }, self.onClose = function(callback) {
                        return self.onCloseCb = callback, self;
                    }, self.open = function() {
                        return self.$toggleOpen(!0);
                    }, self.close = function() {
                        return self.$toggleOpen(!1);
                    }, self.toggle = function() {
                        return self.$toggleOpen(!$scope.isOpen);
                    }, self.$toggleOpen = function(value) {
                        return $q.when($scope.isOpen = value);
                    };
                    var rawId = $attrs.mdComponentId, hasDataBinding = rawId && rawId.indexOf($interpolate.startSymbol()) > -1, componentId = hasDataBinding ? $interpolate(rawId)($scope.$parent) : rawId;
                    self.destroy = $mdComponentRegistry.register(self, componentId), hasDataBinding && $attrs.$observe("mdComponentId", (function(id) {
                        id && id !== self.$$mdHandle && (self.destroy(), self.destroy = $mdComponentRegistry.register(self, id));
                    }));
                }
                SidenavService.$inject = [ "$mdComponentRegistry", "$mdUtil", "$q", "$log" ], SidenavDirective.$inject = [ "$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$mdInteraction", "$animate", "$compile", "$parse", "$log", "$q", "$document", "$window", "$$rAF" ], 
                SidenavController.$inject = [ "$scope", "$attrs", "$mdComponentRegistry", "$q", "$interpolate" ], 
                angular.module("material.components.sidenav", [ "material.core", "material.components.backdrop" ]).factory("$mdSidenav", SidenavService).directive("mdSidenav", SidenavDirective).controller("$mdSidenavController", SidenavController);
            }(), function() {
                SliderDirective.$inject = [ "$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log", "$timeout" ], 
                angular.module("material.components.slider", [ "material.core" ]).directive("mdSlider", SliderDirective).directive("mdSliderContainer", (function() {
                    return {
                        controller: function() {},
                        compile: function(elem) {
                            var slider = elem.find("md-slider");
                            if (slider) return undefined !== slider.attr("md-vertical") && elem.attr("md-vertical", ""), 
                            slider.attr("flex") || slider.attr("flex", ""), function(scope, element, attr, ctrl) {
                                function setDisable(value) {
                                    element.children().attr("disabled", value), element.find("input").attr("disabled", value);
                                }
                                element.addClass("_md");
                                var initialMaxWidth, stopDisabledWatch = angular.noop;
                                attr.disabled ? setDisable(!0) : attr.ngDisabled && (stopDisabledWatch = scope.$watch(attr.ngDisabled, (function(value) {
                                    setDisable(value);
                                }))), scope.$on("$destroy", (function() {
                                    stopDisabledWatch();
                                })), ctrl.fitInputWidthToTextLength = function(length) {
                                    var input = element[0].querySelector("md-input-container");
                                    if (input) {
                                        var computedStyle = getComputedStyle(input), minWidth = parseInt(computedStyle.minWidth), padding = parseInt(computedStyle.paddingLeft) + parseInt(computedStyle.paddingRight);
                                        initialMaxWidth = initialMaxWidth || parseInt(computedStyle.maxWidth);
                                        var newMaxWidth = Math.max(initialMaxWidth, minWidth + padding + minWidth / 2 * length);
                                        input.style.maxWidth = newMaxWidth + "px";
                                    }
                                };
                            };
                        }
                    };
                }));
                var stepPageSize = 10, modifierMultiplier = 4;
                function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log, $timeout) {
                    return {
                        scope: {},
                        require: [ "?ngModel", "?^mdSliderContainer" ],
                        template: '<div class="md-slider-wrapper"><div class="md-slider-content"><div class="md-track-container"><div class="md-track"></div><div class="md-track md-track-fill"></div><div class="md-track-ticks"></div></div><div class="md-thumb-container"><div class="md-thumb"></div><div class="md-focus-thumb"></div><div class="md-focus-ring"></div><div class="md-sign"><span class="md-thumb-text"></span></div><div class="md-disabled-thumb"></div></div></div></div>',
                        compile: function(tElement, tAttrs) {
                            var wrapper = angular.element(tElement[0].getElementsByClassName("md-slider-wrapper")), tabIndex = tAttrs.tabindex || 0;
                            wrapper.attr("tabindex", tabIndex), (tAttrs.disabled || tAttrs.ngDisabled) && wrapper.attr("tabindex", -1);
                            return wrapper.attr("role", "slider"), $mdAria.expect(tElement, "aria-label"), postLink;
                        }
                    };
                    function postLink(scope, element, attr, ctrls) {
                        $mdTheming(element);
                        var ngModelCtrl = ctrls[0] || {
                            $setViewValue: function(val) {
                                this.$viewValue = val, this.$viewChangeListeners.forEach((function(cb) {
                                    cb();
                                }));
                            },
                            $parsers: [],
                            $formatters: [],
                            $viewChangeListeners: []
                        }, containerCtrl = ctrls[1], isDisabled = (angular.element($mdUtil.getClosest(element, "_md-slider-container", !0)), 
                        attr.ngDisabled ? angular.bind(null, $parse(attr.ngDisabled), scope.$parent) : function() {
                            return element[0].hasAttribute("disabled");
                        }), thumb = angular.element(element[0].querySelector(".md-thumb")), thumbText = angular.element(element[0].querySelector(".md-thumb-text")), thumbContainer = thumb.parent(), trackContainer = angular.element(element[0].querySelector(".md-track-container")), activeTrack = angular.element(element[0].querySelector(".md-track-fill")), tickContainer = angular.element(element[0].querySelector(".md-track-ticks")), wrapper = angular.element(element[0].getElementsByClassName("md-slider-wrapper")), throttledRefreshDimensions = (angular.element(element[0].getElementsByClassName("md-slider-content")), 
                        $mdUtil.throttle(refreshSliderDimensions, 5e3)), vertical = angular.isDefined(attr.mdVertical), discrete = angular.isDefined(attr.mdDiscrete), invert = angular.isDefined(attr.mdInvert);
                        angular.isDefined(attr.min) ? attr.$observe("min", updateMin) : updateMin(0), angular.isDefined(attr.max) ? attr.$observe("max", updateMax) : updateMax(100), 
                        angular.isDefined(attr.step) ? attr.$observe("step", updateStep) : updateStep(1), 
                        angular.isDefined(attr.round) ? attr.$observe("round", updateRound) : updateRound(3);
                        angular.noop;
                        function updateAll() {
                            refreshSliderDimensions(), ngModelRender();
                        }
                        attr.ngDisabled && scope.$parent.$watch(attr.ngDisabled, (function() {
                            element.attr("aria-disabled", !!isDisabled());
                        })), $mdGesture.register(wrapper, "drag", {
                            horizontal: !vertical
                        }), scope.mouseActive = !1, wrapper.on("keydown", (function(ev) {
                            if (isDisabled()) return;
                            var changeAmount, keyCodes = $mdConstant.KEY_CODE;
                            switch (ev.keyCode) {
                              case keyCodes.DOWN_ARROW:
                              case keyCodes.LEFT_ARROW:
                                ev.preventDefault(), changeAmount = -step;
                                break;

                              case keyCodes.UP_ARROW:
                              case keyCodes.RIGHT_ARROW:
                                ev.preventDefault(), changeAmount = step;
                                break;

                              case keyCodes.PAGE_DOWN:
                                ev.preventDefault(), changeAmount = -step * stepPageSize;
                                break;

                              case keyCodes.PAGE_UP:
                                ev.preventDefault(), changeAmount = step * stepPageSize;
                                break;

                              case keyCodes.HOME:
                                ev.preventDefault(), ev.stopPropagation(), updateValue(min);
                                break;

                              case keyCodes.END:
                                ev.preventDefault(), ev.stopPropagation(), updateValue(max);
                            }
                            changeAmount && (changeAmount = invert ? -changeAmount : changeAmount, (ev.metaKey || ev.ctrlKey || ev.altKey) && (changeAmount *= modifierMultiplier), 
                            ev.preventDefault(), ev.stopPropagation(), updateValue(ngModelCtrl.$viewValue + changeAmount));
                        })).on("mousedown", (function() {
                            (function() {
                                if (!discrete || isDisabled()) return;
                                if (angular.isUndefined(step)) return;
                                if (step <= 0) {
                                    var msg = "Slider step value must be greater than zero when in discrete mode";
                                    throw $log.error(msg), new Error(msg);
                                }
                                var numSteps = Math.floor((max - min) / step);
                                tickCanvas || (tickCanvas = angular.element("<canvas>").css("position", "absolute"), 
                                tickContainer.append(tickCanvas), tickCtx = tickCanvas[0].getContext("2d"));
                                var distance, dimensions = getSliderDimensions();
                                !dimensions || dimensions.height || dimensions.width || (refreshSliderDimensions(), 
                                dimensions = sliderDimensions);
                                tickCanvas[0].width = dimensions.width, tickCanvas[0].height = dimensions.height;
                                for (var i = 0; i <= numSteps; i++) {
                                    var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                                    tickCtx.fillStyle = trackTicksStyle.color || "black", distance = Math.floor((vertical ? dimensions.height : dimensions.width) * (i / numSteps)), 
                                    tickCtx.fillRect(vertical ? 0 : distance - 1, vertical ? distance - 1 : 0, vertical ? dimensions.width : 2, vertical ? 2 : dimensions.height);
                                }
                            })(), scope.mouseActive = !0, wrapper.removeClass("md-focused"), $timeout((function() {
                                scope.mouseActive = !1;
                            }), 100);
                        })).on("focus", (function() {
                            !1 === scope.mouseActive && wrapper.addClass("md-focused");
                        })).on("blur", (function() {
                            wrapper.removeClass("md-focused"), element.removeClass("md-active"), function() {
                                if (tickCanvas && tickCtx) {
                                    var dimensions = getSliderDimensions();
                                    tickCtx.clearRect(0, 0, dimensions.width, dimensions.height);
                                }
                            }();
                        })).on("$md.pressdown", (function(ev) {
                            if (isDisabled()) return;
                            element.addClass("md-active"), element[0].focus(), refreshSliderDimensions();
                            var closestVal = minMaxValidator(stepValidator(percentToValue(positionToPercent(vertical ? ev.srcEvent.clientY : ev.srcEvent.clientX))));
                            scope.$apply((function() {
                                setModelValue(closestVal), setSliderPercent(valueToPercent(closestVal));
                            }));
                        })).on("$md.pressup", (function(ev) {
                            if (isDisabled()) return;
                            element.removeClass("md-dragging");
                            var closestVal = minMaxValidator(stepValidator(percentToValue(positionToPercent(vertical ? ev.srcEvent.clientY : ev.srcEvent.clientX))));
                            scope.$apply((function() {
                                setModelValue(closestVal), ngModelRender();
                            }));
                        })).on("$md.dragstart", (function(ev) {
                            if (isDisabled()) return;
                            isDragging = !0, ev.stopPropagation(), element.addClass("md-dragging"), setSliderFromEvent(ev);
                        })).on("$md.drag", (function(ev) {
                            if (!isDragging) return;
                            ev.stopPropagation(), setSliderFromEvent(ev);
                        })).on("$md.dragend", (function(ev) {
                            if (!isDragging) return;
                            ev.stopPropagation(), isDragging = !1;
                        })), setTimeout(updateAll, 0);
                        var min, max, step, round, tickCanvas, tickCtx, debouncedUpdateAll = $$rAF.throttle(updateAll);
                        function updateMin(value) {
                            min = parseFloat(value), ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$modelValue, min, max), 
                            wrapper.attr("aria-valuemin", value), updateAll();
                        }
                        function updateMax(value) {
                            max = parseFloat(value), ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$modelValue, min, max), 
                            wrapper.attr("aria-valuemax", value), updateAll();
                        }
                        function updateStep(value) {
                            step = parseFloat(value);
                        }
                        function updateRound(value) {
                            round = minMaxValidator(parseInt(value), 0, 6);
                        }
                        angular.element($window).on("resize", debouncedUpdateAll), scope.$on("$destroy", (function() {
                            angular.element($window).off("resize", debouncedUpdateAll);
                        })), ngModelCtrl.$render = ngModelRender, ngModelCtrl.$viewChangeListeners.push(ngModelRender), 
                        ngModelCtrl.$formatters.push(minMaxValidator), ngModelCtrl.$formatters.push(stepValidator);
                        var sliderDimensions = {};
                        function refreshSliderDimensions() {
                            sliderDimensions = trackContainer[0].getBoundingClientRect();
                        }
                        function getSliderDimensions() {
                            return throttledRefreshDimensions(), sliderDimensions;
                        }
                        function updateValue(value) {
                            scope.$evalAsync((function() {
                                setModelValue(value);
                            }));
                        }
                        function setModelValue(value) {
                            ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
                        }
                        function ngModelRender() {
                            isNaN(ngModelCtrl.$viewValue) && (ngModelCtrl.$viewValue = ngModelCtrl.$modelValue), 
                            ngModelCtrl.$viewValue = minMaxValidator(ngModelCtrl.$viewValue);
                            var percent = valueToPercent(ngModelCtrl.$viewValue);
                            scope.modelValue = ngModelCtrl.$viewValue, wrapper.attr("aria-valuenow", ngModelCtrl.$viewValue), 
                            setSliderPercent(percent), thumbText.text(ngModelCtrl.$viewValue);
                        }
                        function minMaxValidator(value, minValue, maxValue) {
                            if (angular.isNumber(value)) return minValue = angular.isNumber(minValue) ? minValue : min, 
                            maxValue = angular.isNumber(maxValue) ? maxValue : max, Math.max(minValue, Math.min(maxValue, value));
                        }
                        function stepValidator(value) {
                            if (angular.isNumber(value)) {
                                var formattedValue = Math.round((value - min) / step) * step + min;
                                return formattedValue = Math.round(formattedValue * Math.pow(10, round)) / Math.pow(10, round), 
                                containerCtrl && containerCtrl.fitInputWidthToTextLength && $mdUtil.debounce((function() {
                                    containerCtrl.fitInputWidthToTextLength(formattedValue.toString().length);
                                }), 100)(), formattedValue;
                            }
                        }
                        function setSliderPercent(percent) {
                            var value;
                            value = percent;
                            var thumbPosition = 100 * (percent = Math.max(0, Math.min(value || 0, 1))) + "%", activeTrackPercent = invert ? 100 * (1 - percent) + "%" : thumbPosition;
                            vertical ? thumbContainer.css("bottom", thumbPosition) : $mdUtil.bidiProperty(thumbContainer, "left", "right", thumbPosition), 
                            activeTrack.css(vertical ? "height" : "width", activeTrackPercent), element.toggleClass(invert ? "md-max" : "md-min", 0 === percent), 
                            element.toggleClass(invert ? "md-min" : "md-max", 1 === percent);
                        }
                        refreshSliderDimensions();
                        var isDragging = !1;
                        function setSliderFromEvent(ev) {
                            var x, closestVal;
                            discrete ? (x = vertical ? ev.srcEvent.clientY : ev.srcEvent.clientX, closestVal = minMaxValidator(stepValidator(percentToValue(positionToPercent(x)))), 
                            setSliderPercent(positionToPercent(x)), thumbText.text(closestVal)) : function(x) {
                                scope.$evalAsync((function() {
                                    setModelValue(percentToValue(positionToPercent(x)));
                                }));
                            }(vertical ? ev.srcEvent.clientY : ev.srcEvent.clientX);
                        }
                        function positionToPercent(position) {
                            var calc = (position - (vertical ? sliderDimensions.top : sliderDimensions.left)) / (vertical ? sliderDimensions.height : sliderDimensions.width);
                            return !vertical && $mdUtil.isRtl(attr) && (calc = 1 - calc), Math.max(0, Math.min(1, vertical ? 1 - calc : calc));
                        }
                        function percentToValue(percent) {
                            return min + (invert ? 1 - percent : percent) * (max - min);
                        }
                        function valueToPercent(val) {
                            var percent = (val - min) / (max - min);
                            return invert ? 1 - percent : percent;
                        }
                    }
                }
            }(), function() {
                function MdSticky($mdConstant, $$rAF, $mdUtil, $compile) {
                    var browserStickySupport = $mdUtil.checkStickySupport();
                    return function(scope, element, stickyClone) {
                        var contentCtrl = element.controller("mdContent");
                        if (contentCtrl) if (browserStickySupport) element.css({
                            position: browserStickySupport,
                            top: 0,
                            "z-index": 2
                        }); else {
                            var $$sticky = contentCtrl.$element.data("$$sticky");
                            $$sticky || ($$sticky = function(contentCtrl) {
                                var self, contentEl = contentCtrl.$element, debouncedRefreshElements = $$rAF.throttle(refreshElements);
                                return function(element) {
                                    var isScrolling, lastScrollTime, SCROLL_END_DELAY = 200;
                                    function loopScrollEvent() {
                                        +$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY ? (isScrolling = !1, element.triggerHandler("$scrollend")) : (element.triggerHandler("$scroll"), 
                                        $$rAF.throttle(loopScrollEvent));
                                    }
                                    element.on("scroll touchmove", (function() {
                                        isScrolling || (isScrolling = !0, $$rAF.throttle(loopScrollEvent), element.triggerHandler("$scrollstart")), 
                                        element.triggerHandler("$scroll"), lastScrollTime = +$mdUtil.now();
                                    }));
                                }(contentEl), contentEl.on("$scrollstart", debouncedRefreshElements), contentEl.on("$scroll", onScroll), 
                                self = {
                                    prev: null,
                                    current: null,
                                    next: null,
                                    items: [],
                                    add,
                                    refreshElements
                                };
                                function add(element, stickyClone) {
                                    stickyClone.addClass("md-sticky-clone");
                                    var item = {
                                        element,
                                        clone: stickyClone
                                    };
                                    return self.items.push(item), $mdUtil.nextTick((function() {
                                        contentEl.prepend(item.clone);
                                    })), debouncedRefreshElements(), function() {
                                        self.items.forEach((function(item, index) {
                                            item.element[0] === element[0] && (self.items.splice(index, 1), item.clone.remove());
                                        })), debouncedRefreshElements();
                                    };
                                }
                                function refreshElements() {
                                    var item;
                                    self.items.forEach(refreshPosition), self.items = self.items.sort((function(a, b) {
                                        return a.top < b.top ? -1 : 1;
                                    }));
                                    for (var currentScrollTop = contentEl.prop("scrollTop"), i = self.items.length - 1; i >= 0; i--) if (currentScrollTop > self.items[i].top) {
                                        item = self.items[i];
                                        break;
                                    }
                                    setCurrentItem(item);
                                }
                                function refreshPosition(item) {
                                    var current = item.element[0];
                                    for (item.top = 0, item.left = 0, item.right = 0; current && current !== contentEl[0]; ) item.top += current.offsetTop, 
                                    item.left += current.offsetLeft, current.offsetParent && (item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft), 
                                    current = current.offsetParent;
                                    item.height = item.element.prop("offsetHeight");
                                    var defaultVal = $mdUtil.floatingScrollbars() ? "0" : undefined;
                                    $mdUtil.bidi(item.clone, "margin-left", item.left, defaultVal), $mdUtil.bidi(item.clone, "margin-right", defaultVal, item.right);
                                }
                                function onScroll() {
                                    var scrollTop = contentEl.prop("scrollTop"), isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
                                    if (onScroll.prevScrollTop = scrollTop, 0 !== scrollTop) {
                                        if (isScrollingDown) {
                                            if (self.next && self.next.top <= scrollTop) return void setCurrentItem(self.next);
                                            if (self.current && self.next && self.next.top - scrollTop <= self.next.height) return void translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
                                        }
                                        if (!isScrollingDown) {
                                            if (self.current && self.prev && scrollTop < self.current.top) return void setCurrentItem(self.prev);
                                            if (self.next && self.current && scrollTop >= self.next.top - self.current.height) return void translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
                                        }
                                        self.current && translate(self.current, scrollTop);
                                    } else setCurrentItem(null);
                                }
                                function setCurrentItem(item) {
                                    if (self.current !== item) {
                                        self.current && (translate(self.current, null), setStickyState(self.current, null)), 
                                        item && setStickyState(item, "active"), self.current = item;
                                        var index = self.items.indexOf(item);
                                        self.next = self.items[index + 1], self.prev = self.items[index - 1], setStickyState(self.next, "next"), 
                                        setStickyState(self.prev, "prev");
                                    }
                                }
                                function setStickyState(item, state) {
                                    item && item.state !== state && (item.state && (item.clone.attr("sticky-prev-state", item.state), 
                                    item.element.attr("sticky-prev-state", item.state)), item.clone.attr("sticky-state", state), 
                                    item.element.attr("sticky-state", state), item.state = state);
                                }
                                function translate(item, amount) {
                                    item && (null == amount ? item.translateY && (item.translateY = null, item.clone.css($mdConstant.CSS.TRANSFORM, "")) : (item.translateY = amount, 
                                    $mdUtil.bidi(item.clone, $mdConstant.CSS.TRANSFORM, "translate3d(" + item.left + "px," + amount + "px,0)", "translateY(" + amount + "px)")));
                                }
                            }(contentCtrl), contentCtrl.$element.data("$$sticky", $$sticky));
                            var cloneElement = stickyClone || $compile(element.clone())(scope), deregister = $$sticky.add(element, cloneElement);
                            scope.$on("$destroy", deregister);
                        }
                    };
                }
                MdSticky.$inject = [ "$mdConstant", "$$rAF", "$mdUtil", "$compile" ], angular.module("material.components.sticky", [ "material.core", "material.components.content" ]).factory("$mdSticky", MdSticky);
            }(), function() {
                function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil, $mdAria) {
                    return {
                        restrict: "E",
                        replace: !0,
                        transclude: !0,
                        template: '<div class="md-subheader _md">  <div class="md-subheader-inner">    <div class="md-subheader-content"></div>  </div></div>',
                        link: function(scope, element, attr, controllers, transclude) {
                            $mdTheming(element), element.addClass("_md"), $mdUtil.prefixer().removeAttribute(element, "ng-repeat");
                            var outerHTML = element[0].outerHTML;
                            function getContent(el) {
                                return angular.element(el[0].querySelector(".md-subheader-content"));
                            }
                            attr.$set("role", "heading"), $mdAria.expect(element, "aria-level", "2"), transclude(scope, (function(clone) {
                                getContent(element).append(clone);
                            })), element.hasClass("md-no-sticky") || transclude(scope, (function(clone) {
                                var wrapper = $compile('<div class="md-subheader-wrapper" aria-hidden="true">' + outerHTML + "</div>")(scope);
                                $mdUtil.nextTick((function() {
                                    getContent(wrapper).append(clone);
                                })), $mdSticky(scope, element, wrapper);
                            }));
                        }
                    };
                }
                MdSubheaderDirective.$inject = [ "$mdSticky", "$compile", "$mdTheming", "$mdUtil", "$mdAria" ], 
                angular.module("material.components.subheader", [ "material.core", "material.components.sticky" ]).directive("mdSubheader", MdSubheaderDirective);
            }(), function() {
                function getDirective(name) {
                    DirectiveFactory.$inject = [ "$parse" ];
                    var directiveName = "md" + name, eventName = "$md." + name.toLowerCase();
                    return DirectiveFactory;
                    function DirectiveFactory($parse) {
                        return {
                            restrict: "A",
                            link: function(scope, element, attr) {
                                var fn = $parse(attr[directiveName]);
                                element.on(eventName, (function(ev) {
                                    var currentTarget = ev.currentTarget;
                                    scope.$applyAsync((function() {
                                        fn(scope, {
                                            $event: ev,
                                            $target: {
                                                current: currentTarget
                                            }
                                        });
                                    }));
                                }));
                            }
                        };
                    }
                }
                angular.module("material.components.swipe", [ "material.core" ]).directive("mdSwipeLeft", getDirective("SwipeLeft")).directive("mdSwipeRight", getDirective("SwipeRight")).directive("mdSwipeUp", getDirective("SwipeUp")).directive("mdSwipeDown", getDirective("SwipeDown"));
            }(), function() {
                function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture, $timeout) {
                    var checkboxDirective = mdCheckboxDirective[0];
                    return {
                        restrict: "E",
                        priority: $mdConstant.BEFORE_NG_ARIA,
                        transclude: !0,
                        template: '<div class="md-container"><div class="md-bar"></div><div class="md-thumb-container"><div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div></div></div><div ng-transclude class="md-label"></div>',
                        require: [ "^?mdInputContainer", "?ngModel", "?^form" ],
                        compile: function(element, attr) {
                            var checkboxLink = checkboxDirective.compile(element, attr).post;
                            return element.addClass("md-dragging"), function(scope, element, attr, ctrls) {
                                ctrls[0];
                                var ngModel = ctrls[1] || $mdUtil.fakeNgModel(), disabledGetter = (ctrls[2], null);
                                null != attr.disabled ? disabledGetter = function() {
                                    return !0;
                                } : attr.ngDisabled && (disabledGetter = $parse(attr.ngDisabled));
                                var drag, thumbContainer = angular.element(element[0].querySelector(".md-thumb-container")), switchContainer = angular.element(element[0].querySelector(".md-container")), labelContainer = angular.element(element[0].querySelector(".md-label"));
                                $$rAF((function() {
                                    element.removeClass("md-dragging");
                                })), checkboxLink(scope, element, attr, ctrls), disabledGetter && scope.$watch(disabledGetter, (function(isDisabled) {
                                    element.attr("tabindex", isDisabled ? -1 : 0);
                                })), attr.$observe("mdInvert", (function(newValue) {
                                    var isInverted = $mdUtil.parseAttributeBoolean(newValue);
                                    isInverted ? element.prepend(labelContainer) : element.prepend(switchContainer), 
                                    element.toggleClass("md-inverted", isInverted);
                                })), $mdGesture.register(switchContainer, "drag"), switchContainer.on("$md.dragstart", (function(ev) {
                                    if (disabledGetter && disabledGetter(scope)) return;
                                    ev.stopPropagation(), element.addClass("md-dragging"), drag = {
                                        width: thumbContainer.prop("offsetWidth")
                                    };
                                })).on("$md.drag", (function(ev) {
                                    if (!drag) return;
                                    ev.stopPropagation(), ev.srcEvent && ev.srcEvent.preventDefault();
                                    var percent = ev.pointer.distanceX / drag.width, translate = ngModel.$viewValue ? 1 + percent : percent;
                                    translate = Math.max(0, Math.min(1, translate)), thumbContainer.css($mdConstant.CSS.TRANSFORM, "translate3d(" + 100 * translate + "%,0,0)"), 
                                    drag.translate = translate;
                                })).on("$md.dragend", (function(ev) {
                                    if (!drag) return;
                                    ev.stopPropagation(), element.removeClass("md-dragging"), thumbContainer.css($mdConstant.CSS.TRANSFORM, ""), 
                                    (ngModel.$viewValue ? drag.translate < .5 : drag.translate > .5) && (newValue = !ngModel.$viewValue, 
                                    scope.$apply((function() {
                                        ngModel.$setViewValue(newValue), ngModel.$render();
                                    })));
                                    var newValue;
                                    drag = null, scope.skipToggle = !0, $timeout((function() {
                                        scope.skipToggle = !1;
                                    }), 1);
                                }));
                            };
                        }
                    };
                }
                MdSwitch.$inject = [ "mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture", "$timeout" ], 
                angular.module("material.components.switch", [ "material.core", "material.components.checkbox" ]).directive("mdSwitch", MdSwitch);
            }(), angular.module("material.components.tabs", [ "material.core", "material.components.icon" ]), 
            angular.module("material.components.tabs").service("MdTabsPaginationService", (function() {
                return {
                    decreasePageOffset: function(elements, currentOffset) {
                        var i, firstVisibleTabOffset, canvas = elements.canvas, tabOffsets = getTabOffsets(elements);
                        for (i = 0; i < tabOffsets.length; i++) if (tabOffsets[i] >= currentOffset) {
                            firstVisibleTabOffset = tabOffsets[i];
                            break;
                        }
                        return Math.max(0, firstVisibleTabOffset - canvas.clientWidth);
                    },
                    increasePageOffset: function(elements, currentOffset) {
                        var i, firstHiddenTabOffset, canvas = elements.canvas, maxOffset = getTotalTabsWidth(elements) - canvas.clientWidth, tabOffsets = getTabOffsets(elements);
                        for (i = 0; tabOffsets.length, tabOffsets[i] <= currentOffset + canvas.clientWidth; i++) firstHiddenTabOffset = tabOffsets[i];
                        return Math.min(maxOffset, firstHiddenTabOffset);
                    },
                    getTabOffsets,
                    getTotalTabsWidth
                };
                function getTabOffsets(elements) {
                    var i, tab, currentOffset = 0, offsets = [];
                    for (i = 0; i < elements.tabs.length; i++) tab = elements.tabs[i], offsets.push(currentOffset), 
                    currentOffset += tab.offsetWidth;
                    return offsets;
                }
                function getTotalTabsWidth(elements) {
                    var i, sum = 0;
                    for (i = 0; i < elements.tabs.length; i++) sum += elements.tabs[i].offsetWidth;
                    return sum;
                }
            })), angular.module("material.components.tabs").directive("mdTab", (function() {
                return {
                    require: "^?mdTabs",
                    terminal: !0,
                    compile: function(element, attr) {
                        var label = firstChild(element, "md-tab-label"), body = firstChild(element, "md-tab-body");
                        if (0 === label.length && (label = angular.element("<md-tab-label></md-tab-label>"), 
                        attr.label ? label.text(attr.label) : label.append(element.contents()), 0 === body.length)) {
                            var contents = element.contents().detach();
                            (body = angular.element("<md-tab-body></md-tab-body>")).append(contents);
                        }
                        return element.append(label), body.html() && element.append(body), postLink;
                    },
                    scope: {
                        active: "=?mdActive",
                        disabled: "=?ngDisabled",
                        select: "&?mdOnSelect",
                        deselect: "&?mdOnDeselect",
                        tabClass: "@mdTabClass"
                    }
                };
                function postLink(scope, element, attr, ctrl) {
                    if (ctrl) {
                        var index = ctrl.getTabElementIndex(element), body = firstChild(element, "md-tab-body").remove(), label = firstChild(element, "md-tab-label").remove(), data = ctrl.insertTab({
                            scope,
                            parent: scope.$parent,
                            index,
                            element,
                            template: body.html(),
                            label: label.html()
                        }, index);
                        scope.select = scope.select || angular.noop, scope.deselect = scope.deselect || angular.noop, 
                        scope.$watch("active", (function(active) {
                            active && ctrl.select(data.getIndex(), !0);
                        })), scope.$watch("disabled", (function() {
                            ctrl.refreshIndex();
                        })), scope.$watch((function() {
                            return ctrl.getTabElementIndex(element);
                        }), (function(newIndex) {
                            data.index = newIndex, ctrl.updateTabOrder();
                        })), scope.$on("$destroy", (function() {
                            ctrl.removeTab(data);
                        }));
                    }
                }
                function firstChild(element, tagName) {
                    for (var children = element[0].children, i = 0, len = children.length; i < len; i++) {
                        var child = children[i];
                        if (child.tagName === tagName.toUpperCase()) return angular.element(child);
                    }
                    return angular.element();
                }
            })), angular.module("material.components.tabs").directive("mdTabItem", (function() {
                return {
                    require: "^?mdTabs",
                    link: function(scope, element, attr, ctrl) {
                        ctrl && ctrl.attachRipple(scope, element);
                    }
                };
            })), angular.module("material.components.tabs").directive("mdTabLabel", (function() {
                return {
                    terminal: !0
                };
            })), function() {
                function MdTabScroll($parse) {
                    return {
                        restrict: "A",
                        compile: function($element, attr) {
                            var fn = $parse(attr.mdTabScroll, null, !0);
                            return function(scope, element) {
                                element.on("wheel", (function(event) {
                                    scope.$apply((function() {
                                        fn(scope, {
                                            $event: event
                                        });
                                    }));
                                }));
                            };
                        }
                    };
                }
                MdTabScroll.$inject = [ "$parse" ], angular.module("material.components.tabs").directive("mdTabScroll", MdTabScroll);
            }(), function() {
                function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming, $mdInteraction, $timeout, MdTabsPaginationService) {
                    var ctrl = this, locked = !1, queue = [], destroyed = !1, loaded = !1;
                    function defineBooleanAttribute(key, handler) {
                        var attr = $attrs.$normalize("md-" + key);
                        function updateValue(newValue) {
                            ctrl[key] = "false" !== newValue;
                        }
                        handler && defineProperty(key, handler, undefined), $attrs.hasOwnProperty(attr) && updateValue($attrs[attr]), 
                        $attrs.$observe(attr, updateValue);
                    }
                    function cleanup() {
                        destroyed = !0, angular.element($window).off("resize", handleWindowResize);
                    }
                    function handleStretchTabs() {
                        var elements = getElements();
                        angular.element(elements.wrapper).toggleClass("md-stretch-tabs", function() {
                            switch (ctrl.stretchTabs) {
                              case "always":
                                return !0;

                              case "never":
                                return !1;

                              default:
                                return !ctrl.shouldPaginate && $window.matchMedia("(max-width: 600px)").matches;
                            }
                        }()), updateInkBarStyles();
                    }
                    function handleCenterTabs() {
                        ctrl.shouldCenterTabs = shouldCenterTabs();
                    }
                    function handleMaxTabWidth(newWidth, oldWidth) {
                        if (newWidth !== oldWidth) {
                            var elements = getElements();
                            angular.forEach(elements.tabs, (function(tab) {
                                tab.style.maxWidth = newWidth + "px";
                            })), angular.forEach(elements.dummies, (function(tab) {
                                tab.style.maxWidth = newWidth + "px";
                            })), $mdUtil.nextTick(ctrl.updateInkBarStyles);
                        }
                    }
                    function handleShouldPaginate(newValue, oldValue) {
                        newValue !== oldValue && (ctrl.maxTabWidth = getMaxTabWidth(), ctrl.shouldCenterTabs = shouldCenterTabs(), 
                        $mdUtil.nextTick((function() {
                            ctrl.maxTabWidth = getMaxTabWidth(), adjustOffset(ctrl.selectedIndex);
                        })));
                    }
                    function handleHasContent(hasContent) {
                        $element[hasContent ? "removeClass" : "addClass"]("md-no-tab-content");
                    }
                    function handleOffsetChange(left) {
                        var newValue = (ctrl.shouldCenterTabs || isRtl() ? "" : "-") + left + "px";
                        newValue = newValue.replace("--", ""), angular.element(getElements().paging).css($mdConstant.CSS.TRANSFORM, "translate(" + newValue + ", 0)"), 
                        $scope.$broadcast("$mdTabsPaginationChanged");
                    }
                    function handleFocusIndexChange(newIndex, oldIndex) {
                        newIndex !== oldIndex && getElements().tabs[newIndex] && (adjustOffset(), redirectFocus());
                    }
                    function handleSelectedIndexChange(newValue, oldValue) {
                        newValue !== oldValue && (ctrl.selectedIndex = getNearestSafeIndex(newValue), ctrl.lastSelectedIndex = oldValue, 
                        ctrl.updateInkBarStyles(), updateHeightFromContent(), adjustOffset(newValue), $scope.$broadcast("$mdTabsChanged"), 
                        ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect(), ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select());
                    }
                    function handleResizeWhenVisible() {
                        handleResizeWhenVisible.watcher || (handleResizeWhenVisible.watcher = $scope.$watch((function() {
                            $mdUtil.nextTick((function() {
                                handleResizeWhenVisible.watcher && $element.prop("offsetParent") && (handleResizeWhenVisible.watcher(), 
                                handleResizeWhenVisible.watcher = null, handleWindowResize());
                            }), !1);
                        })));
                    }
                    function select(index, canSkipClick) {
                        locked || (ctrl.focusIndex = ctrl.selectedIndex = index), canSkipClick && ctrl.noSelectClick || $mdUtil.nextTick((function() {
                            ctrl.tabs[index].element.triggerHandler("click");
                        }), !1);
                    }
                    function handleWindowResize() {
                        ctrl.lastSelectedIndex = ctrl.selectedIndex, ctrl.offsetLeft = fixOffset(ctrl.offsetLeft), 
                        $mdUtil.nextTick((function() {
                            ctrl.updateInkBarStyles(), updatePagination();
                        }));
                    }
                    function handleInkBar(hide) {
                        angular.element(getElements().inkBar).toggleClass("ng-hide", hide);
                    }
                    function handleDynamicHeight(value) {
                        $element.toggleClass("md-dynamic-height", value);
                    }
                    function getElements() {
                        var elements = {}, node = $element[0];
                        return elements.wrapper = node.querySelector("md-tabs-wrapper"), elements.canvas = elements.wrapper.querySelector("md-tabs-canvas"), 
                        elements.paging = elements.canvas.querySelector("md-pagination-wrapper"), elements.inkBar = elements.paging.querySelector("md-ink-bar"), 
                        elements.nextButton = node.querySelector("md-next-button"), elements.prevButton = node.querySelector("md-prev-button"), 
                        elements.contents = node.querySelectorAll("md-tabs-content-wrapper > md-tab-content"), 
                        elements.tabs = elements.paging.querySelectorAll("md-tab-item"), elements.dummies = elements.canvas.querySelectorAll("md-dummy-tab"), 
                        elements;
                    }
                    function shouldCenterTabs() {
                        return ctrl.centerTabs && !ctrl.shouldPaginate;
                    }
                    function getNearestSafeIndex(newIndex) {
                        if (-1 === newIndex) return -1;
                        var i, tab, maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex);
                        for (i = 0; i <= maxOffset; i++) {
                            if ((tab = ctrl.tabs[newIndex + i]) && !0 !== tab.scope.disabled) return tab.getIndex();
                            if ((tab = ctrl.tabs[newIndex - i]) && !0 !== tab.scope.disabled) return tab.getIndex();
                        }
                        return newIndex;
                    }
                    function defineProperty(key, handler, value) {
                        Object.defineProperty(ctrl, key, {
                            get: function() {
                                return value;
                            },
                            set: function(newValue) {
                                var oldValue = value;
                                value = newValue, handler && handler(newValue, oldValue);
                            }
                        });
                    }
                    function updatePagination() {
                        ctrl.maxTabWidth = getMaxTabWidth(), ctrl.shouldPaginate = function() {
                            var shouldPaginate;
                            if (ctrl.noPagination || !loaded) return !1;
                            var canvasWidth = $element.prop("clientWidth");
                            return angular.forEach(getElements().tabs, (function(tab) {
                                canvasWidth -= tab.offsetWidth;
                            })), shouldPaginate = canvasWidth < 0, $mdUtil.msie && (getElements().paging.style.width = shouldPaginate ? "999999px" : void 0), 
                            shouldPaginate;
                        }();
                    }
                    function calcTabsWidth(tabs) {
                        var width = 0;
                        return angular.forEach(tabs, (function(tab) {
                            width += Math.max(tab.offsetWidth, tab.getBoundingClientRect().width);
                        })), Math.ceil(width);
                    }
                    function getMaxTabWidth() {
                        var containerWidth = getElements().canvas.clientWidth;
                        return Math.max(0, Math.min(containerWidth - 1, 264));
                    }
                    function incrementIndex(inc, focus) {
                        var newIndex, key = focus ? "focusIndex" : "selectedIndex", index = ctrl[key];
                        for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) ;
                        newIndex = (index + inc + ctrl.tabs.length) % ctrl.tabs.length, ctrl.tabs[newIndex] && (ctrl[key] = newIndex);
                    }
                    function redirectFocus() {
                        ctrl.styleTabItemFocus = "keyboard" === $mdInteraction.getLastInteractionType();
                        var tabToFocus = getElements().tabs[ctrl.focusIndex];
                        tabToFocus && tabToFocus.focus();
                    }
                    function adjustOffset(index) {
                        var elements = getElements();
                        if (angular.isNumber(index) || (index = ctrl.focusIndex), elements.tabs[index] && !ctrl.shouldCenterTabs) {
                            var tab = elements.tabs[index], left = tab.offsetLeft, right = tab.offsetWidth + left;
                            if (0 !== index) if (isRtl()) {
                                var tabWidthsBefore = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index)), tabWidthsIncluding = calcTabsWidth(Array.prototype.slice.call(elements.tabs, 0, index + 1));
                                ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(tabWidthsBefore)), ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(tabWidthsIncluding - elements.canvas.clientWidth));
                            } else ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + 32)), 
                            ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left)); else ctrl.offsetLeft = 0;
                        }
                    }
                    function refreshIndex() {
                        ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex), ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);
                    }
                    function updateHeightFromContent() {
                        if (!ctrl.dynamicHeight) return $element.css("height", "");
                        if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);
                        var elements = getElements(), tabContent = elements.contents[ctrl.selectedIndex], contentHeight = tabContent ? tabContent.offsetHeight : 0, tabsHeight = elements.wrapper.offsetHeight, newHeight = contentHeight + tabsHeight, currentHeight = $element.prop("clientHeight");
                        if (currentHeight !== newHeight) {
                            "bottom" === $element.attr("md-align-tabs") && (currentHeight -= tabsHeight, newHeight -= tabsHeight, 
                            undefined !== $element.attr("md-border-bottom") && ++currentHeight), locked = !0;
                            var fromHeight = {
                                height: currentHeight + "px"
                            }, toHeight = {
                                height: newHeight + "px"
                            };
                            $element.css(fromHeight), $animateCss($element, {
                                from: fromHeight,
                                to: toHeight,
                                easing: "cubic-bezier(0.35, 0, 0.25, 1)",
                                duration: .5
                            }).start().done((function() {
                                $element.css({
                                    transition: "none",
                                    height: ""
                                }), $mdUtil.nextTick((function() {
                                    $element.css("transition", "");
                                })), locked = !1;
                            }));
                        }
                    }
                    function updateInkBarStyles(previousTotalWidth, previousWidthOfTabItems) {
                        if (!ctrl.noInkBar) {
                            var elements = getElements();
                            if (elements.tabs[ctrl.selectedIndex]) if (ctrl.tabs.length) if ($element.prop("offsetParent")) {
                                var index = ctrl.selectedIndex, totalWidth = elements.paging.offsetWidth, tab = elements.tabs[index], left = tab.offsetLeft, right = totalWidth - left - tab.offsetWidth;
                                if (ctrl.shouldCenterTabs) {
                                    var totalWidthOfTabItems = calcTabsWidth(elements.tabs);
                                    totalWidth > totalWidthOfTabItems && previousTotalWidth !== totalWidth && previousWidthOfTabItems !== totalWidthOfTabItems && $timeout(updateInkBarStyles, 0, !0, totalWidth, totalWidthOfTabItems);
                                }
                                !function() {
                                    var elements = getElements(), newIndex = ctrl.selectedIndex, oldIndex = ctrl.lastSelectedIndex, ink = angular.element(elements.inkBar);
                                    if (!angular.isNumber(oldIndex)) return;
                                    ink.toggleClass("md-left", newIndex < oldIndex).toggleClass("md-right", newIndex > oldIndex);
                                }(), angular.element(elements.inkBar).css({
                                    left: left + "px",
                                    right: right + "px"
                                });
                            } else handleResizeWhenVisible(); else queue.push(ctrl.updateInkBarStyles); else angular.element(elements.inkBar).css({
                                left: "auto",
                                right: "auto"
                            });
                        }
                    }
                    function fixOffset(value) {
                        var elements = getElements();
                        if (!elements.tabs.length || !ctrl.shouldPaginate) return 0;
                        var lastTab = elements.tabs[elements.tabs.length - 1], totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
                        return isRtl() ? (value = Math.min(elements.paging.offsetWidth - elements.canvas.clientWidth, value), 
                        value = Math.max(0, value)) : (value = Math.max(0, value), value = Math.min(totalWidth - elements.canvas.clientWidth, value)), 
                        value;
                    }
                    function isRtl() {
                        return $mdUtil.isRtl($attrs);
                    }
                    ctrl.$onInit = function() {
                        (function(key, handler) {
                            var attr = $attrs.$normalize("md-" + key);
                            handler && defineProperty(key, handler);
                            $attrs.$observe(attr, (function(newValue) {
                                ctrl[key] = newValue;
                            }));
                        })("stretchTabs", handleStretchTabs), defineProperty("focusIndex", handleFocusIndexChange, ctrl.selectedIndex || 0), 
                        defineProperty("offsetLeft", handleOffsetChange, 0), defineProperty("hasContent", handleHasContent, !1), 
                        defineProperty("maxTabWidth", handleMaxTabWidth, getMaxTabWidth()), defineProperty("shouldPaginate", handleShouldPaginate, !1), 
                        defineBooleanAttribute("noInkBar", handleInkBar), defineBooleanAttribute("dynamicHeight", handleDynamicHeight), 
                        defineBooleanAttribute("noPagination"), defineBooleanAttribute("swipeContent"), 
                        defineBooleanAttribute("autoselect"), defineBooleanAttribute("noSelectClick"), defineBooleanAttribute("centerTabs", handleCenterTabs), 
                        defineBooleanAttribute("enableDisconnect"), ctrl.scope = $scope, ctrl.parent = $scope.$parent, 
                        ctrl.tabs = [], ctrl.lastSelectedIndex = null, ctrl.hasFocus = !1, ctrl.styleTabItemFocus = !1, 
                        ctrl.shouldCenterTabs = shouldCenterTabs(), ctrl.tabContentPrefix = "tab-content-", 
                        ctrl.navigationHint = "Use the left and right arrow keys to navigate between tabs", 
                        ctrl.selectedIndex = ctrl.selectedIndex || 0, template = $attrs.$mdTabsTemplate, 
                        element = angular.element($element[0].querySelector("md-tab-data")), element.html(template), 
                        $compile(element.contents())(ctrl.parent), delete $attrs.$mdTabsTemplate, $scope.$watch("$mdTabsCtrl.selectedIndex", handleSelectedIndexChange), 
                        angular.element($window).on("resize", handleWindowResize), $scope.$on("$destroy", cleanup), 
                        $mdTheming($element), $mdUtil.nextTick((function() {
                            updateHeightFromContent(), adjustOffset(), updateInkBarStyles(), ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select(), 
                            loaded = !0, updatePagination();
                        }));
                        var template, element;
                    }, ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100), ctrl.redirectFocus = redirectFocus, 
                    ctrl.attachRipple = function(scope, element) {
                        var elements = getElements(), options = {
                            colorElement: angular.element(elements.inkBar)
                        };
                        $mdTabInkRipple.attach(scope, element, options);
                    }, ctrl.insertTab = function(tabData, index) {
                        var hasLoaded = loaded, proto = {
                            getIndex: function() {
                                return ctrl.tabs.indexOf(tab);
                            },
                            isActive: function() {
                                return this.getIndex() === ctrl.selectedIndex;
                            },
                            isLeft: function() {
                                return this.getIndex() < ctrl.selectedIndex;
                            },
                            isRight: function() {
                                return this.getIndex() > ctrl.selectedIndex;
                            },
                            shouldRender: function() {
                                return ctrl.dynamicHeight || this.isActive();
                            },
                            hasFocus: function() {
                                return ctrl.styleTabItemFocus && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
                            },
                            id: $mdUtil.nextUid(),
                            hasContent: !(!tabData.template || !tabData.template.trim())
                        }, tab = angular.extend(proto, tabData);
                        angular.isDefined(index) ? ctrl.tabs.splice(index, 0, tab) : ctrl.tabs.push(tab);
                        return function() {
                            queue.forEach((function(func) {
                                $mdUtil.nextTick(func);
                            })), queue = [];
                        }(), function() {
                            var i, hasContent = !1;
                            for (i = 0; i < ctrl.tabs.length; i++) if (ctrl.tabs[i].hasContent) {
                                hasContent = !0;
                                break;
                            }
                            ctrl.hasContent = hasContent;
                        }(), $mdUtil.nextTick((function() {
                            updatePagination(), function(tab) {
                                if (tab.hasContent) {
                                    var nodes = $element[0].querySelectorAll('[md-tab-id="' + tab.id + '"]');
                                    angular.element(nodes).attr("aria-controls", ctrl.tabContentPrefix + tab.id);
                                }
                            }(tab), hasLoaded && ctrl.autoselect && $mdUtil.nextTick((function() {
                                $mdUtil.nextTick((function() {
                                    select(ctrl.tabs.indexOf(tab));
                                }));
                            }));
                        })), tab;
                    }, ctrl.removeTab = function(tabData) {
                        if (destroyed) return;
                        var selectedIndex = ctrl.selectedIndex, tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
                        refreshIndex(), ctrl.selectedIndex === selectedIndex && (tab.scope.deselect(), ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select());
                        $mdUtil.nextTick((function() {
                            updatePagination(), ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
                        }));
                    }, ctrl.select = select, ctrl.scroll = function(event) {
                        if (!ctrl.shouldPaginate) return;
                        event.preventDefault(), event.deltaY ? ctrl.offsetLeft = fixOffset(ctrl.offsetLeft + event.deltaY) : event.deltaX && (ctrl.offsetLeft = fixOffset(ctrl.offsetLeft + event.deltaX));
                    }, ctrl.nextPage = function() {
                        if (!ctrl.canPageForward()) return;
                        var newOffset = MdTabsPaginationService.increasePageOffset(getElements(), ctrl.offsetLeft);
                        ctrl.offsetLeft = fixOffset(newOffset);
                    }, ctrl.previousPage = function() {
                        if (!ctrl.canPageBack()) return;
                        var newOffset = MdTabsPaginationService.decreasePageOffset(getElements(), ctrl.offsetLeft);
                        ctrl.offsetLeft = fixOffset(newOffset);
                    }, ctrl.keydown = function(event) {
                        switch (event.keyCode) {
                          case $mdConstant.KEY_CODE.LEFT_ARROW:
                            event.preventDefault(), incrementIndex(-1, !0);
                            break;

                          case $mdConstant.KEY_CODE.RIGHT_ARROW:
                            event.preventDefault(), incrementIndex(1, !0);
                            break;

                          case $mdConstant.KEY_CODE.SPACE:
                          case $mdConstant.KEY_CODE.ENTER:
                            event.preventDefault(), locked || select(ctrl.focusIndex);
                            break;

                          case $mdConstant.KEY_CODE.TAB:
                            ctrl.focusIndex !== ctrl.selectedIndex && (ctrl.focusIndex = ctrl.selectedIndex);
                        }
                    }, ctrl.canPageForward = function() {
                        var elements = getElements(), lastTab = elements.tabs[elements.tabs.length - 1];
                        if (isRtl()) return ctrl.offsetLeft < elements.paging.offsetWidth - elements.canvas.offsetWidth;
                        return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;
                    }, ctrl.canPageBack = function() {
                        return ctrl.offsetLeft > 0;
                    }, ctrl.refreshIndex = refreshIndex, ctrl.incrementIndex = incrementIndex, ctrl.getTabElementIndex = function(tabEl) {
                        var tabs = $element[0].getElementsByTagName("md-tab");
                        return Array.prototype.indexOf.call(tabs, tabEl[0]);
                    }, ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100), ctrl.updateTabOrder = $mdUtil.debounce((function() {
                        var selectedItem = ctrl.tabs[ctrl.selectedIndex], focusItem = ctrl.tabs[ctrl.focusIndex];
                        ctrl.tabs = ctrl.tabs.sort((function(a, b) {
                            return a.index - b.index;
                        })), ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem), ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);
                    }), 100), ctrl.getFocusedTabId = function() {
                        var focusedTab = ctrl.tabs[ctrl.focusIndex];
                        if (!focusedTab || !focusedTab.id) return null;
                        return "tab-item-" + focusedTab.id;
                    }, 1 === angular.version.major && angular.version.minor <= 4 && this.$onInit();
                }
                MdTabsController.$inject = [ "$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming", "$mdInteraction", "$timeout", "MdTabsPaginationService" ], 
                angular.module("material.components.tabs").controller("MdTabsController", MdTabsController);
            }(), function() {
                function MdTabs($$mdSvgRegistry) {
                    return {
                        scope: {
                            navigationHint: "@?mdNavigationHint",
                            selectedIndex: "=?mdSelected"
                        },
                        template: function(element, attr) {
                            return attr.$mdTabsTemplate = element.html(), '<md-tabs-wrapper> <md-tab-data></md-tab-data> <md-prev-button tabindex="-1" role="button" aria-label="Previous Page" aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.previousPage()"> <md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> </md-prev-button> <md-next-button tabindex="-1" role="button" aria-label="Next Page" aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.nextPage()"> <md-icon md-svg-src="' + $$mdSvgRegistry.mdTabsArrow + '"></md-icon> </md-next-button> <md-tabs-canvas tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" ng-focus="$mdTabsCtrl.redirectFocus()" ng-class="{ \'md-paginated\': $mdTabsCtrl.shouldPaginate, \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ng-keydown="$mdTabsCtrl.keydown($event)"> <md-pagination-wrapper ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" md-tab-scroll="$mdTabsCtrl.scroll($event)" role="tablist" aria-label="{{::$mdTabsCtrl.navigationHint}}"><md-tab-item tabindex="{{ tab.isActive() ? 0 : -1 }}" class="md-tab {{::tab.scope.tabClass}}" ng-repeat="tab in $mdTabsCtrl.tabs" role="tab" id="tab-item-{{::tab.id}}" md-tab-id="{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-click="$mdTabsCtrl.select(tab.getIndex())" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-class="{ \'md-active\':    tab.isActive(), \'md-focused\':   tab.hasFocus(), \'md-disabled\':  tab.scope.disabled }" ng-disabled="tab.scope.disabled" md-swipe-left="$mdTabsCtrl.nextPage()" md-swipe-right="$mdTabsCtrl.previousPage()" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-tab-item> <md-ink-bar></md-ink-bar> </md-pagination-wrapper> <md-tabs-dummy-wrapper aria-hidden="true" class="md-visually-hidden md-dummy-wrapper"> <md-dummy-tab class="md-tab" tabindex="-1" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-repeat="tab in $mdTabsCtrl.tabs" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-dummy-tab> </md-tabs-dummy-wrapper> </md-tabs-canvas> </md-tabs-wrapper> <md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0" class="_md"> <md-tab-content id="{{:: $mdTabsCtrl.tabContentPrefix + tab.id}}" class="_md" role="tabpanel" aria-labelledby="tab-item-{{::tab.id}}" md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ng-if="tab.hasContent" ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ng-class="{ \'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, \'md-active\':        tab.isActive(), \'md-left\':          tab.isLeft(), \'md-right\':         tab.isRight(), \'md-no-scroll\':     $mdTabsCtrl.dynamicHeight }"> <div md-tabs-template="::tab.template" md-connected-if="tab.isActive()" md-scope="::tab.parent" ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> </md-tab-content> </md-tabs-content-wrapper>';
                        },
                        controller: "MdTabsController",
                        controllerAs: "$mdTabsCtrl",
                        bindToController: !0
                    };
                }
                MdTabs.$inject = [ "$$mdSvgRegistry" ], angular.module("material.components.tabs").directive("mdTabs", MdTabs);
            }(), function() {
                function MdTabsDummyWrapper($mdUtil, $window) {
                    return {
                        require: "^?mdTabs",
                        link: function(scope, element, attr, ctrl) {
                            if (ctrl) {
                                var observer, disconnect, mutationCallback = function() {
                                    ctrl.updatePagination(), ctrl.updateInkBarStyles();
                                };
                                if ("MutationObserver" in $window) {
                                    (observer = new MutationObserver(mutationCallback)).observe(element[0], {
                                        childList: !0,
                                        subtree: !0,
                                        characterData: !0
                                    }), disconnect = observer.disconnect.bind(observer);
                                } else {
                                    var debounced = $mdUtil.debounce(mutationCallback, 15, null, !1);
                                    element.on("DOMSubtreeModified", debounced), disconnect = element.off.bind(element, "DOMSubtreeModified", debounced);
                                }
                                scope.$on("$destroy", (function() {
                                    disconnect();
                                }));
                            }
                        }
                    };
                }
                MdTabsDummyWrapper.$inject = [ "$mdUtil", "$window" ], angular.module("material.components.tabs").directive("mdTabsDummyWrapper", MdTabsDummyWrapper);
            }(), function() {
                function MdTabsTemplate($compile, $mdUtil) {
                    return {
                        restrict: "A",
                        link: function(scope, element, attr, ctrl) {
                            if (!ctrl) return;
                            var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
                            return element.html(scope.template), $compile(element.contents())(compileScope), 
                            $mdUtil.nextTick((function() {
                                scope.$watch("connected", (function(value) {
                                    !1 === value ? disconnect() : reconnect();
                                })), scope.$on("$destroy", reconnect);
                            }));
                            function disconnect() {
                                ctrl.enableDisconnect && $mdUtil.disconnectScope(compileScope);
                            }
                            function reconnect() {
                                ctrl.enableDisconnect && $mdUtil.reconnectScope(compileScope);
                            }
                        },
                        scope: {
                            template: "=mdTabsTemplate",
                            connected: "=?mdConnectedIf",
                            compileScope: "=mdScope"
                        },
                        require: "^?mdTabs"
                    };
                }
                MdTabsTemplate.$inject = [ "$compile", "$mdUtil" ], angular.module("material.components.tabs").directive("mdTabsTemplate", MdTabsTemplate);
            }(), function() {
                function MdToastDirective($mdToast) {
                    return {
                        restrict: "E",
                        link: function(scope, element) {
                            element.addClass("_md"), scope.$on("$destroy", (function() {
                                $mdToast.destroy();
                            }));
                        }
                    };
                }
                function MdToastProvider($$interimElementProvider) {
                    MdToastController.$inject = [ "$mdToast", "$scope", "$log" ], toastDefaultOptions.$inject = [ "$animate", "$mdToast", "$mdUtil", "$mdMedia", "$document", "$q" ];
                    var activeToastContent, ACTION_RESOLVE = "ok";
                    return $$interimElementProvider("$mdToast").setDefaults({
                        methods: [ "position", "hideDelay", "capsule", "parent", "position", "toastClass" ],
                        options: toastDefaultOptions
                    }).addPreset("simple", {
                        argOption: "textContent",
                        methods: [ "textContent", "action", "actionKey", "actionHint", "highlightAction", "highlightClass", "theme", "parent", "dismissHint" ],
                        options: [ "$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
                            return {
                                template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">  <div class="md-toast-content" aria-live="polite" aria-relevant="all">    <span class="md-toast-text">      {{ toast.content }}    </span>    <span class="md-visually-hidden">{{ toast.dismissHint }}</span>    <span class="md-visually-hidden" ng-if="toast.action && toast.actionKey">      {{ toast.actionHint }}    </span>    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()"                ng-class="highlightClasses">      {{ toast.action }}    </md-button>  </div></md-toast>',
                                controller: MdToastController,
                                theme: $mdTheming.defaultTheme(),
                                controllerAs: "toast",
                                bindToController: !0
                            };
                        } ]
                    }).addMethod("updateTextContent", (function(newContent) {
                        activeToastContent = newContent;
                    }));
                    function MdToastController($mdToast, $scope, $log) {
                        this.$onInit = function() {
                            var self = this;
                            self.highlightAction && ($scope.highlightClasses = [ "md-highlight", self.highlightClass ]), 
                            self.action && !self.actionKey && $log.warn("Toasts with actions should define an actionKey for accessibility.", "Details: https://material.angularjs.org/latest/api/service/$mdToast#mdtoast-simple"), 
                            self.actionKey && !self.actionHint && (self.actionHint = 'Press Control-"' + self.actionKey + '" to '), 
                            self.dismissHint || (self.dismissHint = "Press Escape to dismiss."), $scope.$watch((function() {
                                return activeToastContent;
                            }), (function() {
                                self.content = activeToastContent;
                            })), this.resolve = function() {
                                $mdToast.hide(ACTION_RESOLVE);
                            };
                        };
                    }
                    function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia, $document, $q) {
                        var SWIPE_EVENTS = "$md.swipeleft $md.swiperight $md.swipeup $md.swipedown";
                        return {
                            onShow: function(scope, element, options) {
                                activeToastContent = options.textContent;
                                var isSmScreen = !$mdMedia("gt-sm");
                                element = $mdUtil.extractElementByName(element, "md-toast", !0), options.element = element, 
                                options.onSwipe = function(ev) {
                                    var swipe = ev.type.replace("$md.", ""), direction = swipe.replace("swipe", "");
                                    "down" === direction && -1 !== options.position.indexOf("top") && !isSmScreen || "up" === direction && (-1 !== options.position.indexOf("bottom") || isSmScreen) || ("left" !== direction && "right" !== direction || !isSmScreen) && (element.addClass("md-" + swipe), 
                                    $mdUtil.nextTick($mdToast.cancel));
                                }, options.openClass = toastOpenClass(options.position), element.addClass(options.toastClass), 
                                options.parent.addClass(options.openClass), $mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "relative");
                                actionKey = scope.toast && scope.toast.actionKey ? scope.toast.actionKey : void 0, 
                                handleKeyDown = function(event) {
                                    "Escape" === event.key && $mdToast.hide(!1), actionKey && event.key === actionKey && event.ctrlKey && $mdToast.hide(ACTION_RESOLVE);
                                }, $document.on("keydown", handleKeyDown), element.on(SWIPE_EVENTS, options.onSwipe);
                                var actionKey, handleKeyDown;
                                var verticalPositionDefined = !1, positionClasses = options.position.split(" ").map((function(position) {
                                    if (position) {
                                        var className = "md-" + position;
                                        return "md-top" !== className && "md-bottom" !== className || (verticalPositionDefined = !0), 
                                        className;
                                    }
                                    return "md-bottom";
                                }));
                                verticalPositionDefined || positionClasses.push("md-bottom");
                                element.addClass(isSmScreen ? "md-bottom" : positionClasses.join(" ")), options.parent && options.parent.addClass("md-toast-animating");
                                return $animate.enter(element, options.parent).then((function() {
                                    options.parent && options.parent.removeClass("md-toast-animating");
                                }));
                            },
                            onRemove: function(scope, element, options) {
                                scope.toast && scope.toast.actionKey && $document.off("keydown");
                                element.off(SWIPE_EVENTS, options.onSwipe), options.parent && options.parent.addClass("md-toast-animating");
                                options.openClass && options.parent.removeClass(options.openClass);
                                return (!0 === options.$destroy ? $q.when(element.remove()) : $animate.leave(element)).then((function() {
                                    options.parent && options.parent.removeClass("md-toast-animating"), $mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "");
                                }));
                            },
                            toastClass: "",
                            position: "bottom left",
                            themable: !0,
                            hideDelay: 3e3,
                            autoWrap: !0,
                            transformTemplate: function(template, options) {
                                if (options.autoWrap && template && !/md-toast-content/g.test(template)) {
                                    var templateRoot = document.createElement("md-template");
                                    templateRoot.innerHTML = template;
                                    for (var i = 0; i < templateRoot.children.length; i++) if ("MD-TOAST" === templateRoot.children[i].nodeName) {
                                        var wrapper = angular.element('<div class="md-toast-content">');
                                        wrapper.append(angular.element(templateRoot.children[i].childNodes)), templateRoot.children[i].appendChild(wrapper[0]);
                                    }
                                    return templateRoot.innerHTML;
                                }
                                return template || "";
                            }
                        };
                        function toastOpenClass(position) {
                            return $mdMedia("gt-xs") ? "md-toast-open-" + (position.indexOf("top") > -1 ? "top" : "bottom") : "md-toast-open-bottom";
                        }
                    }
                }
                MdToastDirective.$inject = [ "$mdToast" ], MdToastProvider.$inject = [ "$$interimElementProvider" ], 
                angular.module("material.components.toast", [ "material.core", "material.components.button" ]).directive("mdToast", MdToastDirective).provider("$mdToast", MdToastProvider);
            }(), function() {
                function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate, $timeout) {
                    var translateY = angular.bind(null, $mdUtil.supplant, "translate3d(0,{0}px,0)");
                    return {
                        template: "",
                        restrict: "E",
                        link: function(scope, element, attr) {
                            element.addClass("_md"), $mdTheming(element), $mdUtil.nextTick((function() {
                                element.addClass("_md-toolbar-transitions");
                            }), !1), angular.isDefined(attr.mdScrollShrink) && function() {
                                var toolbarHeight, contentElement, disableScrollShrink = angular.noop, y = 0, prevScrollTop = 0, shrinkSpeedFactor = attr.mdShrinkSpeedFactor || .5, debouncedContentScroll = $$rAF.throttle(onContentScroll), debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5e3);
                                scope.$on("$mdContentLoaded", onMdContentLoad), attr.$observe("mdScrollShrink", onChangeScrollShrink), 
                                attr.ngShow && scope.$watch(attr.ngShow, updateToolbarHeight);
                                attr.ngHide && scope.$watch(attr.ngHide, updateToolbarHeight);
                                function onChangeScrollShrink(shrinkWithScroll) {
                                    var closestContent = $mdUtil.getSiblings(element, "md-content");
                                    !contentElement && closestContent.length && onMdContentLoad(null, closestContent[0]), 
                                    !1 === (shrinkWithScroll = scope.$eval(shrinkWithScroll)) ? disableScrollShrink() : disableScrollShrink = enableScrollShrink();
                                }
                                function onMdContentLoad($event, newContentEl) {
                                    newContentEl && element.parent()[0] === newContentEl.parent()[0] && (contentElement && contentElement.off("scroll", debouncedContentScroll), 
                                    contentElement = newContentEl, disableScrollShrink = enableScrollShrink());
                                }
                                function onContentScroll(e) {
                                    var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                                    debouncedUpdateHeight(), y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop)), 
                                    element.css($mdConstant.CSS.TRANSFORM, translateY([ -y * shrinkSpeedFactor ])), 
                                    contentElement.css($mdConstant.CSS.TRANSFORM, translateY([ (toolbarHeight - y) * shrinkSpeedFactor ])), 
                                    prevScrollTop = scrollTop, $mdUtil.nextTick((function() {
                                        var hasWhiteFrame = element.hasClass("md-whiteframe-z1");
                                        hasWhiteFrame && !y ? $animate.removeClass(element, "md-whiteframe-z1") : !hasWhiteFrame && y && $animate.addClass(element, "md-whiteframe-z1");
                                    }));
                                }
                                function enableScrollShrink() {
                                    return contentElement ? (contentElement.on("scroll", debouncedContentScroll), contentElement.attr("scroll-shrink", "true"), 
                                    $timeout(updateToolbarHeight), function() {
                                        contentElement.off("scroll", debouncedContentScroll), contentElement.attr("scroll-shrink", "false"), 
                                        updateToolbarHeight();
                                    }) : angular.noop;
                                }
                                function updateToolbarHeight() {
                                    var margin = -(toolbarHeight = element.prop("offsetHeight")) * shrinkSpeedFactor + "px";
                                    contentElement.css({
                                        "margin-top": margin,
                                        "margin-bottom": margin
                                    }), onContentScroll();
                                }
                                scope.$on("$destroy", disableScrollShrink);
                            }();
                        }
                    };
                }
                mdToolbarDirective.$inject = [ "$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate", "$timeout" ], 
                angular.module("material.components.toolbar", [ "material.core", "material.components.content" ]).directive("mdToolbar", mdToolbarDirective);
            }(), function() {
                function MdTooltipDirective($timeout, $window, $$rAF, $document, $interpolate, $mdUtil, $mdPanel, $$mdTooltipRegistry) {
                    var LEAVE_EVENTS = "blur touchcancel mouseleave", TOOLTIP_DIRECTIONS = {
                        top: {
                            x: $mdPanel.xPosition.CENTER,
                            y: $mdPanel.yPosition.ABOVE
                        },
                        right: {
                            x: $mdPanel.xPosition.OFFSET_END,
                            y: $mdPanel.yPosition.CENTER
                        },
                        bottom: {
                            x: $mdPanel.xPosition.CENTER,
                            y: $mdPanel.yPosition.BELOW
                        },
                        left: {
                            x: $mdPanel.xPosition.OFFSET_START,
                            y: $mdPanel.yPosition.CENTER
                        }
                    };
                    return {
                        restrict: "E",
                        priority: 210,
                        scope: {
                            mdZIndex: "=?mdZIndex",
                            mdDelay: "=?mdDelay",
                            mdVisible: "=?mdVisible",
                            mdAutohide: "=?mdAutohide",
                            mdDirection: "@?mdDirection"
                        },
                        link: function(scope, element, attr) {
                            var origin, position, panelPosition, panelRef, showTimeout, tooltipId = "md-tooltip-" + $mdUtil.nextUid(), parent = $mdUtil.getParentWithPointerEvents(element), debouncedOnResize = $$rAF.throttle(updatePosition), mouseActive = !1, elementFocusedOnWindowBlur = null;
                            function setDefaults() {
                                scope.mdZIndex = scope.mdZIndex || 100, scope.mdDelay = scope.mdDelay || 0, TOOLTIP_DIRECTIONS[scope.mdDirection] || (scope.mdDirection = "bottom");
                            }
                            function addAriaLabel(labelText) {
                                var interpolatedText = labelText || $interpolate(element.text().trim())(scope.$parent);
                                (!parent.attr("aria-label") && !parent.attr("aria-labelledby") || parent.attr("md-labeled-by-tooltip")) && (parent.attr("aria-label", interpolatedText), 
                                parent.attr("md-labeled-by-tooltip") || parent.attr("md-labeled-by-tooltip", tooltipId));
                            }
                            function updatePosition() {
                                setDefaults(), panelRef && panelRef.panelEl && panelRef.panelEl.removeClass(origin), 
                                origin = "md-origin-" + scope.mdDirection, position = TOOLTIP_DIRECTIONS[scope.mdDirection], 
                                panelPosition = $mdPanel.newPanelPosition().relativeTo(parent).addPanelPosition(position.x, position.y), 
                                panelRef && panelRef.panelEl && (panelRef.panelEl.addClass(origin), panelRef.updatePosition(panelPosition));
                            }
                            function setVisible(value) {
                                setVisible.queued && setVisible.value === !!value || !setVisible.queued && scope.mdVisible === !!value || (setVisible.value = !!value, 
                                setVisible.queued || (value ? (setVisible.queued = !0, showTimeout = $timeout((function() {
                                    scope.mdVisible = setVisible.value, setVisible.queued = !1, showTimeout = null, 
                                    scope.visibleWatcher || onVisibleChanged(scope.mdVisible);
                                }), scope.mdDelay)) : $mdUtil.nextTick((function() {
                                    scope.mdVisible = !1, scope.visibleWatcher || onVisibleChanged(!1);
                                }))));
                            }
                            function onVisibleChanged(isVisible) {
                                isVisible ? function() {
                                    if (!element[0].textContent.trim()) throw new Error("Text for the tooltip has not been provided. Please include text within the mdTooltip element.");
                                    if (!panelRef) {
                                        var attachTo = angular.element(document.body), panelAnimation = $mdPanel.newPanelAnimation().openFrom(parent).closeTo(parent).withAnimation({
                                            open: "md-show",
                                            close: "md-hide"
                                        }), panelConfig = {
                                            id: tooltipId,
                                            attachTo,
                                            contentElement: element,
                                            propagateContainerEvents: !0,
                                            panelClass: "md-tooltip",
                                            animation: panelAnimation,
                                            position: panelPosition,
                                            zIndex: scope.mdZIndex,
                                            focusOnOpen: !1,
                                            onDomAdded: function() {
                                                panelRef.panelEl.addClass(origin);
                                            }
                                        };
                                        panelRef = $mdPanel.create(panelConfig);
                                    }
                                    panelRef.open().then((function() {
                                        panelRef.panelEl.attr("role", "tooltip");
                                    }));
                                }() : panelRef && panelRef.close();
                            }
                            setDefaults(), addAriaLabel(), element.detach(), updatePosition(), function() {
                                if (parent[0] && "MutationObserver" in $window) {
                                    var attributeObserver = new MutationObserver((function(mutations) {
                                        (function(mutations) {
                                            return mutations.some((function(mutation) {
                                                return "disabled" === mutation.attributeName && parent[0].disabled;
                                            })), !1;
                                        })(mutations) && $mdUtil.nextTick((function() {
                                            setVisible(!1);
                                        }));
                                    }));
                                    attributeObserver.observe(parent[0], {
                                        attributes: !0
                                    });
                                }
                                function windowScrollEventHandler() {
                                    setVisible(!1);
                                }
                                function windowBlurEventHandler() {
                                    elementFocusedOnWindowBlur = document.activeElement === parent[0];
                                }
                                function enterEventHandler($event) {
                                    "focus" === $event.type && elementFocusedOnWindowBlur ? elementFocusedOnWindowBlur = !1 : scope.mdVisible || (parent.on(LEAVE_EVENTS, leaveEventHandler), 
                                    setVisible(!0), "touchstart" === $event.type && parent.one("touchend", (function() {
                                        $mdUtil.nextTick((function() {
                                            $document.one("touchend", leaveEventHandler);
                                        }), !1);
                                    })));
                                }
                                function leaveEventHandler() {
                                    ((scope.hasOwnProperty("mdAutohide") ? scope.mdAutohide : attr.hasOwnProperty("mdAutohide")) || mouseActive || $document[0].activeElement !== parent[0]) && (showTimeout && ($timeout.cancel(showTimeout), 
                                    setVisible.queued = !1, showTimeout = null), parent.off(LEAVE_EVENTS, leaveEventHandler), 
                                    parent.triggerHandler("blur"), setVisible(!1)), mouseActive = !1;
                                }
                                function mousedownEventHandler() {
                                    mouseActive = !0;
                                }
                                elementFocusedOnWindowBlur = !1, $$mdTooltipRegistry.register("scroll", windowScrollEventHandler, !0), 
                                $$mdTooltipRegistry.register("blur", windowBlurEventHandler), $$mdTooltipRegistry.register("resize", debouncedOnResize), 
                                scope.$on("$destroy", (function() {
                                    $$mdTooltipRegistry.deregister("scroll", windowScrollEventHandler, !0), $$mdTooltipRegistry.deregister("blur", windowBlurEventHandler), 
                                    $$mdTooltipRegistry.deregister("resize", debouncedOnResize), parent.off("focus touchstart mouseenter", enterEventHandler).off(LEAVE_EVENTS, leaveEventHandler).off("mousedown", mousedownEventHandler), 
                                    leaveEventHandler(), attributeObserver && attributeObserver.disconnect();
                                })), parent.on("mousedown", mousedownEventHandler), parent.on("focus touchstart mouseenter", enterEventHandler);
                            }(), function() {
                                if (element[0] && "MutationObserver" in $window) {
                                    var attributeObserver = new MutationObserver((function(mutations) {
                                        mutations.forEach((function(mutation) {
                                            "md-visible" !== mutation.attributeName || scope.visibleWatcher || (scope.visibleWatcher = scope.$watch("mdVisible", onVisibleChanged));
                                        }));
                                    }));
                                    attributeObserver.observe(element[0], {
                                        attributes: !0
                                    }), attr.hasOwnProperty("mdVisible") && (scope.visibleWatcher = scope.$watch("mdVisible", onVisibleChanged));
                                } else scope.visibleWatcher = scope.$watch("mdVisible", onVisibleChanged);
                                function onElementDestroy() {
                                    scope.$destroy();
                                }
                                scope.$watch("mdDirection", updatePosition), element.one("$destroy", onElementDestroy), 
                                parent.one("$destroy", onElementDestroy), scope.$on("$destroy", (function() {
                                    setVisible(!1), panelRef && panelRef.destroy(), attributeObserver && attributeObserver.disconnect(), 
                                    element.remove();
                                })), element.text().indexOf($interpolate.startSymbol()) > -1 && scope.$watch((function() {
                                    return element.text().trim();
                                }), addAriaLabel);
                            }();
                        }
                    };
                }
                MdTooltipDirective.$inject = [ "$timeout", "$window", "$$rAF", "$document", "$interpolate", "$mdUtil", "$mdPanel", "$$mdTooltipRegistry" ], 
                angular.module("material.components.tooltip", [ "material.core", "material.components.panel" ]).directive("mdTooltip", MdTooltipDirective).service("$$mdTooltipRegistry", (function() {
                    var listeners = {}, ngWindow = angular.element(window);
                    return {
                        register: function(type, handler, useCapture) {
                            var handlers = listeners[type] = listeners[type] || [];
                            handlers.length || (useCapture ? window.addEventListener(type, globalEventHandler, !0) : ngWindow.on(type, globalEventHandler));
                            -1 === handlers.indexOf(handler) && handlers.push(handler);
                        },
                        deregister: function(type, handler, useCapture) {
                            var handlers = listeners[type], index = handlers ? handlers.indexOf(handler) : -1;
                            index > -1 && (handlers.splice(index, 1), 0 === handlers.length && (useCapture ? window.removeEventListener(type, globalEventHandler, !0) : ngWindow.off(type, globalEventHandler)));
                        }
                    };
                    function globalEventHandler(event) {
                        listeners[event.type] && listeners[event.type].forEach((function(currentHandler) {
                            currentHandler.call(this, event);
                        }), this);
                    }
                }));
            }(), function() {
                function MdTruncateController($element) {
                    $element.addClass("md-truncate");
                }
                MdTruncateController.$inject = [ "$element" ], angular.module("material.components.truncate", [ "material.core" ]).directive("mdTruncate", (function() {
                    return {
                        restrict: "AE",
                        controller: MdTruncateController
                    };
                }));
            }(), function() {
                function virtualRepeatContainerTemplate($element) {
                    return '<div class="md-virtual-repeat-scroller" role="presentation"><div class="md-virtual-repeat-sizer" role="presentation"></div><div class="md-virtual-repeat-offsetter" role="presentation">' + $element[0].innerHTML + "</div></div>";
                }
                VirtualRepeatContainerController.$inject = [ "$$rAF", "$mdUtil", "$mdConstant", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs" ], 
                VirtualRepeatController.$inject = [ "$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF", "$mdUtil" ], 
                VirtualRepeatDirective.$inject = [ "$parse" ], angular.module("material.components.virtualRepeat", [ "material.core", "material.components.showHide" ]).directive("mdVirtualRepeatContainer", (function() {
                    return {
                        controller: VirtualRepeatContainerController,
                        template: virtualRepeatContainerTemplate,
                        compile: function($element, $attrs) {
                            $element.addClass("md-virtual-repeat-container").addClass($attrs.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical");
                        }
                    };
                })).directive("mdVirtualRepeat", VirtualRepeatDirective).directive("mdForceHeight", ForceHeightDirective);
                function VirtualRepeatContainerController($$rAF, $mdUtil, $mdConstant, $parse, $rootScope, $window, $scope, $element, $attrs) {
                    this.$rootScope = $rootScope, this.$scope = $scope, this.$element = $element, this.$attrs = $attrs, 
                    this.size = 0, this.scrollSize = 0, this.scrollOffset = 0, this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal"), 
                    this.repeater = null, this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink"), 
                    this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0, this.originalSize = null, 
                    this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0, this.oldElementSize = null, 
                    this.maxElementPixels = $mdConstant.ELEMENT_MAX_PIXELS, this.ltr = !$mdUtil.isRtl(this.$attrs), 
                    this.$attrs.mdTopIndex ? (this.bindTopIndex = $parse(this.$attrs.mdTopIndex), this.topIndex = this.bindTopIndex(this.$scope), 
                    angular.isDefined(this.topIndex) || (this.topIndex = 0, this.bindTopIndex.assign(this.$scope, 0)), 
                    this.$scope.$watch(this.bindTopIndex, angular.bind(this, (function(newIndex) {
                        newIndex !== this.topIndex && this.scrollToIndex(newIndex);
                    })))) : this.topIndex = 0, this.scroller = $element[0].querySelector(".md-virtual-repeat-scroller"), 
                    this.sizer = this.scroller.querySelector(".md-virtual-repeat-sizer"), this.offsetter = this.scroller.querySelector(".md-virtual-repeat-offsetter");
                    var boundUpdateSize = angular.bind(this, this.updateSize);
                    $$rAF(angular.bind(this, (function() {
                        boundUpdateSize();
                        var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, !1), jWindow = angular.element($window);
                        this.size || debouncedUpdateSize(), jWindow.on("resize", debouncedUpdateSize), $scope.$on("$destroy", (function() {
                            jWindow.off("resize", debouncedUpdateSize);
                        })), $scope.$emit("$md-resize-enable"), $scope.$on("$md-resize", boundUpdateSize);
                    })));
                }
                function VirtualRepeatDirective($parse) {
                    return {
                        controller: VirtualRepeatController,
                        priority: 1e3,
                        require: [ "mdVirtualRepeat", "^^mdVirtualRepeatContainer" ],
                        restrict: "A",
                        terminal: !0,
                        transclude: "element",
                        compile: function($element, $attrs) {
                            var match = $attrs.mdVirtualRepeat.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/), repeatName = match[1], repeatListExpression = $parse(match[2]), extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
                            return function($scope, $element, $attrs, ctrl, $transclude) {
                                ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
                            };
                        }
                    };
                }
                function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF, $mdUtil) {
                    this.$scope = $scope, this.$element = $element, this.$attrs = $attrs, this.$browser = $browser, 
                    this.$document = $document, this.$mdUtil = $mdUtil, this.$rootScope = $rootScope, 
                    this.$$rAF = $$rAF, this.onDemand = $mdUtil.parseAttributeBoolean($attrs.mdOnDemand), 
                    this.browserCheckUrlChange = $browser.$$checkUrlChange, this.newStartIndex = 0, 
                    this.newEndIndex = 0, this.newVisibleEnd = 0, this.startIndex = 0, this.endIndex = 0, 
                    this.itemSize = $scope.$eval($attrs.mdItemSize) || null, this.isFirstRender = !0, 
                    this.isVirtualRepeatUpdating_ = !1, this.itemsLength = 0, this.unwatchItemSize_ = angular.noop, 
                    this.blocks = {}, this.pooledBlocks = [], $scope.$on("$destroy", angular.bind(this, this.cleanupBlocks_));
                }
                function VirtualRepeatModelArrayLike(model) {
                    if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength().");
                    this.model = model;
                }
                function ForceHeightDirective($mdUtil) {
                    return {
                        restrict: "A",
                        link: function(scope, element, attrs) {
                            var height = scope.$eval(attrs.mdForceHeight) || null;
                            height && element && (element[0].style.height = height);
                        }
                    };
                }
                VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
                    this.repeater = repeaterCtrl, angular.element(this.scroller).on("scroll wheel touchmove touchend", angular.bind(this, this.handleScroll_));
                }, VirtualRepeatContainerController.prototype.isHorizontal = function() {
                    return this.horizontal;
                }, VirtualRepeatContainerController.prototype.getSize = function() {
                    return this.size;
                }, VirtualRepeatContainerController.prototype.setSize_ = function(size) {
                    var dimension = this.getDimensionName_();
                    this.size = size, this.$element[0].style[dimension] = size + "px";
                }, VirtualRepeatContainerController.prototype.unsetSize_ = function() {
                    this.$element[0].style[this.getDimensionName_()] = this.oldElementSize, this.oldElementSize = null;
                }, VirtualRepeatContainerController.prototype.updateSize = function() {
                    if (!this.originalSize) {
                        var size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
                        size && (this.size = size), this.handleScroll_(), this.repeater && this.repeater.containerUpdated();
                    }
                }, VirtualRepeatContainerController.prototype.getScrollSize = function() {
                    return this.scrollSize;
                }, VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
                    return this.isHorizontal() ? "width" : "height";
                }, VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
                    var dimension = this.getDimensionName_(), crossDimension = this.isHorizontal() ? "height" : "width";
                    if (this.sizer.innerHTML = "", size < this.maxElementPixels) this.sizer.style[dimension] = size + "px"; else {
                        this.sizer.style[dimension] = "auto", this.sizer.style[crossDimension] = "auto";
                        var numChildren = Math.floor(size / this.maxElementPixels), sizerChild = document.createElement("div");
                        sizerChild.style[dimension] = this.maxElementPixels + "px", sizerChild.style[crossDimension] = "1px";
                        for (var i = 0; i < numChildren; i++) this.sizer.appendChild(sizerChild.cloneNode(!1));
                        sizerChild.style[dimension] = size - numChildren * this.maxElementPixels + "px", 
                        this.sizer.appendChild(sizerChild);
                    }
                }, VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
                    var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
                    if (this.autoShrink && shrinkSize !== this.size) {
                        null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]);
                        var currentSize = this.originalSize || this.size;
                        if (!currentSize || shrinkSize < currentSize) this.originalSize || (this.originalSize = this.size), 
                        this.setSize_(shrinkSize); else if (null !== this.originalSize) {
                            this.unsetSize_();
                            var _originalSize = this.originalSize;
                            this.originalSize = null, _originalSize || this.updateSize(), this.setSize_(_originalSize || this.size);
                        }
                        this.repeater.containerUpdated();
                    }
                }, VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
                    var size = itemsSize + this.offsetSize;
                    this.scrollSize !== size && (this.sizeScroller_(size), this.autoShrink_(size), this.scrollSize = size);
                }, VirtualRepeatContainerController.prototype.getScrollOffset = function() {
                    return this.scrollOffset;
                }, VirtualRepeatContainerController.prototype.scrollTo = function(position) {
                    this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = position, this.handleScroll_();
                }, VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
                    var itemSize = this.repeater.getItemSize(), itemsLength = this.repeater.itemsLength;
                    index > itemsLength && (index = itemsLength - 1), this.scrollTo(itemSize * index);
                }, VirtualRepeatContainerController.prototype.resetScroll = function() {
                    this.scrollTo(0);
                }, VirtualRepeatContainerController.prototype.handleScroll_ = function() {
                    this.ltr || this.maxSize || (this.scroller.scrollLeft = this.scrollSize, this.maxSize = this.scroller.scrollLeft);
                    var offset = this.isHorizontal() ? this.ltr ? this.scroller.scrollLeft : this.maxSize - this.scroller.scrollLeft : this.scroller.scrollTop;
                    if (!(this.scrollSize < this.size) && (offset > this.scrollSize - this.size && (offset = this.scrollSize - this.size), 
                    offset !== this.scrollOffset)) {
                        var itemSize = this.repeater.getItemSize();
                        if (itemSize) {
                            var numItems = Math.max(0, Math.floor(offset / itemSize) - 3), transform = (this.isHorizontal() ? "translateX(" : "translateY(") + (!this.isHorizontal() || this.ltr ? numItems * itemSize : -numItems * itemSize) + "px)";
                            if (this.scrollOffset = offset, this.offsetter.style.webkitTransform = transform, 
                            this.offsetter.style.transform = transform, this.bindTopIndex) {
                                var topIndex = Math.floor(offset / itemSize);
                                topIndex !== this.topIndex && topIndex < this.repeater.getItemCount() && (this.topIndex = topIndex, 
                                this.bindTopIndex.assign(this.$scope, topIndex), this.$rootScope.$$phase || this.$scope.$digest());
                            }
                            this.repeater.containerUpdated();
                        }
                    }
                }, VirtualRepeatController.Block, VirtualRepeatController.prototype.link_ = function(container, transclude, repeatName, repeatListExpression, extraName) {
                    this.container = container, this.transclude = transclude, this.repeatName = repeatName, 
                    this.rawRepeatListExpression = repeatListExpression, this.extraName = extraName, 
                    this.sized = !1, this.repeatListExpression = angular.bind(this, this.repeatListExpression_), 
                    this.container.register(this);
                }, VirtualRepeatController.prototype.cleanupBlocks_ = function() {
                    angular.forEach(this.pooledBlocks, (function(block) {
                        block.element.remove();
                    }));
                }, VirtualRepeatController.prototype.readItemSize_ = function() {
                    if (!this.itemSize) {
                        this.items = this.repeatListExpression(this.$scope), this.parentNode = this.$element[0].parentNode;
                        var block = this.getBlock_(0);
                        block.element[0].parentNode || this.parentNode.appendChild(block.element[0]), this.itemSize = block.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null, 
                        this.blocks[0] = block, this.poolBlock_(0), this.itemSize && this.containerUpdated();
                    }
                }, VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
                    var repeatList = this.rawRepeatListExpression(scope);
                    if (this.onDemand && repeatList) {
                        var virtualList = new VirtualRepeatModelArrayLike(repeatList);
                        return virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd), virtualList;
                    }
                    return repeatList;
                }, VirtualRepeatController.prototype.containerUpdated = function() {
                    if (!this.itemSize) return this.unwatchItemSize_ && this.unwatchItemSize_ !== angular.noop && this.unwatchItemSize_(), 
                    this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, (function(items) {
                        items && items.length && this.readItemSize_();
                    }))), void (this.$rootScope.$$phase || this.$scope.$digest());
                    this.sized || (this.items = this.repeatListExpression(this.$scope)), this.sized || (this.unwatchItemSize_(), 
                    this.sized = !0, this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, (function(items, oldItems) {
                        this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(items, oldItems);
                    })))), this.updateIndexes_(), (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) && (this.items instanceof VirtualRepeatModelArrayLike && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex), 
                    this.virtualRepeatUpdate_(this.items, this.items));
                }, VirtualRepeatController.prototype.getItemSize = function() {
                    return this.itemSize;
                }, VirtualRepeatController.prototype.getItemCount = function() {
                    return this.itemsLength;
                }, VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
                    this.isVirtualRepeatUpdating_ = !0;
                    var itemsLength = items && items.length || 0, lengthChanged = !1;
                    if (this.items && itemsLength < this.items.length && 0 !== this.container.getScrollOffset()) {
                        this.items = items;
                        var previousScrollOffset = this.container.getScrollOffset();
                        this.container.resetScroll(), this.container.scrollTo(previousScrollOffset);
                    }
                    itemsLength !== this.itemsLength && (lengthChanged = !0, this.itemsLength = itemsLength), 
                    this.items = items, (items !== oldItems || lengthChanged) && this.updateIndexes_(), 
                    this.parentNode = this.$element[0].parentNode, lengthChanged && this.container.setScrollSize(itemsLength * this.itemSize), 
                    Object.keys(this.blocks).forEach((function(blockIndex) {
                        var index = parseInt(blockIndex, 10);
                        (index < this.newStartIndex || index >= this.newEndIndex) && this.poolBlock_(index);
                    }), this), this.$browser.$$checkUrlChange = angular.noop;
                    var i, block, newStartBlocks = [], newEndBlocks = [];
                    for (i = this.newStartIndex; i < this.newEndIndex && null == this.blocks[i]; i++) block = this.getBlock_(i), 
                    this.updateBlock_(block, i), newStartBlocks.push(block);
                    for (;null != this.blocks[i]; i++) this.updateBlock_(this.blocks[i], i);
                    for (var maxIndex = i - 1; i < this.newEndIndex; i++) block = this.getBlock_(i), 
                    this.updateBlock_(block, i), newEndBlocks.push(block);
                    if (newStartBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling), 
                    newEndBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling), 
                    this.$browser.$$checkUrlChange = this.browserCheckUrlChange, this.startIndex = this.newStartIndex, 
                    this.endIndex = this.newEndIndex, this.isFirstRender) {
                        this.isFirstRender = !1;
                        var firstRenderStartIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
                        this.$mdUtil.nextTick(function() {
                            this.container.scrollToIndex(firstRenderStartIndex);
                        }.bind(this));
                    }
                    this.isVirtualRepeatUpdating_ = !1;
                }, VirtualRepeatController.prototype.getBlock_ = function(index) {
                    return this.pooledBlocks.length ? this.pooledBlocks.pop() : (this.transclude(angular.bind(this, (function(clone, scope) {
                        block = {
                            element: clone,
                            new: !0,
                            scope
                        }, this.updateScope_(scope, index), this.parentNode.appendChild(clone[0]);
                    }))), block);
                    var block;
                }, VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
                    this.blocks[index] = block, (block.new || block.scope.$index !== index || block.scope[this.repeatName] !== this.items[index]) && (block.new = !1, 
                    this.updateScope_(block.scope, index), this.$rootScope.$$phase || block.scope.$digest());
                }, VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
                    scope.$index = index, scope[this.repeatName] = this.items && this.items[index], 
                    this.extraName && (scope[this.extraName(this.$scope)] = this.items[index]);
                }, VirtualRepeatController.prototype.poolBlock_ = function(index) {
                    this.pooledBlocks.push(this.blocks[index]), this.parentNode.removeChild(this.blocks[index].element[0]), 
                    delete this.blocks[index];
                }, VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
                    var fragment = this.$document[0].createDocumentFragment();
                    return blocks.forEach((function(block) {
                        fragment.appendChild(block.element[0]);
                    })), fragment;
                }, VirtualRepeatController.prototype.updateIndexes_ = function() {
                    var itemsLength = this.items ? this.items.length : 0, containerLength = Math.ceil(this.container.getSize() / this.itemSize);
                    this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize))), 
                    this.newVisibleEnd = this.newStartIndex + containerLength + 3, this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd), 
                    this.newStartIndex = Math.max(0, this.newStartIndex - 3);
                }, VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
                    for (var i = start; i < end; i++) this.hasOwnProperty(i) || (this[i] = this.model.getItemAtIndex(i));
                    this.length = this.model.getLength();
                }, ForceHeightDirective.$inject = [ "$mdUtil" ];
            }(), function() {
                function MdWhiteframeDirective($log) {
                    return {
                        link: function(scope, element, attr) {
                            var oldClass = "";
                            attr.$observe("mdWhiteframe", (function(elevation) {
                                -1 != (elevation = parseInt(elevation, 10) || 4) && (elevation > 24 || elevation < 1) && ($log.warn("md-whiteframe attribute value is invalid. It should be a number between 1 and 24", element[0]), 
                                elevation = 4);
                                var newClass = -1 == elevation ? "" : "md-whiteframe-" + elevation + "dp";
                                attr.$updateClass(newClass, oldClass), oldClass = newClass;
                            }));
                        }
                    };
                }
                MdWhiteframeDirective.$inject = [ "$log" ], angular.module("material.components.whiteframe", [ "material.core" ]).directive("mdWhiteframe", MdWhiteframeDirective);
            }(), angular.module("material.core").constant("$MD_THEME_CSS", 'md-autocomplete.md-THEME_NAME-theme{background:"{{background-hue-1}}"}md-autocomplete.md-THEME_NAME-theme[disabled]:not([md-floating-label]){background:"{{background-hue-2}}"}md-autocomplete.md-THEME_NAME-theme button md-icon path{fill:"{{background-600}}"}md-autocomplete.md-THEME_NAME-theme button:after{background:"{{background-600-0.3}}"}md-autocomplete.md-THEME_NAME-theme input{color:"{{foreground-1}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused .md-input{border-color:"{{accent-color}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused label,md-autocomplete.md-THEME_NAME-theme.md-accent md-input-container.md-input-focused md-icon{color:"{{accent-color}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-progress-linear .md-container{background-color:"{{accent-100}}"}md-autocomplete.md-THEME_NAME-theme.md-accent md-progress-linear .md-bar{background-color:"{{accent-color}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused .md-input{border-color:"{{warn-A700}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused label,md-autocomplete.md-THEME_NAME-theme.md-warn md-input-container.md-input-focused md-icon{color:"{{warn-A700}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-progress-linear .md-container{background-color:"{{warn-100}}"}md-autocomplete.md-THEME_NAME-theme.md-warn md-progress-linear .md-bar{background-color:"{{warn-color}}"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme,.md-autocomplete-suggestions-container.md-THEME_NAME-theme{background:"{{background-hue-1}}"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme .md-autocomplete-suggestion,.md-autocomplete-suggestions-container.md-THEME_NAME-theme .md-autocomplete-suggestion{color:"{{foreground-1}}"}.md-autocomplete-standard-list-container.md-THEME_NAME-theme .md-autocomplete-suggestion.selected,.md-autocomplete-standard-list-container.md-THEME_NAME-theme .md-autocomplete-suggestion:hover,.md-autocomplete-suggestions-container.md-THEME_NAME-theme .md-autocomplete-suggestion.selected,.md-autocomplete-suggestions-container.md-THEME_NAME-theme .md-autocomplete-suggestion:hover{background:"{{background-500-0.18}}"}md-backdrop{background-color:"{{background-900-0.0}}"}md-backdrop.md-opaque.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-bottom-sheet.md-THEME_NAME-theme{background-color:"{{background-color}}";border-top-color:"{{background-hue-3}}"}md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item{color:"{{foreground-1}}"}md-bottom-sheet.md-THEME_NAME-theme .md-subheader{background-color:"{{background-color}}";color:"{{foreground-1}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]):hover{background-color:"{{background-500-0.2}}"}.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover{background-color:transparent}.md-button.md-THEME_NAME-theme.md-fab{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab,.md-button.md-THEME_NAME-theme.md-primary.md-raised{background-color:"{{primary-color}}";color:"{{primary-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon{color:"{{primary-contrast}}"}.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover{background-color:"{{primary-600}}"}.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon{color:"{{primary-color}}"}.md-button.md-THEME_NAME-theme.md-raised{background-color:"{{background-50}}";color:"{{background-900}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon{color:"{{background-900}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover{background-color:"{{background-50}}"}.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused{background-color:"{{background-200}}"}.md-button.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab,.md-button.md-THEME_NAME-theme.md-warn.md-raised{background-color:"{{warn-color}}";color:"{{warn-contrast}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon{color:"{{warn-contrast}}"}.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover{background-color:"{{warn-600}}"}.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon{color:"{{warn-color}}"}.md-button.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab,.md-button.md-THEME_NAME-theme.md-accent.md-raised{background-color:"{{accent-color}}";color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon{color:"{{accent-contrast}}"}.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover{background-color:"{{accent-A700}}"}.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon{color:"{{accent-color}}"}.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}";cursor:default}.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,.md-button.md-THEME_NAME-theme[disabled] md-icon{color:"{{foreground-3}}"}.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled]{background-color:"{{foreground-4}}"}.md-button.md-THEME_NAME-theme[disabled]{background-color:transparent}._md a.md-THEME_NAME-theme:not(.md-button).md-primary{color:"{{primary-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-primary:hover{color:"{{primary-700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent{color:"{{accent-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-accent:hover{color:"{{accent-A700}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn{color:"{{warn-color}}"}._md a.md-THEME_NAME-theme:not(.md-button).md-warn:hover{color:"{{warn-700}}"}md-card.md-THEME_NAME-theme{background-color:"{{background-hue-1}}";border-radius:2px;color:"{{foreground-1}}"}md-card.md-THEME_NAME-theme .md-card-image{border-radius:2px 2px 0 0}md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon{background-color:"{{foreground-3}}";color:"{{background-color}}"}md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead,md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme .md-ripple{color:"{{accent-A700}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before{background-color:"{{accent-color-0.26}}"}md-checkbox.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon{background-color:"{{accent-color-0.87}}"}md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after{border-color:"{{background-default}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple{color:"{{primary-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple{color:"{{background-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon{background-color:"{{primary-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after{border-color:"{{primary-contrast-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple{color:"{{warn-600}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple{color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon{background-color:"{{warn-color-0.87}}"}md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before{background-color:"{{warn-color-0.26}}"}md-checkbox.md-THEME_NAME-theme[disabled]:not(.md-checked) .md-icon{border-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon{background-color:"{{foreground-3}}"}md-checkbox.md-THEME_NAME-theme[disabled] .md-label{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips{box-shadow:0 1px "{{foreground-4}}"}md-chips.md-THEME_NAME-theme .md-chips.md-focused{box-shadow:0 2px "{{primary-color}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input{color:"{{foreground-1}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-webkit-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-ms-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-ms-input-placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::placeholder{color:"{{foreground-3}}"}md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input:-moz-placeholder,md-chips.md-THEME_NAME-theme .md-chips .md-chip-input-container input::-moz-placeholder{color:"{{foreground-3}}";opacity:1}md-chips.md-THEME_NAME-theme md-chip{background:"{{background-300}}";color:"{{background-800}}"}md-chips.md-THEME_NAME-theme md-chip md-icon{color:"{{background-700}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused{background:"{{primary-color}}";color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip.md-focused md-icon{color:"{{primary-contrast}}"}md-chips.md-THEME_NAME-theme md-chip._md-chip-editing{background:transparent;color:"{{background-800}}"}md-chips.md-THEME_NAME-theme .md-chip-remove-container button.md-chip-remove md-icon,md-chips.md-THEME_NAME-theme .md-chip-remove-container buttonmd-chip-remove md-icon{fill:"{{foreground-2}}";color:"{{foreground-2}}"}.md-contact-suggestion span.md-contact-email{color:"{{background-400}}"}md-content.md-THEME_NAME-theme{background-color:"{{background-default}}";color:"{{foreground-1}}"}.md-THEME_NAME-theme .md-calendar{background:"{{background-hue-1}}";color:"{{foreground-1-0.87}}"}.md-THEME_NAME-theme .md-calendar tr:last-child td{border-bottom-color:"{{background-hue-2}}"}.md-THEME_NAME-theme .md-calendar-day-header{background:"{{background-500-0.32}}";color:"{{foreground-1-0.87}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator{border:1px solid "{{primary-500}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled{color:"{{primary-500-0.6}}"}.md-calendar-date.md-focus .md-THEME_NAME-theme .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover{background:"{{background-500-0.32}}"}.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator{background:"{{primary-500}}";border-color:transparent;color:"{{primary-500-contrast}}"}.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-calendar-month-label md-icon,.md-THEME_NAME-theme .md-datepicker-input{color:"{{foreground-1}}"}.md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input::-ms-input-placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input::placeholder{color:"{{foreground-3}}"}.md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder,.md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder{color:"{{foreground-3}}";opacity:1}.md-THEME_NAME-theme .md-datepicker-input-container{border-bottom-color:"{{foreground-4}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid,.md-warn .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused{border-bottom-color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar-pane{border-color:"{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle{border-top-color:"{{foreground-2}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{primary-color}}"}.md-accent .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon,.md-THEME_NAME-theme .md-datepicker-open.md-accent .md-datepicker-calendar-icon{color:"{{accent-color}}"}.md-THEME_NAME-theme .md-datepicker-open.md-warn .md-datepicker-calendar-icon,.md-warn .md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon{color:"{{warn-A700}}"}.md-THEME_NAME-theme .md-datepicker-calendar{background:"{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-input-mask-opaque{box-shadow:0 0 0 9999px "{{background-hue-1}}"}.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-input-container{background:"{{background-hue-1}}"}md-dialog.md-THEME_NAME-theme{background-color:"{{background-hue-1}}";border-radius:4px;color:"{{foreground-1}}"}md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions{border-top-color:"{{foreground-4}}"}md-divider.md-THEME_NAME-theme{border-color:"{{foreground-4}}"}md-fab-speed-dial.md-THEME_NAME-theme md-fab-trigger .md-fab.md-button[disabled]{background-color:"{{foreground-4}}"}md-fab-speed-dial.md-THEME_NAME-theme md-fab-actions .md-fab-action-item .md-button.md-fab.md-raised.md-mini.md-focused,md-fab-speed-dial.md-THEME_NAME-theme md-fab-actions .md-fab-action-item .md-button.md-fab.md-raised.md-mini:hover{background-color:"{{background-500}}"}md-icon.md-THEME_NAME-theme{color:"{{foreground-2}}"}md-icon.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}md-icon.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}md-icon.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-input-container.md-THEME_NAME-theme .md-input{border-color:"{{background-default-contrast-divider}}";color:"{{background-default-contrast}}"}md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme .md-input::-ms-input-placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme .md-input::placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder{color:"{{background-default-contrast-secondary}}";opacity:1}md-input-container.md-THEME_NAME-theme>md-icon{color:"{{background-default-contrast}}"}md-input-container.md-THEME_NAME-theme .md-placeholder,md-input-container.md-THEME_NAME-theme label{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme label.md-required:after{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-focused):not(.md-input-invalid) label.md-required:after{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation,md-input-container.md-THEME_NAME-theme .md-input-messages-animation{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme .md-input-message-animation .md-char-counter,md-input-container.md-THEME_NAME-theme .md-input-messages-animation .md-char-counter{color:"{{background-default-contrast}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-webkit-input-placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-ms-input-placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-ms-input-placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::placeholder{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme.md-input-focused .md-input:-moz-placeholder,md-input-container.md-THEME_NAME-theme.md-input-focused .md-input::-moz-placeholder{color:"{{background-default-contrast-secondary}}";opacity:1}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label{color:"{{background-default-contrast-secondary}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-resized .md-input{border-color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon{color:"{{primary-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent md-icon{color:"{{accent-color}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label,md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn md-icon{color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input{border-color:"{{warn-A700}}"}md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter,md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input-message-animation,md-input-container.md-THEME_NAME-theme.md-input-invalid label{color:"{{warn-A700}}"}[disabled] md-input-container.md-THEME_NAME-theme .md-input,md-input-container.md-THEME_NAME-theme .md-input[disabled]{background-image:linear-gradient(90deg,"{{background-default-contrast-disabled}}" 0,"{{background-default-contrast-disabled}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{background-default-contrast-disabled}}" 100%);border-bottom-color:transparent;color:"{{background-default-contrast-disabled}}"}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4{color:"{{foreground-1}}"}md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style{background-color:"{{background-100}}"}md-list.md-THEME_NAME-theme md-list-item .md-avatar-icon{background-color:"{{foreground-3}}";color:"{{background-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon{color:"{{foreground-2}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight{color:"{{primary-color}}"}md-list.md-THEME_NAME-theme md-list-item>md-icon.md-highlight.md-accent{color:"{{accent-color}}"}md-menu-content.md-THEME_NAME-theme{background-color:"{{background-hue-1}}"}md-menu-content.md-THEME_NAME-theme md-menu-item{color:"{{foreground-1}}"}md-menu-content.md-THEME_NAME-theme md-menu-item md-icon{color:"{{foreground-2}}"}md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled],md-menu-content.md-THEME_NAME-theme md-menu-item .md-button[disabled] md-icon{color:"{{foreground-3}}"}md-menu-content.md-THEME_NAME-theme md-menu-divider{background-color:"{{foreground-4}}"}md-menu-bar.md-THEME_NAME-theme>button.md-button{border-radius:2px;color:"{{foreground-1}}"}md-menu-bar.md-THEME_NAME-theme md-menu>button{color:"{{foreground-1}}"}md-menu-bar.md-THEME_NAME-theme md-menu.md-open>button,md-menu-bar.md-THEME_NAME-theme md-menu>button:focus{background-color:"{{ background-500-0.18}}";outline:none}md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover>button{background-color:"{{ background-500-0.18}}"}md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover{background:transparent}md-menu-content.md-THEME_NAME-theme .md-menu>.md-button:after{color:"{{foreground-2}}"}md-menu-content.md-THEME_NAME-theme .md-menu.md-open>.md-button{background-color:"{{ background-500-0.18}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar{background-color:"{{background-hue-1}}";color:"{{foreground-1}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler{background-color:"{{primary-color}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon{color:"{{primary-contrast}}"}md-nav-bar.md-THEME_NAME-theme .md-nav-bar{background-color:transparent;border-color:"{{foreground-4}}"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button.md-unselected{color:"{{foreground-2}}"}md-nav-bar.md-THEME_NAME-theme .md-button._md-nav-button[disabled]{color:"{{foreground-3}}"}md-nav-bar.md-THEME_NAME-theme md-nav-ink-bar{background:"{{accent-color}}";color:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar{background-color:"{{accent-color}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-accent>.md-nav-bar md-nav-ink-bar{background:"{{primary-600-1}}";color:"{{primary-600-1}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar{background-color:"{{warn-color}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-warn>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar{background-color:"{{primary-color}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-active,md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-nav-bar.md-THEME_NAME-theme.md-primary>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{primary-color}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{primary-100}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{primary-contrast}}"}md-toolbar>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{accent-color}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{accent-A100}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{accent-contrast}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{accent-contrast-0.1}}"}md-toolbar.md-accent>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar md-nav-ink-bar{background:"{{primary-600-1}}";color:"{{primary-600-1}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar{background-color:"{{warn-color}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button{color:"{{warn-100}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-active,md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{color:"{{warn-contrast}}"}md-toolbar.md-warn>md-nav-bar.md-THEME_NAME-theme>.md-nav-bar .md-button._md-nav-button.md-focused{background:"{{warn-contrast-0.1}}"}._md-panel-backdrop.md-THEME_NAME-theme{background-color:"{{background-900-1.0}}"}md-progress-circular.md-THEME_NAME-theme path{stroke:"{{primary-color}}"}md-progress-circular.md-THEME_NAME-theme.md-warn path{stroke:"{{warn-color}}"}md-progress-circular.md-THEME_NAME-theme.md-accent path{stroke:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme .md-container{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme .md-bar{background-color:"{{primary-color}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-container{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar{background-color:"{{warn-color}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-container{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar{background-color:"{{accent-color}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-bar1{background-color:"{{primary-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-primary .md-dashed:before{background:radial-gradient("{{primary-100}}" 0,"{{primary-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1{background-color:"{{warn-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before{background:radial-gradient("{{warn-100}}" 0,"{{warn-100}}" 16%,transparent 42%)}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1{background-color:"{{accent-100}}"}md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before{background:radial-gradient("{{accent-100}}" 0,"{{accent-100}}" 16%,transparent 42%)}md-radio-button.md-THEME_NAME-theme .md-off{border-color:"{{foreground-2}}"}md-radio-button.md-THEME_NAME-theme .md-on{background-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-off{border-color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple{color:"{{accent-color-0.87}}"}md-radio-button.md-THEME_NAME-theme .md-container .md-ripple{color:"{{accent-A700}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on{background-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off{border-color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple{color:"{{primary-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple{color:"{{primary-600}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on{background-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off{border-color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple{color:"{{warn-color-0.87}}"}md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple{color:"{{warn-600}}"}md-radio-button.md-THEME_NAME-theme[disabled],md-radio-group.md-THEME_NAME-theme[disabled]{color:"{{foreground-3}}"}md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on{border-color:"{{foreground-3}}"}md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple{color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple,md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple{color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused.ng-empty>md-radio-button:first-child .md-container:before{background-color:"{{foreground-3-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before{background-color:"{{accent-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before{background-color:"{{primary-color-0.26}}"}md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before{background-color:"{{warn-color-0.26}}"}md-input-container md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-input-container:not(.md-input-focused):not(.md-input-invalid) md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{foreground-3}}"}md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value,md-input-container.md-input-focused:not(.md-input-has-value) md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{primary-color}}"}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme .md-select-value{border-bottom-color:"{{warn-A700}}"!important;color:"{{warn-A700}}"!important}md-input-container.md-input-invalid md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-input-container:not(.md-input-invalid).md-input-focused.md-accent .md-select-value{border-color:"{{accent-color}}"}md-input-container:not(.md-input-invalid).md-input-focused.md-accent .md-select-value span{color:"{{accent-color}}"}md-input-container:not(.md-input-invalid).md-input-focused.md-warn .md-select-value{border-color:"{{warn-A700}}"}md-input-container:not(.md-input-invalid).md-input-focused.md-warn .md-select-value span{color:"{{warn-A700}}"}md-select.md-THEME_NAME-theme[disabled] .md-select-value{background-image:linear-gradient(90deg,"{{foreground-3}}" 0,"{{foreground-3}}" 33%,transparent 0);background-image:-ms-linear-gradient(left,transparent 0,"{{foreground-3}}" 100%);border-bottom-color:transparent}md-select.md-THEME_NAME-theme .md-select-value{border-bottom-color:"{{foreground-4}}"}md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-value span:first-child:after{color:"{{warn-A700}}"}md-select.md-THEME_NAME-theme.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched .md-select-value{border-bottom-color:"{{warn-A700}}"!important;color:"{{warn-A700}}"!important}md-select.md-THEME_NAME-theme.ng-invalid.ng-touched.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value{border-bottom-color:"{{primary-color}}";color:"{{ foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder{color:"{{ foreground-1 }}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-no-underline .md-select-value{border-bottom-color:transparent!important}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value{border-bottom-color:"{{accent-color}}"}md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value{border-bottom-color:"{{warn-color}}"}md-select.md-THEME_NAME-theme[disabled] .md-select-icon,md-select.md-THEME_NAME-theme[disabled] .md-select-value,md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder{color:"{{foreground-3}}"}md-select.md-THEME_NAME-theme .md-select-icon{color:"{{foreground-2}}"}md-select-menu.md-THEME_NAME-theme md-content{background-color:"{{background-hue-1}}"}md-select-menu.md-THEME_NAME-theme md-content md-optgroup{color:"{{foreground-2}}"}md-select-menu.md-THEME_NAME-theme md-content md-option{color:"{{foreground-1}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[disabled] .md-text{color:"{{foreground-3}}"}md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):hover{background-color:"{{background-500-0.10}}"}md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]).md-focused,md-select-menu.md-THEME_NAME-theme md-content md-option:not([disabled]):focus{background-color:"{{background-500-0.18}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected]{color:"{{primary-500}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-focused,md-select-menu.md-THEME_NAME-theme md-content md-option[selected]:focus{color:"{{primary-600}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent{color:"{{accent-color}}"}md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent.md-focused,md-select-menu.md-THEME_NAME-theme md-content md-option[selected].md-accent:focus{color:"{{accent-A700}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ripple{color:"{{primary-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple{color:"{{background-600}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple{color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple{color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme:not(.md-checked) .md-icon{border-color:"{{foreground-2}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon{background-color:"{{primary-color-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused .md-container:before{background-color:"{{primary-color-0.26}}"}.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon:after{border-color:"{{primary-contrast-0.87}}"}.md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] .md-container{color:"{{foreground-3}}"}.md-checkbox-enabled.md-THEME_NAME-theme md-option .md-text{color:"{{foreground-1}}"}md-sidenav.md-THEME_NAME-theme,md-sidenav.md-THEME_NAME-theme md-content{background-color:"{{background-hue-1}}"}md-slider.md-THEME_NAME-theme .md-track{background-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme .md-track-ticks{color:"{{background-contrast}}"}md-slider.md-THEME_NAME-theme .md-focus-ring{background-color:"{{accent-A200-0.2}}"}md-slider.md-THEME_NAME-theme .md-disabled-thumb{background-color:"{{background-color}}";border-color:"{{background-color}}"}md-slider.md-THEME_NAME-theme.md-min .md-thumb:after{background-color:"{{background-color}}";border-color:"{{foreground-3}}"}md-slider.md-THEME_NAME-theme.md-min .md-focus-ring{background-color:"{{foreground-3-0.38}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-thumb:after{background-color:"{{background-contrast}}";border-color:transparent}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme.md-min[md-discrete][md-vertical] .md-sign:after{border-left-color:"{{background-400}}";border-top-color:transparent}md-slider.md-THEME_NAME-theme .md-track.md-track-fill{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-thumb:after{background-color:"{{accent-color}}";border-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign{background-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme .md-sign:after{border-top-color:"{{accent-color}}"}md-slider.md-THEME_NAME-theme[md-vertical] .md-sign:after{border-left-color:"{{accent-color}}";border-top-color:transparent}md-slider.md-THEME_NAME-theme .md-thumb-text{color:"{{accent-contrast}}"}md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring{background-color:"{{warn-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after{background-color:"{{warn-color}}";border-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign{background-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn .md-sign:after{border-top-color:"{{warn-color}}"}md-slider.md-THEME_NAME-theme.md-warn[md-vertical] .md-sign:after{border-left-color:"{{warn-color}}";border-top-color:transparent}md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text{color:"{{warn-contrast}}"}md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring{background-color:"{{primary-200-0.38}}"}md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after{background-color:"{{primary-color}}";border-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign{background-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary .md-sign:after{border-top-color:"{{primary-color}}"}md-slider.md-THEME_NAME-theme.md-primary[md-vertical] .md-sign:after{border-left-color:"{{primary-color}}";border-top-color:transparent}md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text{color:"{{primary-contrast}}"}md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after{border-color:transparent}md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after,md-slider.md-THEME_NAME-theme[disabled][md-discrete] .md-thumb:after{background-color:"{{foreground-3}}";border-color:transparent}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign{background-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-sign:after{border-top-color:"{{background-400}}"}md-slider.md-THEME_NAME-theme[disabled][readonly][md-vertical] .md-sign:after{border-left-color:"{{background-400}}";border-top-color:transparent}md-slider.md-THEME_NAME-theme[disabled][readonly] .md-disabled-thumb{background-color:transparent;border-color:transparent}md-slider-container[disabled]>:first-child:not(md-slider),md-slider-container[disabled]>:last-child:not(md-slider){color:"{{foreground-3}}"}.md-subheader.md-THEME_NAME-theme{background-color:"{{background-default}}";color:"{{ foreground-2-0.54 }}"}.md-subheader.md-THEME_NAME-theme.md-primary{color:"{{primary-color}}"}.md-subheader.md-THEME_NAME-theme.md-accent{color:"{{accent-color}}"}.md-subheader.md-THEME_NAME-theme.md-warn{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme .md-ink-ripple{color:"{{background-500}}"}md-switch.md-THEME_NAME-theme .md-thumb{background-color:"{{background-50}}"}md-switch.md-THEME_NAME-theme .md-bar{background-color:"{{background-500}}"}md-switch.md-THEME_NAME-theme.md-focused:not(.md-checked) .md-thumb:before,md-switch.md-THEME_NAME-theme.md-focused[disabled] .md-thumb:before{background-color:"{{foreground-4}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-ink-ripple{color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-thumb{background-color:"{{accent-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]) .md-bar{background-color:"{{accent-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-focused .md-thumb:before{background-color:"{{accent-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-ink-ripple{color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-thumb{background-color:"{{primary-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary .md-bar{background-color:"{{primary-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-primary.md-focused .md-thumb:before{background-color:"{{primary-color-0.26}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-ink-ripple{color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-thumb{background-color:"{{warn-color}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn .md-bar{background-color:"{{warn-color-0.5}}"}md-switch.md-THEME_NAME-theme.md-checked:not([disabled]).md-warn.md-focused .md-thumb:before{background-color:"{{warn-color-0.26}}"}md-switch.md-THEME_NAME-theme[disabled] .md-thumb{background-color:"{{background-400}}"}md-switch.md-THEME_NAME-theme[disabled] .md-bar{background-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme md-tabs-wrapper{background-color:transparent;border-color:"{{foreground-4}}"}md-tabs.md-THEME_NAME-theme md-next-button md-icon,md-tabs.md-THEME_NAME-theme md-prev-button md-icon{color:"{{foreground-2}}"}md-tabs.md-THEME_NAME-theme md-ink-bar{background:"{{accent-color}}";color:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme .md-tab{color:"{{foreground-2}}"}md-tabs.md-THEME_NAME-theme .md-tab[disabled],md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon{color:"{{foreground-3}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-active,md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon,md-tabs.md-THEME_NAME-theme .md-tab.md-focused,md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon{color:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme .md-tab.md-focused{background:"{{primary-color-0.1}}"}md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container{color:"{{accent-A100}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper{background-color:"{{accent-500}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper md-next-button md-icon,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper md-prev-button md-icon{color:"{{accent-500-contrast-0.7}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-500-contrast-1}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-500-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-accent>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{accent-500-contrast}}";color:"{{accent-500-contrast}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper{background-color:"{{primary-color}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper md-next-button md-icon,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper md-prev-button md-icon{color:"{{primary-contrast}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-contrast-0.7}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-primary>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{accent-color}}";color:"{{accent-color}}"}md-tabs.md-THEME_NAME-theme.md-primary.md-no-ink-bar-color>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{primary-contrast}}";color:"{{primary-contrast}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper{background-color:"{{warn-500}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper md-next-button md-icon,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper md-prev-button md-icon{color:"{{warn-500-contrast}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-500-contrast-0.7}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-500-contrast-1}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-500-contrast-0.1}}"}md-tabs.md-THEME_NAME-theme.md-warn>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{warn-500-contrast}}";color:"{{warn-500-contrast}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{primary-color}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper md-next-button md-icon,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper md-prev-button md-icon{color:"{{primary-contrast}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{primary-contrast-0.7}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{primary-contrast}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{primary-contrast-0.1}}"}md-toolbar>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{accent-color}}";color:"{{accent-color}}"}md-toolbar>md-tabs.md-THEME_NAME-theme.md-no-ink-bar-color>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{primary-contrast}}";color:"{{primary-contrast}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{accent-500}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper md-next-button md-icon,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper md-prev-button md-icon{color:"{{accent-500-contrast-0.7}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{accent-500-contrast-1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{accent-500-contrast-0.1}}"}md-toolbar.md-accent>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{accent-500-contrast}}";color:"{{accent-500-contrast}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper{background-color:"{{warn-500}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper md-next-button md-icon,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper md-prev-button md-icon{color:"{{warn-500-contrast}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]),md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]) md-icon{color:"{{warn-500-contrast-0.7}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-active md-icon,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused,md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused md-icon{color:"{{warn-500-contrast-1}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-tab-item:not([disabled]).md-focused{background:"{{warn-500-contrast-0.1}}"}md-toolbar.md-warn>md-tabs.md-THEME_NAME-theme>md-tabs-wrapper>md-tabs-canvas>md-pagination-wrapper>md-ink-bar{background:"{{warn-500-contrast}}";color:"{{warn-500-contrast}}"}md-toast.md-THEME_NAME-theme .md-toast-content{background-color:#323232;color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button{color:"{{background-50}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight{color:"{{accent-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-primary{color:"{{primary-color}}"}md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn{color:"{{warn-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar){background-color:"{{primary-color}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon{fill:"{{primary-contrast}}";color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button[disabled] md-icon{fill:"{{primary-contrast-0.26}}";color:"{{primary-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float] .md-input{border-color:"{{primary-default-contrast-divider}}";color:"{{primary-default-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float] .md-input::-webkit-input-placeholder{color:"{{primary-default-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float] .md-input:-ms-input-placeholder{color:"{{primary-default-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float] .md-input::-ms-input-placeholder{color:"{{primary-default-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float] .md-input::placeholder{color:"{{primary-default-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float] .md-input:-moz-placeholder,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float] .md-input::-moz-placeholder{color:"{{primary-default-contrast-hint}}";opacity:1}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float].md-input-focused .md-input::-webkit-input-placeholder{color:"{{primary-default-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float].md-input-focused .md-input:-ms-input-placeholder{color:"{{primary-default-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float].md-input-focused .md-input::-ms-input-placeholder{color:"{{primary-default-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float].md-input-focused .md-input::placeholder{color:"{{primary-default-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float].md-input-focused .md-input:-moz-placeholder,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float].md-input-focused .md-input::-moz-placeholder{color:"{{primary-default-contrast-secondary}}";opacity:1}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused .md-input,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float]:not(.md-input-invalid).md-input-resized .md-input{border-color:"{{primary-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:"{{accent-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:"{{warn-A700}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent{background-color:"{{accent-500}}";color:"{{accent-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-ink-ripple{color:"{{accent-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-icon{fill:"{{accent-500-contrast}}";color:"{{accent-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent .md-button[disabled] md-icon{fill:"{{accent-500-contrast-0.26}}";color:"{{accent-500-contrast-0.26}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float] .md-input{border-color:"{{accent-500-contrast-divider}}";color:"{{accent-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float] .md-input::-webkit-input-placeholder{color:"{{accent-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float] .md-input:-ms-input-placeholder{color:"{{accent-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float] .md-input::-ms-input-placeholder{color:"{{accent-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float] .md-input::placeholder{color:"{{accent-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float] .md-input:-moz-placeholder,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float] .md-input::-moz-placeholder{color:"{{accent-500-contrast-hint}}";opacity:1}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float].md-input-focused .md-input::-webkit-input-placeholder{color:"{{accent-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float].md-input-focused .md-input:-ms-input-placeholder{color:"{{accent-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float].md-input-focused .md-input::-ms-input-placeholder{color:"{{accent-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float].md-input-focused .md-input::placeholder{color:"{{accent-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float].md-input-focused .md-input:-moz-placeholder,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float].md-input-focused .md-input::-moz-placeholder{color:"{{accent-500-contrast-secondary}}";opacity:1}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused .md-input,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float]:not(.md-input-invalid).md-input-resized .md-input{border-color:"{{primary-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:"{{accent-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:"{{warn-A700}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn{background-color:"{{warn-500}}";color:"{{warn-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-icon{fill:"{{warn-500-contrast}}";color:"{{warn-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float] .md-input{border-color:"{{warn-500-contrast-divider}}";color:"{{warn-500-contrast}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float] .md-input::-webkit-input-placeholder{color:"{{warn-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float] .md-input:-ms-input-placeholder{color:"{{warn-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float] .md-input::-ms-input-placeholder{color:"{{warn-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float] .md-input::placeholder{color:"{{warn-500-contrast-hint}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float] .md-input:-moz-placeholder,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float] .md-input::-moz-placeholder{color:"{{warn-500-contrast-hint}}";opacity:1}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float].md-input-focused .md-input::-webkit-input-placeholder{color:"{{warn-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float].md-input-focused .md-input:-ms-input-placeholder{color:"{{warn-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float].md-input-focused .md-input::-ms-input-placeholder{color:"{{warn-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float].md-input-focused .md-input::placeholder{color:"{{warn-500-contrast-secondary}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float].md-input-focused .md-input:-moz-placeholder,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float].md-input-focused .md-input::-moz-placeholder{color:"{{warn-500-contrast-secondary}}";opacity:1}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused .md-input,md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float]:not(.md-input-invalid).md-input-resized .md-input{border-color:"{{primary-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused.md-accent .md-input{border-color:"{{accent-color}}"}md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn md-input-container[md-no-float]:not(.md-input-invalid).md-input-focused.md-warn .md-input{border-color:"{{warn-500-contrast}}"}.md-panel.md-tooltip.md-THEME_NAME-theme{background-color:"{{background-700}}";color:"{{background-700-contrast}}"}body.md-THEME_NAME-theme,html.md-THEME_NAME-theme{background-color:"{{background-color}}";color:"{{foreground-1}}"}');
        }(window, window.angular), window.ngMaterial = {
            version: {
                full: "1.2.5"
            }
        };
    },
    993: (module, __unused_webpack_exports, __webpack_require__) => {
        __webpack_require__(789), __webpack_require__(811), __webpack_require__(613), __webpack_require__(937), 
        module.exports = "ngMaterial";
    },
    995: () => {
        !function(window) {
            "use strict";
            var minErrConfig = {
                objectMaxDepth: 5,
                urlErrorParamsEnabled: !0
            };
            function errorHandlingConfig(config) {
                if (!isObject(config)) return minErrConfig;
                isDefined(config.objectMaxDepth) && (minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN), 
                isDefined(config.urlErrorParamsEnabled) && isBoolean(config.urlErrorParamsEnabled) && (minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled);
            }
            function isValidObjectMaxDepth(maxDepth) {
                return isNumber(maxDepth) && maxDepth > 0;
            }
            function minErr(module, ErrorConstructor) {
                ErrorConstructor = ErrorConstructor || Error;
                var url = "https://errors.angularjs.org/1.8.3/", regex = url.replace(".", "\\.") + "[\\s\\S]*", errRegExp = new RegExp(regex, "g");
                return function() {
                    var paramPrefix, i, code = arguments[0], template = arguments[1], message = "[" + (module ? module + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map((function(arg) {
                        return toDebugString(arg, minErrConfig.objectMaxDepth);
                    }));
                    if (message += template.replace(/\{\d+\}/g, (function(match) {
                        var index = +match.slice(1, -1);
                        return index < templateArgs.length ? templateArgs[index].replace(errRegExp, "") : match;
                    })), message += "\n" + url + (module ? module + "/" : "") + code, minErrConfig.urlErrorParamsEnabled) for (i = 0, 
                    paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
                    return new ErrorConstructor(message);
                };
            }
            var msie, jqLite, jQuery, angularModule, REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", hasOwnProperty = Object.prototype.hasOwnProperty, lowercase = function(string) {
                return isString(string) ? string.toLowerCase() : string;
            }, uppercase = function(string) {
                return isString(string) ? string.toUpperCase() : string;
            }, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
            function isArrayLike(obj) {
                if (null == obj || isWindow(obj)) return !1;
                if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return !0;
                var length = "length" in Object(obj) && obj.length;
                return isNumber(length) && (length >= 0 && length - 1 in obj || "function" == typeof obj.item);
            }
            function forEach(obj, iterator, context) {
                var key, length;
                if (obj) if (isFunction(obj)) for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
                    var isPrimitive = "object" != typeof obj;
                    for (key = 0, length = obj.length; key < length; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
                } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
                return obj;
            }
            function forEachSorted(obj, iterator, context) {
                for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
                return keys;
            }
            function reverseParams(iteratorFn) {
                return function(value, key) {
                    iteratorFn(key, value);
                };
            }
            function nextUid() {
                return ++uid;
            }
            function setHashKey(obj, h) {
                h ? obj.$$hashKey = h : delete obj.$$hashKey;
            }
            function baseExtend(dst, objs, deep) {
                for (var h = dst.$$hashKey, i = 0, ii = objs.length; i < ii; ++i) {
                    var obj = objs[i];
                    if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; j < jj; j++) {
                        var key = keys[j], src = obj[key];
                        deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : "__proto__" !== key && (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), 
                        baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
                    }
                }
                return setHashKey(dst, h), dst;
            }
            function extend(dst) {
                return baseExtend(dst, slice.call(arguments, 1), !1);
            }
            function merge(dst) {
                return baseExtend(dst, slice.call(arguments, 1), !0);
            }
            function toInt(str) {
                return parseInt(str, 10);
            }
            msie = window.document.documentMode;
            var isNumberNaN = Number.isNaN || function(num) {
                return num != num;
            };
            function inherit(parent, extra) {
                return extend(Object.create(parent), extra);
            }
            function noop() {}
            function identity($) {
                return $;
            }
            function valueFn(value) {
                return function() {
                    return value;
                };
            }
            function hasCustomToString(obj) {
                return isFunction(obj.toString) && obj.toString !== toString;
            }
            function isUndefined(value) {
                return void 0 === value;
            }
            function isDefined(value) {
                return void 0 !== value;
            }
            function isObject(value) {
                return null !== value && "object" == typeof value;
            }
            function isBlankObject(value) {
                return null !== value && "object" == typeof value && !getPrototypeOf(value);
            }
            function isString(value) {
                return "string" == typeof value;
            }
            function isNumber(value) {
                return "number" == typeof value;
            }
            function isDate(value) {
                return "[object Date]" === toString.call(value);
            }
            function isArray(arr) {
                return Array.isArray(arr) || arr instanceof Array;
            }
            function isError(value) {
                switch (toString.call(value)) {
                  case "[object Error]":
                  case "[object Exception]":
                  case "[object DOMException]":
                    return !0;

                  default:
                    return value instanceof Error;
                }
            }
            function isFunction(value) {
                return "function" == typeof value;
            }
            function isRegExp(value) {
                return "[object RegExp]" === toString.call(value);
            }
            function isWindow(obj) {
                return obj && obj.window === obj;
            }
            function isScope(obj) {
                return obj && obj.$evalAsync && obj.$watch;
            }
            function isBoolean(value) {
                return "boolean" == typeof value;
            }
            function isPromiseLike(obj) {
                return obj && isFunction(obj.then);
            }
            noop.$inject = [], identity.$inject = [];
            var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
            var trim = function(value) {
                return isString(value) ? value.trim() : value;
            }, escapeForRegexp = function(s) {
                return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
            };
            function isElement(node) {
                return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
            }
            function nodeName_(element) {
                return lowercase(element.nodeName || element[0] && element[0].nodeName);
            }
            function includes(array, obj) {
                return -1 !== Array.prototype.indexOf.call(array, obj);
            }
            function arrayRemove(array, value) {
                var index = array.indexOf(value);
                return index >= 0 && array.splice(index, 1), index;
            }
            function copy(source, destination, maxDepth) {
                var obj, value, stackSource = [], stackDest = [];
                if (maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN, destination) {
                    if ((value = destination) && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value)) || (obj = destination, 
                    "[object ArrayBuffer]" === toString.call(obj))) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
                    if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                    return isArray(destination) ? destination.length = 0 : forEach(destination, (function(value, key) {
                        "$$hashKey" !== key && delete destination[key];
                    })), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination, maxDepth);
                }
                return copyElement(source, maxDepth);
                function copyRecurse(source, destination, maxDepth) {
                    if (--maxDepth < 0) return "...";
                    var key, h = destination.$$hashKey;
                    if (isArray(source)) for (var i = 0, ii = source.length; i < ii; i++) destination.push(copyElement(source[i], maxDepth)); else if (isBlankObject(source)) for (key in source) destination[key] = copyElement(source[key], maxDepth); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key], maxDepth)); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key], maxDepth));
                    return setHashKey(destination, h), destination;
                }
                function copyElement(source, maxDepth) {
                    if (!isObject(source)) return source;
                    var index = stackSource.indexOf(source);
                    if (-1 !== index) return stackDest[index];
                    if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
                    var needsRecurse = !1, destination = function(source) {
                        switch (toString.call(source)) {
                          case "[object Int8Array]":
                          case "[object Int16Array]":
                          case "[object Int32Array]":
                          case "[object Float32Array]":
                          case "[object Float64Array]":
                          case "[object Uint8Array]":
                          case "[object Uint8ClampedArray]":
                          case "[object Uint16Array]":
                          case "[object Uint32Array]":
                            return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

                          case "[object ArrayBuffer]":
                            if (!source.slice) {
                                var copied = new ArrayBuffer(source.byteLength);
                                return new Uint8Array(copied).set(new Uint8Array(source)), copied;
                            }
                            return source.slice(0);

                          case "[object Boolean]":
                          case "[object Number]":
                          case "[object String]":
                          case "[object Date]":
                            return new source.constructor(source.valueOf());

                          case "[object RegExp]":
                            var re = new RegExp(source.source, source.toString().match(/[^/]*$/)[0]);
                            return re.lastIndex = source.lastIndex, re;

                          case "[object Blob]":
                            return new source.constructor([ source ], {
                                type: source.type
                            });
                        }
                        if (isFunction(source.cloneNode)) return source.cloneNode(!0);
                    }(source);
                    return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), 
                    needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
                }
            }
            function simpleCompare(a, b) {
                return a === b || a != a && b != b;
            }
            function equals(o1, o2) {
                if (o1 === o2) return !0;
                if (null === o1 || null === o2) return !1;
                if (o1 != o1 && o2 != o2) return !0;
                var length, key, keySet, t1 = typeof o1;
                if (t1 === typeof o2 && "object" === t1) {
                    if (!isArray(o1)) {
                        if (isDate(o1)) return !!isDate(o2) && simpleCompare(o1.getTime(), o2.getTime());
                        if (isRegExp(o1)) return !!isRegExp(o2) && o1.toString() === o2.toString();
                        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                        for (key in keySet = createMap(), o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                            if (!equals(o1[key], o2[key])) return !1;
                            keySet[key] = !0;
                        }
                        for (key in o2) if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                        return !0;
                    }
                    if (!isArray(o2)) return !1;
                    if ((length = o1.length) === o2.length) {
                        for (key = 0; key < length; key++) if (!equals(o1[key], o2[key])) return !1;
                        return !0;
                    }
                }
                return !1;
            }
            var csp = function() {
                if (!isDefined(csp.rules)) {
                    var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
                    if (ngCspElement) {
                        var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                        csp.rules = {
                            noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                            noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                        };
                    } else csp.rules = {
                        noUnsafeEval: function() {
                            try {
                                return new Function(""), !1;
                            } catch (e) {
                                return !0;
                            }
                        }(),
                        noInlineStyle: !1
                    };
                }
                return csp.rules;
            }, jq = function() {
                if (isDefined(jq.name_)) return jq.name_;
                var el, i, prefix, name, ii = ngAttrPrefixes.length;
                for (i = 0; i < ii; ++i) if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
                    name = el.getAttribute(prefix + "jq");
                    break;
                }
                return jq.name_ = name;
            };
            function concat(array1, array2, index) {
                return array1.concat(slice.call(array2, index));
            }
            function sliceArgs(args, startIndex) {
                return slice.call(args, startIndex || 0);
            }
            function bind(self, fn) {
                var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
                return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
                    return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
                } : function() {
                    return arguments.length ? fn.apply(self, arguments) : fn.call(self);
                };
            }
            function toJsonReplacer(key, value) {
                var val = value;
                return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
                val;
            }
            function toJson(obj, pretty) {
                if (!isUndefined(obj)) return isNumber(pretty) || (pretty = pretty ? 2 : null), 
                JSON.stringify(obj, toJsonReplacer, pretty);
            }
            function fromJson(json) {
                return isString(json) ? JSON.parse(json) : json;
            }
            var ALL_COLONS = /:/g;
            function timezoneToOffset(timezone, fallback) {
                timezone = timezone.replace(ALL_COLONS, "");
                var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
                return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
            }
            function addDateMinutes(date, minutes) {
                return (date = new Date(date.getTime())).setMinutes(date.getMinutes() + minutes), 
                date;
            }
            function convertTimezoneToLocal(date, timezone, reverse) {
                reverse = reverse ? -1 : 1;
                var dateTimezoneOffset = date.getTimezoneOffset();
                return addDateMinutes(date, reverse * (timezoneToOffset(timezone, dateTimezoneOffset) - dateTimezoneOffset));
            }
            function startingTag(element) {
                element = jqLite(element).clone().empty();
                var elemHtml = jqLite("<div></div>").append(element).html();
                try {
                    return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, (function(match, nodeName) {
                        return "<" + lowercase(nodeName);
                    }));
                } catch (e) {
                    return lowercase(elemHtml);
                }
            }
            function tryDecodeURIComponent(value) {
                try {
                    return decodeURIComponent(value);
                } catch (e) {}
            }
            function parseKeyValue(keyValue) {
                var obj = {};
                return forEach((keyValue || "").split("&"), (function(keyValue) {
                    var splitPoint, key, val;
                    keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), -1 !== (splitPoint = keyValue.indexOf("=")) && (key = keyValue.substring(0, splitPoint), 
                    val = keyValue.substring(splitPoint + 1)), isDefined(key = tryDecodeURIComponent(key)) && (val = !isDefined(val) || tryDecodeURIComponent(val), 
                    hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val));
                })), obj;
            }
            function encodeUriSegment(val) {
                return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
            }
            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
            }
            var ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ];
            var isAutoBootstrapAllowed = function(document) {
                var script = document.currentScript;
                if (!script) return !0;
                if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) return !1;
                var attributes = script.attributes;
                return [ attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href") ].every((function(src) {
                    if (!src) return !0;
                    if (!src.value) return !1;
                    var link = document.createElement("a");
                    if (link.href = src.value, document.location.origin === link.origin) return !0;
                    switch (link.protocol) {
                      case "http:":
                      case "https:":
                      case "ftp:":
                      case "blob:":
                      case "file:":
                      case "data:":
                        return !0;

                      default:
                        return !1;
                    }
                }));
            }(window.document);
            function angularInit(element, bootstrap) {
                var appElement, module, config = {};
                if (forEach(ngAttrPrefixes, (function(prefix) {
                    var name = prefix + "app";
                    !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, 
                    module = element.getAttribute(name));
                })), forEach(ngAttrPrefixes, (function(prefix) {
                    var candidate, name = prefix + "app";
                    !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, 
                    module = candidate.getAttribute(name));
                })), appElement) {
                    if (!isAutoBootstrapAllowed) return void window.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
                    config.strictDi = null !== function(element, ngAttr) {
                        var attr, i, ii = ngAttrPrefixes.length;
                        for (i = 0; i < ii; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
                        return null;
                    }(appElement, "strict-di"), bootstrap(appElement, module ? [ module ] : [], config);
                }
            }
            function bootstrap(element, modules, config) {
                isObject(config) || (config = {});
                config = extend({
                    strictDi: !1
                }, config);
                var doBootstrap = function() {
                    if ((element = jqLite(element)).injector()) {
                        var tag = element[0] === window.document ? "document" : startingTag(element);
                        throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
                    }
                    (modules = modules || []).unshift([ "$provide", function($provide) {
                        $provide.value("$rootElement", element);
                    } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                        $compileProvider.debugInfoEnabled(!0);
                    } ]), modules.unshift("ng");
                    var injector = createInjector(modules, config.strictDi);
                    return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                        scope.$apply((function() {
                            element.data("$injector", injector), compile(element)(scope);
                        }));
                    } ]), injector;
                }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
                if (window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
                window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name)) return doBootstrap();
                window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), angular.resumeBootstrap = function(extraModules) {
                    return forEach(extraModules, (function(module) {
                        modules.push(module);
                    })), doBootstrap();
                }, isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap();
            }
            function reloadWithDebugInfo() {
                window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
            }
            function getTestability(rootElement) {
                var injector = angular.element(rootElement).injector();
                if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
                return injector.get("$$testability");
            }
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            function snake_case(name, separator) {
                return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, (function(letter, pos) {
                    return (pos ? separator : "") + letter.toLowerCase();
                }));
            }
            var bindJQueryFired = !1;
            function UNSAFE_restoreLegacyJqLiteXHTMLReplacement() {
                JQLite.legacyXHTMLReplacement = !0;
            }
            function assertArg(arg, name, reason) {
                if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
                return arg;
            }
            function assertArgFn(arg, name, acceptArrayAnnotation) {
                return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
                arg;
            }
            function assertNotHasOwnProperty(name, context) {
                if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
            }
            function getBlockNodes(nodes) {
                for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++) (blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), 
                blockNodes.push(node));
                return blockNodes || nodes;
            }
            function createMap() {
                return Object.create(null);
            }
            function stringify(value) {
                if (null == value) return "";
                switch (typeof value) {
                  case "string":
                    break;

                  case "number":
                    value = "" + value;
                    break;

                  default:
                    value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString();
                }
                return value;
            }
            var NODE_TYPE_ELEMENT = 1, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11;
            function shallowCopy(src, dst) {
                if (isArray(src)) {
                    dst = dst || [];
                    for (var i = 0, ii = src.length; i < ii; i++) dst[i] = src[i];
                } else if (isObject(src)) for (var key in dst = dst || {}, src) "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
                return dst || src;
            }
            function toDebugString(obj, maxDepth) {
                return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? function(obj, maxDepth) {
                    var seen = [];
                    return isValidObjectMaxDepth(maxDepth) && (obj = angular.copy(obj, null, maxDepth)), 
                    JSON.stringify(obj, (function(key, val) {
                        if (isObject(val = toJsonReplacer(key, val))) {
                            if (seen.indexOf(val) >= 0) return "...";
                            seen.push(val);
                        }
                        return val;
                    }));
                }(obj, maxDepth) : obj;
            }
            var version = {
                full: "1.8.3",
                major: 1,
                minor: 8,
                dot: 3,
                codeName: "ultimate-farewell"
            };
            JQLite.expando = "ng339";
            var jqCache = JQLite.cache = {}, jqId = 1;
            JQLite._data = function(node) {
                return this.cache[node[this.expando]] || {};
            };
            var DASH_LOWERCASE_REGEXP = /-([a-z])/g, MS_HACK_REGEXP = /^-ms-/, MOUSE_EVENT_MAP = {
                mouseleave: "mouseout",
                mouseenter: "mouseover"
            }, jqLiteMinErr = minErr("jqLite");
            function fnCamelCaseReplace(all, letter) {
                return letter.toUpperCase();
            }
            function kebabToCamel(name) {
                return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
            }
            var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
                thead: [ "table" ],
                col: [ "colgroup", "table" ],
                tr: [ "tbody", "table" ],
                td: [ "tr", "tbody", "table" ]
            };
            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
            wrapMap.th = wrapMap.td;
            var wrapMapIE9 = {
                option: [ 1, '<select multiple="multiple">', "</select>" ],
                _default: [ 0, "", "" ]
            };
            for (var key in wrapMap) {
                var wrapMapValueClosing = wrapMap[key], wrapMapValue = wrapMapValueClosing.slice().reverse();
                wrapMapIE9[key] = [ wrapMapValue.length, "<" + wrapMapValue.join("><") + ">", "</" + wrapMapValueClosing.join("></") + ">" ];
            }
            function jqLiteIsTextNode(html) {
                return !HTML_REGEXP.test(html);
            }
            function jqLiteAcceptsData(node) {
                var nodeType = node.nodeType;
                return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
            }
            function jqLiteBuildFragment(html, context) {
                var tmp, tag, wrap, finalHtml, i, fragment = context.createDocumentFragment(), nodes = [];
                if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
                    if (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
                    finalHtml = JQLite.legacyXHTMLReplacement ? html.replace(XHTML_TAG_REGEXP, "<$1></$2>") : html, 
                    msie < 10) for (wrap = wrapMapIE9[tag] || wrapMapIE9._default, tmp.innerHTML = wrap[1] + finalHtml + wrap[2], 
                    i = wrap[0]; i--; ) tmp = tmp.firstChild; else {
                        for (i = (wrap = wrapMap[tag] || []).length; --i > -1; ) tmp.appendChild(window.document.createElement(wrap[i])), 
                        tmp = tmp.firstChild;
                        tmp.innerHTML = finalHtml;
                    }
                    nodes = concat(nodes, tmp.childNodes), (tmp = fragment.firstChild).textContent = "";
                }
                return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, (function(node) {
                    fragment.appendChild(node);
                })), fragment;
            }
            wrapMapIE9.optgroup = wrapMapIE9.option;
            var jqLiteContains = window.Node.prototype.contains || function(arg) {
                return !!(16 & this.compareDocumentPosition(arg));
            };
            function JQLite(element) {
                if (element instanceof JQLite) return element;
                var argIsString, html, context, parsed;
                if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
                    if (argIsString && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                    return new JQLite(element);
                }
                argIsString ? jqLiteAddNodes(this, (html = element, context = context || window.document, 
                (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [])) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element);
            }
            function jqLiteClone(element) {
                return element.cloneNode(!0);
            }
            function jqLiteDealoc(element, onlyDescendants) {
                !onlyDescendants && jqLiteAcceptsData(element) && jqLite.cleanData([ element ]), 
                element.querySelectorAll && jqLite.cleanData(element.querySelectorAll("*"));
            }
            function isEmptyObject(obj) {
                var name;
                for (name in obj) return !1;
                return !0;
            }
            function removeIfEmptyData(element) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId], events = expandoStore && expandoStore.events, data = expandoStore && expandoStore.data;
                data && !isEmptyObject(data) || events && !isEmptyObject(events) || (delete jqCache[expandoId], 
                element.ng339 = void 0);
            }
            function jqLiteOff(element, type, fn, unsupported) {
                if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
                var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
                if (handle) {
                    if (type) {
                        var removeHandler = function(type) {
                            var listenerFns = events[type];
                            isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (element.removeEventListener(type, handle), 
                            delete events[type]);
                        };
                        forEach(type.split(" "), (function(type) {
                            removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type]);
                        }));
                    } else for (type in events) "$destroy" !== type && element.removeEventListener(type, handle), 
                    delete events[type];
                    removeIfEmptyData(element);
                }
            }
            function jqLiteRemoveData(element, name) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
                expandoStore && (name ? delete expandoStore.data[name] : expandoStore.data = {}, 
                removeIfEmptyData(element));
            }
            function jqLiteExpandoStore(element, createIfNecessary) {
                var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
                return createIfNecessary && !expandoStore && (element.ng339 = expandoId = ++jqId, 
                expandoStore = jqCache[expandoId] = {
                    events: {},
                    data: {},
                    handle: void 0
                }), expandoStore;
            }
            function jqLiteData(element, key, value) {
                if (jqLiteAcceptsData(element)) {
                    var prop, isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
                    if (isSimpleSetter) data[kebabToCamel(key)] = value; else {
                        if (massGetter) return data;
                        if (isSimpleGetter) return data && data[kebabToCamel(key)];
                        for (prop in key) data[kebabToCamel(prop)] = key[prop];
                    }
                }
            }
            function jqLiteHasClass(element, selector) {
                return !!element.getAttribute && (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1;
            }
            function jqLiteRemoveClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), newClasses = existingClasses;
                    forEach(cssClasses.split(" "), (function(cssClass) {
                        cssClass = trim(cssClass), newClasses = newClasses.replace(" " + cssClass + " ", " ");
                    })), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses));
                }
            }
            function jqLiteAddClass(element, cssClasses) {
                if (cssClasses && element.setAttribute) {
                    var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), newClasses = existingClasses;
                    forEach(cssClasses.split(" "), (function(cssClass) {
                        cssClass = trim(cssClass), -1 === newClasses.indexOf(" " + cssClass + " ") && (newClasses += cssClass + " ");
                    })), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses));
                }
            }
            function jqLiteAddNodes(root, elements) {
                if (elements) if (elements.nodeType) root[root.length++] = elements; else {
                    var length = elements.length;
                    if ("number" == typeof length && elements.window !== elements) {
                        if (length) for (var i = 0; i < length; i++) root[root.length++] = elements[i];
                    } else root[root.length++] = elements;
                }
            }
            function jqLiteController(element, name) {
                return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
            }
            function jqLiteInheritedData(element, name, value) {
                element.nodeType === NODE_TYPE_DOCUMENT && (element = element.documentElement);
                for (var names = isArray(name) ? name : [ name ]; element; ) {
                    for (var i = 0, ii = names.length; i < ii; i++) if (isDefined(value = jqLite.data(element, names[i]))) return value;
                    element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
                }
            }
            function jqLiteEmpty(element) {
                for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
            }
            function jqLiteRemove(element, keepData) {
                keepData || jqLiteDealoc(element);
                var parent = element.parentNode;
                parent && parent.removeChild(element);
            }
            function jqLiteReady(fn) {
                function trigger() {
                    window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger), 
                    fn();
                }
                "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger), 
                window.addEventListener("load", trigger));
            }
            var JQLitePrototype = JQLite.prototype = {
                ready: jqLiteReady,
                toString: function() {
                    var value = [];
                    return forEach(this, (function(e) {
                        value.push("" + e);
                    })), "[" + value.join(", ") + "]";
                },
                eq: function(index) {
                    return jqLite(index >= 0 ? this[index] : this[this.length + index]);
                },
                length: 0,
                push,
                sort: [].sort,
                splice: [].splice
            }, BOOLEAN_ATTR = {};
            forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), (function(value) {
                BOOLEAN_ATTR[lowercase(value)] = value;
            }));
            var BOOLEAN_ELEMENTS = {};
            forEach("input,select,option,textarea,button,form,details".split(","), (function(value) {
                BOOLEAN_ELEMENTS[value] = !0;
            }));
            var ALIASED_ATTR = {
                ngMinlength: "minlength",
                ngMaxlength: "maxlength",
                ngMin: "min",
                ngMax: "max",
                ngPattern: "pattern",
                ngStep: "step"
            };
            function getBooleanAttrName(element, name) {
                var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
                return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
            }
            function defaultHandlerWrapper(element, event, handler) {
                handler.call(element, event);
            }
            function specialMouseHandlerWrapper(target, event, handler) {
                var related = event.relatedTarget;
                related && (related === target || jqLiteContains.call(target, related)) || handler.call(target, event);
            }
            function $$jqLiteProvider() {
                this.$get = function() {
                    return extend(JQLite, {
                        hasClass: function(node, classes) {
                            return node.attr && (node = node[0]), jqLiteHasClass(node, classes);
                        },
                        addClass: function(node, classes) {
                            return node.attr && (node = node[0]), jqLiteAddClass(node, classes);
                        },
                        removeClass: function(node, classes) {
                            return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes);
                        }
                    });
                };
            }
            function hashKey(obj, nextUidFn) {
                var key = obj && obj.$$hashKey;
                if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
                var objType = typeof obj;
                return key = "function" === objType || "object" === objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
            }
            forEach({
                data: jqLiteData,
                removeData: jqLiteRemoveData,
                hasData: function(node) {
                    for (var key in jqCache[node.ng339]) return !0;
                    return !1;
                },
                cleanData: function(nodes) {
                    for (var i = 0, ii = nodes.length; i < ii; i++) jqLiteRemoveData(nodes[i]), jqLiteOff(nodes[i]);
                }
            }, (function(fn, name) {
                JQLite[name] = fn;
            })), forEach({
                data: jqLiteData,
                inheritedData: jqLiteInheritedData,
                scope: function(element) {
                    return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
                },
                isolateScope: function(element) {
                    return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
                },
                controller: jqLiteController,
                injector: function(element) {
                    return jqLiteInheritedData(element, "$injector");
                },
                removeAttr: function(element, name) {
                    element.removeAttribute(name);
                },
                hasClass: jqLiteHasClass,
                css: function(element, name, value) {
                    if (name = function(name) {
                        return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
                    }(name), !isDefined(value)) return element.style[name];
                    element.style[name] = value;
                },
                attr: function(element, name, value) {
                    var ret, nodeType = element.nodeType;
                    if (nodeType !== NODE_TYPE_TEXT && 2 !== nodeType && nodeType !== NODE_TYPE_COMMENT && element.getAttribute) {
                        var lowercasedName = lowercase(name), isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                        if (!isDefined(value)) return ret = element.getAttribute(name), isBooleanAttr && null !== ret && (ret = lowercasedName), 
                        null === ret ? void 0 : ret;
                        null === value || !1 === value && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value);
                    }
                },
                prop: function(element, name, value) {
                    if (!isDefined(value)) return element[name];
                    element[name] = value;
                },
                text: function() {
                    return getText.$dv = "", getText;
                    function getText(element, value) {
                        if (isUndefined(value)) {
                            var nodeType = element.nodeType;
                            return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                        }
                        element.textContent = value;
                    }
                }(),
                val: function(element, value) {
                    if (isUndefined(value)) {
                        if (element.multiple && "select" === nodeName_(element)) {
                            var result = [];
                            return forEach(element.options, (function(option) {
                                option.selected && result.push(option.value || option.text);
                            })), result;
                        }
                        return element.value;
                    }
                    element.value = value;
                },
                html: function(element, value) {
                    if (isUndefined(value)) return element.innerHTML;
                    jqLiteDealoc(element, !0), element.innerHTML = value;
                },
                empty: jqLiteEmpty
            }, (function(fn, name) {
                JQLite.prototype[name] = function(arg1, arg2) {
                    var i, key, nodeCount = this.length;
                    if (fn !== jqLiteEmpty && isUndefined(2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                        if (isObject(arg1)) {
                            for (i = 0; i < nodeCount; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                            return this;
                        }
                        for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; j < jj; j++) {
                            var nodeValue = fn(this[j], arg1, arg2);
                            value = value ? value + nodeValue : nodeValue;
                        }
                        return value;
                    }
                    for (i = 0; i < nodeCount; i++) fn(this[i], arg1, arg2);
                    return this;
                };
            })), forEach({
                removeData: jqLiteRemoveData,
                on: function(element, type, fn, unsupported) {
                    if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                    if (jqLiteAcceptsData(element)) {
                        var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                        handle || (handle = expandoStore.handle = function(element, events) {
                            var eventHandler = function(event, type) {
                                event.isDefaultPrevented = function() {
                                    return event.defaultPrevented;
                                };
                                var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
                                if (eventFnsLength) {
                                    if (isUndefined(event.immediatePropagationStopped)) {
                                        var originalStopImmediatePropagation = event.stopImmediatePropagation;
                                        event.stopImmediatePropagation = function() {
                                            event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                                            originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                                        };
                                    }
                                    event.isImmediatePropagationStopped = function() {
                                        return !0 === event.immediatePropagationStopped;
                                    };
                                    var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                                    eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                                    for (var i = 0; i < eventFnsLength; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i]);
                                }
                            };
                            return eventHandler.elem = element, eventHandler;
                        }(element, events));
                        for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                            var eventFns = events[type];
                            eventFns || ((eventFns = events[type] = []).specialHandlerWrapper = specialHandlerWrapper, 
                            "$destroy" === type || noEventListener || element.addEventListener(type, handle)), 
                            eventFns.push(fn);
                        }; i--; ) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), 
                        addHandler(type, void 0, !0)) : addHandler(type);
                    }
                },
                off: jqLiteOff,
                one: function(element, type, fn) {
                    (element = jqLite(element)).on(type, (function onFn() {
                        element.off(type, fn), element.off(type, onFn);
                    })), element.on(type, fn);
                },
                replaceWith: function(element, replaceNode) {
                    var index, parent = element.parentNode;
                    jqLiteDealoc(element), forEach(new JQLite(replaceNode), (function(node) {
                        index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                        index = node;
                    }));
                },
                children: function(element) {
                    var children = [];
                    return forEach(element.childNodes, (function(element) {
                        element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
                    })), children;
                },
                contents: function(element) {
                    return element.contentDocument || element.childNodes || [];
                },
                append: function(element, node) {
                    var nodeType = element.nodeType;
                    if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) for (var i = 0, ii = (node = new JQLite(node)).length; i < ii; i++) {
                        var child = node[i];
                        element.appendChild(child);
                    }
                },
                prepend: function(element, node) {
                    if (element.nodeType === NODE_TYPE_ELEMENT) {
                        var index = element.firstChild;
                        forEach(new JQLite(node), (function(child) {
                            element.insertBefore(child, index);
                        }));
                    }
                },
                wrap: function(element, wrapNode) {
                    var node, wrapper, parent;
                    node = element, wrapper = jqLite(wrapNode).eq(0).clone()[0], (parent = node.parentNode) && parent.replaceChild(wrapper, node), 
                    wrapper.appendChild(node);
                },
                remove: jqLiteRemove,
                detach: function(element) {
                    jqLiteRemove(element, !0);
                },
                after: function(element, newElement) {
                    var index = element, parent = element.parentNode;
                    if (parent) for (var i = 0, ii = (newElement = new JQLite(newElement)).length; i < ii; i++) {
                        var node = newElement[i];
                        parent.insertBefore(node, index.nextSibling), index = node;
                    }
                },
                addClass: jqLiteAddClass,
                removeClass: jqLiteRemoveClass,
                toggleClass: function(element, selector, condition) {
                    selector && forEach(selector.split(" "), (function(className) {
                        var classCondition = condition;
                        isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                    }));
                },
                parent: function(element) {
                    var parent = element.parentNode;
                    return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
                },
                next: function(element) {
                    return element.nextElementSibling;
                },
                find: function(element, selector) {
                    return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
                },
                clone: jqLiteClone,
                triggerHandler: function(element, event, extraParameters) {
                    var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
                    eventFns && (dummyEvent = {
                        preventDefault: function() {
                            this.defaultPrevented = !0;
                        },
                        isDefaultPrevented: function() {
                            return !0 === this.defaultPrevented;
                        },
                        stopImmediatePropagation: function() {
                            this.immediatePropagationStopped = !0;
                        },
                        isImmediatePropagationStopped: function() {
                            return !0 === this.immediatePropagationStopped;
                        },
                        stopPropagation: noop,
                        type: eventName,
                        target: element
                    }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
                    handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
                    forEach(eventFnsCopy, (function(fn) {
                        dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
                    })));
                }
            }, (function(fn, name) {
                JQLite.prototype[name] = function(arg1, arg2, arg3) {
                    for (var value, i = 0, ii = this.length; i < ii; i++) isUndefined(value) ? isDefined(value = fn(this[i], arg1, arg2, arg3)) && (value = jqLite(value)) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                    return isDefined(value) ? value : this;
                };
            })), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
            var nanKey = Object.create(null);
            function NgMapShim() {
                this._keys = [], this._values = [], this._lastKey = NaN, this._lastIndex = -1;
            }
            NgMapShim.prototype = {
                _idx: function(key) {
                    return key !== this._lastKey && (this._lastKey = key, this._lastIndex = this._keys.indexOf(key)), 
                    this._lastIndex;
                },
                _transformKey: function(key) {
                    return isNumberNaN(key) ? nanKey : key;
                },
                get: function(key) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    if (-1 !== idx) return this._values[idx];
                },
                has: function(key) {
                    return key = this._transformKey(key), -1 !== this._idx(key);
                },
                set: function(key, value) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    -1 === idx && (idx = this._lastIndex = this._keys.length), this._keys[idx] = key, 
                    this._values[idx] = value;
                },
                delete: function(key) {
                    key = this._transformKey(key);
                    var idx = this._idx(key);
                    return -1 !== idx && (this._keys.splice(idx, 1), this._values.splice(idx, 1), this._lastKey = NaN, 
                    this._lastIndex = -1, !0);
                }
            };
            var NgMap = NgMapShim, $$MapProvider = [ function() {
                this.$get = [ function() {
                    return NgMap;
                } ];
            } ], ARROW_ARG = /^([^(]+?)=>/, FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
            function stringifyFn(fn) {
                return Function.prototype.toString.call(fn);
            }
            function extractArgs(fn) {
                var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, "");
                return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
            }
            function createInjector(modulesToLoad, strictDi) {
                strictDi = !0 === strictDi;
                var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap, providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject((function(name, constructor) {
                            return factory(name, [ "$injector", function($injector) {
                                return $injector.instantiate(constructor);
                            } ]);
                        })),
                        value: supportObject((function(name, val) {
                            return factory(name, valueFn(val), !1);
                        })),
                        constant: supportObject((function(name, value) {
                            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
                        })),
                        decorator: function(serviceName, decorFn) {
                            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                            origProvider.$get = function() {
                                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                                return instanceInjector.invoke(decorFn, null, {
                                    $delegate: origInstance
                                });
                            };
                        }
                    }
                }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, (function(serviceName, caller) {
                    throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
                })), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, (function(serviceName, caller) {
                    var provider = providerInjector.get(serviceName + providerSuffix, caller);
                    return instanceInjector.invoke(provider.$get, provider, void 0, serviceName);
                })), instanceInjector = protoInstanceInjector;
                providerCache["$injector" + providerSuffix] = {
                    $get: valueFn(protoInstanceInjector)
                }, instanceInjector.modules = providerInjector.modules = createMap();
                var runBlocks = loadModules(modulesToLoad);
                return (instanceInjector = protoInstanceInjector.get("$injector")).strictDi = strictDi, 
                forEach(runBlocks, (function(fn) {
                    fn && instanceInjector.invoke(fn);
                })), instanceInjector.loadNewModules = function(mods) {
                    forEach(loadModules(mods), (function(fn) {
                        fn && instanceInjector.invoke(fn);
                    }));
                }, instanceInjector;
                function supportObject(delegate) {
                    return function(key, value) {
                        if (!isObject(key)) return delegate(key, value);
                        forEach(key, reverseParams(delegate));
                    };
                }
                function provider(name, provider_) {
                    if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
                    !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                    return providerCache[name + providerSuffix] = provider_;
                }
                function enforceReturnValue(name, factory) {
                    return function() {
                        var result = instanceInjector.invoke(factory, this);
                        if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                        return result;
                    };
                }
                function factory(name, factoryFn, enforce) {
                    return provider(name, {
                        $get: !1 !== enforce ? enforceReturnValue(name, factoryFn) : factoryFn
                    });
                }
                function loadModules(modulesToLoad) {
                    assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
                    var moduleFn, runBlocks = [];
                    return forEach(modulesToLoad, (function(module) {
                        if (!loadedModules.get(module)) {
                            loadedModules.set(module, !0);
                            try {
                                isString(module) ? (moduleFn = angularModule(module), instanceInjector.modules[module] = moduleFn, 
                                runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                                runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) || isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                            } catch (e) {
                                throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                                $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                            }
                        }
                        function runInvokeQueue(queue) {
                            var i, ii;
                            for (i = 0, ii = queue.length; i < ii; i++) {
                                var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                                provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                            }
                        }
                    })), runBlocks;
                }
                function createInternalInjector(cache, factory) {
                    function getService(serviceName, caller) {
                        if (cache.hasOwnProperty(serviceName)) {
                            if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                            return cache[serviceName];
                        }
                        try {
                            return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller), 
                            cache[serviceName];
                        } catch (err) {
                            throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                        } finally {
                            path.shift();
                        }
                    }
                    function injectionArgs(fn, locals, serviceName) {
                        for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; i < length; i++) {
                            var key = $inject[i];
                            if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                            args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                        }
                        return args;
                    }
                    return {
                        invoke: function(fn, self, locals, serviceName) {
                            "string" == typeof locals && (serviceName = locals, locals = null);
                            var args = injectionArgs(fn, locals, serviceName);
                            return isArray(fn) && (fn = fn[fn.length - 1]), function(func) {
                                if (msie || "function" != typeof func) return !1;
                                var result = func.$$ngIsClass;
                                return isBoolean(result) || (result = func.$$ngIsClass = /^class\b/.test(stringifyFn(func))), 
                                result;
                            }(fn) ? (args.unshift(null), new (Function.prototype.bind.apply(fn, args))) : fn.apply(self, args);
                        },
                        instantiate: function(Type, locals, serviceName) {
                            var ctor = isArray(Type) ? Type[Type.length - 1] : Type, args = injectionArgs(Type, locals, serviceName);
                            return args.unshift(null), new (Function.prototype.bind.apply(ctor, args));
                        },
                        get: getService,
                        annotate: createInjector.$$annotate,
                        has: function(name) {
                            return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                        }
                    };
                }
            }
            function $AnchorScrollProvider() {
                var autoScrollingEnabled = !0;
                this.disableAutoScrolling = function() {
                    autoScrollingEnabled = !1;
                }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
                    var document = $window.document;
                    function scrollTo(elem) {
                        if (elem) {
                            elem.scrollIntoView();
                            var offset = function() {
                                var offset = scroll.yOffset;
                                if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                                    var elem = offset[0];
                                    offset = "fixed" !== $window.getComputedStyle(elem).position ? 0 : elem.getBoundingClientRect().bottom;
                                } else isNumber(offset) || (offset = 0);
                                return offset;
                            }();
                            if (offset) {
                                var elemTop = elem.getBoundingClientRect().top;
                                $window.scrollBy(0, elemTop - offset);
                            }
                        } else $window.scrollTo(0, 0);
                    }
                    function scroll(hash) {
                        var elm, list, result;
                        (hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash()) ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (list = document.getElementsByName(hash), 
                        result = null, Array.prototype.some.call(list, (function(element) {
                            if ("a" === nodeName_(element)) return result = element, !0;
                        })), (elm = result) ? scrollTo(elm) : "top" === hash && scrollTo(null)) : scrollTo(null);
                    }
                    return autoScrollingEnabled && $rootScope.$watch((function() {
                        return $location.hash();
                    }), (function(newVal, oldVal) {
                        var action, win;
                        newVal === oldVal && "" === newVal || (action = function() {
                            $rootScope.$evalAsync(scroll);
                        }, "complete" === (win = win || window).document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action));
                    })), scroll;
                } ];
            }
            createInjector.$$annotate = function(fn, strictDi, name) {
                var $inject, last;
                if ("function" == typeof fn) {
                    if (!($inject = fn.$inject)) {
                        if ($inject = [], fn.length) {
                            if (strictDi) throw isString(name) && name || (name = fn.name || function(fn) {
                                var args = extractArgs(fn);
                                return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
                            }(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                            forEach(extractArgs(fn)[1].split(FN_ARG_SPLIT), (function(arg) {
                                arg.replace(FN_ARG, (function(all, underscore, name) {
                                    $inject.push(name);
                                }));
                            }));
                        }
                        fn.$inject = $inject;
                    }
                } else isArray(fn) ? (assertArgFn(fn[last = fn.length - 1], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
                return $inject;
            };
            var $animateMinErr = minErr("$animate");
            function mergeClasses(a, b) {
                return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
                a + " " + b) : a : b : "";
            }
            function prepareAnimateOptions(options) {
                return isObject(options) ? options : {};
            }
            var $$CoreAnimateJsProvider = function() {
                this.$get = noop;
            }, $$CoreAnimateQueueProvider = function() {
                var postDigestQueue = new NgMap, postDigestElements = [];
                this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function(element, event, options, domOperation) {
                            domOperation && domOperation(), (options = options || {}).from && element.css(options.from), 
                            options.to && element.css(options.to), (options.addClass || options.removeClass) && function(element, add, remove) {
                                var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, add, !0), classesRemoved = updateData(data, remove, !1);
                                (classesAdded || classesRemoved) && (postDigestQueue.set(element, data), postDigestElements.push(element), 
                                1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges));
                            }(element, options.addClass, options.removeClass);
                            var runner = new $$AnimateRunner;
                            return runner.complete(), runner;
                        }
                    };
                    function updateData(data, classes, value) {
                        var changed = !1;
                        return classes && forEach(classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], (function(className) {
                            className && (changed = !0, data[className] = value);
                        })), changed;
                    }
                    function handleCSSClassChanges() {
                        forEach(postDigestElements, (function(element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = function(classes) {
                                    isString(classes) && (classes = classes.split(" "));
                                    var obj = createMap();
                                    return forEach(classes, (function(klass) {
                                        klass.length && (obj[klass] = !0);
                                    })), obj;
                                }(element.attr("class")), toAdd = "", toRemove = "";
                                forEach(data, (function(status, className) {
                                    status !== !!existing[className] && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                                })), forEach(element, (function(elm) {
                                    toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                                })), postDigestQueue.delete(element);
                            }
                        })), postDigestElements.length = 0;
                    }
                } ];
            }, $AnimateProvider = [ "$provide", function($provide) {
                var provider = this, classNameFilter = null, customFilter = null;
                this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
                    if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                    var key = name + "-animation";
                    provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
                }, this.customFilter = function(filterFn) {
                    return 1 === arguments.length && (customFilter = isFunction(filterFn) ? filterFn : null), 
                    customFilter;
                }, this.classNameFilter = function(expression) {
                    if (1 === arguments.length && ((classNameFilter = expression instanceof RegExp ? expression : null) && new RegExp("[(\\s|\\/)]ng-animate[(\\s|\\/)]").test(classNameFilter.toString()))) throw classNameFilter = null, 
                    $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', "ng-animate");
                    return classNameFilter;
                }, this.$get = [ "$$animateQueue", function($$animateQueue) {
                    function domInsert(element, parentElement, afterElement) {
                        if (afterElement) {
                            var afterNode = function(element) {
                                for (var i = 0; i < element.length; i++) {
                                    var elm = element[i];
                                    if (1 === elm.nodeType) return elm;
                                }
                            }(afterElement);
                            !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null);
                        }
                        afterElement ? afterElement.after(element) : parentElement.prepend(element);
                    }
                    return {
                        on: $$animateQueue.on,
                        off: $$animateQueue.off,
                        pin: $$animateQueue.pin,
                        enabled: $$animateQueue.enabled,
                        cancel: function(runner) {
                            runner.cancel && runner.cancel();
                        },
                        enter: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), domInsert(element, parent = parent || after.parent(), after), 
                            $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                        },
                        move: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), domInsert(element, parent = parent || after.parent(), after), 
                            $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                        },
                        leave: function(element, options) {
                            return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), (function() {
                                element.remove();
                            }));
                        },
                        addClass: function(element, className, options) {
                            return (options = prepareAnimateOptions(options)).addClass = mergeClasses(options.addclass, className), 
                            $$animateQueue.push(element, "addClass", options);
                        },
                        removeClass: function(element, className, options) {
                            return (options = prepareAnimateOptions(options)).removeClass = mergeClasses(options.removeClass, className), 
                            $$animateQueue.push(element, "removeClass", options);
                        },
                        setClass: function(element, add, remove, options) {
                            return (options = prepareAnimateOptions(options)).addClass = mergeClasses(options.addClass, add), 
                            options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                        },
                        animate: function(element, from, to, className, options) {
                            return (options = prepareAnimateOptions(options)).from = options.from ? extend(options.from, from) : from, 
                            options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", 
                            options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                        }
                    };
                } ];
            } ], $$AnimateAsyncRunFactoryProvider = function() {
                this.$get = [ "$$rAF", function($$rAF) {
                    var waitQueue = [];
                    function waitForTick(fn) {
                        waitQueue.push(fn), waitQueue.length > 1 || $$rAF((function() {
                            for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                            waitQueue = [];
                        }));
                    }
                    return function() {
                        var passed = !1;
                        return waitForTick((function() {
                            passed = !0;
                        })), function(callback) {
                            passed ? callback() : waitForTick(callback);
                        };
                    };
                } ];
            }, $$AnimateRunnerFactoryProvider = function() {
                this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
                    function AnimateRunner(host) {
                        this.setHost(host);
                        var rafTick = $$animateAsyncRun();
                        this._doneCallbacks = [], this._tick = function(fn) {
                            $$isDocumentHidden() ? function(fn) {
                                $timeout(fn, 0, !1);
                            }(fn) : rafTick(fn);
                        }, this._state = 0;
                    }
                    return AnimateRunner.chain = function(chain, callback) {
                        var index = 0;
                        !function next() {
                            if (index === chain.length) return void callback(!0);
                            chain[index]((function(response) {
                                !1 !== response ? (index++, next()) : callback(!1);
                            }));
                        }();
                    }, AnimateRunner.all = function(runners, callback) {
                        var count = 0, status = !0;
                        function onProgress(response) {
                            status = status && response, ++count === runners.length && callback(status);
                        }
                        forEach(runners, (function(runner) {
                            runner.done(onProgress);
                        }));
                    }, AnimateRunner.prototype = {
                        setHost: function(host) {
                            this.host = host || {};
                        },
                        done: function(fn) {
                            2 === this._state ? fn() : this._doneCallbacks.push(fn);
                        },
                        progress: noop,
                        getPromise: function() {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q((function(resolve, reject) {
                                    self.done((function(status) {
                                        !1 === status ? reject() : resolve();
                                    }));
                                }));
                            }
                            return this.promise;
                        },
                        then: function(resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler);
                        },
                        catch: function(handler) {
                            return this.getPromise().catch(handler);
                        },
                        finally: function(handler) {
                            return this.getPromise().finally(handler);
                        },
                        pause: function() {
                            this.host.pause && this.host.pause();
                        },
                        resume: function() {
                            this.host.resume && this.host.resume();
                        },
                        end: function() {
                            this.host.end && this.host.end(), this._resolve(!0);
                        },
                        cancel: function() {
                            this.host.cancel && this.host.cancel(), this._resolve(!1);
                        },
                        complete: function(response) {
                            var self = this;
                            0 === self._state && (self._state = 1, self._tick((function() {
                                self._resolve(response);
                            })));
                        },
                        _resolve: function(response) {
                            2 !== this._state && (forEach(this._doneCallbacks, (function(fn) {
                                fn(response);
                            })), this._doneCallbacks.length = 0, this._state = 2);
                        }
                    }, AnimateRunner;
                } ];
            }, $CoreAnimateCssProvider = function() {
                this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
                    return function(element, initialOptions) {
                        var options = initialOptions || {};
                        options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null), 
                        options.from && (element.css(options.from), options.from = null);
                        var closed, runner = new $$AnimateRunner;
                        return {
                            start: run,
                            end: run
                        };
                        function run() {
                            return $$rAF((function() {
                                !function() {
                                    options.addClass && (element.addClass(options.addClass), options.addClass = null);
                                    options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null);
                                    options.to && (element.css(options.to), options.to = null);
                                }(), closed || runner.complete(), closed = !0;
                            })), runner;
                        }
                    };
                } ];
            };
            function Browser(window, document, $log, $sniffer, $$taskTrackerFactory) {
                var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {}, taskTracker = $$taskTrackerFactory($log);
                self.isMock = !1, self.$$completeOutstandingRequest = taskTracker.completeTask, 
                self.$$incOutstandingRequestCount = taskTracker.incTaskCount, self.notifyWhenNoOutstandingRequests = taskTracker.notifyWhenNoPendingTasks;
                var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = $sniffer.history ? function() {
                    try {
                        return history.state;
                    } catch (e) {}
                } : noop;
                cacheState(), self.url = function(url, replace, state) {
                    if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), 
                    history !== window.history && (history = window.history), url) {
                        var sameState = lastHistoryState === state;
                        if (url = urlResolve(url).href, lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                        var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                        return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), 
                        replace ? location.replace(url) : sameBase ? location.hash = function(url) {
                            var index = url.indexOf("#");
                            return -1 === index ? "" : url.substr(index);
                        }(url) : location.href = url, location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                        cacheState()), pendingLocation && (pendingLocation = url), self;
                    }
                    return function(url) {
                        return url.replace(/#$/, "");
                    }(pendingLocation || location.href);
                }, self.state = function() {
                    return cachedState;
                };
                var urlChangeListeners = [], urlChangeInit = !1;
                function cacheStateAndFireUrlChange() {
                    pendingLocation = null, fireStateOrUrlChange();
                }
                var lastCachedState = null;
                function cacheState() {
                    equals(cachedState = isUndefined(cachedState = getCurrentState()) ? null : cachedState, lastCachedState) && (cachedState = lastCachedState), 
                    lastCachedState = cachedState, lastHistoryState = cachedState;
                }
                function fireStateOrUrlChange() {
                    var prevLastHistoryState = lastHistoryState;
                    cacheState(), lastBrowserUrl === self.url() && prevLastHistoryState === cachedState || (lastBrowserUrl = self.url(), 
                    lastHistoryState = cachedState, forEach(urlChangeListeners, (function(listener) {
                        listener(self.url(), cachedState);
                    })));
                }
                self.onUrlChange = function(callback) {
                    return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
                    jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
                    urlChangeListeners.push(callback), callback;
                }, self.$$applicationDestroyed = function() {
                    jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
                }, self.$$checkUrlChange = fireStateOrUrlChange, self.baseHref = function() {
                    var href = baseElement.attr("href");
                    return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : "";
                }, self.defer = function(fn, delay, taskType) {
                    var timeoutId;
                    return delay = delay || 0, taskType = taskType || taskTracker.DEFAULT_TASK_TYPE, 
                    taskTracker.incTaskCount(taskType), timeoutId = setTimeout((function() {
                        delete pendingDeferIds[timeoutId], taskTracker.completeTask(fn, taskType);
                    }), delay), pendingDeferIds[timeoutId] = taskType, timeoutId;
                }, self.defer.cancel = function(deferId) {
                    if (pendingDeferIds.hasOwnProperty(deferId)) {
                        var taskType = pendingDeferIds[deferId];
                        return delete pendingDeferIds[deferId], clearTimeout(deferId), taskTracker.completeTask(noop, taskType), 
                        !0;
                    }
                    return !1;
                };
            }
            function $BrowserProvider() {
                this.$get = [ "$window", "$log", "$sniffer", "$document", "$$taskTrackerFactory", function($window, $log, $sniffer, $document, $$taskTrackerFactory) {
                    return new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory);
                } ];
            }
            function $CacheFactoryProvider() {
                this.$get = function() {
                    var caches = {};
                    function cacheFactory(cacheId, options) {
                        if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                        var size = 0, stats = extend({}, options, {
                            id: cacheId
                        }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                        return caches[cacheId] = {
                            put: function(key, value) {
                                if (!isUndefined(value)) {
                                    if (capacity < Number.MAX_VALUE) refresh(lruHash[key] || (lruHash[key] = {
                                        key
                                    }));
                                    return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                                    value;
                                }
                            },
                            get: function(key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry) return;
                                    refresh(lruEntry);
                                }
                                return data[key];
                            },
                            remove: function(key) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key];
                                    if (!lruEntry) return;
                                    lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n), 
                                    link(lruEntry.n, lruEntry.p), delete lruHash[key];
                                }
                                key in data && (delete data[key], size--);
                            },
                            removeAll: function() {
                                data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null;
                            },
                            destroy: function() {
                                data = null, stats = null, lruHash = null, delete caches[cacheId];
                            },
                            info: function() {
                                return extend({}, stats, {
                                    size
                                });
                            }
                        };
                        function refresh(entry) {
                            entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry, 
                            link(entry.n, entry.p), link(entry, freshEnd), (freshEnd = entry).n = null);
                        }
                        function link(nextEntry, prevEntry) {
                            nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                        }
                    }
                    return cacheFactory.info = function() {
                        var info = {};
                        return forEach(caches, (function(cache, cacheId) {
                            info[cacheId] = cache.info();
                        })), info;
                    }, cacheFactory.get = function(cacheId) {
                        return caches[cacheId];
                    }, cacheFactory;
                };
            }
            function $TemplateCacheProvider() {
                this.$get = [ "$cacheFactory", function($cacheFactory) {
                    return $cacheFactory("templates");
                } ];
            }
            var $compileMinErr = minErr("$compile");
            var _UNINITIALIZED_VALUE = new function() {};
            function $CompileProvider($provide, $$sanitizeUriProvider) {
                var hasDirectives = {}, COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = function(str) {
                    var i, obj = {}, items = str.split(",");
                    for (i = 0; i < items.length; i++) obj[items[i]] = !0;
                    return obj;
                }("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/, bindingCache = createMap();
                function parseIsolateBindings(scope, directiveName, isController) {
                    var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/, bindings = createMap();
                    return forEach(scope, (function(definition, scopeName) {
                        if ((definition = definition.trim()) in bindingCache) bindings[scopeName] = bindingCache[definition]; else {
                            var match = definition.match(LOCAL_REGEXP);
                            if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                            bindings[scopeName] = {
                                mode: match[1][0],
                                collection: "*" === match[2],
                                optional: "?" === match[3],
                                attrName: match[4] || scopeName
                            }, match[4] && (bindingCache[definition] = bindings[scopeName]);
                        }
                    })), bindings;
                }
                function parseDirectiveBindings(directive, directiveName) {
                    var bindings = {
                        isolateScope: null,
                        bindToController: null
                    };
                    if (isObject(directive.scope) && (!0 === directive.bindToController ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), 
                    bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), 
                    isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), 
                    bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                    return bindings;
                }
                this.directive = function registerDirective(name, directiveFactory) {
                    return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (!function(name) {
                        var letter = name.charAt(0);
                        if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                        if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
                    }(name), assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], 
                    $provide.factory(name + "Directive", [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                        var directives = [];
                        return forEach(hasDirectives[name], (function(directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                isFunction(directive) ? directive = {
                                    compile: valueFn(directive)
                                } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                                directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                                directive.require = function(directive) {
                                    var require = directive.require || directive.controller && directive.name;
                                    return !isArray(require) && isObject(require) && forEach(require, (function(value, key) {
                                        var match = value.match(REQUIRE_PREFIX_REGEXP);
                                        value.substring(match[0].length) || (require[key] = match[0] + key);
                                    })), require;
                                }(directive), directive.restrict = function(restrict, name) {
                                    if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
                                    return restrict || "EA";
                                }(directive.restrict, name), directive.$$moduleName = directiveFactory.$$moduleName, 
                                directives.push(directive);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        })), directives;
                    } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
                    this;
                }, this.component = function registerComponent(name, options) {
                    if (!isString(name)) return forEach(name, reverseParams(bind(this, registerComponent))), 
                    this;
                    var controller = options.controller || function() {};
                    function factory($injector) {
                        function makeInjectable(fn) {
                            return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                                return $injector.invoke(fn, this, {
                                    $element: tElement,
                                    $attrs: tAttrs
                                });
                            } : fn;
                        }
                        var template = options.template || options.templateUrl ? options.template : "", ddo = {
                            controller,
                            controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                            template: makeInjectable(template),
                            templateUrl: makeInjectable(options.templateUrl),
                            transclude: options.transclude,
                            scope: {},
                            bindToController: options.bindings || {},
                            restrict: "E",
                            require: options.require
                        };
                        return forEach(options, (function(val, key) {
                            "$" === key.charAt(0) && (ddo[key] = val);
                        })), ddo;
                    }
                    return forEach(options, (function(val, key) {
                        "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val));
                    })), factory.$inject = [ "$injector" ], this.directive(name, factory);
                }, this.aHrefSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp), 
                    this) : $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList();
                }, Object.defineProperty(this, "aHrefSanitizationWhitelist", {
                    get: function() {
                        return this.aHrefSanitizationTrustedUrlList;
                    },
                    set: function(value) {
                        this.aHrefSanitizationTrustedUrlList = value;
                    }
                }), this.imgSrcSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp), 
                    this) : $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList();
                }, Object.defineProperty(this, "imgSrcSanitizationWhitelist", {
                    get: function() {
                        return this.imgSrcSanitizationTrustedUrlList;
                    },
                    set: function(value) {
                        this.imgSrcSanitizationTrustedUrlList = value;
                    }
                });
                var debugInfoEnabled = !0;
                this.debugInfoEnabled = function(enabled) {
                    return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
                };
                var strictComponentBindingsEnabled = !1;
                this.strictComponentBindingsEnabled = function(enabled) {
                    return isDefined(enabled) ? (strictComponentBindingsEnabled = enabled, this) : strictComponentBindingsEnabled;
                };
                var TTL = 10;
                this.onChangesTtl = function(value) {
                    return arguments.length ? (TTL = value, this) : TTL;
                };
                var commentDirectivesEnabledConfig = !0;
                this.commentDirectivesEnabled = function(value) {
                    return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig;
                };
                var cssClassDirectivesEnabledConfig = !0;
                this.cssClassDirectivesEnabled = function(value) {
                    return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig;
                };
                var PROP_CONTEXTS = createMap();
                this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
                    var key = elementName.toLowerCase() + "|" + propertyName.toLowerCase();
                    if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) throw $compileMinErr("ctxoverride", "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.", elementName, propertyName, PROP_CONTEXTS[key], ctx);
                    return PROP_CONTEXTS[key] = ctx, this;
                }, function() {
                    function registerContext(ctx, values) {
                        forEach(values, (function(v) {
                            PROP_CONTEXTS[v.toLowerCase()] = ctx;
                        }));
                    }
                    registerContext(SCE_CONTEXTS.HTML, [ "iframe|srcdoc", "*|innerHTML", "*|outerHTML" ]), 
                    registerContext(SCE_CONTEXTS.CSS, [ "*|style" ]), registerContext(SCE_CONTEXTS.URL, [ "area|href", "area|ping", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "input|src", "ins|cite", "q|cite" ]), 
                    registerContext(SCE_CONTEXTS.MEDIA_URL, [ "audio|src", "img|src", "img|srcset", "source|src", "source|srcset", "track|src", "video|src", "video|poster" ]), 
                    registerContext(SCE_CONTEXTS.RESOURCE_URL, [ "*|formAction", "applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "form|action", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src" ]);
                }(), this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
                    var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/, specialAttrHolder = window.document.createElement("div"), commentDirectivesEnabled = commentDirectivesEnabledConfig, cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig, onChangesTtl = TTL;
                    function flushOnChangesQueue() {
                        try {
                            if (! --onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                            $rootScope.$apply((function() {
                                for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) try {
                                    onChangesQueue[i]();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                                onChangesQueue = void 0;
                            }));
                        } finally {
                            onChangesTtl++;
                        }
                    }
                    function sanitizeSrcset(value, invokeType) {
                        if (!value) return value;
                        if (!isString(value)) throw $compileMinErr("srcset", 'Can\'t pass trusted values to `{0}`: "{1}"', invokeType, value.toString());
                        for (var result = "", trimmedSrcset = trim(value), pattern = /\s/.test(trimmedSrcset) ? /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/ : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = 2 * i;
                            result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx])), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        return result += $sce.getTrustedMediaUrl(trim(lastTuple[0])), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                        result;
                    }
                    function Attributes(element, attributesToCopy) {
                        if (attributesToCopy) {
                            var i, l, key, keys = Object.keys(attributesToCopy);
                            for (i = 0, l = keys.length; i < l; i++) this[key = keys[i]] = attributesToCopy[key];
                        } else this.$attr = {};
                        this.$$element = element;
                    }
                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className);
                        } catch (e) {}
                    }
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                        },
                        $removeClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                        },
                        $updateClass: function(newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                        },
                        $set: function(key, value, writeAttr, attrName) {
                            var booleanKey = getBooleanAttrName(this.$$element[0], key), aliasedKey = ALIASED_ATTR[key], observer = key;
                            booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                            observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key]) || (this.$attr[key] = attrName = snake_case(key, "-")), 
                            "img" === nodeName_(this.$$element) && "srcset" === key && (this[key] = value = sanitizeSrcset(value, "$set('srcset', value)")), 
                            !1 !== writeAttr && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? booleanKey && !1 === value ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value) : function(element, attrName, value) {
                                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                                var attributes = specialAttrHolder.firstChild.attributes, attribute = attributes[0];
                                attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute);
                            }(this.$$element[0], attrName, value));
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[observer], (function(fn) {
                                try {
                                    fn(value);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }));
                        },
                        $observe: function(key, fn) {
                            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                            return listeners.push(fn), $rootScope.$evalAsync((function() {
                                listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key]);
                            })), function() {
                                arrayRemove(listeners, fn);
                            };
                        }
                    };
                    var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                    }, NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/, MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                        var bindings = $element.data("$binding") || [];
                        isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                        $element.data("$binding", bindings);
                    } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                        safeAddClass($element, "ng-binding");
                    } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                        $element.data(dataName, scope);
                    } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                        safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
                    } : noop, compile.$$createComment = function(directiveName, comment) {
                        var content = "";
                        return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), 
                        window.document.createComment(content);
                    }, compile;
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function(scope, cloneConnectFn, options) {
                            if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                            assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new());
                            var parentElement, node, $linkNode, parentBoundTranscludeFn = (options = options || {}).parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                            namespace || (node = (parentElement = futureParentElement) && parentElement[0], 
                            namespace = node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html"), 
                            $linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                            transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                            return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                            compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                            cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode;
                        };
                    }
                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) attrs = new Attributes, 
                        11 === msie && mergeConsecutiveTextNodes(nodeList, i, notLiveList), (nodeLinkFn = (directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective)).length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null) && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), 
                        childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                        (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                        return linkFnFound ? function(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) stableNodeList[idx = linkFns[i]] = nodeList[idx];
                            } else stableNodeList = nodeList;
                            for (i = 0, ii = linkFns.length; i < ii; ) node = stableNodeList[linkFns[i++]], 
                            nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                            compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, nodeLinkFn(childLinkFn, childScope, node, $rootElement, nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn);
                        } : null;
                    }
                    function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                        var sibling, node = nodeList[idx], parent = node.parentNode;
                        if (node.nodeType === NODE_TYPE_TEXT) for (;(sibling = parent ? node.nextSibling : nodeList[idx + 1]) && sibling.nodeType === NODE_TYPE_TEXT; ) node.nodeValue = node.nodeValue + sibling.nodeValue, 
                        sibling.parentNode && sibling.parentNode.removeChild(sibling), notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1);
                    }
                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            return transcludedScope || ((transcludedScope = scope.$new(!1, containingScope)).$$transcluded = !0), 
                            transcludeFn(transcludedScope, cloneFn, {
                                parentBoundTranscludeFn: previousBoundTranscludeFn,
                                transcludeControllers: controllers,
                                futureParentElement
                            });
                        }
                        var boundSlots = boundTranscludeFn.$$slots = createMap();
                        for (var slotName in transcludeFn.$$slots) transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                        return boundTranscludeFn;
                    }
                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var match, nodeName, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                        switch (nodeType) {
                          case NODE_TYPE_ELEMENT:
                            addDirective(directives, directiveNormalize(nodeName = nodeName_(node)), "E", maxPriority, ignoreDirective);
                            for (var attr, name, nName, value, ngPrefixMatch, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                var multiElementMatch, attrStartName = !1, attrEndName = !1, isNgAttr = !1, isNgProp = !1, isNgEvent = !1;
                                name = (attr = nAttrs[j]).name, value = attr.value, (ngPrefixMatch = (nName = directiveNormalize(name.toLowerCase())).match(NG_PREFIX_BINDING)) ? (isNgAttr = "Attr" === ngPrefixMatch[1], 
                                isNgProp = "Prop" === ngPrefixMatch[1], isNgEvent = "On" === ngPrefixMatch[1], name = name.replace(PREFIX_REGEXP, "").toLowerCase().substr(4 + ngPrefixMatch[1].length).replace(/_(.)/g, (function(match, letter) {
                                    return letter.toUpperCase();
                                }))) : (multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name, 
                                attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), 
                                isNgProp || isNgEvent ? (attrs[nName] = value, attrsMap[nName] = attr.name, isNgProp ? addPropertyDirective(node, directives, nName, name) : addEventDirective(directives, nName, name)) : (attrsMap[nName = directiveNormalize(name.toLowerCase())] = name, 
                                !isNgAttr && attrs.hasOwnProperty(nName) || (attrs[nName] = value, getBooleanAttrName(node, nName) && (attrs[nName] = !0)), 
                                addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName));
                            }
                            if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"), 
                            !cssClassDirectivesEnabled) break;
                            if (isObject(className = node.className) && (className = className.animVal), isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) addDirective(directives, nName = directiveNormalize(match[2]), "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                            className = className.substr(match.index + match[0].length);
                            break;

                          case NODE_TYPE_TEXT:
                            !function(directives, text) {
                                var interpolateFn = $interpolate(text, !0);
                                interpolateFn && directives.push({
                                    priority: 0,
                                    compile: function(templateNode) {
                                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                                            var parent = node.parent();
                                            hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                                            scope.$watch(interpolateFn, (function(value) {
                                                node[0].nodeValue = value;
                                            }));
                                        };
                                    }
                                });
                            }(directives, node.nodeValue);
                            break;

                          case NODE_TYPE_COMMENT:
                            if (!commentDirectivesEnabled) break;
                            !function(node, directives, attrs, maxPriority, ignoreDirective) {
                                try {
                                    var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                                    if (match) {
                                        var nName = directiveNormalize(match[1]);
                                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]));
                                    }
                                } catch (e) {}
                            }(node, directives, attrs, maxPriority, ignoreDirective);
                        }
                        return directives.sort(byPriority), directives;
                    }
                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [], depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) do {
                            if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                            node.nodeType === NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                            node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                        } while (depth > 0); else nodes.push(node);
                        return jqLite(nodes);
                    }
                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function(scope, element, attrs, controllers, transcludeFn) {
                            return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                        };
                    }
                    function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        var compiled;
                        return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                            return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), 
                            $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments);
                        };
                    }
                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        previousCompileContext = previousCompileContext || {};
                        for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; i < ii; i++) {
                            var attrStart = (directive = directives[i]).$$start, attrEnd = directive.$$end;
                            if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, 
                            terminalPriority > directive.priority) break;
                            if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                            newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                            newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                            !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                                for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                    mightHaveMultipleTransclusionError = !0;
                                    break;
                                }
                                didScanForMultipleTransclusion = !0;
                            }
                            if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(), 
                            assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                            controllerDirectives[directiveName] = directive), directiveValue = directive.transclude) if (hasTranscludeDirective = !0, 
                            directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                            nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0, 
                            terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), 
                            compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                            childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                nonTlbTranscludeDirective
                            }); else {
                                var slots = createMap();
                                if (isObject(directiveValue)) {
                                    $template = window.document.createDocumentFragment();
                                    var slotMap = createMap(), filledSlots = createMap();
                                    for (var slotName in forEach(directiveValue, (function(elementSelector, slotName) {
                                        var optional = "?" === elementSelector.charAt(0);
                                        elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, 
                                        slots[slotName] = null, filledSlots[slotName] = optional;
                                    })), forEach($compileNode.contents(), (function(node) {
                                        var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                        slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || window.document.createDocumentFragment(), 
                                        slots[slotName].appendChild(node)) : $template.appendChild(node);
                                    })), forEach(filledSlots, (function(filled, slotName) {
                                        if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                                    })), slots) if (slots[slotName]) {
                                        var slotCompileNodes = jqLite(slots[slotName].childNodes);
                                        slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn);
                                    }
                                    $template = jqLite($template.childNodes);
                                } else $template = jqLite(jqLiteClone(compileNode)).contents();
                                $compileNode.empty(), (childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                                    needsNewScope: directive.$$isolateScope || directive.$$newScope
                                })).$$slots = slots;
                            }
                            if (directive.template) if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                            templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                            directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                                if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                                compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                replaceWith(jqCollection, $compileNode, compileNode);
                                var newTemplateAttrs = {
                                    $attr: {}
                                }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), 
                                directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                                mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                            } else $compileNode.html(directiveValue);
                            if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                            templateDirective = directive, directive.replace && (replaceDirective = directive), 
                            nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                controllerDirectives,
                                newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                newIsolateScopeDirective,
                                templateDirective,
                                nonTlbTranscludeDirective
                            }), ii = directives.length; else if (directive.compile) try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                var context = directive.$$originalDirective || directive;
                                isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode));
                            }
                            directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                        }
                        return nodeLinkFn.scope = newScopeDirective && !0 === newScopeDirective.scope, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                        nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                        previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                        nodeLinkFn;
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                            pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                                isolateScope: !0
                            })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                            post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                                isolateScope: !0
                            })), postLinkFns.push(post));
                        }
                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                            for (var name in compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : attrs = new Attributes($element = jqLite(linkNode), templateAttrs), 
                            controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), 
                            boundTranscludeFn && (transcludeFn = function(scope, cloneAttachFn, futureParentElement, slotName) {
                                var transcludeControllers;
                                isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, 
                                cloneAttachFn = scope, scope = void 0);
                                hasElementTranscludeDirective && (transcludeControllers = elementControllers);
                                futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element);
                                if (!slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                                if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                if (isUndefined(slotTranscludeFn)) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element));
                            }, transcludeFn.$$boundTransclude = boundTranscludeFn, transcludeFn.isSlotFilled = function(slotName) {
                                return !!boundTranscludeFn.$$slots[slotName];
                            }), controllerDirectives && (elementControllers = function($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                                var elementControllers = createMap();
                                for (var controllerKey in controllerDirectives) {
                                    var directive = controllerDirectives[controllerKey], locals = {
                                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                        $element,
                                        $attrs: attrs,
                                        $transclude: transcludeFn
                                    }, controller = directive.controller;
                                    "@" === controller && (controller = attrs[directive.name]);
                                    var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                                    elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                                }
                                return elementControllers;
                            }($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), 
                            newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                            compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, 
                            (scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective)).removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches)), 
                            elementControllers) {
                                var controllerDirective = controllerDirectives[name], controller = elementControllers[name], bindings = controllerDirective.$$bindings.bindToController;
                                controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance), 
                                controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                            }
                            for (forEach(controllerDirectives, (function(controllerDirective, name) {
                                var require = controllerDirective.require;
                                controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                            })), forEach(elementControllers, (function(controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$onChanges)) try {
                                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                                if (isFunction(controllerInstance.$onInit)) try {
                                    controllerInstance.$onInit();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                                isFunction(controllerInstance.$doCheck) && (controllerScope.$watch((function() {
                                    controllerInstance.$doCheck();
                                })), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", (function() {
                                    controllerInstance.$onDestroy();
                                }));
                            })), i = 0, ii = preLinkFns.length; i < ii; i++) invokeLinkFn(linkFn = preLinkFns[i], linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            var scopeToChild = scope;
                            for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                            childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), 
                            i = postLinkFns.length - 1; i >= 0; i--) invokeLinkFn(linkFn = postLinkFns[i], linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            forEach(elementControllers, (function(controller) {
                                var controllerInstance = controller.instance;
                                isFunction(controllerInstance.$postLink) && controllerInstance.$postLink();
                            }));
                        }
                    }
                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value;
                        if (isString(require)) {
                            var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                            if ("^^" === inheritType ? $element = $element.parent() : value = (value = elementControllers && elementControllers[name]) && value.instance, 
                            !value) {
                                var dataName = "$" + name + "Controller";
                                value = "^^" === inheritType && $element[0] && $element[0].nodeType === NODE_TYPE_DOCUMENT ? null : inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                            }
                            if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                        } else if (isArray(require)) {
                            value = [];
                            for (var i = 0, ii = require.length; i < ii; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                        } else isObject(require) && (value = {}, forEach(require, (function(controller, property) {
                            value[property] = getControllers(directiveName, controller, $element, elementControllers);
                        })));
                        return value || null;
                    }
                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) directives[j] = inherit(directives[j], {
                            $$isolateScope: isolateScope,
                            $$newScope: newScope
                        });
                    }
                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + "Directive"), i = 0, ii = directives.length; i < ii; i++) if (directive = directives[i], 
                        (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 !== directive.restrict.indexOf(location)) {
                            if (startAttrName && (directive = inherit(directive, {
                                $$start: startAttrName,
                                $$end: endAttrName
                            })), !directive.$$bindings) {
                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope);
                            }
                            tDirectives.push(directive), match = directive;
                        }
                        return match;
                    }
                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name)) for (var directives = $injector.get(name + "Directive"), i = 0, ii = directives.length; i < ii; i++) if (directives[i].multiElement) return !0;
                        return !1;
                    }
                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr, dstAttr = dst.$attr;
                        forEach(dst, (function(value, key) {
                            "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]), 
                            dst.$set(key, value, !0, srcAttr[key]));
                        })), forEach(src, (function(value, key) {
                            dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]));
                        }));
                    }
                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                            templateUrl: null,
                            transclude: null,
                            replace: null,
                            $$originalDirective: origAsyncDirective
                        }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                        return $compileNode.empty(), $templateRequest(templateUrl).then((function(content) {
                            var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                            if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                                if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                                compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                tempTemplateAttrs = {
                                    $attr: {}
                                }, replaceWith($rootElement, $compileNode, compileNode);
                                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), 
                                directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                            for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                            forEach($rootElement, (function(node, i) {
                                node === compileNode && ($rootElement[i] = $compileNode[0]);
                            })), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                                var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                                if (!scope.$$destroyed) {
                                    if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                        var oldClasses = beforeTemplateLinkNode.className;
                                        previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                        replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                                    }
                                    childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                                }
                            }
                            linkQueue = null;
                        })).catch((function(error) {
                            isError(error) && $exceptionHandler(error);
                        })), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                            var childBoundTranscludeFn = boundTranscludeFn;
                            scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)));
                        };
                    }
                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
                    }
                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? " (module: " + moduleName + ")" : "";
                        }
                        if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                    }
                    function wrapTemplate(type, template) {
                        switch (type = lowercase(type || "html")) {
                          case "svg":
                          case "math":
                            var wrapper = window.document.createElement("div");
                            return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                          default:
                            return template;
                        }
                    }
                    function sanitizeSrcsetPropertyValue(value) {
                        return sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset");
                    }
                    function addPropertyDirective(node, directives, attrName, propName) {
                        if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) throw $compileMinErr("nodomevents", "Property bindings for HTML DOM event properties are disallowed");
                        var nodeName = nodeName_(node), trustedContext = function(nodeName, propNormalizedName) {
                            var prop = propNormalizedName.toLowerCase();
                            return PROP_CONTEXTS[nodeName + "|" + prop] || PROP_CONTEXTS["*|" + prop];
                        }(nodeName, propName), sanitizer = identity;
                        "srcset" !== propName || "img" !== nodeName && "source" !== nodeName ? trustedContext && (sanitizer = $sce.getTrusted.bind($sce, trustedContext)) : sanitizer = sanitizeSrcsetPropertyValue, 
                        directives.push({
                            priority: 100,
                            compile: function(_, attr) {
                                var ngPropGetter = $parse(attr[attrName]), ngPropWatch = $parse(attr[attrName], (function(val) {
                                    return $sce.valueOf(val);
                                }));
                                return {
                                    pre: function(scope, $element) {
                                        function applyPropValue() {
                                            var propValue = ngPropGetter(scope);
                                            $element[0][propName] = sanitizer(propValue);
                                        }
                                        applyPropValue(), scope.$watch(ngPropWatch, applyPropValue);
                                    }
                                };
                            }
                        });
                    }
                    function addEventDirective(directives, attrName, eventName) {
                        directives.push(createEventDirective($parse, $rootScope, $exceptionHandler, attrName, eventName, !1));
                    }
                    function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                        var nodeName = nodeName_(node), trustedContext = function(nodeName, attrNormalizedName) {
                            return "srcdoc" === attrNormalizedName ? $sce.HTML : "src" === attrNormalizedName || "ngSrc" === attrNormalizedName ? -1 === [ "img", "video", "audio", "source", "track" ].indexOf(nodeName) ? $sce.RESOURCE_URL : $sce.MEDIA_URL : "xlinkHref" === attrNormalizedName ? "image" === nodeName ? $sce.MEDIA_URL : "a" === nodeName ? $sce.URL : $sce.RESOURCE_URL : "form" === nodeName && "action" === attrNormalizedName || "base" === nodeName && "href" === attrNormalizedName || "link" === nodeName && "href" === attrNormalizedName ? $sce.RESOURCE_URL : "a" !== nodeName || "href" !== attrNormalizedName && "ngHref" !== attrNormalizedName ? void 0 : $sce.URL;
                        }(nodeName, name), mustHaveExpression = !isNgAttr, allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr, interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                        if (interpolateFn) {
                            if ("multiple" === name && "select" === nodeName) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed");
                            directives.push({
                                priority: 100,
                                compile: function() {
                                    return {
                                        pre: function(scope, element, attr) {
                                            var $$observers = attr.$$observers || (attr.$$observers = createMap()), newValue = attr[name];
                                            newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), 
                                            value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                            (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, (function(newValue, oldValue) {
                                                "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                            })));
                                        }
                                    };
                                }
                            });
                        }
                    }
                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                        if ($rootElement) for (i = 0, ii = $rootElement.length; i < ii; i++) if ($rootElement[i] === firstElementToRemove) {
                            $rootElement[i++] = newNode;
                            for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, 
                            j2++) j2 < jj ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                            $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                            break;
                        }
                        parent && parent.replaceChild(newNode, firstElementToRemove);
                        var fragment = window.document.createDocumentFragment();
                        for (i = 0; i < removeCount; i++) fragment.appendChild(elementsToRemove[i]);
                        for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), 
                        jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), 
                        i = 1; i < removeCount; i++) delete elementsToRemove[i];
                        elementsToRemove[0] = newNode, elementsToRemove.length = 1;
                    }
                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend((function() {
                            return fn.apply(null, arguments);
                        }), fn, annotation);
                    }
                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    function strictBindingsCheck(attrName, directiveName) {
                        if (strictComponentBindingsEnabled) throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);
                    }
                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        var changes, removeWatchCollection = [], initialChanges = {};
                        function recordChanges(key, currentValue, previousValue) {
                            isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue) && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), 
                            onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), 
                            changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue));
                        }
                        function triggerOnChangesHook() {
                            destination.$onChanges(changes), changes = void 0;
                        }
                        return forEach(bindings, (function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName, optional = definition.optional;
                            switch (definition.mode) {
                              case "@":
                                optional || hasOwnProperty.call(attrs, attrName) || (strictBindingsCheck(attrName, directive.name), 
                                destination[scopeName] = attrs[attrName] = void 0), removeWatch = attrs.$observe(attrName, (function(value) {
                                    if (isString(value) || isBoolean(value)) {
                                        var oldValue = destination[scopeName];
                                        recordChanges(scopeName, value, oldValue), destination[scopeName] = value;
                                    }
                                })), attrs.$$observers[attrName].$$scope = scope, isString(lastValue = attrs[attrName]) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), 
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                                removeWatchCollection.push(removeWatch);
                                break;

                              case "=":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional) break;
                                    strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                                }
                                if (optional && !attrs[attrName]) break;
                                parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : simpleCompare, 
                                parentSet = parentGet.assign || function() {
                                    throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                                }, lastValue = destination[scopeName] = parentGet(scope);
                                var parentValueWatch = function(parentValue) {
                                    return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), 
                                    lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                                removeWatchCollection.push(removeWatch);
                                break;

                              case "<":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional) break;
                                    strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                                }
                                if (optional && !attrs[attrName]) break;
                                var isLiteral = (parentGet = $parse(attrs[attrName])).literal, initialValue = destination[scopeName] = parentGet(scope);
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                                removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, (function(newValue, oldValue) {
                                    if (oldValue === newValue) {
                                        if (oldValue === initialValue || isLiteral && equals(oldValue, initialValue)) return;
                                        oldValue = initialValue;
                                    }
                                    recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue;
                                })), removeWatchCollection.push(removeWatch);
                                break;

                              case "&":
                                if (optional || hasOwnProperty.call(attrs, attrName) || strictBindingsCheck(attrName, directive.name), 
                                (parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop) === noop && optional) break;
                                destination[scopeName] = function(locals) {
                                    return parentGet(scope, locals);
                                };
                            }
                        })), {
                            initialChanges,
                            removeWatches: removeWatchCollection.length && function() {
                                for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) removeWatchCollection[i]();
                            }
                        };
                    }
                } ];
            }
            function SimpleChange(previous, current) {
                this.previousValue = previous, this.currentValue = current;
            }
            $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ], SimpleChange.prototype.isFirstChange = function() {
                return this.previousValue === _UNINITIALIZED_VALUE;
            };
            var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i, SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;
            function directiveNormalize(name) {
                return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, (function(_, letter, offset) {
                    return offset ? letter.toUpperCase() : letter;
                }));
            }
            function tokenDifference(str1, str2) {
                var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                    values += (values.length > 0 ? " " : "") + token;
                }
                return values;
            }
            function removeComments(jqNodes) {
                var i = (jqNodes = jqLite(jqNodes)).length;
                if (i <= 1) return jqNodes;
                for (;i--; ) {
                    var node = jqNodes[i];
                    (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1);
                }
                return jqNodes;
            }
            var $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
            function identifierForController(controller, ident) {
                if (ident && isString(ident)) return ident;
                if (isString(controller)) {
                    var match = CNTRL_REG.exec(controller);
                    if (match) return match[3];
                }
            }
            function $ControllerProvider() {
                var controllers = {};
                this.has = function(name) {
                    return controllers.hasOwnProperty(name);
                }, this.register = function(name, constructor) {
                    assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
                }, this.$get = [ "$injector", function($injector) {
                    return function(expression, locals, later, ident) {
                        var instance, match, constructor, identifier;
                        if (later = !0 === later, ident && isString(ident) && (identifier = ident), isString(expression)) {
                            if (!(match = expression.match(CNTRL_REG))) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                            if (constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : function(obj, path, bindFnToScope) {
                                if (!path) return obj;
                                for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; i < len; i++) key = keys[i], 
                                obj && (obj = (lastInstance = obj)[key]);
                                return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
                            }(locals.$scope, constructor, !0), !expression) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                            assertArgFn(expression, constructor, !0);
                        }
                        if (later) {
                            var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                            return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                            extend((function() {
                                var result = $injector.invoke(expression, instance, locals, constructor);
                                return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, 
                                identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), 
                                instance;
                            }), {
                                instance,
                                identifier
                            });
                        }
                        return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                        instance;
                    };
                    function addIdentifier(locals, identifier, instance, name) {
                        if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                        locals.$scope[identifier] = instance;
                    }
                } ];
            }
            function $DocumentProvider() {
                this.$get = [ "$window", function(window) {
                    return jqLite(window.document);
                } ];
            }
            function $$IsDocumentHiddenProvider() {
                this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
                    var doc = $document[0], hidden = doc && doc.hidden;
                    function changeListener() {
                        hidden = doc.hidden;
                    }
                    return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", (function() {
                        $document.off("visibilitychange", changeListener);
                    })), function() {
                        return hidden;
                    };
                } ];
            }
            function $ExceptionHandlerProvider() {
                this.$get = [ "$log", function($log) {
                    return function(exception, cause) {
                        $log.error.apply($log, arguments);
                    };
                } ];
            }
            var $$ForceReflowProvider = function() {
                this.$get = [ "$document", function($document) {
                    return function(domNode) {
                        return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, 
                        domNode.offsetWidth + 1;
                    };
                } ];
            }, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
                "Content-Type": APPLICATION_JSON + ";charset=utf-8"
            }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
                "[": /]$/,
                "{": /}$/
            }, JSON_PROTECTION_PREFIX = /^\)]\}',?\n/, $httpMinErr = minErr("$http");
            function serializeValue(v) {
                return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
            }
            function $HttpParamSerializerProvider() {
                this.$get = function() {
                    return function(params) {
                        if (!params) return "";
                        var parts = [];
                        return forEachSorted(params, (function(value, key) {
                            null === value || isUndefined(value) || isFunction(value) || (isArray(value) ? forEach(value, (function(v) {
                                parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                            })) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                        })), parts.join("&");
                    };
                };
            }
            function $HttpParamSerializerJQLikeProvider() {
                this.$get = function() {
                    return function(params) {
                        if (!params) return "";
                        var parts = [];
                        return function serialize(toSerialize, prefix, topLevel) {
                            isArray(toSerialize) ? forEach(toSerialize, (function(value, index) {
                                serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                            })) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, (function(value, key) {
                                serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                            })) : (isFunction(toSerialize) && (toSerialize = toSerialize()), parts.push(encodeUriQuery(prefix) + "=" + (null == toSerialize ? "" : encodeUriQuery(serializeValue(toSerialize)))));
                        }(params, "", !0), parts.join("&");
                    };
                };
            }
            function defaultHttpResponseTransform(data, headers) {
                if (isString(data)) {
                    var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
                    if (tempData) {
                        var contentType = headers("Content-Type"), hasJsonContentType = contentType && 0 === contentType.indexOf(APPLICATION_JSON);
                        if (hasJsonContentType || (jsonStart = (str = tempData).match(JSON_START)) && JSON_ENDS[jsonStart[0]].test(str)) try {
                            data = fromJson(tempData);
                        } catch (e) {
                            if (!hasJsonContentType) return data;
                            throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e);
                        }
                    }
                }
                var str, jsonStart;
                return data;
            }
            function parseHeaders(headers) {
                var i, parsed = createMap();
                function fillInParsed(key, val) {
                    key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
                }
                return isString(headers) ? forEach(headers.split("\n"), (function(line) {
                    i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
                })) : isObject(headers) && forEach(headers, (function(headerVal, headerKey) {
                    fillInParsed(lowercase(headerKey), trim(headerVal));
                })), parsed;
            }
            function headersGetter(headers) {
                var headersObj;
                return function(name) {
                    if (headersObj || (headersObj = parseHeaders(headers)), name) {
                        var value = headersObj[lowercase(name)];
                        return void 0 === value && (value = null), value;
                    }
                    return headersObj;
                };
            }
            function transformData(data, headers, status, fns) {
                return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, (function(fn) {
                    data = fn(data, headers, status);
                })), data);
            }
            function isSuccess(status) {
                return 200 <= status && status < 300;
            }
            function $HttpProvider() {
                var defaults = this.defaults = {
                    transformResponse: [ defaultHttpResponseTransform ],
                    transformRequest: [ function(d) {
                        return !isObject(d) || (obj = d, "[object File]" === toString.call(obj)) || function(obj) {
                            return "[object Blob]" === toString.call(obj);
                        }(d) || function(obj) {
                            return "[object FormData]" === toString.call(obj);
                        }(d) ? d : toJson(d);
                        var obj;
                    } ],
                    headers: {
                        common: {
                            Accept: "application/json, text/plain, */*"
                        },
                        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                    },
                    xsrfCookieName: "XSRF-TOKEN",
                    xsrfHeaderName: "X-XSRF-TOKEN",
                    paramSerializer: "$httpParamSerializer",
                    jsonpCallbackParam: "callback"
                }, useApplyAsync = !1;
                this.useApplyAsync = function(value) {
                    return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
                };
                var interceptorFactories = this.interceptors = [], xsrfTrustedOrigins = this.xsrfTrustedOrigins = [];
                Object.defineProperty(this, "xsrfWhitelistedOrigins", {
                    get: function() {
                        return this.xsrfTrustedOrigins;
                    },
                    set: function(origins) {
                        this.xsrfTrustedOrigins = origins;
                    }
                }), this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
                    var defaultCache = $cacheFactory("$http");
                    defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                    var reversedInterceptors = [];
                    forEach(interceptorFactories, (function(interceptorFactory) {
                        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                    }));
                    var parsedAllowedOriginUrls, urlIsAllowedOrigin = (parsedAllowedOriginUrls = [ originUrl ].concat(xsrfTrustedOrigins.map(urlResolve)), 
                    function(requestUrl) {
                        var parsedUrl = urlResolve(requestUrl);
                        return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl));
                    });
                    function $http(requestConfig) {
                        if (!isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                        if (!isString($sce.valueOf(requestConfig.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                        var config = extend({
                            method: "get",
                            transformRequest: defaults.transformRequest,
                            transformResponse: defaults.transformResponse,
                            paramSerializer: defaults.paramSerializer,
                            jsonpCallbackParam: defaults.jsonpCallbackParam
                        }, requestConfig);
                        config.headers = function(config) {
                            var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                            defaultHeadersIteration: for (defHeaderName in defHeaders) {
                                for (reqHeaderName in lowercaseDefHeaderName = lowercase(defHeaderName), reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                                reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                            }
                            return function(headers, config) {
                                var headerContent, processedHeaders = {};
                                return forEach(headers, (function(headerFn, header) {
                                    isFunction(headerFn) ? null != (headerContent = headerFn(config)) && (processedHeaders[header] = headerContent) : processedHeaders[header] = headerFn;
                                })), processedHeaders;
                            }(reqHeaders, shallowCopy(config));
                        }(requestConfig), config.method = uppercase(config.method), config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer, 
                        $browser.$$incOutstandingRequestCount("$http");
                        var requestInterceptors = [], responseInterceptors = [], promise = $q.resolve(config);
                        return forEach(reversedInterceptors, (function(interceptor) {
                            (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), 
                            (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError);
                        })), promise = (promise = chainInterceptors(promise, requestInterceptors)).then((function(config) {
                            var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                            isUndefined(reqData) && forEach(headers, (function(value, header) {
                                "content-type" === lowercase(header) && delete headers[header];
                            }));
                            isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials);
                            return function(config, reqData) {
                                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, isJsonp = "jsonp" === lowercase(config.method), url = config.url;
                                isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url));
                                url = function(url, serializedParams) {
                                    serializedParams.length > 0 && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams);
                                    return url;
                                }(url, config.paramSerializer(config.params)), isJsonp && (url = function(url, cbKey) {
                                    var parts = url.split("?");
                                    if (parts.length > 2) throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                                    return forEach(parseKeyValue(parts[1]), (function(value, key) {
                                        if ("JSON_CALLBACK" === value) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                                        if (key === cbKey) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                                    })), url += (-1 === url.indexOf("?") ? "?" : "&") + cbKey + "=JSON_CALLBACK", url;
                                }(url, config.jsonpCallbackParam));
                                $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                                !config.cache && !defaults.cache || !1 === config.cache || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache);
                                cache && (isDefined(cachedResp = cache.get(url)) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]) : resolvePromise(cachedResp, 200, {}, "OK", "complete") : cache.put(url, promise));
                                if (isUndefined(cachedResp)) {
                                    var xsrfValue = urlIsAllowedOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                                }
                                return promise;
                                function createApplyHandlers(eventHandlers) {
                                    if (eventHandlers) {
                                        var applyHandlers = {};
                                        return forEach(eventHandlers, (function(eventHandler, key) {
                                            applyHandlers[key] = function(event) {
                                                function callEventHandler() {
                                                    eventHandler(event);
                                                }
                                                useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler);
                                            };
                                        })), applyHandlers;
                                    }
                                }
                                function done(status, response, headersString, statusText, xhrStatus) {
                                    function resolveHttpPromise() {
                                        resolvePromise(response, status, headersString, statusText, xhrStatus);
                                    }
                                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText, xhrStatus ]) : cache.remove(url)), 
                                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                                    $rootScope.$$phase || $rootScope.$apply());
                                }
                                function resolvePromise(response, status, headers, statusText, xhrStatus) {
                                    (isSuccess(status = status >= -1 ? status : 0) ? deferred.resolve : deferred.reject)({
                                        data: response,
                                        status,
                                        headers: headersGetter(headers),
                                        config,
                                        statusText,
                                        xhrStatus
                                    });
                                }
                                function resolvePromiseWithResult(result) {
                                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);
                                }
                                function removePendingReq() {
                                    var idx = $http.pendingRequests.indexOf(config);
                                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                                }
                            }(config, reqData).then(transformResponse, transformResponse);
                        })), promise = (promise = chainInterceptors(promise, responseInterceptors)).finally((function() {
                            $browser.$$completeOutstandingRequest(noop, "$http");
                        }));
                        function chainInterceptors(promise, interceptors) {
                            for (var i = 0, ii = interceptors.length; i < ii; ) {
                                var thenFn = interceptors[i++], rejectFn = interceptors[i++];
                                promise = promise.then(thenFn, rejectFn);
                            }
                            return interceptors.length = 0, promise;
                        }
                        function transformResponse(response) {
                            var resp = extend({}, response);
                            return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), 
                            isSuccess(response.status) ? resp : $q.reject(resp);
                        }
                    }
                    return $http.pendingRequests = [], function(names) {
                        forEach(arguments, (function(name) {
                            $http[name] = function(url, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url
                                }));
                            };
                        }));
                    }("get", "delete", "head", "jsonp"), function(name) {
                        forEach(arguments, (function(name) {
                            $http[name] = function(url, data, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url,
                                    data
                                }));
                            };
                        }));
                    }("post", "put", "patch"), $http.defaults = defaults, $http;
                } ];
            }
            function $xhrFactoryProvider() {
                this.$get = function() {
                    return function() {
                        return new window.XMLHttpRequest;
                    };
                };
            }
            function $HttpBackendProvider() {
                this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
                    return function($browser, createXhr, $browserDefer, callbacks, rawDocument) {
                        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                            if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url), jsonpDone = jsonpReq(url, callbackPath, (function(status, text) {
                                var response = 200 === status && callbacks.getResponse(callbackPath);
                                completeRequest(callback, status, response, "", text, "complete"), callbacks.removeCallback(callbackPath);
                            })); else {
                                var xhr = createXhr(method, url), abortedByTimeout = !1;
                                xhr.open(method, url, !0), forEach(headers, (function(value, key) {
                                    isDefined(value) && xhr.setRequestHeader(key, value);
                                })), xhr.onload = function() {
                                    var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                                    0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0), 
                                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete");
                                };
                                var requestError = function() {
                                    completeRequest(callback, -1, null, null, "", "error");
                                }, requestAborted = function() {
                                    completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort");
                                }, requestTimeout = function() {
                                    completeRequest(callback, -1, null, null, "", "timeout");
                                };
                                if (xhr.onerror = requestError, xhr.ontimeout = requestTimeout, xhr.onabort = requestAborted, 
                                forEach(eventHandlers, (function(value, key) {
                                    xhr.addEventListener(key, value);
                                })), forEach(uploadEventHandlers, (function(value, key) {
                                    xhr.upload.addEventListener(key, value);
                                })), withCredentials && (xhr.withCredentials = !0), responseType) try {
                                    xhr.responseType = responseType;
                                } catch (e) {
                                    if ("json" !== responseType) throw e;
                                }
                                xhr.send(isUndefined(post) ? null : post);
                            }
                            if (timeout > 0) var timeoutId = $browserDefer((function() {
                                timeoutRequest("timeout");
                            }), timeout); else isPromiseLike(timeout) && timeout.then((function() {
                                timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort");
                            }));
                            function timeoutRequest(reason) {
                                abortedByTimeout = "timeout" === reason, jsonpDone && jsonpDone(), xhr && xhr.abort();
                            }
                            function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                                isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 
                                callback(status, response, headersString, statusText, xhrStatus);
                            }
                        };
                        function jsonpReq(url, callbackPath, done) {
                            url = url.replace("JSON_CALLBACK", callbackPath);
                            var script = rawDocument.createElement("script"), callback = null;
                            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                                script.removeEventListener("load", callback), script.removeEventListener("error", callback), 
                                rawDocument.body.removeChild(script), script = null;
                                var status = -1, text = "unknown";
                                event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {
                                    type: "error"
                                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
                            }, script.addEventListener("load", callback), script.addEventListener("error", callback), 
                            rawDocument.body.appendChild(script), callback;
                        }
                    }($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
                } ];
            }
            var $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
            function $InterpolateProvider() {
                var startSymbol = "{{", endSymbol = "}}";
                this.startSymbol = function(value) {
                    return value ? (startSymbol = value, this) : startSymbol;
                }, this.endSymbol = function(value) {
                    return value ? (endSymbol = value, this) : endSymbol;
                }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
                    var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
                    function escape(ch) {
                        return "\\\\\\" + ch;
                    }
                    function unescapeText(text) {
                        return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                        var unwatch = scope.$watch((function(scope) {
                            return unwatch(), constantInterp(scope);
                        }), listener, objectEquality);
                        return unwatch;
                    }
                    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                        var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
                        if (!text.length || -1 === text.indexOf(startSymbol)) {
                            if (mustHaveExpression) return;
                            var unescapedText = unescapeText(text);
                            contextAllowsConcatenation && (unescapedText = $sce.getTrusted(trustedContext, unescapedText));
                            var constantInterp = valueFn(unescapedText);
                            return constantInterp.exp = text, constantInterp.expressions = [], constantInterp.$$watchDelegate = constantWatchDelegate, 
                            constantInterp;
                        }
                        allOrNothing = !!allOrNothing;
                        for (var startIndex, endIndex, parseFns, exp, singleExpression, index = 0, expressions = [], textLength = text.length, concat = [], expressionPositions = []; index < textLength; ) {
                            if (-1 === (startIndex = text.indexOf(startSymbol, index)) || -1 === (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                                index !== textLength && concat.push(unescapeText(text.substring(index)));
                                break;
                            }
                            index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), 
                            exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), 
                            index = endIndex + endSymbolLength, expressionPositions.push(concat.length), concat.push("");
                        }
                        singleExpression = 1 === concat.length && 1 === expressionPositions.length;
                        var interceptor = contextAllowsConcatenation && singleExpression ? void 0 : function(value) {
                            try {
                                return value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value), 
                                allOrNothing && !isDefined(value) ? value : stringify(value);
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err));
                            }
                        };
                        if (parseFns = expressions.map((function(exp) {
                            return $parse(exp, interceptor);
                        })), !mustHaveExpression || expressions.length) {
                            var compute = function(values) {
                                for (var i = 0, ii = expressions.length; i < ii; i++) {
                                    if (allOrNothing && isUndefined(values[i])) return;
                                    concat[expressionPositions[i]] = values[i];
                                }
                                return contextAllowsConcatenation ? $sce.getTrusted(trustedContext, singleExpression ? concat[0] : concat.join("")) : (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), 
                                concat.join(""));
                            };
                            return extend((function(context) {
                                var i = 0, ii = expressions.length, values = new Array(ii);
                                try {
                                    for (;i < ii; i++) values[i] = parseFns[i](context);
                                    return compute(values);
                                } catch (err) {
                                    $exceptionHandler($interpolateMinErr.interr(text, err));
                                }
                            }), {
                                exp: text,
                                expressions,
                                $$watchDelegate: function(scope, listener) {
                                    var lastValue;
                                    return scope.$watchGroup(parseFns, (function(values, oldValues) {
                                        var currValue = compute(values);
                                        listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                        lastValue = currValue;
                                    }));
                                }
                            });
                        }
                    }
                    return $interpolate.startSymbol = function() {
                        return startSymbol;
                    }, $interpolate.endSymbol = function() {
                        return endSymbol;
                    }, $interpolate;
                } ];
            }
            $interpolateMinErr.throwNoconcat = function(text) {
                throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
            }, $interpolateMinErr.interr = function(text, err) {
                return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
            };
            var $intervalMinErr = minErr("$interval");
            function $IntervalProvider() {
                this.$get = [ "$$intervalFactory", "$window", function($$intervalFactory, $window) {
                    var intervals = {}, clearIntervalFn = function(id) {
                        $window.clearInterval(id), delete intervals[id];
                    }, interval = $$intervalFactory((function(tick, delay, deferred) {
                        var id = $window.setInterval(tick, delay);
                        return intervals[id] = deferred, id;
                    }), clearIntervalFn);
                    return interval.cancel = function(promise) {
                        if (!promise) return !1;
                        if (!promise.hasOwnProperty("$$intervalId")) throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                        if (!intervals.hasOwnProperty(promise.$$intervalId)) return !1;
                        var id = promise.$$intervalId, deferred = intervals[id];
                        return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), clearIntervalFn(id), 
                        !0;
                    }, interval;
                } ];
            }
            function $$IntervalFactoryProvider() {
                this.$get = [ "$browser", "$q", "$$q", "$rootScope", function($browser, $q, $$q, $rootScope) {
                    return function(setIntervalFn, clearIntervalFn) {
                        return function(fn, delay, count, invokeApply) {
                            var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                            function callback() {
                                hasParams ? fn.apply(null, args) : fn(iteration);
                            }
                            return count = isDefined(count) ? count : 0, promise.$$intervalId = setIntervalFn((function() {
                                skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), 
                                count > 0 && iteration >= count && (deferred.resolve(iteration), clearIntervalFn(promise.$$intervalId)), 
                                skipApply || $rootScope.$apply();
                            }), delay, deferred, skipApply), promise;
                        };
                    };
                } ];
            }
            var $jsonpCallbacksProvider = function() {
                this.$get = function() {
                    var callbacks = angular.callbacks, callbackMap = {};
                    return {
                        createCallback: function(url) {
                            var callbackId = "_" + (callbacks.$$counter++).toString(36), callbackPath = "angular.callbacks." + callbackId, callback = function(callbackId) {
                                var callback = function(data) {
                                    callback.data = data, callback.called = !0;
                                };
                                return callback.id = callbackId, callback;
                            }(callbackId);
                            return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath;
                        },
                        wasCalled: function(callbackPath) {
                            return callbackMap[callbackPath].called;
                        },
                        getResponse: function(callbackPath) {
                            return callbackMap[callbackPath].data;
                        },
                        removeCallback: function(callbackPath) {
                            var callback = callbackMap[callbackPath];
                            delete callbacks[callback.id], delete callbackMap[callbackPath];
                        }
                    };
                };
            }, PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
                http: 80,
                https: 443,
                ftp: 21
            }, $locationMinErr = minErr("$location");
            function normalizePath(pathValue, searchValue, hashValue) {
                var parts, search = (parts = [], forEach(searchValue, (function(value, key) {
                    isArray(value) ? forEach(value, (function(arrayValue) {
                        parts.push(encodeUriQuery(key, !0) + (!0 === arrayValue ? "" : "=" + encodeUriQuery(arrayValue, !0)));
                    })) : parts.push(encodeUriQuery(key, !0) + (!0 === value ? "" : "=" + encodeUriQuery(value, !0)));
                })), parts.length ? parts.join("&") : ""), hash = hashValue ? "#" + encodeUriSegment(hashValue) : "";
                return function(path) {
                    for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
                    return segments.join("/");
                }(pathValue) + (search ? "?" + search : "") + hash;
            }
            function parseAbsoluteUrl(absoluteUrl, locationObj) {
                var parsedUrl = urlResolve(absoluteUrl);
                locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
                locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
            }
            var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/;
            function parseAppUrl(url, locationObj, html5Mode) {
                if (DOUBLE_SLASH_REGEX.test(url)) throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
                var prefixed = "/" !== url.charAt(0);
                prefixed && (url = "/" + url);
                var match = urlResolve(url), path = prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname;
                locationObj.$$path = function(path, html5Mode) {
                    for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = decodeURIComponent(segments[i]), 
                    html5Mode && (segments[i] = segments[i].replace(/\//g, "%2F"));
                    return segments.join("/");
                }(path, html5Mode), locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
                locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
            }
            function startsWith(str, search) {
                return str.slice(0, search.length) === search;
            }
            function stripBaseUrl(base, url) {
                if (startsWith(url, base)) return url.substr(base.length);
            }
            function stripHash(url) {
                var index = url.indexOf("#");
                return -1 === index ? url : url.substr(0, index);
            }
            function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
                this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), 
                this.$$parse = function(url) {
                    var pathUrl = stripBaseUrl(appBaseNoFile, url);
                    if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                    parseAppUrl(pathUrl, this, !0), this.$$path || (this.$$path = "/"), this.$$compose();
                }, this.$$normalizeUrl = function(url) {
                    return appBaseNoFile + url.substr(1);
                }, this.$$parseLinkUrl = function(url, relHref) {
                    return relHref && "#" === relHref[0] ? (this.hash(relHref.slice(1)), !0) : (isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, 
                    rewrittenUrl = basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
                    rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl);
                    var appUrl, prevAppUrl, rewrittenUrl;
                };
            }
            function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
                parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
                    var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
                    isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", 
                    isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : isUndefined(withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl)) && (withoutHashUrl = withoutBaseUrl), 
                    parseAppUrl(withoutHashUrl, this, !1), this.$$path = function(path, url, base) {
                        var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                        startsWith(url, base) && (url = url.replace(base, ""));
                        if (windowsFilePathExp.exec(url)) return path;
                        return (firstPathSegmentMatch = windowsFilePathExp.exec(path)) ? firstPathSegmentMatch[1] : path;
                    }(this.$$path, withoutHashUrl, appBase), this.$$compose();
                }, this.$$normalizeUrl = function(url) {
                    return appBase + (url ? hashPrefix + url : "");
                }, this.$$parseLinkUrl = function(url, relHref) {
                    return stripHash(appBase) === stripHash(url) && (this.$$parse(url), !0);
                };
            }
            function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
                this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
                    return relHref && "#" === relHref[0] ? (this.hash(relHref.slice(1)), !0) : (appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
                    rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl);
                    var rewrittenUrl, appUrl;
                }, this.$$normalizeUrl = function(url) {
                    return appBase + hashPrefix + url;
                };
            }
            var locationPrototype = {
                $$absUrl: "",
                $$html5: !1,
                $$replace: !1,
                $$compose: function() {
                    this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash), this.$$absUrl = this.$$normalizeUrl(this.$$url), 
                    this.$$urlUpdatedByLocation = !0;
                },
                absUrl: locationGetter("$$absUrl"),
                url: function(url) {
                    if (isUndefined(url)) return this.$$url;
                    var match = PATH_MATCH.exec(url);
                    return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), 
                    this.hash(match[5] || ""), this;
                },
                protocol: locationGetter("$$protocol"),
                host: locationGetter("$$host"),
                port: locationGetter("$$port"),
                path: locationGetterSetter("$$path", (function(path) {
                    return "/" === (path = null !== path ? path.toString() : "").charAt(0) ? path : "/" + path;
                })),
                search: function(search, paramValue) {
                    switch (arguments.length) {
                      case 0:
                        return this.$$search;

                      case 1:
                        if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                            if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                            forEach(search = copy(search, {}), (function(value, key) {
                                null == value && delete search[key];
                            })), this.$$search = search;
                        }
                        break;

                      default:
                        isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
                    }
                    return this.$$compose(), this;
                },
                hash: locationGetterSetter("$$hash", (function(hash) {
                    return null !== hash ? hash.toString() : "";
                })),
                replace: function() {
                    return this.$$replace = !0, this;
                }
            };
            function locationGetter(property) {
                return function() {
                    return this[property];
                };
            }
            function locationGetterSetter(property, preprocess) {
                return function(value) {
                    return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
                    this.$$compose(), this);
                };
            }
            function $LocationProvider() {
                var hashPrefix = "!", html5Mode = {
                    enabled: !1,
                    requireBase: !0,
                    rewriteLinks: !0
                };
                this.hashPrefix = function(prefix) {
                    return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
                }, this.html5Mode = function(mode) {
                    return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
                    isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
                    this) : html5Mode;
                }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
                    var $location, LocationMode, appBase, url, baseHref = $browser.baseHref(), initialUrl = $browser.url();
                    if (html5Mode.enabled) {
                        if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                        appBase = (url = initialUrl).substring(0, url.indexOf("/", url.indexOf("//") + 2)) + (baseHref || "/"), 
                        LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                    } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
                    var appBaseNoFile = function(url) {
                        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
                    }(appBase);
                    ($location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix)).$$parseLinkUrl(initialUrl, initialUrl), 
                    $location.$$state = $browser.state();
                    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                    function setBrowserUrlWithFallback(url, replace, state) {
                        var oldUrl = $location.url(), oldState = $location.$$state;
                        try {
                            $browser.url(url, replace, state), $location.$$state = $browser.state();
                        } catch (e) {
                            throw $location.url(oldUrl), $location.$$state = oldState, e;
                        }
                    }
                    $rootElement.on("click", (function(event) {
                        var rewriteLinks = html5Mode.rewriteLinks;
                        if (rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                            for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                            if (!isString(rewriteLinks) || !isUndefined(elm.attr(rewriteLinks))) {
                                var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                                isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                                IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                                $location.absUrl() !== $browser.url() && $rootScope.$apply());
                            }
                        }
                    })), $location.absUrl() !== initialUrl && $browser.url($location.absUrl(), !0);
                    var initializing = !0;
                    return $browser.onUrlChange((function(newUrl, newState) {
                        startsWith(newUrl, appBaseNoFile) ? ($rootScope.$evalAsync((function() {
                            var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                            $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                            $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                            $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                            afterLocationChange(oldUrl, oldState)));
                        })), $rootScope.$$phase || $rootScope.$digest()) : $window.location.href = newUrl;
                    })), $rootScope.$watch((function() {
                        if (initializing || $location.$$urlUpdatedByLocation) {
                            $location.$$urlUpdatedByLocation = !1;
                            var oldUrl = $browser.url(), newUrl = $location.absUrl(), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = !((a = oldUrl) === (b = newUrl) || urlResolve(a).href === urlResolve(b).href) || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                            (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync((function() {
                                var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                                $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                                $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                                afterLocationChange(oldUrl, oldState)));
                            })));
                        }
                        var a, b;
                        $location.$$replace = !1;
                    })), $location;
                    function afterLocationChange(oldUrl, oldState) {
                        $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
                    }
                } ];
            }
            function $LogProvider() {
                var debug = !0, self = this;
                this.debugEnabled = function(flag) {
                    return isDefined(flag) ? (debug = flag, this) : debug;
                }, this.$get = [ "$window", function($window) {
                    var fn, formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
                    return {
                        log: consoleLog("log"),
                        info: consoleLog("info"),
                        warn: consoleLog("warn"),
                        error: consoleLog("error"),
                        debug: (fn = consoleLog("debug"), function() {
                            debug && fn.apply(self, arguments);
                        })
                    };
                    function consoleLog(type) {
                        var console = $window.console || {}, logFn = console[type] || console.log || noop;
                        return function() {
                            var args = [];
                            return forEach(arguments, (function(arg) {
                                args.push(function(arg) {
                                    return isError(arg) && (arg.stack && formatStackTrace ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                                    arg;
                                }(arg));
                            })), Function.prototype.apply.call(logFn, console, args);
                        };
                    }
                } ];
            }
            forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], (function(Location) {
                Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
                    if (!arguments.length) return this.$$state;
                    if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
                    return this.$$state = isUndefined(state) ? null : state, this.$$urlUpdatedByLocation = !0, 
                    this;
                };
            }));
            var $parseMinErr = minErr("$parse"), objectValueOf = {}.constructor.prototype.valueOf;
            function getStringValue(name) {
                return name + "";
            }
            var OPERATORS = createMap();
            forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), (function(operator) {
                OPERATORS[operator] = !0;
            }));
            var ESCAPE = {
                n: "\n",
                f: "\f",
                r: "\r",
                t: "\t",
                v: "\v",
                "'": "'",
                '"': '"'
            }, Lexer = function(options) {
                this.options = options;
            };
            Lexer.prototype = {
                constructor: Lexer,
                lex: function(text) {
                    for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                        var ch = this.text.charAt(this.index);
                        if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                            index: this.index,
                            text: ch
                        }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                            var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                            if (op1 || op2 || op3) {
                                var token = op3 ? ch3 : op2 ? ch2 : ch;
                                this.tokens.push({
                                    index: this.index,
                                    text: token,
                                    operator: !0
                                }), this.index += token.length;
                            } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                        }
                    }
                    return this.tokens;
                },
                is: function(ch, chars) {
                    return -1 !== chars.indexOf(ch);
                },
                peek: function(i) {
                    var num = i || 1;
                    return this.index + num < this.text.length && this.text.charAt(this.index + num);
                },
                isNumber: function(ch) {
                    return "0" <= ch && ch <= "9" && "string" == typeof ch;
                },
                isWhitespace: function(ch) {
                    return " " === ch || "\r" === ch || "\t" === ch || "\n" === ch || "\v" === ch || "" === ch;
                },
                isIdentifierStart: function(ch) {
                    return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
                },
                isValidIdentifierStart: function(ch) {
                    return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || "$" === ch;
                },
                isIdentifierContinue: function(ch) {
                    return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
                },
                isValidIdentifierContinue: function(ch, cp) {
                    return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
                },
                codePointAt: function(ch) {
                    return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
                },
                peekMultichar: function() {
                    var ch = this.text.charAt(this.index), peek = this.peek();
                    if (!peek) return ch;
                    var cp1 = ch.charCodeAt(0), cp2 = peek.charCodeAt(0);
                    return cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343 ? ch + peek : ch;
                },
                isExpOperator: function(ch) {
                    return "-" === ch || "+" === ch || this.isNumber(ch);
                },
                throwError: function(error, start, end) {
                    end = end || this.index;
                    var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                    throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
                },
                readNumber: function() {
                    for (var number = "", start = this.index; this.index < this.text.length; ) {
                        var ch = lowercase(this.text.charAt(this.index));
                        if ("." === ch || this.isNumber(ch)) number += ch; else {
                            var peekCh = this.peek();
                            if ("e" === ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch; else {
                                if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                                this.throwError("Invalid exponent");
                            }
                        }
                        this.index++;
                    }
                    this.tokens.push({
                        index: start,
                        text: number,
                        constant: !0,
                        value: Number(number)
                    });
                },
                readIdent: function() {
                    var start = this.index;
                    for (this.index += this.peekMultichar().length; this.index < this.text.length; ) {
                        var ch = this.peekMultichar();
                        if (!this.isIdentifierContinue(ch)) break;
                        this.index += ch.length;
                    }
                    this.tokens.push({
                        index: start,
                        text: this.text.slice(start, this.index),
                        identifier: !0
                    });
                },
                readString: function(quote) {
                    var start = this.index;
                    this.index++;
                    for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                        var ch = this.text.charAt(this.index);
                        if (rawString += ch, escape) {
                            if ("u" === ch) {
                                var hex = this.text.substring(this.index + 1, this.index + 5);
                                hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                                this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                            } else {
                                string += ESCAPE[ch] || ch;
                            }
                            escape = !1;
                        } else if ("\\" === ch) escape = !0; else {
                            if (ch === quote) return this.index++, void this.tokens.push({
                                index: start,
                                text: rawString,
                                constant: !0,
                                value: string
                            });
                            string += ch;
                        }
                        this.index++;
                    }
                    this.throwError("Unterminated quote", start);
                }
            };
            var AST = function(lexer, options) {
                this.lexer = lexer, this.options = options;
            };
            function ifDefined(v, d) {
                return void 0 !== v ? v : d;
            }
            function plusFn(l, r) {
                return void 0 === l ? r : void 0 === r ? l : l + r;
            }
            AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", 
            AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", 
            AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", 
            AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", 
            AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", 
            AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", 
            AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", 
            AST.prototype = {
                ast: function(text) {
                    this.text = text, this.tokens = this.lexer.lex(text);
                    var value = this.program();
                    return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
                    value;
                },
                program: function() {
                    for (var body = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), 
                    !this.expect(";")) return {
                        type: AST.Program,
                        body
                    };
                },
                expressionStatement: function() {
                    return {
                        type: AST.ExpressionStatement,
                        expression: this.filterChain()
                    };
                },
                filterChain: function() {
                    for (var left = this.expression(); this.expect("|"); ) left = this.filter(left);
                    return left;
                },
                expression: function() {
                    return this.assignment();
                },
                assignment: function() {
                    var result = this.ternary();
                    if (this.expect("=")) {
                        if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                        result = {
                            type: AST.AssignmentExpression,
                            left: result,
                            right: this.assignment(),
                            operator: "="
                        };
                    }
                    return result;
                },
                ternary: function() {
                    var alternate, consequent, test = this.logicalOR();
                    return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), 
                    {
                        type: AST.ConditionalExpression,
                        test,
                        alternate,
                        consequent
                    }) : test;
                },
                logicalOR: function() {
                    for (var left = this.logicalAND(); this.expect("||"); ) left = {
                        type: AST.LogicalExpression,
                        operator: "||",
                        left,
                        right: this.logicalAND()
                    };
                    return left;
                },
                logicalAND: function() {
                    for (var left = this.equality(); this.expect("&&"); ) left = {
                        type: AST.LogicalExpression,
                        operator: "&&",
                        left,
                        right: this.equality()
                    };
                    return left;
                },
                equality: function() {
                    for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left,
                        right: this.relational()
                    };
                    return left;
                },
                relational: function() {
                    for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left,
                        right: this.additive()
                    };
                    return left;
                },
                additive: function() {
                    for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left,
                        right: this.multiplicative()
                    };
                    return left;
                },
                multiplicative: function() {
                    for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left,
                        right: this.unary()
                    };
                    return left;
                },
                unary: function() {
                    var token;
                    return (token = this.expect("+", "-", "!")) ? {
                        type: AST.UnaryExpression,
                        operator: token.text,
                        prefix: !0,
                        argument: this.unary()
                    } : this.primary();
                },
                primary: function() {
                    var primary, next;
                    for (this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                        type: AST.Literal,
                        value: this.options.literals[this.consume().text]
                    } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek()); next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                        type: AST.CallExpression,
                        callee: primary,
                        arguments: this.parseArguments()
                    }, this.consume(")")) : "[" === next.text ? (primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.expression(),
                        computed: !0
                    }, this.consume("]")) : "." === next.text ? primary = {
                        type: AST.MemberExpression,
                        object: primary,
                        property: this.identifier(),
                        computed: !1
                    } : this.throwError("IMPOSSIBLE");
                    return primary;
                },
                filter: function(baseExpression) {
                    for (var args = [ baseExpression ], result = {
                        type: AST.CallExpression,
                        callee: this.identifier(),
                        arguments: args,
                        filter: !0
                    }; this.expect(":"); ) args.push(this.expression());
                    return result;
                },
                parseArguments: function() {
                    var args = [];
                    if (")" !== this.peekToken().text) do {
                        args.push(this.filterChain());
                    } while (this.expect(","));
                    return args;
                },
                identifier: function() {
                    var token = this.consume();
                    return token.identifier || this.throwError("is not a valid identifier", token), 
                    {
                        type: AST.Identifier,
                        name: token.text
                    };
                },
                constant: function() {
                    return {
                        type: AST.Literal,
                        value: this.consume().value
                    };
                },
                arrayDeclaration: function() {
                    var elements = [];
                    if ("]" !== this.peekToken().text) do {
                        if (this.peek("]")) break;
                        elements.push(this.expression());
                    } while (this.expect(","));
                    return this.consume("]"), {
                        type: AST.ArrayExpression,
                        elements
                    };
                },
                object: function() {
                    var property, properties = [];
                    if ("}" !== this.peekToken().text) do {
                        if (this.peek("}")) break;
                        property = {
                            type: AST.Property,
                            kind: "init"
                        }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, 
                        this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), 
                        property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), 
                        property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), 
                        property.value = this.expression()) : this.throwError("invalid key", this.peek()), 
                        properties.push(property);
                    } while (this.expect(","));
                    return this.consume("}"), {
                        type: AST.ObjectExpression,
                        properties
                    };
                },
                throwError: function(msg, token) {
                    throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
                },
                consume: function(e1) {
                    if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                    var token = this.expect(e1);
                    return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
                    token;
                },
                peekToken: function() {
                    if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                    return this.tokens[0];
                },
                peek: function(e1, e2, e3, e4) {
                    return this.peekAhead(0, e1, e2, e3, e4);
                },
                peekAhead: function(i, e1, e2, e3, e4) {
                    if (this.tokens.length > i) {
                        var token = this.tokens[i], t = token.text;
                        if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
                    }
                    return !1;
                },
                expect: function(e1, e2, e3, e4) {
                    var token = this.peek(e1, e2, e3, e4);
                    return !!token && (this.tokens.shift(), token);
                },
                selfReferential: {
                    this: {
                        type: AST.ThisExpression
                    },
                    $locals: {
                        type: AST.LocalsExpression
                    }
                }
            };
            var PURITY_ABSOLUTE = 1, PURITY_RELATIVE = 2;
            function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
                var allConstants, argsToWatch, isStatelessFilter, astIsPure = ast.isPure = function(node, parentIsPure) {
                    switch (node.type) {
                      case AST.MemberExpression:
                        if (node.computed) return !1;
                        break;

                      case AST.UnaryExpression:
                        return PURITY_ABSOLUTE;

                      case AST.BinaryExpression:
                        return "+" !== node.operator && PURITY_ABSOLUTE;

                      case AST.CallExpression:
                        return !1;
                    }
                    return void 0 === parentIsPure ? PURITY_RELATIVE : parentIsPure;
                }(ast, parentIsPure);
                switch (ast.type) {
                  case AST.Program:
                    allConstants = !0, forEach(ast.body, (function(expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter, astIsPure), allConstants = allConstants && expr.expression.constant;
                    })), ast.constant = allConstants;
                    break;

                  case AST.Literal:
                    ast.constant = !0, ast.toWatch = [];
                    break;

                  case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter, astIsPure), ast.constant = ast.argument.constant, 
                    ast.toWatch = ast.argument.toWatch;
                    break;

                  case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
                    ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;

                  case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
                    ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter, astIsPure), findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure), 
                    findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, 
                    ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.Identifier:
                    ast.constant = !1, ast.toWatch = [ ast ];
                    break;

                  case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter, astIsPure), ast.computed && findConstantAndWatchExpressions(ast.property, $filter, astIsPure), 
                    ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), 
                    ast.toWatch = ast.constant ? [] : [ ast ];
                    break;

                  case AST.CallExpression:
                    isStatelessFilter = !!ast.filter && function($filter, filterName) {
                        return !$filter(filterName).$stateful;
                    }($filter, ast.callee.name), allConstants = isStatelessFilter, argsToWatch = [], 
                    forEach(ast.arguments, (function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, 
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    })), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
                    break;

                  case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
                    ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
                    break;

                  case AST.ArrayExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.elements, (function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, 
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    })), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;

                  case AST.ObjectExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.properties, (function(property) {
                        findConstantAndWatchExpressions(property.value, $filter, astIsPure), allConstants = allConstants && property.value.constant, 
                        argsToWatch.push.apply(argsToWatch, property.value.toWatch), property.computed && (findConstantAndWatchExpressions(property.key, $filter, !1), 
                        allConstants = allConstants && property.key.constant, argsToWatch.push.apply(argsToWatch, property.key.toWatch));
                    })), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;

                  case AST.ThisExpression:
                  case AST.LocalsExpression:
                    ast.constant = !1, ast.toWatch = [];
                }
            }
            function getInputs(body) {
                if (1 === body.length) {
                    var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
                    return 1 !== candidate.length || candidate[0] !== lastExpression ? candidate : void 0;
                }
            }
            function isAssignable(ast) {
                return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
            }
            function assignableAST(ast) {
                if (1 === ast.body.length && isAssignable(ast.body[0].expression)) return {
                    type: AST.AssignmentExpression,
                    left: ast.body[0].expression,
                    right: {
                        type: AST.NGValueParameter
                    },
                    operator: "="
                };
            }
            function ASTCompiler($filter) {
                this.$filter = $filter;
            }
            function ASTInterpreter($filter) {
                this.$filter = $filter;
            }
            function Parser(lexer, $filter, options) {
                this.ast = new AST(lexer, options), this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
            }
            function getValueOf(value) {
                return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
            }
            function $ParseProvider() {
                var identStart, identContinue, cache = createMap(), literals = {
                    true: !0,
                    false: !1,
                    null: null,
                    undefined: void 0
                };
                this.addLiteral = function(literalName, literalValue) {
                    literals[literalName] = literalValue;
                }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
                    return identStart = identifierStart, identContinue = identifierContinue, this;
                }, this.$get = [ "$filter", function($filter) {
                    var $parseOptions = {
                        csp: csp().noUnsafeEval,
                        literals: copy(literals),
                        isIdentifierStart: isFunction(identStart) && identStart,
                        isIdentifierContinue: isFunction(identContinue) && identContinue
                    };
                    return $parse.$$getAst = function(exp) {
                        return new Parser(new Lexer($parseOptions), $filter, $parseOptions).getAst(exp).ast;
                    }, $parse;
                    function $parse(exp, interceptorFn) {
                        var parsedExpression, cacheKey;
                        switch (typeof exp) {
                          case "string":
                            if (exp = exp.trim(), !(parsedExpression = cache[cacheKey = exp])) parsedExpression = new Parser(new Lexer($parseOptions), $filter, $parseOptions).parse(exp), 
                            cache[cacheKey] = addWatchDelegate(parsedExpression);
                            return addInterceptor(parsedExpression, interceptorFn);

                          case "function":
                            return addInterceptor(exp, interceptorFn);

                          default:
                            return addInterceptor(noop, interceptorFn);
                        }
                    }
                    function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                        return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : !("object" == typeof newValue && "object" == typeof (newValue = getValueOf(newValue)) && !compareObjectIdentity) && (newValue === oldValueOfValue || newValue != newValue && oldValueOfValue != oldValueOfValue);
                    }
                    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var lastResult, inputExpressions = parsedExpression.inputs;
                        if (1 === inputExpressions.length) {
                            var oldInputValueOf = expressionInputDirtyCheck;
                            return inputExpressions = inputExpressions[0], scope.$watch((function(scope) {
                                var newInputValue = inputExpressions(scope);
                                return expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure) || (lastResult = parsedExpression(scope, void 0, void 0, [ newInputValue ]), 
                                oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                            }), listener, objectEquality, prettyPrintExpression);
                        }
                        for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; i < ii; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, 
                        oldInputValues[i] = null;
                        return scope.$watch((function(scope) {
                            for (var changed = !1, i = 0, ii = inputExpressions.length; i < ii; i++) {
                                var newInputValue = inputExpressions[i](scope);
                                (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) && (oldInputValues[i] = newInputValue, 
                                oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                            }
                            return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)), 
                            lastResult;
                        }), listener, objectEquality, prettyPrintExpression);
                    }
                    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var unwatch, lastValue, isDone = parsedExpression.literal ? isAllDefined : isDefined, exp = parsedExpression.$$intercepted || parsedExpression, post = parsedExpression.$$interceptor || identity, useInputs = parsedExpression.inputs && !exp.inputs;
                        return oneTimeWatch.literal = parsedExpression.literal, oneTimeWatch.constant = parsedExpression.constant, 
                        oneTimeWatch.inputs = parsedExpression.inputs, addWatchDelegate(oneTimeWatch), unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);
                        function unwatchIfDone() {
                            isDone(lastValue) && unwatch();
                        }
                        function oneTimeWatch(scope, locals, assign, inputs) {
                            return lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs), 
                            isDone(lastValue) && scope.$$postDigest(unwatchIfDone), post(lastValue);
                        }
                    }
                    function isAllDefined(value) {
                        var allDefined = !0;
                        return forEach(value, (function(val) {
                            isDefined(val) || (allDefined = !1);
                        })), allDefined;
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch = scope.$watch((function(scope) {
                            return unwatch(), parsedExpression(scope);
                        }), listener, objectEquality);
                        return unwatch;
                    }
                    function addWatchDelegate(parsedExpression) {
                        return parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : parsedExpression.oneTime ? parsedExpression.$$watchDelegate = oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                        parsedExpression;
                    }
                    function addInterceptor(parsedExpression, interceptorFn) {
                        if (!interceptorFn) return parsedExpression;
                        parsedExpression.$$interceptor && (interceptorFn = function(first, second) {
                            function chainedInterceptor(value) {
                                return second(first(value));
                            }
                            return chainedInterceptor.$stateful = first.$stateful || second.$stateful, chainedInterceptor.$$pure = first.$$pure && second.$$pure, 
                            chainedInterceptor;
                        }(parsedExpression.$$interceptor, interceptorFn), parsedExpression = parsedExpression.$$intercepted);
                        var useInputs = !1, fn = function(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value);
                        };
                        return fn.$$intercepted = parsedExpression, fn.$$interceptor = interceptorFn, fn.literal = parsedExpression.literal, 
                        fn.oneTime = parsedExpression.oneTime, fn.constant = parsedExpression.constant, 
                        interceptorFn.$stateful || (useInputs = !parsedExpression.inputs, fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ], 
                        interceptorFn.$$pure || (fn.inputs = fn.inputs.map((function(e) {
                            return e.isPure === PURITY_RELATIVE ? function(s) {
                                return e(s);
                            } : e;
                        })))), addWatchDelegate(fn);
                    }
                } ];
            }
            function $QProvider() {
                var errorOnUnhandledRejections = !0;
                this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
                    return qFactory((function(callback) {
                        $rootScope.$evalAsync(callback);
                    }), $exceptionHandler, errorOnUnhandledRejections);
                } ], this.errorOnUnhandledRejections = function(value) {
                    return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
                };
            }
            function $$QProvider() {
                var errorOnUnhandledRejections = !0;
                this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
                    return qFactory((function(callback) {
                        $browser.defer(callback);
                    }), $exceptionHandler, errorOnUnhandledRejections);
                } ], this.errorOnUnhandledRejections = function(value) {
                    return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
                };
            }
            function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
                var $qMinErr = minErr("$q", TypeError), queueSize = 0, checkQueue = [];
                function defer() {
                    return new Deferred;
                }
                function Deferred() {
                    var promise = this.promise = new Promise;
                    this.resolve = function(val) {
                        resolvePromise(promise, val);
                    }, this.reject = function(reason) {
                        rejectPromise(promise, reason);
                    }, this.notify = function(progress) {
                        notifyPromise(promise, progress);
                    };
                }
                function Promise() {
                    this.$$state = {
                        status: 0
                    };
                }
                function processChecks() {
                    for (;!queueSize && checkQueue.length; ) {
                        var toCheck = checkQueue.shift();
                        if (!isStateExceptionHandled(toCheck)) {
                            markQStateExceptionHandled(toCheck);
                            var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                            isError(toCheck.value) ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage);
                        }
                    }
                }
                function scheduleProcessQueue(state) {
                    !errorOnUnhandledRejections || state.pending || 2 !== state.status || isStateExceptionHandled(state) || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks), 
                    checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0, 
                    ++queueSize, nextTick((function() {
                        !function(state) {
                            var fn, promise, pending;
                            pending = state.pending, state.processScheduled = !1, state.pending = void 0;
                            try {
                                for (var i = 0, ii = pending.length; i < ii; ++i) {
                                    markQStateExceptionHandled(state), promise = pending[i][0], fn = pending[i][state.status];
                                    try {
                                        isFunction(fn) ? resolvePromise(promise, fn(state.value)) : 1 === state.status ? resolvePromise(promise, state.value) : rejectPromise(promise, state.value);
                                    } catch (e) {
                                        rejectPromise(promise, e), e && !0 === e.$$passToExceptionHandler && exceptionHandler(e);
                                    }
                                }
                            } finally {
                                --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks);
                            }
                        }(state);
                    })));
                }
                function resolvePromise(promise, val) {
                    promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : $$resolve(promise, val));
                }
                function $$resolve(promise, val) {
                    var then, done = !1;
                    try {
                        (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1, 
                        then.call(val, (function(val) {
                            if (done) return;
                            done = !0, $$resolve(promise, val);
                        }), doReject, (function(progress) {
                            notifyPromise(promise, progress);
                        }))) : (promise.$$state.value = val, promise.$$state.status = 1, scheduleProcessQueue(promise.$$state));
                    } catch (e) {
                        doReject(e);
                    }
                    function doReject(val) {
                        done || (done = !0, $$reject(promise, val));
                    }
                }
                function rejectPromise(promise, reason) {
                    promise.$$state.status || $$reject(promise, reason);
                }
                function $$reject(promise, reason) {
                    promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state);
                }
                function notifyPromise(promise, progress) {
                    var callbacks = promise.$$state.pending;
                    promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick((function() {
                        for (var callback, result, i = 0, ii = callbacks.length; i < ii; i++) {
                            result = callbacks[i][0], callback = callbacks[i][3];
                            try {
                                notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                            } catch (e) {
                                exceptionHandler(e);
                            }
                        }
                    }));
                }
                function reject(reason) {
                    var result = new Promise;
                    return rejectPromise(result, reason), result;
                }
                function handleCallback(value, resolver, callback) {
                    var callbackOutput = null;
                    try {
                        isFunction(callback) && (callbackOutput = callback());
                    } catch (e) {
                        return reject(e);
                    }
                    return isPromiseLike(callbackOutput) ? callbackOutput.then((function() {
                        return resolver(value);
                    }), reject) : resolver(value);
                }
                function when(value, callback, errback, progressBack) {
                    var result = new Promise;
                    return resolvePromise(result, value), result.then(callback, errback, progressBack);
                }
                extend(Promise.prototype, {
                    then: function(onFulfilled, onRejected, progressBack) {
                        if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                        var result = new Promise;
                        return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                        this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result;
                    },
                    catch: function(callback) {
                        return this.then(null, callback);
                    },
                    finally: function(callback, progressBack) {
                        return this.then((function(value) {
                            return handleCallback(value, resolve, callback);
                        }), (function(error) {
                            return handleCallback(error, reject, callback);
                        }), progressBack);
                    }
                });
                var resolve = when;
                function $Q(resolver) {
                    if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
                    var promise = new Promise;
                    return resolver((function(value) {
                        resolvePromise(promise, value);
                    }), (function(reason) {
                        rejectPromise(promise, reason);
                    })), promise;
                }
                return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, 
                $Q.resolve = resolve, $Q.all = function(promises) {
                    var result = new Promise, counter = 0, results = isArray(promises) ? [] : {};
                    return forEach(promises, (function(promise, key) {
                        counter++, when(promise).then((function(value) {
                            results[key] = value, --counter || resolvePromise(result, results);
                        }), (function(reason) {
                            rejectPromise(result, reason);
                        }));
                    })), 0 === counter && resolvePromise(result, results), result;
                }, $Q.race = function(promises) {
                    var deferred = defer();
                    return forEach(promises, (function(promise) {
                        when(promise).then(deferred.resolve, deferred.reject);
                    })), deferred.promise;
                }, $Q;
            }
            function isStateExceptionHandled(state) {
                return !!state.pur;
            }
            function markQStateExceptionHandled(state) {
                state.pur = !0;
            }
            function markQExceptionHandled(q) {
                q.$$state && markQStateExceptionHandled(q.$$state);
            }
            function $$RAFProvider() {
                this.$get = [ "$window", "$timeout", function($window, $timeout) {
                    var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                        var id = requestAnimationFrame(fn);
                        return function() {
                            cancelAnimationFrame(id);
                        };
                    } : function(fn) {
                        var timer = $timeout(fn, 16.66, !1);
                        return function() {
                            $timeout.cancel(timer);
                        };
                    };
                    return raf.supported = rafSupported, raf;
                } ];
            }
            function $RootScopeProvider() {
                var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
                this.digestTtl = function(value) {
                    return arguments.length && (TTL = value), TTL;
                }, this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
                    function destroyChildScope($event) {
                        $event.currentScope.$$destroyed = !0;
                    }
                    function cleanUpScope($scope) {
                        9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), 
                        $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                    }
                    function Scope() {
                        this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                        this.$root = this, this.$$destroyed = !1, this.$$suspended = !1, this.$$listeners = {}, 
                        this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null;
                    }
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function(isolate, parent) {
                            var child;
                            return parent = parent || this, isolate ? (child = new Scope).$root = this.$root : (this.$$ChildScope || (this.$$ChildScope = function(parent) {
                                function ChildScope() {
                                    this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                                    this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), 
                                    this.$$ChildScope = null, this.$$suspended = !1;
                                }
                                return ChildScope.prototype = parent, ChildScope;
                            }(this)), child = new this.$$ChildScope), child.$parent = parent, child.$$prevSibling = parent.$$childTail, 
                            parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, 
                            (isolate || parent !== this) && child.$on("$destroy", destroyChildScope), child;
                        },
                        $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                            var get = $parse(watchExp), fn = isFunction(listener) ? listener : noop;
                            if (get.$$watchDelegate) return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                            var scope = this, array = scope.$$watchers, watcher = {
                                fn,
                                last: initWatchVal,
                                get,
                                exp: prettyPrintExpression || watchExp,
                                eq: !!objectEquality
                            };
                            return lastDirtyWatch = null, array || ((array = scope.$$watchers = []).$$digestWatchIndex = -1), 
                            array.unshift(watcher), array.$$digestWatchIndex++, incrementWatchersCount(this, 1), 
                            function() {
                                var index = arrayRemove(array, watcher);
                                index >= 0 && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--), 
                                lastDirtyWatch = null;
                            };
                        },
                        $watchGroup: function(watchExpressions, listener) {
                            var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                            if (!watchExpressions.length) {
                                var shouldCall = !0;
                                return self.$evalAsync((function() {
                                    shouldCall && listener(newValues, newValues, self);
                                })), function() {
                                    shouldCall = !1;
                                };
                            }
                            if (1 === watchExpressions.length) return this.$watch(watchExpressions[0], (function(value, oldValue, scope) {
                                newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                            }));
                            function watchGroupAction() {
                                changeReactionScheduled = !1;
                                try {
                                    firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                                } finally {
                                    for (var i = 0; i < watchExpressions.length; i++) oldValues[i] = newValues[i];
                                }
                            }
                            return forEach(watchExpressions, (function(expr, i) {
                                var unwatchFn = self.$watch(expr, (function(value) {
                                    newValues[i] = value, changeReactionScheduled || (changeReactionScheduled = !0, 
                                    self.$evalAsync(watchGroupAction));
                                }));
                                deregisterFns.push(unwatchFn);
                            })), function() {
                                for (;deregisterFns.length; ) deregisterFns.shift()();
                            };
                        },
                        $watchCollection: function(obj, listener) {
                            $watchCollectionInterceptor.$$pure = $parse(obj).literal, $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                            var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                            function $watchCollectionInterceptor(_value) {
                                var newLength, key, newItem, oldItem;
                                if (!isUndefined(newValue = _value)) {
                                    if (isObject(newValue)) if (isArrayLike(newValue)) {
                                        oldValue !== internalArray && (oldLength = (oldValue = internalArray).length = 0, 
                                        changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                        oldValue.length = oldLength = newLength);
                                        for (var i = 0; i < newLength; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                        oldItem != oldItem && newItem != newItem || oldItem === newItem || (changeDetected++, 
                                        oldValue[i] = newItem);
                                    } else {
                                        for (key in oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, 
                                        changeDetected++), newLength = 0, newValue) hasOwnProperty.call(newValue, key) && (newLength++, 
                                        newItem = newValue[key], oldItem = oldValue[key], key in oldValue ? oldItem != oldItem && newItem != newItem || oldItem === newItem || (changeDetected++, 
                                        oldValue[key] = newItem) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                        if (oldLength > newLength) for (key in changeDetected++, oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, 
                                        delete oldValue[key]);
                                    } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                    return changeDetected;
                                }
                            }
                            return this.$watch(changeDetector, (function() {
                                if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                                trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                                    veryOldValue = new Array(newValue.length);
                                    for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                                } else for (var key in veryOldValue = {}, newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]); else veryOldValue = newValue;
                            }));
                        },
                        $digest: function() {
                            var watch, value, last, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = asyncQueue.length ? $rootScope : this, watchLog = [];
                            beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                            flushApplyAsync()), lastDirtyWatch = null;
                            do {
                                dirty = !1, current = target;
                                for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                                    try {
                                        (0, (asyncTask = asyncQueue[asyncQueuePosition]).fn)(asyncTask.scope, asyncTask.locals);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    lastDirtyWatch = null;
                                }
                                asyncQueue.length = 0;
                                traverseScopesLoop: do {
                                    if (watchers = !current.$$suspended && current.$$watchers) for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--; ) try {
                                        if (watch = watchers[watchers.$$digestWatchIndex]) if ((value = (0, watch.get)(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                            if (watch === lastDirtyWatch) {
                                                dirty = !1;
                                                break traverseScopesLoop;
                                            }
                                        } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                        (0, watch.fn)(value, last === initWatchVal ? value : last, current), ttl < 5 && (watchLog[logIdx = 4 - ttl] || (watchLog[logIdx] = []), 
                                        watchLog[logIdx].push({
                                            msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                            newVal: value,
                                            oldVal: last
                                        }));
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                                } while (current = next);
                                if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                            } while (dirty || asyncQueue.length);
                            for (clearPhase(); postDigestQueuePosition < postDigestQueue.length; ) try {
                                postDigestQueue[postDigestQueuePosition++]();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            postDigestQueue.length = postDigestQueuePosition = 0, $browser.$$checkUrlChange();
                        },
                        $suspend: function() {
                            this.$$suspended = !0;
                        },
                        $isSuspended: function() {
                            return this.$$suspended;
                        },
                        $resume: function() {
                            this.$$suspended = !1;
                        },
                        $destroy: function() {
                            if (!this.$$destroyed) {
                                var parent = this.$parent;
                                for (var eventName in this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), 
                                incrementWatchersCount(this, -this.$$watchersCount), this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                                parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling), 
                                parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling), 
                                this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                                this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                                this.$on = this.$watch = this.$watchGroup = function() {
                                    return noop;
                                }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this);
                            }
                        },
                        $eval: function(expr, locals) {
                            return $parse(expr)(this, locals);
                        },
                        $evalAsync: function(expr, locals) {
                            $rootScope.$$phase || asyncQueue.length || $browser.defer((function() {
                                asyncQueue.length && $rootScope.$digest();
                            }), null, "$evalAsync"), asyncQueue.push({
                                scope: this,
                                fn: $parse(expr),
                                locals
                            });
                        },
                        $$postDigest: function(fn) {
                            postDigestQueue.push(fn);
                        },
                        $apply: function(expr) {
                            try {
                                beginPhase("$apply");
                                try {
                                    return this.$eval(expr);
                                } finally {
                                    clearPhase();
                                }
                            } catch (e) {
                                $exceptionHandler(e);
                            } finally {
                                try {
                                    $rootScope.$digest();
                                } catch (e) {
                                    throw $exceptionHandler(e), e;
                                }
                            }
                        },
                        $applyAsync: function(expr) {
                            var scope = this;
                            expr && applyAsyncQueue.push((function() {
                                scope.$eval(expr);
                            })), expr = $parse(expr), null === applyAsyncId && (applyAsyncId = $browser.defer((function() {
                                $rootScope.$apply(flushApplyAsync);
                            }), null, "$applyAsync"));
                        },
                        $on: function(name, listener) {
                            var namedListeners = this.$$listeners[name];
                            namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                            var current = this;
                            do {
                                current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++;
                            } while (current = current.$parent);
                            var self = this;
                            return function() {
                                var indexOfListener = namedListeners.indexOf(listener);
                                -1 !== indexOfListener && (delete namedListeners[indexOfListener], decrementListenerCount(self, 1, name));
                            };
                        },
                        $emit: function(name, args) {
                            var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                                name,
                                targetScope: scope,
                                stopPropagation: function() {
                                    stopPropagation = !0;
                                },
                                preventDefault: function() {
                                    event.defaultPrevented = !0;
                                },
                                defaultPrevented: !1
                            }, listenerArgs = concat([ event ], arguments, 1);
                            do {
                                for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                                i = 0, length = namedListeners.length; i < length; i++) if (namedListeners[i]) try {
                                    namedListeners[i].apply(null, listenerArgs);
                                } catch (e) {
                                    $exceptionHandler(e);
                                } else namedListeners.splice(i, 1), i--, length--;
                                if (stopPropagation) break;
                                scope = scope.$parent;
                            } while (scope);
                            return event.currentScope = null, event;
                        },
                        $broadcast: function(name, args) {
                            var current = this, next = this, event = {
                                name,
                                targetScope: this,
                                preventDefault: function() {
                                    event.defaultPrevented = !0;
                                },
                                defaultPrevented: !1
                            };
                            if (!this.$$listenerCount[name]) return event;
                            for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                                for (event.currentScope = current, i = 0, length = (listeners = current.$$listeners[name] || []).length; i < length; i++) if (listeners[i]) try {
                                    listeners[i].apply(null, listenerArgs);
                                } catch (e) {
                                    $exceptionHandler(e);
                                } else listeners.splice(i, 1), i--, length--;
                                if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== this && current.$$nextSibling)) for (;current !== this && !(next = current.$$nextSibling); ) current = current.$parent;
                            }
                            return event.currentScope = null, event;
                        }
                    };
                    var $rootScope = new Scope, asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [], postDigestQueuePosition = 0;
                    return $rootScope;
                    function beginPhase(phase) {
                        if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                        $rootScope.$$phase = phase;
                    }
                    function clearPhase() {
                        $rootScope.$$phase = null;
                    }
                    function incrementWatchersCount(current, count) {
                        do {
                            current.$$watchersCount += count;
                        } while (current = current.$parent);
                    }
                    function decrementListenerCount(current, count, name) {
                        do {
                            current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name];
                        } while (current = current.$parent);
                    }
                    function initWatchVal() {}
                    function flushApplyAsync() {
                        for (;applyAsyncQueue.length; ) try {
                            applyAsyncQueue.shift()();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        applyAsyncId = null;
                    }
                } ];
            }
            function $$SanitizeUriProvider() {
                var aHrefSanitizationTrustedUrlList = /^\s*(https?|s?ftp|mailto|tel|file):/, imgSrcSanitizationTrustedUrlList = /^\s*((https?|ftp|file|blob):|data:image\/)/;
                this.aHrefSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? (aHrefSanitizationTrustedUrlList = regexp, this) : aHrefSanitizationTrustedUrlList;
                }, this.imgSrcSanitizationTrustedUrlList = function(regexp) {
                    return isDefined(regexp) ? (imgSrcSanitizationTrustedUrlList = regexp, this) : imgSrcSanitizationTrustedUrlList;
                }, this.$get = function() {
                    return function(uri, isMediaUrl) {
                        var regex = isMediaUrl ? imgSrcSanitizationTrustedUrlList : aHrefSanitizationTrustedUrlList, normalizedVal = urlResolve(uri && uri.trim()).href;
                        return "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
                    };
                };
            }
            ASTCompiler.prototype = {
                compile: function(ast) {
                    var self = this;
                    this.state = {
                        nextId: 0,
                        filters: {},
                        fn: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        assign: {
                            vars: [],
                            body: [],
                            own: {}
                        },
                        inputs: []
                    }, findConstantAndWatchExpressions(ast, self.$filter);
                    var assignable, extra = "";
                    if (this.stage = "assign", assignable = assignableAST(ast)) {
                        this.state.computing = "assign";
                        var result = this.nextId();
                        this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
                    }
                    var toWatch = getInputs(ast.body);
                    self.stage = "inputs", forEach(toWatch, (function(watch, key) {
                        var fnKey = "fn" + key;
                        self.state[fnKey] = {
                            vars: [],
                            body: [],
                            own: {}
                        }, self.state.computing = fnKey;
                        var intoId = self.nextId();
                        self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push({
                            name: fnKey,
                            isPure: watch.isPure
                        }), watch.watchId = key;
                    })), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
                    var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
                    return this.state = this.stage = void 0, fn;
                },
                USE: "use",
                STRICT: "strict",
                watchFns: function() {
                    var result = [], inputs = this.state.inputs, self = this;
                    return forEach(inputs, (function(input) {
                        result.push("var " + input.name + "=" + self.generateFunction(input.name, "s")), 
                        input.isPure && result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";");
                    })), inputs.length && result.push("fn.inputs=[" + inputs.map((function(i) {
                        return i.name;
                    })).join(",") + "];"), result.join("");
                },
                generateFunction: function(name, params) {
                    return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
                },
                filterPrefix: function() {
                    var parts = [], self = this;
                    return forEach(this.state.filters, (function(id, filter) {
                        parts.push(id + "=$filter(" + self.escape(filter) + ")");
                    })), parts.length ? "var " + parts.join(",") + ";" : "";
                },
                varsPrefix: function(section) {
                    return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
                },
                body: function(section) {
                    return this.state[section].body.join("");
                },
                recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var left, right, args, expression, computed, self = this;
                    if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), 
                    void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
                    switch (ast.type) {
                      case AST.Program:
                        forEach(ast.body, (function(expression, pos) {
                            self.recurse(expression.expression, void 0, void 0, (function(expr) {
                                right = expr;
                            })), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                        }));
                        break;

                      case AST.Literal:
                        expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;

                      case AST.UnaryExpression:
                        this.recurse(ast.argument, void 0, void 0, (function(expr) {
                            right = expr;
                        })), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), 
                        recursionFn(expression);
                        break;

                      case AST.BinaryExpression:
                        this.recurse(ast.left, void 0, void 0, (function(expr) {
                            left = expr;
                        })), this.recurse(ast.right, void 0, void 0, (function(expr) {
                            right = expr;
                        })), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", 
                        this.assign(intoId, expression), recursionFn(expression);
                        break;

                      case AST.LogicalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), 
                        recursionFn(intoId);
                        break;

                      case AST.ConditionalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), 
                        recursionFn(intoId);
                        break;

                      case AST.Identifier:
                        intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), 
                        nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), (function() {
                            self.if_("inputs" === self.stage || "s", (function() {
                                create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), 
                                self.assign(intoId, self.nonComputedMember("s", ast.name));
                            }));
                        }), intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                        break;

                      case AST.MemberExpression:
                        left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), 
                        self.recurse(ast.object, left, void 0, (function() {
                            self.if_(self.notNull(left), (function() {
                                ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), 
                                create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), 
                                expression = self.computedMember(left, right), self.assign(intoId, expression), 
                                nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), 
                                expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression), 
                                nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                            }), (function() {
                                self.assign(intoId, "undefined");
                            })), recursionFn(intoId);
                        }), !!create);
                        break;

                      case AST.CallExpression:
                        intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), 
                        args = [], forEach(ast.arguments, (function(expr) {
                            var argument = self.nextId();
                            self.recurse(expr, argument), args.push(argument);
                        })), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), 
                        recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, (function() {
                            self.if_(self.notNull(right), (function() {
                                forEach(ast.arguments, (function(expr) {
                                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, (function(argument) {
                                        args.push(argument);
                                    }));
                                })), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")", 
                                self.assign(intoId, expression);
                            }), (function() {
                                self.assign(intoId, "undefined");
                            })), recursionFn(intoId);
                        })));
                        break;

                      case AST.AssignmentExpression:
                        right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, (function() {
                            self.if_(self.notNull(left.context), (function() {
                                self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, 
                                self.assign(intoId, expression), recursionFn(intoId || expression);
                            }));
                        }), 1);
                        break;

                      case AST.ArrayExpression:
                        args = [], forEach(ast.elements, (function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, (function(argument) {
                                args.push(argument);
                            }));
                        })), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;

                      case AST.ObjectExpression:
                        args = [], computed = !1, forEach(ast.properties, (function(property) {
                            property.computed && (computed = !0);
                        })), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, (function(property) {
                            property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, 
                            right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right);
                        }))) : (forEach(ast.properties, (function(property) {
                            self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, (function(expr) {
                                args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                            }));
                        })), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), 
                        recursionFn(intoId || expression);
                        break;

                      case AST.ThisExpression:
                        this.assign(intoId, "s"), recursionFn(intoId || "s");
                        break;

                      case AST.LocalsExpression:
                        this.assign(intoId, "l"), recursionFn(intoId || "l");
                        break;

                      case AST.NGValueParameter:
                        this.assign(intoId, "v"), recursionFn(intoId || "v");
                    }
                },
                getHasOwnProperty: function(element, property) {
                    var key = element + "." + property, own = this.current().own;
                    return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), 
                    own[key];
                },
                assign: function(id, value) {
                    if (id) return this.current().body.push(id, "=", value, ";"), id;
                },
                filter: function(filterName) {
                    return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), 
                    this.state.filters[filterName];
                },
                ifDefined: function(id, defaultValue) {
                    return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
                },
                plus: function(left, right) {
                    return "plus(" + left + "," + right + ")";
                },
                return_: function(id) {
                    this.current().body.push("return ", id, ";");
                },
                if_: function(test, alternate, consequent) {
                    if (!0 === test) alternate(); else {
                        var body = this.current().body;
                        body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), 
                        consequent(), body.push("}"));
                    }
                },
                not: function(expression) {
                    return "!(" + expression + ")";
                },
                isNull: function(expression) {
                    return expression + "==null";
                },
                notNull: function(expression) {
                    return expression + "!=null";
                },
                nonComputedMember: function(left, right) {
                    return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(right) ? left + "." + right : left + '["' + right.replace(/[^$_a-zA-Z0-9]/g, this.stringEscapeFn) + '"]';
                },
                computedMember: function(left, right) {
                    return left + "[" + right + "]";
                },
                member: function(left, right, computed) {
                    return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
                },
                getStringValue: function(item) {
                    this.assign(item, "getStringValue(" + item + ")");
                },
                lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                    var self = this;
                    return function() {
                        self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
                    };
                },
                lazyAssign: function(id, value) {
                    var self = this;
                    return function() {
                        self.assign(id, value);
                    };
                },
                stringEscapeRegex: /[^ a-zA-Z0-9]/g,
                stringEscapeFn: function(c) {
                    return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
                },
                escape: function(value) {
                    if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
                    if (isNumber(value)) return value.toString();
                    if (!0 === value) return "true";
                    if (!1 === value) return "false";
                    if (null === value) return "null";
                    if (void 0 === value) return "undefined";
                    throw $parseMinErr("esc", "IMPOSSIBLE");
                },
                nextId: function(skip, init) {
                    var id = "v" + this.state.nextId++;
                    return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
                },
                current: function() {
                    return this.state[this.state.computing];
                }
            }, ASTInterpreter.prototype = {
                compile: function(ast) {
                    var assignable, assign, self = this;
                    findConstantAndWatchExpressions(ast, self.$filter), (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
                    var inputs, toWatch = getInputs(ast.body);
                    toWatch && (inputs = [], forEach(toWatch, (function(watch, key) {
                        var input = self.recurse(watch);
                        input.isPure = watch.isPure, watch.input = input, inputs.push(input), watch.watchId = key;
                    })));
                    var expressions = [];
                    forEach(ast.body, (function(expression) {
                        expressions.push(self.recurse(expression.expression));
                    }));
                    var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                        var lastValue;
                        return forEach(expressions, (function(exp) {
                            lastValue = exp(scope, locals);
                        })), lastValue;
                    };
                    return assign && (fn.assign = function(scope, value, locals) {
                        return assign(scope, locals, value);
                    }), inputs && (fn.inputs = inputs), fn;
                },
                recurse: function(ast, context, create) {
                    var left, right, args, self = this;
                    if (ast.input) return this.inputs(ast.input, ast.watchId);
                    switch (ast.type) {
                      case AST.Literal:
                        return this.value(ast.value, context);

                      case AST.UnaryExpression:
                        return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

                      case AST.BinaryExpression:
                      case AST.LogicalExpression:
                        return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

                      case AST.ConditionalExpression:
                        return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

                      case AST.Identifier:
                        return self.identifier(ast.name, context, create);

                      case AST.MemberExpression:
                        return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name), 
                        ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

                      case AST.CallExpression:
                        return args = [], forEach(ast.arguments, (function(expr) {
                            args.push(self.recurse(expr));
                        })), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), 
                        ast.filter ? function(scope, locals, assign, inputs) {
                            for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                            var value = right.apply(void 0, values, inputs);
                            return context ? {
                                context: void 0,
                                name: void 0,
                                value
                            } : value;
                        } : function(scope, locals, assign, inputs) {
                            var value, rhs = right(scope, locals, assign, inputs);
                            if (null != rhs.value) {
                                for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                                value = rhs.value.apply(rhs.context, values);
                            }
                            return context ? {
                                value
                            } : value;
                        };

                      case AST.AssignmentExpression:
                        return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, inputs) {
                            var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                            return lhs.context[lhs.name] = rhs, context ? {
                                value: rhs
                            } : rhs;
                        };

                      case AST.ArrayExpression:
                        return args = [], forEach(ast.elements, (function(expr) {
                            args.push(self.recurse(expr));
                        })), function(scope, locals, assign, inputs) {
                            for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                            return context ? {
                                value
                            } : value;
                        };

                      case AST.ObjectExpression:
                        return args = [], forEach(ast.properties, (function(property) {
                            property.computed ? args.push({
                                key: self.recurse(property.key),
                                computed: !0,
                                value: self.recurse(property.value)
                            }) : args.push({
                                key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                                computed: !1,
                                value: self.recurse(property.value)
                            });
                        })), function(scope, locals, assign, inputs) {
                            for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                            return context ? {
                                value
                            } : value;
                        };

                      case AST.ThisExpression:
                        return function(scope) {
                            return context ? {
                                value: scope
                            } : scope;
                        };

                      case AST.LocalsExpression:
                        return function(scope, locals) {
                            return context ? {
                                value: locals
                            } : locals;
                        };

                      case AST.NGValueParameter:
                        return function(scope, locals, assign) {
                            return context ? {
                                value: assign
                            } : assign;
                        };
                    }
                },
                "unary+": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        return arg = isDefined(arg) ? +arg : 0, context ? {
                            value: arg
                        } : arg;
                    };
                },
                "unary-": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = argument(scope, locals, assign, inputs);
                        return arg = isDefined(arg) ? -arg : -0, context ? {
                            value: arg
                        } : arg;
                    };
                },
                "unary!": function(argument, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = !argument(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary+": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = plusFn(left(scope, locals, assign, inputs), right(scope, locals, assign, inputs));
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary-": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary*": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary/": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary%": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary===": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary!==": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary==": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary!=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary<": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary>": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary<=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary>=": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary&&": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "binary||": function(left, right, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                "ternary?:": function(test, alternate, consequent, context) {
                    return function(scope, locals, assign, inputs) {
                        var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                        return context ? {
                            value: arg
                        } : arg;
                    };
                },
                value: function(value, context) {
                    return function() {
                        return context ? {
                            context: void 0,
                            name: void 0,
                            value
                        } : value;
                    };
                },
                identifier: function(name, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var base = locals && name in locals ? locals : scope;
                        create && 1 !== create && base && null == base[name] && (base[name] = {});
                        var value = base ? base[name] : void 0;
                        return context ? {
                            context: base,
                            name,
                            value
                        } : value;
                    };
                },
                computedMember: function(left, right, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var rhs, value, lhs = left(scope, locals, assign, inputs);
                        return null != lhs && (rhs = getStringValue(rhs = right(scope, locals, assign, inputs)), 
                        create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs]), 
                        context ? {
                            context: lhs,
                            name: rhs,
                            value
                        } : value;
                    };
                },
                nonComputedMember: function(left, right, context, create) {
                    return function(scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                        var value = null != lhs ? lhs[right] : void 0;
                        return context ? {
                            context: lhs,
                            name: right,
                            value
                        } : value;
                    };
                },
                inputs: function(input, watchId) {
                    return function(scope, value, locals, inputs) {
                        return inputs ? inputs[watchId] : input(scope, value, locals);
                    };
                }
            }, Parser.prototype = {
                constructor: Parser,
                parse: function(text) {
                    var ast = this.getAst(text), fn = this.astCompiler.compile(ast.ast);
                    return fn.literal = function(ast) {
                        return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
                    }(ast.ast), fn.constant = function(ast) {
                        return ast.constant;
                    }(ast.ast), fn.oneTime = ast.oneTime, fn;
                },
                getAst: function(exp) {
                    var oneTime = !1;
                    return ":" === (exp = exp.trim()).charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, 
                    exp = exp.substring(2)), {
                        ast: this.ast.ast(exp),
                        oneTime
                    };
                }
            };
            var $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
                HTML: "html",
                CSS: "css",
                MEDIA_URL: "mediaUrl",
                URL: "url",
                RESOURCE_URL: "resourceUrl",
                JS: "js"
            }, UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;
            function snakeToCamel(name) {
                return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
            }
            function adjustMatchers(matchers) {
                var adjustedMatchers = [];
                return isDefined(matchers) && forEach(matchers, (function(matcher) {
                    adjustedMatchers.push(function(matcher) {
                        if ("self" === matcher) return matcher;
                        if (isString(matcher)) {
                            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                            return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"), 
                            new RegExp("^" + matcher + "$");
                        }
                        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
                        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
                    }(matcher));
                })), adjustedMatchers;
            }
            function $SceDelegateProvider() {
                this.SCE_CONTEXTS = SCE_CONTEXTS;
                var trustedResourceUrlList = [ "self" ], bannedResourceUrlList = [];
                this.trustedResourceUrlList = function(value) {
                    return arguments.length && (trustedResourceUrlList = adjustMatchers(value)), trustedResourceUrlList;
                }, Object.defineProperty(this, "resourceUrlWhitelist", {
                    get: function() {
                        return this.trustedResourceUrlList;
                    },
                    set: function(value) {
                        this.trustedResourceUrlList = value;
                    }
                }), this.bannedResourceUrlList = function(value) {
                    return arguments.length && (bannedResourceUrlList = adjustMatchers(value)), bannedResourceUrlList;
                }, Object.defineProperty(this, "resourceUrlBlacklist", {
                    get: function() {
                        return this.bannedResourceUrlList;
                    },
                    set: function(value) {
                        this.bannedResourceUrlList = value;
                    }
                }), this.$get = [ "$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
                    var htmlSanitizer = function(html) {
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                    };
                    function matchUrl(matcher, parsedUrl) {
                        return "self" === matcher ? urlsAreSameOrigin(parsedUrl, originUrl) || function(requestUrl) {
                            return urlsAreSameOrigin(requestUrl, function() {
                                if (window.document.baseURI) return window.document.baseURI;
                                baseUrlParsingNode || ((baseUrlParsingNode = window.document.createElement("a")).href = ".", 
                                baseUrlParsingNode = baseUrlParsingNode.cloneNode(!1));
                                return baseUrlParsingNode.href;
                            }());
                        }(parsedUrl) : !!matcher.exec(parsedUrl.href);
                    }
                    function generateHolderType(Base) {
                        var holderType = function(trustedValue) {
                            this.$$unwrapTrustedValue = function() {
                                return trustedValue;
                            };
                        };
                        return Base && (holderType.prototype = new Base), holderType.prototype.valueOf = function() {
                            return this.$$unwrapTrustedValue();
                        }, holderType.prototype.toString = function() {
                            return this.$$unwrapTrustedValue().toString();
                        }, holderType;
                    }
                    $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                    var trustedValueHolderBase = generateHolderType(), byType = {};
                    return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
                    byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]), 
                    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
                    {
                        trustAs: function(type, trustedValue) {
                            var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                            if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                            if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                            if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                            return new Constructor(trustedValue);
                        },
                        getTrusted: function(type, maybeTrusted) {
                            if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                            var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                            if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                            if (isFunction(maybeTrusted.$$unwrapTrustedValue) && (maybeTrusted = maybeTrusted.$$unwrapTrustedValue()), 
                            type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) return $$sanitizeUri(maybeTrusted.toString(), type === SCE_CONTEXTS.MEDIA_URL);
                            if (type === SCE_CONTEXTS.RESOURCE_URL) {
                                if (function(url) {
                                    var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                                    for (i = 0, n = trustedResourceUrlList.length; i < n; i++) if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
                                        allowed = !0;
                                        break;
                                    }
                                    if (allowed) for (i = 0, n = bannedResourceUrlList.length; i < n; i++) if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
                                        allowed = !1;
                                        break;
                                    }
                                    return allowed;
                                }(maybeTrusted)) return maybeTrusted;
                                throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                            }
                            if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                            throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
                        },
                        valueOf: function(maybeTrusted) {
                            return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
                        }
                    };
                } ];
            }
            function $SceProvider() {
                var enabled = !0;
                this.enabled = function(value) {
                    return arguments.length && (enabled = !!value), enabled;
                }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
                    if (enabled && msie < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                    var sce = shallowCopy(SCE_CONTEXTS);
                    sce.isEnabled = function() {
                        return enabled;
                    }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
                    sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                        return value;
                    }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                        var parsed = $parse(expr);
                        return parsed.literal && parsed.constant ? parsed : $parse(expr, (function(value) {
                            return sce.getTrusted(type, value);
                        }));
                    };
                    var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                    return forEach(SCE_CONTEXTS, (function(enumValue, name) {
                        var lName = lowercase(name);
                        sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                            return parse(enumValue, expr);
                        }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                            return getTrusted(enumValue, value);
                        }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                            return trustAs(enumValue, value);
                        };
                    })), sce;
                } ];
            }
            function $SnifferProvider() {
                this.$get = [ "$window", "$document", function($window, $document) {
                    var eventSupport = {}, hasHistoryPushState = !(!($window.nw && $window.nw.process) && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id)) && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
                    return bodyStyle && (transitions = !(!("transition" in bodyStyle) && !("webkitTransition" in bodyStyle)), 
                    animations = !(!("animation" in bodyStyle) && !("webkitAnimation" in bodyStyle))), 
                    {
                        history: !(!hasHistoryPushState || android < 4 || boxee),
                        hasEvent: function(event) {
                            if ("input" === event && msie) return !1;
                            if (isUndefined(eventSupport[event])) {
                                var divElm = document.createElement("div");
                                eventSupport[event] = "on" + event in divElm;
                            }
                            return eventSupport[event];
                        },
                        csp: csp(),
                        transitions,
                        animations,
                        android
                    };
                } ];
            }
            function $$TaskTrackerFactoryProvider() {
                this.$get = valueFn((function(log) {
                    return new TaskTracker(log);
                }));
            }
            function TaskTracker(log) {
                var taskCounts = {}, taskCallbacks = [], ALL_TASKS_TYPE = this.ALL_TASKS_TYPE = "$$all$$", DEFAULT_TASK_TYPE = this.DEFAULT_TASK_TYPE = "$$default$$";
                function getLastCallback() {
                    var cbInfo = taskCallbacks.pop();
                    return cbInfo && cbInfo.cb;
                }
                function getLastCallbackForType(taskType) {
                    for (var i = taskCallbacks.length - 1; i >= 0; --i) {
                        var cbInfo = taskCallbacks[i];
                        if (cbInfo.type === taskType) return taskCallbacks.splice(i, 1), cbInfo.cb;
                    }
                }
                this.completeTask = function(fn, taskType) {
                    taskType = taskType || DEFAULT_TASK_TYPE;
                    try {
                        fn();
                    } finally {
                        !function(taskType) {
                            taskType = taskType || DEFAULT_TASK_TYPE, taskCounts[taskType] && (taskCounts[taskType]--, 
                            taskCounts[ALL_TASKS_TYPE]--);
                        }(taskType);
                        var countForType = taskCounts[taskType], countForAll = taskCounts[ALL_TASKS_TYPE];
                        if (!countForAll || !countForType) for (var nextCb, getNextCallback = countForAll ? getLastCallbackForType : getLastCallback; nextCb = getNextCallback(taskType); ) try {
                            nextCb();
                        } catch (e) {
                            log.error(e);
                        }
                    }
                }, this.incTaskCount = function(taskType) {
                    taskCounts[taskType = taskType || DEFAULT_TASK_TYPE] = (taskCounts[taskType] || 0) + 1, 
                    taskCounts[ALL_TASKS_TYPE] = (taskCounts[ALL_TASKS_TYPE] || 0) + 1;
                }, this.notifyWhenNoPendingTasks = function(callback, taskType) {
                    taskCounts[taskType = taskType || ALL_TASKS_TYPE] ? taskCallbacks.push({
                        type: taskType,
                        cb: callback
                    }) : callback();
                };
            }
            var $templateRequestMinErr = minErr("$templateRequest");
            function $TemplateRequestProvider() {
                var httpOptions;
                this.httpOptions = function(val) {
                    return val ? (httpOptions = val, this) : httpOptions;
                }, this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
                    function handleRequestFn(tpl, ignoreRequestError) {
                        handleRequestFn.totalPendingRequests++, isString(tpl) && !isUndefined($templateCache.get(tpl)) || (tpl = $sce.getTrustedResourceUrl(tpl));
                        var transformResponse = $http.defaults && $http.defaults.transformResponse;
                        return isArray(transformResponse) ? transformResponse = transformResponse.filter((function(transformer) {
                            return transformer !== defaultHttpResponseTransform;
                        })) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), 
                        $http.get(tpl, extend({
                            cache: $templateCache,
                            transformResponse
                        }, httpOptions)).finally((function() {
                            handleRequestFn.totalPendingRequests--;
                        })).then((function(response) {
                            return $templateCache.put(tpl, response.data);
                        }), (function(resp) {
                            ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText), 
                            $exceptionHandler(resp));
                            return $q.reject(resp);
                        }));
                    }
                    return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
                } ];
            }
            function $$TestabilityProvider() {
                this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
                    var testability = {
                        findBindings: function(element, expression, opt_exactMatch) {
                            var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                            return forEach(bindings, (function(binding) {
                                var dataBinding = angular.element(binding).data("$binding");
                                dataBinding && forEach(dataBinding, (function(bindingName) {
                                    opt_exactMatch ? new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)").test(bindingName) && matches.push(binding) : -1 !== bindingName.indexOf(expression) && matches.push(binding);
                                }));
                            })), matches;
                        },
                        findModels: function(element, expression, opt_exactMatch) {
                            for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                                var selector = "[" + prefixes[p] + "model" + (opt_exactMatch ? "=" : "*=") + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                                if (elements.length) return elements;
                            }
                        },
                        getLocation: function() {
                            return $location.url();
                        },
                        setLocation: function(url) {
                            url !== $location.url() && ($location.url(url), $rootScope.$digest());
                        },
                        whenStable: function(callback) {
                            $browser.notifyWhenNoOutstandingRequests(callback);
                        }
                    };
                    return testability;
                } ];
            }
            var $timeoutMinErr = minErr("$timeout");
            function $TimeoutProvider() {
                this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
                    var deferreds = {};
                    function timeout(fn, delay, invokeApply) {
                        isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                        var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                        return timeoutId = $browser.defer((function() {
                            try {
                                deferred.resolve(fn.apply(null, args));
                            } catch (e) {
                                deferred.reject(e), $exceptionHandler(e);
                            } finally {
                                delete deferreds[promise.$$timeoutId];
                            }
                            skipApply || $rootScope.$apply();
                        }), delay, "$timeout"), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, 
                        promise;
                    }
                    return timeout.cancel = function(promise) {
                        if (!promise) return !1;
                        if (!promise.hasOwnProperty("$$timeoutId")) throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                        if (!deferreds.hasOwnProperty(promise.$$timeoutId)) return !1;
                        var id = promise.$$timeoutId, deferred = deferreds[id];
                        return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), delete deferreds[id], 
                        $browser.defer.cancel(id);
                    }, timeout;
                } ];
            }
            var baseUrlParsingNode, urlParsingNode = window.document.createElement("a"), originUrl = urlResolve(window.location.href);
            urlParsingNode.href = "http://[::1]";
            var ipv6InBrackets = "[::1]" === urlParsingNode.hostname;
            function urlResolve(url) {
                if (!isString(url)) return url;
                var href = url;
                msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
                urlParsingNode.setAttribute("href", href);
                var hostname = urlParsingNode.hostname;
                return !ipv6InBrackets && hostname.indexOf(":") > -1 && (hostname = "[" + hostname + "]"), 
                {
                    href: urlParsingNode.href,
                    protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                    host: urlParsingNode.host,
                    search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                    hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                    hostname,
                    port: urlParsingNode.port,
                    pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
                };
            }
            function urlsAreSameOrigin(url1, url2) {
                return url1 = urlResolve(url1), url2 = urlResolve(url2), url1.protocol === url2.protocol && url1.host === url2.host;
            }
            function $WindowProvider() {
                this.$get = valueFn(window);
            }
            function $$CookieReader($document) {
                var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
                function safeDecodeURIComponent(str) {
                    try {
                        return decodeURIComponent(str);
                    } catch (e) {
                        return str;
                    }
                }
                return function() {
                    var cookieArray, cookie, i, index, name, currentCookieString = function(rawDocument) {
                        try {
                            return rawDocument.cookie || "";
                        } catch (e) {
                            return "";
                        }
                    }(rawDocument);
                    if (currentCookieString !== lastCookieString) for (cookieArray = (lastCookieString = currentCookieString).split("; "), 
                    lastCookies = {}, i = 0; i < cookieArray.length; i++) (index = (cookie = cookieArray[i]).indexOf("=")) > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
                    isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                    return lastCookies;
                };
            }
            function $$CookieReaderProvider() {
                this.$get = $$CookieReader;
            }
            function $FilterProvider($provide) {
                function register(name, factory) {
                    if (isObject(name)) {
                        var filters = {};
                        return forEach(name, (function(filter, key) {
                            filters[key] = register(key, filter);
                        })), filters;
                    }
                    return $provide.factory(name + "Filter", factory);
                }
                this.register = register, this.$get = [ "$injector", function($injector) {
                    return function(name) {
                        return $injector.get(name + "Filter");
                    };
                } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
                register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
                register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
            }
            function filterFilter() {
                return function(array, expression, comparator, anyPropertyKey) {
                    if (!isArrayLike(array)) {
                        if (null == array) return array;
                        throw minErr("filter")("notarray", "Expected array but received: {0}", array);
                    }
                    var predicateFn, matchAgainstAnyProp;
                    switch (anyPropertyKey = anyPropertyKey || "$", getTypeForFilter(expression)) {
                      case "function":
                        predicateFn = expression;
                        break;

                      case "boolean":
                      case "null":
                      case "number":
                      case "string":
                        matchAgainstAnyProp = !0;

                      case "object":
                        predicateFn = function(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
                            var predicateFn, shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
                            !0 === comparator ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
                                return !isUndefined(actual) && (null === actual || null === expected ? actual === expected : !(isObject(expected) || isObject(actual) && !hasCustomToString(actual)) && (actual = lowercase("" + actual), 
                                expected = lowercase("" + expected), -1 !== actual.indexOf(expected)));
                            });
                            return predicateFn = function(item) {
                                return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                            }, predicateFn;
                        }(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                        break;

                      default:
                        return array;
                    }
                    return Array.prototype.filter.call(array, predicateFn);
                };
            }
            function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
                var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
                if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
                if (isArray(actual)) return actual.some((function(item) {
                    return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
                }));
                switch (actualType) {
                  case "object":
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual) if (key.charAt && "$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                        return !dontMatchWholeObject && deepCompare(actual, expected, comparator, anyPropertyKey, !1);
                    }
                    if ("object" === expectedType) {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                                var matchAnyProperty = key === anyPropertyKey;
                                if (!deepCompare(matchAnyProperty ? actual : actual[key], expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1;
                            }
                        }
                        return !0;
                    }
                    return comparator(actual, expected);

                  case "function":
                    return !1;

                  default:
                    return comparator(actual, expected);
                }
            }
            function getTypeForFilter(val) {
                return null === val ? "null" : typeof val;
            }
            $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ];
            var MAX_DIGITS = 22, DECIMAL_SEP = ".", ZERO_CHAR = "0";
            function currencyFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function(amount, currencySymbol, fractionSize) {
                    isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac);
                    var currencySymbolRe = currencySymbol ? /\u00A4/g : /\s*\u00A4\s*/g;
                    return null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);
                };
            }
            function numberFilter($locale) {
                var formats = $locale.NUMBER_FORMATS;
                return function(number, fractionSize) {
                    return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
                };
            }
            function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
                if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
                var parsedNumber, isInfinity = !isFinite(number), isZero = !1, numStr = Math.abs(number) + "", formattedText = "";
                if (isInfinity) formattedText = ""; else {
                    parsedNumber = function(numStr) {
                        var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
                        for ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1 && (numStr = numStr.replace(DECIMAL_SEP, "")), 
                        (i = numStr.search(/e/i)) > 0 ? (numberOfIntegerDigits < 0 && (numberOfIntegerDigits = i), 
                        numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : numberOfIntegerDigits < 0 && (numberOfIntegerDigits = numStr.length), 
                        i = 0; numStr.charAt(i) === ZERO_CHAR; i++) ;
                        if (i === (zeros = numStr.length)) digits = [ 0 ], numberOfIntegerDigits = 1; else {
                            for (zeros--; numStr.charAt(zeros) === ZERO_CHAR; ) zeros--;
                            for (numberOfIntegerDigits -= i, digits = [], j = 0; i <= zeros; i++, j++) digits[j] = +numStr.charAt(i);
                        }
                        return numberOfIntegerDigits > MAX_DIGITS && (digits = digits.splice(0, MAX_DIGITS - 1), 
                        exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
                            d: digits,
                            e: exponent,
                            i: numberOfIntegerDigits
                        };
                    }(numStr), function(parsedNumber, fractionSize, minFrac, maxFrac) {
                        var digits = parsedNumber.d, fractionLen = digits.length - parsedNumber.i, roundAt = (fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize) + parsedNumber.i, digit = digits[roundAt];
                        if (roundAt > 0) {
                            digits.splice(Math.max(parsedNumber.i, roundAt));
                            for (var j = roundAt; j < digits.length; j++) digits[j] = 0;
                        } else {
                            fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), 
                            digits[0] = 0;
                            for (var i = 1; i < roundAt; i++) digits[i] = 0;
                        }
                        if (digit >= 5) if (roundAt - 1 < 0) {
                            for (var k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.i++;
                            digits.unshift(1), parsedNumber.i++;
                        } else digits[roundAt - 1]++;
                        for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
                        var carry = digits.reduceRight((function(carry, d, i, digits) {
                            return d += carry, digits[i] = d % 10, Math.floor(d / 10);
                        }), 0);
                        carry && (digits.unshift(carry), parsedNumber.i++);
                    }(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                    var digits = parsedNumber.d, integerLen = parsedNumber.i, exponent = parsedNumber.e, decimals = [];
                    for (isZero = digits.reduce((function(isZero, d) {
                        return isZero && !d;
                    }), !0); integerLen < 0; ) digits.unshift(0), integerLen++;
                    integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, 
                    digits = [ 0 ]);
                    var groups = [];
                    for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize; ) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                    digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), 
                    decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent);
                }
                return number < 0 && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf;
            }
            function padNumber(num, digits, trim, negWrap) {
                var neg = "";
                for ((num < 0 || negWrap && num <= 0) && (negWrap ? num = 1 - num : (num = -num, 
                neg = "-")), num = "" + num; num.length < digits; ) num = ZERO_CHAR + num;
                return trim && (num = num.substr(num.length - digits)), neg + num;
            }
            function dateGetter(name, size, offset, trim, negWrap) {
                return offset = offset || 0, function(date) {
                    var value = date["get" + name]();
                    return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 === offset && (value = 12), 
                    padNumber(value, size, trim, negWrap);
                };
            }
            function dateStrGetter(name, shortForm, standAlone) {
                return function(date, formats) {
                    var value = date["get" + name]();
                    return formats[uppercase((standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "") + name)][value];
                };
            }
            function getFirstThursdayOfYear(year) {
                var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
                return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
            }
            function weekGetter(size) {
                return function(date) {
                    var datetime, firstThurs = getFirstThursdayOfYear(date.getFullYear()), diff = +(datetime = date, 
                    new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()))) - +firstThurs;
                    return padNumber(1 + Math.round(diff / 6048e5), size);
                };
            }
            function eraGetter(date, formats) {
                return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
            }
            currencyFilter.$inject = [ "$locale" ], numberFilter.$inject = [ "$locale" ];
            var DATE_FORMATS = {
                yyyy: dateGetter("FullYear", 4, 0, !1, !0),
                yy: dateGetter("FullYear", 2, 0, !0, !0),
                y: dateGetter("FullYear", 1, 0, !1, !0),
                MMMM: dateStrGetter("Month"),
                MMM: dateStrGetter("Month", !0),
                MM: dateGetter("Month", 2, 1),
                M: dateGetter("Month", 1, 1),
                LLLL: dateStrGetter("Month", !1, !0),
                dd: dateGetter("Date", 2),
                d: dateGetter("Date", 1),
                HH: dateGetter("Hours", 2),
                H: dateGetter("Hours", 1),
                hh: dateGetter("Hours", 2, -12),
                h: dateGetter("Hours", 1, -12),
                mm: dateGetter("Minutes", 2),
                m: dateGetter("Minutes", 1),
                ss: dateGetter("Seconds", 2),
                s: dateGetter("Seconds", 1),
                sss: dateGetter("Milliseconds", 3),
                EEEE: dateStrGetter("Day"),
                EEE: dateStrGetter("Day", !0),
                a: function(date, formats) {
                    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
                },
                Z: function(date, formats, offset) {
                    var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
                    return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
                },
                ww: weekGetter(2),
                w: weekGetter(1),
                G: eraGetter,
                GG: eraGetter,
                GGG: eraGetter,
                GGGG: function(date, formats) {
                    return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
                }
            }, DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
            function dateFilter($locale) {
                var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
                return function(date, format, timezone) {
                    var fn, match, text = "", parts = [];
                    if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
                    isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : function(string) {
                        var match;
                        if (match = string.match(R_ISO8601_STR)) {
                            var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                            match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), 
                            dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                            var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                            return timeSetter.call(date, h, m, s, ms), date;
                        }
                        return string;
                    }(date)), isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
                    for (;format; ) (match = DATE_FORMATS_SPLIT.exec(format)) ? format = (parts = concat(parts, match, 1)).pop() : (parts.push(format), 
                    format = null);
                    var dateTimezoneOffset = date.getTimezoneOffset();
                    return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), 
                    date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, (function(value) {
                        fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
                    })), text;
                };
            }
            function jsonFilter() {
                return function(object, spacing) {
                    return isUndefined(spacing) && (spacing = 2), toJson(object, spacing);
                };
            }
            dateFilter.$inject = [ "$locale" ];
            var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
            function limitToFilter() {
                return function(input, limit, begin) {
                    return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit), 
                    isNumberNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArrayLike(input) ? (begin = (begin = !begin || isNaN(begin) ? 0 : toInt(begin)) < 0 ? Math.max(0, input.length + begin) : begin, 
                    limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input);
                };
            }
            function sliceFn(input, begin, end) {
                return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end);
            }
            function orderByFilter($parse) {
                return function(array, sortPredicate, reverseOrder, compareFn) {
                    if (null == array) return array;
                    if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
                    isArray(sortPredicate) || (sortPredicate = [ sortPredicate ]), 0 === sortPredicate.length && (sortPredicate = [ "+" ]);
                    var predicates = sortPredicate.map((function(predicate) {
                        var descending = 1, get = identity;
                        if (isFunction(predicate)) get = predicate; else if (isString(predicate) && ("+" !== predicate.charAt(0) && "-" !== predicate.charAt(0) || (descending = "-" === predicate.charAt(0) ? -1 : 1, 
                        predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate)).constant)) {
                            var key = get();
                            get = function(value) {
                                return value[key];
                            };
                        }
                        return {
                            get,
                            descending
                        };
                    })), descending = reverseOrder ? -1 : 1, compare = isFunction(compareFn) ? compareFn : defaultCompare, compareValues = Array.prototype.map.call(array, (function(value, index) {
                        return {
                            value,
                            tieBreaker: {
                                value: index,
                                type: "number",
                                index
                            },
                            predicateValues: predicates.map((function(predicate) {
                                return function(value, index) {
                                    var type = typeof value;
                                    null === value ? type = "null" : "object" === type && (value = function(value) {
                                        if (isFunction(value.valueOf) && isPrimitive(value = value.valueOf())) return value;
                                        if (hasCustomToString(value) && isPrimitive(value = value.toString())) return value;
                                        return value;
                                    }(value));
                                    return {
                                        value,
                                        type,
                                        index
                                    };
                                }(predicate.get(value), index);
                            }))
                        };
                    }));
                    return compareValues.sort((function(v1, v2) {
                        for (var i = 0, ii = predicates.length; i < ii; i++) {
                            var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                            if (result) return result * predicates[i].descending * descending;
                        }
                        return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
                    })), array = compareValues.map((function(item) {
                        return item.value;
                    }));
                };
                function isPrimitive(value) {
                    switch (typeof value) {
                      case "number":
                      case "boolean":
                      case "string":
                        return !0;

                      default:
                        return !1;
                    }
                }
                function defaultCompare(v1, v2) {
                    var result = 0, type1 = v1.type, type2 = v2.type;
                    if (type1 === type2) {
                        var value1 = v1.value, value2 = v2.value;
                        "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), 
                        isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value1 < value2 ? -1 : 1);
                    } else result = "undefined" === type1 ? 1 : "undefined" === type2 ? -1 : "null" === type1 ? 1 : "null" === type2 || type1 < type2 ? -1 : 1;
                    return result;
                }
            }
            function ngDirective(directive) {
                return isFunction(directive) && (directive = {
                    link: directive
                }), directive.restrict = directive.restrict || "AC", valueFn(directive);
            }
            orderByFilter.$inject = [ "$parse" ];
            var htmlAnchorDirective = valueFn({
                restrict: "E",
                compile: function(element, attr) {
                    if (!attr.href && !attr.xlinkHref) return function(scope, element) {
                        if ("a" === element[0].nodeName.toLowerCase()) {
                            var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                            element.on("click", (function(event) {
                                element.attr(href) || event.preventDefault();
                            }));
                        }
                    };
                }
            }), ngAttributeAliasDirectives = {};
            forEach(BOOLEAN_ATTR, (function(propName, attrName) {
                if ("multiple" !== propName) {
                    var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
                    "checked" === propName && (linkFn = function(scope, element, attr) {
                        attr.ngModel !== attr[normalized] && defaultLinkFn(scope, 0, attr);
                    }), ngAttributeAliasDirectives[normalized] = function() {
                        return {
                            restrict: "A",
                            priority: 100,
                            link: linkFn
                        };
                    };
                }
                function defaultLinkFn(scope, element, attr) {
                    scope.$watch(attr[normalized], (function(value) {
                        attr.$set(attrName, !!value);
                    }));
                }
            })), forEach(ALIASED_ATTR, (function(htmlAttr, ngAttr) {
                ngAttributeAliasDirectives[ngAttr] = function() {
                    return {
                        priority: 100,
                        link: function(scope, element, attr) {
                            if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                                var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                                if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                            }
                            scope.$watch(attr[ngAttr], (function(value) {
                                attr.$set(ngAttr, value);
                            }));
                        }
                    };
                };
            })), forEach([ "src", "srcset", "href" ], (function(attrName) {
                var normalized = directiveNormalize("ng-" + attrName);
                ngAttributeAliasDirectives[normalized] = [ "$sce", function($sce) {
                    return {
                        priority: 99,
                        link: function(scope, element, attr) {
                            var propName = attrName, name = attrName;
                            "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                            attr.$attr[name] = "xlink:href", propName = null), attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized])), 
                            attr.$observe(normalized, (function(value) {
                                value ? (attr.$set(name, value), msie && propName && element.prop(propName, attr[name])) : "href" === attrName && attr.$set(name, null);
                            }));
                        }
                    };
                } ];
            }));
            var nullFormCtrl = {
                $addControl: noop,
                $getControls: valueFn([]),
                $$renameControl: function(control, name) {
                    control.$name = name;
                },
                $removeControl: noop,
                $setValidity: noop,
                $setDirty: noop,
                $setPristine: noop,
                $setSubmitted: noop,
                $$setSubmitted: noop
            };
            function FormController($element, $attrs, $scope, $animate, $interpolate) {
                this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, 
                this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1, 
                this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, 
                this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate, 
                setupValidity(this);
            }
            FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ], 
            FormController.prototype = {
                $rollbackViewValue: function() {
                    forEach(this.$$controls, (function(control) {
                        control.$rollbackViewValue();
                    }));
                },
                $commitViewValue: function() {
                    forEach(this.$$controls, (function(control) {
                        control.$commitViewValue();
                    }));
                },
                $addControl: function(control) {
                    assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control), 
                    control.$name && (this[control.$name] = control), control.$$parentForm = this;
                },
                $getControls: function() {
                    return shallowCopy(this.$$controls);
                },
                $$renameControl: function(control, newName) {
                    var oldName = control.$name;
                    this[oldName] === control && delete this[oldName], this[newName] = control, control.$name = newName;
                },
                $removeControl: function(control) {
                    control.$name && this[control.$name] === control && delete this[control.$name], 
                    forEach(this.$pending, (function(value, name) {
                        this.$setValidity(name, null, control);
                    }), this), forEach(this.$error, (function(value, name) {
                        this.$setValidity(name, null, control);
                    }), this), forEach(this.$$success, (function(value, name) {
                        this.$setValidity(name, null, control);
                    }), this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl;
                },
                $setDirty: function() {
                    this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), 
                    this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty();
                },
                $setPristine: function() {
                    this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " ng-submitted"), 
                    this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, (function(control) {
                        control.$setPristine();
                    }));
                },
                $setUntouched: function() {
                    forEach(this.$$controls, (function(control) {
                        control.$setUntouched();
                    }));
                },
                $setSubmitted: function() {
                    for (var rootForm = this; rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl; ) rootForm = rootForm.$$parentForm;
                    rootForm.$$setSubmitted();
                },
                $$setSubmitted: function() {
                    this.$$animate.addClass(this.$$element, "ng-submitted"), this.$submitted = !0, forEach(this.$$controls, (function(control) {
                        control.$$setSubmitted && control.$$setSubmitted();
                    }));
                }
            }, addSetValidityMethod({
                clazz: FormController,
                set: function(object, property, controller) {
                    var list = object[property];
                    list ? -1 === list.indexOf(controller) && list.push(controller) : object[property] = [ controller ];
                },
                unset: function(object, property, controller) {
                    var list = object[property];
                    list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
                }
            });
            var formDirectiveFactory = function(isNgForm) {
                return [ "$timeout", "$parse", function($timeout, $parse) {
                    return {
                        name: "form",
                        restrict: isNgForm ? "EAC" : "E",
                        require: [ "form", "^^?form" ],
                        controller: FormController,
                        compile: function(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? "name" : !(!isNgForm || !attr.ngForm) && "ngForm";
                            return {
                                pre: function(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!("action" in attr)) {
                                        var handleFormSubmission = function(event) {
                                            scope.$apply((function() {
                                                controller.$commitViewValue(), controller.$setSubmitted();
                                            })), event.preventDefault();
                                        };
                                        formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", (function() {
                                            $timeout((function() {
                                                formElement[0].removeEventListener("submit", handleFormSubmission);
                                            }), 0, !1);
                                        }));
                                    }
                                    (ctrls[1] || controller.$$parentForm).$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    nameAttr && (setter(scope, controller), attr.$observe(nameAttr, (function(newValue) {
                                        controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), 
                                        (setter = getSetter(controller.$name))(scope, controller));
                                    }))), formElement.on("$destroy", (function() {
                                        controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl);
                                    }));
                                }
                            };
                        }
                    };
                    function getSetter(expression) {
                        return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop;
                    }
                } ];
            }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0);
            function setupValidity(instance) {
                instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
            }
            function addSetValidityMethod(context) {
                var clazz = context.clazz, set = context.set, unset = context.unset;
                function cachedToggleClass(ctrl, className, switchValue) {
                    switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className), 
                    ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className), 
                    ctrl.$$classCache[className] = !1);
                }
                function toggleValidationCss(ctrl, validationErrorKey, isValid) {
                    validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
                    cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, !0 === isValid), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, !1 === isValid);
                }
                clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
                    var combinedState;
                    isUndefined(state) ? function(ctrl, name, value, controller) {
                        ctrl[name] || (ctrl[name] = {});
                        set(ctrl[name], value, controller);
                    }(this, "$pending", validationErrorKey, controller) : function(ctrl, name, value, controller) {
                        ctrl[name] && unset(ctrl[name], value, controller);
                        isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0);
                    }(this, "$pending", validationErrorKey, controller), isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, controller), 
                    set(this.$$success, validationErrorKey, controller)) : (set(this.$error, validationErrorKey, controller), 
                    unset(this.$$success, validationErrorKey, controller)) : (unset(this.$error, validationErrorKey, controller), 
                    unset(this.$$success, validationErrorKey, controller)), this.$pending ? (cachedToggleClass(this, "ng-pending", !0), 
                    this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, "ng-pending", !1), 
                    this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid)), 
                    toggleValidationCss(this, validationErrorKey, combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : !this.$error[validationErrorKey] && (!!this.$$success[validationErrorKey] || null)), 
                    this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
                };
            }
            function isObjectEmpty(obj) {
                if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
                return !0;
            }
            var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4,})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown", PARTIAL_VALIDATION_TYPES = createMap();
            forEach("date,datetime-local,month,time,week".split(","), (function(type) {
                PARTIAL_VALIDATION_TYPES[type] = !0;
            }));
            var inputType = {
                text: function(scope, element, attr, ctrl, $sniffer, $browser) {
                    baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
                },
                date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
                "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
                time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
                week: createDateInputType("week", WEEK_REGEXP, (function(isoWeek, existingDate) {
                    if (isDate(isoWeek)) return isoWeek;
                    if (isString(isoWeek)) {
                        WEEK_REGEXP.lastIndex = 0;
                        var parts = WEEK_REGEXP.exec(isoWeek);
                        if (parts) {
                            var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                            return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                            seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                            new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                        }
                    }
                    return NaN;
                }), "yyyy-Www"),
                month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
                number: function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                    var parsedMinVal;
                    if (badInputChecker(scope, element, attr, ctrl, "number"), numberFormatterParser(ctrl), 
                    baseInputType(scope, element, attr, ctrl, $sniffer, $browser), isDefined(attr.min) || attr.ngMin) {
                        var minVal = attr.min || $parse(attr.ngMin)(scope);
                        parsedMinVal = parseNumberAttrVal(minVal), ctrl.$validators.min = function(modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || isUndefined(parsedMinVal) || viewValue >= parsedMinVal;
                        }, attr.$observe("min", (function(val) {
                            val !== minVal && (parsedMinVal = parseNumberAttrVal(val), minVal = val, ctrl.$validate());
                        }));
                    }
                    if (isDefined(attr.max) || attr.ngMax) {
                        var maxVal = attr.max || $parse(attr.ngMax)(scope), parsedMaxVal = parseNumberAttrVal(maxVal);
                        ctrl.$validators.max = function(modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || isUndefined(parsedMaxVal) || viewValue <= parsedMaxVal;
                        }, attr.$observe("max", (function(val) {
                            val !== maxVal && (parsedMaxVal = parseNumberAttrVal(val), maxVal = val, ctrl.$validate());
                        }));
                    }
                    if (isDefined(attr.step) || attr.ngStep) {
                        var stepVal = attr.step || $parse(attr.ngStep)(scope), parsedStepVal = parseNumberAttrVal(stepVal);
                        ctrl.$validators.step = function(modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || isUndefined(parsedStepVal) || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal);
                        }, attr.$observe("step", (function(val) {
                            val !== stepVal && (parsedStepVal = parseNumberAttrVal(val), stepVal = val, ctrl.$validate());
                        }));
                    }
                },
                url: function(scope, element, attr, ctrl, $sniffer, $browser) {
                    baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
                    ctrl.$validators.url = function(modelValue, viewValue) {
                        var value = modelValue || viewValue;
                        return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
                    };
                },
                email: function(scope, element, attr, ctrl, $sniffer, $browser) {
                    baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
                    ctrl.$validators.email = function(modelValue, viewValue) {
                        var value = modelValue || viewValue;
                        return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
                    };
                },
                radio: function(scope, element, attr, ctrl) {
                    var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
                    isUndefined(attr.name) && element.attr("name", nextUid());
                    element.on("change", (function(ev) {
                        var value;
                        element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type));
                    })), ctrl.$render = function() {
                        var value = attr.value;
                        doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue;
                    }, attr.$observe("value", ctrl.$render);
                },
                range: function(scope, element, attr, ctrl, $sniffer, $browser) {
                    badInputChecker(scope, element, attr, ctrl, "range"), numberFormatterParser(ctrl), 
                    baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                    var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type, minVal = supportsRange ? 0 : void 0, maxVal = supportsRange ? 100 : void 0, stepVal = supportsRange ? 1 : void 0, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step), originalRender = ctrl.$render;
                    ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function() {
                        originalRender(), ctrl.$setViewValue(element.val());
                    } : originalRender, hasMinAttr && (minVal = parseNumberAttrVal(attr.min), ctrl.$validators.min = supportsRange ? function() {
                        return !0;
                    } : function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
                    }, setInitialValueAndObserver("min", (function(val) {
                        if (minVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue)) return;
                        if (supportsRange) {
                            var elVal = element.val();
                            minVal > elVal && (elVal = minVal, element.val(elVal)), ctrl.$setViewValue(elVal);
                        } else ctrl.$validate();
                    })));
                    hasMaxAttr && (maxVal = parseNumberAttrVal(attr.max), ctrl.$validators.max = supportsRange ? function() {
                        return !0;
                    } : function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal;
                    }, setInitialValueAndObserver("max", (function(val) {
                        if (maxVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue)) return;
                        if (supportsRange) {
                            var elVal = element.val();
                            maxVal < elVal && (element.val(maxVal), elVal = maxVal < minVal ? minVal : maxVal), 
                            ctrl.$setViewValue(elVal);
                        } else ctrl.$validate();
                    })));
                    hasStepAttr && (stepVal = parseNumberAttrVal(attr.step), ctrl.$validators.step = supportsRange ? function() {
                        return !validity.stepMismatch;
                    } : function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
                    }, setInitialValueAndObserver("step", (function(val) {
                        if (stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue)) return;
                        supportsRange ? ctrl.$viewValue !== element.val() && ctrl.$setViewValue(element.val()) : ctrl.$validate();
                    })));
                    function setInitialValueAndObserver(htmlAttrName, changeFn) {
                        element.attr(htmlAttrName, attr[htmlAttrName]);
                        var oldVal = attr[htmlAttrName];
                        attr.$observe(htmlAttrName, (function(val) {
                            val !== oldVal && (oldVal = val, changeFn(val));
                        }));
                    }
                },
                checkbox: function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                    var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1);
                    element.on("change", (function(ev) {
                        ctrl.$setViewValue(element[0].checked, ev && ev.type);
                    })), ctrl.$render = function() {
                        element[0].checked = ctrl.$viewValue;
                    }, ctrl.$isEmpty = function(value) {
                        return !1 === value;
                    }, ctrl.$formatters.push((function(value) {
                        return equals(value, trueValue);
                    })), ctrl.$parsers.push((function(value) {
                        return value ? trueValue : falseValue;
                    }));
                },
                hidden: noop,
                button: noop,
                submit: noop,
                reset: noop,
                file: noop
            };
            function stringBasedInputType(ctrl) {
                ctrl.$formatters.push((function(value) {
                    return ctrl.$isEmpty(value) ? value : value.toString();
                }));
            }
            function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
                var timeout, type = lowercase(element[0].type);
                if (!$sniffer.android) {
                    var composing = !1;
                    element.on("compositionstart", (function() {
                        composing = !0;
                    })), element.on("compositionupdate", (function(ev) {
                        (isUndefined(ev.data) || "" === ev.data) && (composing = !1);
                    })), element.on("compositionend", (function() {
                        composing = !1, listener();
                    }));
                }
                var listener = function(ev) {
                    if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                        var value = element.val(), event = ev && ev.type;
                        "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
                        (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
                    }
                };
                if ($sniffer.hasEvent("input")) element.on("input", listener); else {
                    var deferListener = function(ev, input, origValue) {
                        timeout || (timeout = $browser.defer((function() {
                            timeout = null, input && input.value === origValue || listener(ev);
                        })));
                    };
                    element.on("keydown", (function(event) {
                        var key = event.keyCode;
                        91 === key || 15 < key && key < 19 || 37 <= key && key <= 40 || deferListener(event, this, this.value);
                    })), $sniffer.hasEvent("paste") && element.on("paste cut drop", deferListener);
                }
                element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, (function(ev) {
                    if (!timeout) {
                        var validity = this[VALIDITY_STATE_PROPERTY], origBadInput = validity.badInput, origTypeMismatch = validity.typeMismatch;
                        timeout = $browser.defer((function() {
                            timeout = null, validity.badInput === origBadInput && validity.typeMismatch === origTypeMismatch || listener(ev);
                        }));
                    }
                })), ctrl.$render = function() {
                    var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
                    element.val() !== value && element.val(value);
                };
            }
            function createDateParser(regexp, mapping) {
                return function(iso, previousDate) {
                    var parts, map;
                    if (isDate(iso)) return iso;
                    if (isString(iso)) {
                        if ('"' === iso.charAt(0) && '"' === iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), 
                        ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                        if (regexp.lastIndex = 0, parts = regexp.exec(iso)) {
                            parts.shift(), map = previousDate ? {
                                yyyy: previousDate.getFullYear(),
                                MM: previousDate.getMonth() + 1,
                                dd: previousDate.getDate(),
                                HH: previousDate.getHours(),
                                mm: previousDate.getMinutes(),
                                ss: previousDate.getSeconds(),
                                sss: previousDate.getMilliseconds() / 1e3
                            } : {
                                yyyy: 1970,
                                MM: 1,
                                dd: 1,
                                HH: 0,
                                mm: 0,
                                ss: 0,
                                sss: 0
                            }, forEach(parts, (function(part, index) {
                                index < mapping.length && (map[mapping[index]] = +part);
                            }));
                            var date = new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
                            return map.yyyy < 100 && date.setFullYear(map.yyyy), date;
                        }
                    }
                    return NaN;
                };
            }
            function createDateInputType(type, regexp, parseDate, format) {
                return function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                    badInputChecker(scope, element, attr, ctrl, type), baseInputType(0, element, attr, ctrl, $sniffer, $browser);
                    var previousDate, previousTimezone, isTimeType = "time" === type || "datetimelocal" === type;
                    if (ctrl.$parsers.push((function(value) {
                        return ctrl.$isEmpty(value) ? null : regexp.test(value) ? parseDateAndConvertTimeZoneToLocal(value, previousDate) : void (ctrl.$$parserName = type);
                    })), ctrl.$formatters.push((function(value) {
                        if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                        if (isValidDate(value)) {
                            previousDate = value;
                            var timezone = ctrl.$options.getOption("timezone");
                            return timezone && (previousTimezone = timezone, previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), 
                            function(value, timezone) {
                                var targetFormat = format;
                                isTimeType && isString(ctrl.$options.getOption("timeSecondsFormat")) && (targetFormat = format.replace("ss.sss", ctrl.$options.getOption("timeSecondsFormat")).replace(/:$/, ""));
                                var formatted = $filter("date")(value, targetFormat, timezone);
                                isTimeType && ctrl.$options.getOption("timeStripZeroSeconds") && (formatted = formatted.replace(/(?::00)?(?:\.000)?$/, ""));
                                return formatted;
                            }(value, timezone);
                        }
                        return previousDate = null, previousTimezone = null, "";
                    })), isDefined(attr.min) || attr.ngMin) {
                        var minVal = attr.min || $parse(attr.ngMin)(scope), parsedMinVal = parseObservedDateValue(minVal);
                        ctrl.$validators.min = function(value) {
                            return !isValidDate(value) || isUndefined(parsedMinVal) || parseDate(value) >= parsedMinVal;
                        }, attr.$observe("min", (function(val) {
                            val !== minVal && (parsedMinVal = parseObservedDateValue(val), minVal = val, ctrl.$validate());
                        }));
                    }
                    if (isDefined(attr.max) || attr.ngMax) {
                        var maxVal = attr.max || $parse(attr.ngMax)(scope), parsedMaxVal = parseObservedDateValue(maxVal);
                        ctrl.$validators.max = function(value) {
                            return !isValidDate(value) || isUndefined(parsedMaxVal) || parseDate(value) <= parsedMaxVal;
                        }, attr.$observe("max", (function(val) {
                            val !== maxVal && (parsedMaxVal = parseObservedDateValue(val), maxVal = val, ctrl.$validate());
                        }));
                    }
                    function isValidDate(value) {
                        return value && !(value.getTime && value.getTime() != value.getTime());
                    }
                    function parseObservedDateValue(val) {
                        return isDefined(val) && !isDate(val) ? parseDateAndConvertTimeZoneToLocal(val) || void 0 : val;
                    }
                    function parseDateAndConvertTimeZoneToLocal(value, previousDate) {
                        var timezone = ctrl.$options.getOption("timezone");
                        previousTimezone && previousTimezone !== timezone && (previousDate = addDateMinutes(previousDate, timezoneToOffset(previousTimezone)));
                        var parsedDate = parseDate(value, previousDate);
                        return !isNaN(parsedDate) && timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), 
                        parsedDate;
                    }
                };
            }
            function badInputChecker(scope, element, attr, ctrl, parserName) {
                var node = element[0];
                (ctrl.$$hasNativeValidators = isObject(node.validity)) && ctrl.$parsers.push((function(value) {
                    var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                    if (!validity.badInput && !validity.typeMismatch) return value;
                    ctrl.$$parserName = parserName;
                }));
            }
            function numberFormatterParser(ctrl) {
                ctrl.$parsers.push((function(value) {
                    return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void (ctrl.$$parserName = "number");
                })), ctrl.$formatters.push((function(value) {
                    if (!ctrl.$isEmpty(value)) {
                        if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                        value = value.toString();
                    }
                    return value;
                }));
            }
            function parseNumberAttrVal(val) {
                return isDefined(val) && !isNumber(val) && (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val;
            }
            function isNumberInteger(num) {
                return (0 | num) === num;
            }
            function countDecimals(num) {
                var numString = num.toString(), decimalSymbolIndex = numString.indexOf(".");
                if (-1 === decimalSymbolIndex) {
                    if (-1 < num && num < 1) {
                        var match = /e-(\d+)$/.exec(numString);
                        if (match) return Number(match[1]);
                    }
                    return 0;
                }
                return numString.length - decimalSymbolIndex - 1;
            }
            function isValidForStep(viewValue, stepBase, step) {
                var value = Number(viewValue), isNonIntegerValue = !isNumberInteger(value), isNonIntegerStepBase = !isNumberInteger(stepBase), isNonIntegerStep = !isNumberInteger(step);
                if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
                    var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0, stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0, stepDecimals = isNonIntegerStep ? countDecimals(step) : 0, decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals), multiplier = Math.pow(10, decimalCount);
                    value *= multiplier, stepBase *= multiplier, step *= multiplier, isNonIntegerValue && (value = Math.round(value)), 
                    isNonIntegerStepBase && (stepBase = Math.round(stepBase)), isNonIntegerStep && (step = Math.round(step));
                }
                return (value - stepBase) % step == 0;
            }
            function parseConstantExpr($parse, context, name, expression, fallback) {
                var parseFn;
                if (isDefined(expression)) {
                    if (!(parseFn = $parse(expression)).constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
                    return parseFn(context);
                }
                return fallback;
            }
            var inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: "E",
                    require: [ "?ngModel" ],
                    link: {
                        pre: function(scope, element, attr, ctrls) {
                            ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                        }
                    }
                };
            } ], hiddenInputBrowserCacheDirective = function() {
                var valueProperty = {
                    configurable: !0,
                    enumerable: !1,
                    get: function() {
                        return this.getAttribute("value") || "";
                    },
                    set: function(val) {
                        this.setAttribute("value", val);
                    }
                };
                return {
                    restrict: "E",
                    priority: 200,
                    compile: function(_, attr) {
                        if ("hidden" === lowercase(attr.type)) return {
                            pre: function(scope, element, attr, ctrls) {
                                var node = element[0];
                                node.parentNode && node.parentNode.insertBefore(node, node.nextSibling), Object.defineProperty && Object.defineProperty(node, "value", valueProperty);
                            }
                        };
                    }
                };
            }, CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
                function updateElementValue(element, attr, value) {
                    var propValue = isDefined(value) ? value : 9 === msie ? "" : null;
                    element.prop("value", propValue), attr.$set("value", value);
                }
                return {
                    restrict: "A",
                    priority: 100,
                    compile: function(tpl, tplAttr) {
                        return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                            updateElementValue(elm, attr, scope.$eval(attr.ngValue));
                        } : function(scope, elm, attr) {
                            scope.$watch(attr.ngValue, (function(value) {
                                updateElementValue(elm, attr, value);
                            }));
                        };
                    }
                };
            }, ngBindDirective = [ "$compile", function($compile) {
                return {
                    restrict: "AC",
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, (function(value) {
                                element.textContent = stringify(value);
                            }));
                        };
                    }
                };
            } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
                return {
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                            $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                            attr.$observe("ngBindTemplate", (function(value) {
                                element.textContent = isUndefined(value) ? "" : value;
                            }));
                        };
                    }
                };
            } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
                return {
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, (function(val) {
                            return $sce.valueOf(val);
                        }));
                        return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, (function() {
                                var value = ngBindHtmlGetter(scope);
                                element.html($sce.getTrustedHtml(value) || "");
                            }));
                        };
                    }
                };
            } ], ngChangeDirective = valueFn({
                restrict: "A",
                require: "ngModel",
                link: function(scope, element, attr, ctrl) {
                    ctrl.$viewChangeListeners.push((function() {
                        scope.$eval(attr.ngChange);
                    }));
                }
            });
            function classDirective(name, selector) {
                var indexWatchExpression;
                return name = "ngClass" + name, [ "$parse", function($parse) {
                    return {
                        restrict: "AC",
                        link: function(scope, element, attr) {
                            var oldClassString, classCounts = element.data("$classCounts"), oldModulo = !0;
                            function digestClassCounts(classArray, count) {
                                var classesToUpdate = [];
                                return forEach(classArray, (function(className) {
                                    (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                                    classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                                })), classesToUpdate.join(" ");
                            }
                            classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)), 
                            "ngClass" !== name && (indexWatchExpression || (indexWatchExpression = $parse("$index", (function($index) {
                                return 1 & $index;
                            }))), scope.$watch(indexWatchExpression, (function(newModulo) {
                                newModulo === selector ? (classString = digestClassCounts(split(classString = oldClassString), 1), 
                                attr.$addClass(classString)) : function(classString) {
                                    classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString);
                                }(oldClassString);
                                var classString;
                                oldModulo = newModulo;
                            }))), scope.$watch($parse(attr[name], toClassString), (function(newClassString) {
                                oldModulo === selector && function(oldClassString, newClassString) {
                                    var oldClassArray = split(oldClassString), newClassArray = split(newClassString), toRemoveArray = arrayDifference(oldClassArray, newClassArray), toAddArray = arrayDifference(newClassArray, oldClassArray), toRemoveString = digestClassCounts(toRemoveArray, -1), toAddString = digestClassCounts(toAddArray, 1);
                                    attr.$addClass(toAddString), attr.$removeClass(toRemoveString);
                                }(oldClassString, newClassString);
                                oldClassString = newClassString;
                            }));
                        }
                    };
                } ];
                function arrayDifference(tokens1, tokens2) {
                    if (!tokens1 || !tokens1.length) return [];
                    if (!tokens2 || !tokens2.length) return tokens1;
                    var values = [];
                    outer: for (var i = 0; i < tokens1.length; i++) {
                        for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                        values.push(token);
                    }
                    return values;
                }
                function split(classString) {
                    return classString && classString.split(" ");
                }
                function toClassString(classValue) {
                    if (!classValue) return classValue;
                    var classString = classValue;
                    return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) ? classString = Object.keys(classValue).filter((function(key) {
                        return classValue[key];
                    })).join(" ") : isString(classValue) || (classString = classValue + ""), classString;
                }
            }
            var ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
                compile: function(element, attr) {
                    attr.$set("ngCloak", void 0), element.removeClass("ng-cloak");
                }
            }), ngControllerDirective = [ function() {
                return {
                    restrict: "A",
                    scope: !0,
                    controller: "@",
                    priority: 500
                };
            } ], ngEventDirectives = {}, forceAsyncEvents = {
                blur: !0,
                focus: !0
            };
            function createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
                return {
                    restrict: "A",
                    compile: function($element, attr) {
                        var fn = $parse(attr[directiveName]);
                        return function(scope, element) {
                            element.on(eventName, (function(event) {
                                var callback = function() {
                                    fn(scope, {
                                        $event: event
                                    });
                                };
                                if ($rootScope.$$phase) if (forceAsync) scope.$evalAsync(callback); else try {
                                    callback();
                                } catch (error) {
                                    $exceptionHandler(error);
                                } else scope.$apply(callback);
                            }));
                        };
                    }
                };
            }
            forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), (function(eventName) {
                var directiveName = directiveNormalize("ng-" + eventName);
                ngEventDirectives[directiveName] = [ "$parse", "$rootScope", "$exceptionHandler", function($parse, $rootScope, $exceptionHandler) {
                    return createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsyncEvents[eventName]);
                } ];
            }));
            var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
                return {
                    multiElement: !0,
                    transclude: "element",
                    priority: 600,
                    terminal: !0,
                    restrict: "A",
                    $$tlb: !0,
                    link: function($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, (function(value) {
                            value ? childScope || $transclude((function(clone, newScope) {
                                childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), 
                                block = {
                                    clone
                                }, $animate.enter(clone, $element.parent(), $element);
                            })) : (previousElements && (previousElements.remove(), previousElements = null), 
                            childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                            $animate.leave(previousElements).done((function(response) {
                                !1 !== response && (previousElements = null);
                            })), block = null));
                        }));
                    }
                };
            } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: "ECA",
                    priority: 400,
                    terminal: !0,
                    transclude: "element",
                    controller: angular.noop,
                    compile: function(element, attr) {
                        var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                        return function(scope, $element, $attr, ctrl, $transclude) {
                            var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                                currentScope = null), currentElement && ($animate.leave(currentElement).done((function(response) {
                                    !1 !== response && (previousElement = null);
                                })), previousElement = currentElement, currentElement = null);
                            };
                            scope.$watch(srcExp, (function(src) {
                                var afterAnimation = function(response) {
                                    !1 === response || !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                                }, thisChangeId = ++changeCounter;
                                src ? ($templateRequest(src, !0).then((function(response) {
                                    if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, (function(clone) {
                                            cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation);
                                        }));
                                        currentElement = clone, (currentScope = newScope).$emit("$includeContentLoaded", src), 
                                        scope.$eval(onloadExp);
                                    }
                                }), (function() {
                                    scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), 
                                    scope.$emit("$includeContentError", src));
                                })), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                                ctrl.template = null);
                            }));
                        };
                    }
                };
            } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
                return {
                    restrict: "ECA",
                    priority: -400,
                    require: "ngInclude",
                    link: function(scope, $element, $attr, ctrl) {
                        if (toString.call($element[0]).match(/SVG/)) return $element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, (function(clone) {
                            $element.append(clone);
                        }), {
                            futureParentElement: $element
                        });
                        $element.html(ctrl.template), $compile($element.contents())(scope);
                    }
                };
            } ], ngInitDirective = ngDirective({
                priority: 450,
                compile: function() {
                    return {
                        pre: function(scope, element, attrs) {
                            scope.$eval(attrs.ngInit);
                        }
                    };
                }
            }), ngListDirective = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    require: "ngModel",
                    link: function(scope, element, attr, ctrl) {
                        var ngList = attr.ngList || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList;
                        ctrl.$parsers.push((function(viewValue) {
                            if (!isUndefined(viewValue)) {
                                var list = [];
                                return viewValue && forEach(viewValue.split(separator), (function(value) {
                                    value && list.push(trimValues ? trim(value) : value);
                                })), list;
                            }
                        })), ctrl.$formatters.push((function(value) {
                            if (isArray(value)) return value.join(ngList);
                        })), ctrl.$isEmpty = function(value) {
                            return !value || !value.length;
                        };
                    }
                };
            }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", ngModelMinErr = minErr("ngModel");
            function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
                var ctrl;
                this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, 
                this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], 
                this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, 
                this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, 
                this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), 
                this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$updateEvents = "", 
                this.$$updateEventHandler = this.$$updateEventHandler.bind(this), this.$$parsedNgModel = $parse($attr.ngModel), 
                this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, 
                this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, 
                this.$$parserName = "parse", this.$$currentValidationRunId = 0, this.$$scope = $scope, 
                this.$$rootScope = $scope.$root, this.$$attr = $attr, this.$$element = $element, 
                this.$$animate = $animate, this.$$timeout = $timeout, this.$$parse = $parse, this.$$q = $q, 
                this.$$exceptionHandler = $exceptionHandler, setupValidity(this), (ctrl = this).$$scope.$watch((function(scope) {
                    var modelValue = ctrl.$$ngModelGet(scope);
                    return modelValue === ctrl.$modelValue || ctrl.$modelValue != ctrl.$modelValue && modelValue != modelValue || ctrl.$$setModelValue(modelValue), 
                    modelValue;
                }));
            }
            NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ], 
            NgModelController.prototype = {
                $$initGetterSetters: function() {
                    if (this.$options.getOption("getterSetter")) {
                        var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                        this.$$ngModelGet = function($scope) {
                            var modelValue = this.$$parsedNgModel($scope);
                            return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue;
                        }, this.$$ngModelSet = function($scope, newValue) {
                            isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                                $$$p: newValue
                            }) : this.$$parsedNgModelAssign($scope, newValue);
                        };
                    } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
                },
                $render: noop,
                $isEmpty: function(value) {
                    return isUndefined(value) || "" === value || null === value || value != value;
                },
                $$updateEmptyClasses: function(value) {
                    this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"), 
                    this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"), 
                    this.$$animate.addClass(this.$$element, "ng-not-empty"));
                },
                $setPristine: function() {
                    this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS), 
                    this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
                },
                $setDirty: function() {
                    this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), 
                    this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty();
                },
                $setUntouched: function() {
                    this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched");
                },
                $setTouched: function() {
                    this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched");
                },
                $rollbackViewValue: function() {
                    this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, 
                    this.$render();
                },
                $validate: function() {
                    if (!isNumberNaN(this.$modelValue)) {
                        var viewValue = this.$$lastCommittedViewValue, modelValue = this.$$rawModelValue, prevValid = this.$valid, prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid"), that = this;
                        this.$$runValidators(modelValue, viewValue, (function(allValid) {
                            allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0, 
                            that.$modelValue !== prevModelValue && that.$$writeModelToScope());
                        }));
                    }
                },
                $$runValidators: function(modelValue, viewValue, doneCallback) {
                    this.$$currentValidationRunId++;
                    var validatorPromises, allValid, localValidationRunId = this.$$currentValidationRunId, that = this;
                    (function() {
                        var errorKey = that.$$parserName;
                        if (!isUndefined(that.$$parserValid)) return that.$$parserValid || (forEach(that.$validators, (function(v, name) {
                            setValidity(name, null);
                        })), forEach(that.$asyncValidators, (function(v, name) {
                            setValidity(name, null);
                        }))), setValidity(errorKey, that.$$parserValid), that.$$parserValid;
                        setValidity(errorKey, null);
                        return !0;
                    })() ? !function() {
                        var syncValidatorsValid = !0;
                        if (forEach(that.$validators, (function(validator, name) {
                            var result = Boolean(validator(modelValue, viewValue));
                            syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                        })), !syncValidatorsValid) return forEach(that.$asyncValidators, (function(v, name) {
                            setValidity(name, null);
                        })), !1;
                        return !0;
                    }() ? validationDone(!1) : (validatorPromises = [], allValid = !0, forEach(that.$asyncValidators, (function(validator, name) {
                        var promise = validator(modelValue, viewValue);
                        if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                        setValidity(name, void 0), validatorPromises.push(promise.then((function() {
                            setValidity(name, !0);
                        }), (function() {
                            allValid = !1, setValidity(name, !1);
                        })));
                    })), validatorPromises.length ? that.$$q.all(validatorPromises).then((function() {
                        validationDone(allValid);
                    }), noop) : validationDone(!0)) : validationDone(!1);
                    function setValidity(name, isValid) {
                        localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid);
                    }
                    function validationDone(allValid) {
                        localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid);
                    }
                },
                $commitViewValue: function() {
                    var viewValue = this.$viewValue;
                    this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue), 
                    this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate());
                },
                $$parseAndValidate: function() {
                    var modelValue = this.$$lastCommittedViewValue, that = this;
                    if (this.$$parserValid = !isUndefined(modelValue) || void 0, this.$setValidity(this.$$parserName, null), 
                    this.$$parserName = "parse", this.$$parserValid) for (var i = 0; i < this.$parsers.length; i++) if (isUndefined(modelValue = this.$parsers[i](modelValue))) {
                        this.$$parserValid = !1;
                        break;
                    }
                    isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
                    var prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid");
                    function writeToModelIfNeeded() {
                        that.$modelValue !== prevModelValue && that.$$writeModelToScope();
                    }
                    this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue, 
                    writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, (function(allValid) {
                        allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded());
                    }));
                },
                $$writeModelToScope: function() {
                    this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, (function(listener) {
                        try {
                            listener();
                        } catch (e) {
                            this.$$exceptionHandler(e);
                        }
                    }), this);
                },
                $setViewValue: function(value, trigger) {
                    this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger);
                },
                $$debounceViewValueCommit: function(trigger) {
                    var debounceDelay = this.$options.getOption("debounce");
                    isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay.default) && -1 === this.$options.getOption("updateOn").indexOf(trigger) ? debounceDelay = debounceDelay.default : isNumber(debounceDelay["*"]) && (debounceDelay = debounceDelay["*"]), 
                    this.$$timeout.cancel(this.$$pendingDebounce);
                    var that = this;
                    debounceDelay > 0 ? this.$$pendingDebounce = this.$$timeout((function() {
                        that.$commitViewValue();
                    }), debounceDelay) : this.$$rootScope.$$phase ? this.$commitViewValue() : this.$$scope.$apply((function() {
                        that.$commitViewValue();
                    }));
                },
                $overrideModelOptions: function(options) {
                    this.$options = this.$options.createChild(options), this.$$setUpdateOnEvents();
                },
                $processModelValue: function() {
                    var viewValue = this.$$format();
                    this.$viewValue !== viewValue && (this.$$updateEmptyClasses(viewValue), this.$viewValue = this.$$lastCommittedViewValue = viewValue, 
                    this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, noop));
                },
                $$format: function() {
                    for (var formatters = this.$formatters, idx = formatters.length, viewValue = this.$modelValue; idx--; ) viewValue = formatters[idx](viewValue);
                    return viewValue;
                },
                $$setModelValue: function(modelValue) {
                    this.$modelValue = this.$$rawModelValue = modelValue, this.$$parserValid = void 0, 
                    this.$processModelValue();
                },
                $$setUpdateOnEvents: function() {
                    this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler), 
                    this.$$updateEvents = this.$options.getOption("updateOn"), this.$$updateEvents && this.$$element.on(this.$$updateEvents, this.$$updateEventHandler);
                },
                $$updateEventHandler: function(ev) {
                    this.$$debounceViewValueCommit(ev && ev.type);
                }
            }, addSetValidityMethod({
                clazz: NgModelController,
                set: function(object, property) {
                    object[property] = !0;
                },
                unset: function(object, property) {
                    delete object[property];
                }
            });
            var defaultModelOptions, ngModelDirective = [ "$rootScope", function($rootScope) {
                return {
                    restrict: "A",
                    require: [ "ngModel", "^?form", "^?ngModelOptions" ],
                    controller: NgModelController,
                    priority: 1,
                    compile: function(element) {
                        return element.addClass(PRISTINE_CLASS).addClass("ng-untouched").addClass(VALID_CLASS), 
                        {
                            pre: function(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                                optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(), 
                                formCtrl.$addControl(modelCtrl), attr.$observe("name", (function(newValue) {
                                    modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                                })), scope.$on("$destroy", (function() {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                                }));
                            },
                            post: function(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0];
                                function setTouched() {
                                    modelCtrl.$setTouched();
                                }
                                modelCtrl.$$setUpdateOnEvents(), element.on("blur", (function() {
                                    modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched));
                                }));
                            }
                        };
                    }
                };
            } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
            function ModelOptions(options) {
                this.$$options = options;
            }
            ModelOptions.prototype = {
                getOption: function(name) {
                    return this.$$options[name];
                },
                createChild: function(options) {
                    var inheritAll = !1;
                    return forEach(options = extend({}, options), (function(option, key) {
                        "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key], 
                        "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1, 
                        options[key] = trim(option.replace(DEFAULT_REGEXP, (function() {
                            return options.updateOnDefault = !0, " ";
                        }))));
                    }), this), inheritAll && (delete options["*"], defaults(options, this.$$options)), 
                    defaults(options, defaultModelOptions.$$options), new ModelOptions(options);
                }
            }, defaultModelOptions = new ModelOptions({
                updateOn: "",
                updateOnDefault: !0,
                debounce: 0,
                getterSetter: !1,
                allowInvalid: !1,
                timezone: null
            });
            var ngModelOptionsDirective = function() {
                function NgModelOptionsController($attrs, $scope) {
                    this.$$attrs = $attrs, this.$$scope = $scope;
                }
                return NgModelOptionsController.$inject = [ "$attrs", "$scope" ], NgModelOptionsController.prototype = {
                    $onInit: function() {
                        var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions, modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                        this.$options = parentOptions.createChild(modelOptionsDefinition);
                    }
                }, {
                    restrict: "A",
                    priority: 10,
                    require: {
                        parentCtrl: "?^^ngModelOptions"
                    },
                    bindToController: !0,
                    controller: NgModelOptionsController
                };
            };
            function defaults(dst, src) {
                forEach(src, (function(value, key) {
                    isDefined(dst[key]) || (dst[key] = value);
                }));
            }
            var ngNonBindableDirective = ngDirective({
                terminal: !0,
                priority: 1e3
            }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
                var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
                return {
                    restrict: "A",
                    terminal: !0,
                    require: [ "select", "ngModel" ],
                    link: {
                        pre: function(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop;
                        },
                        post: function(scope, selectElement, attr, ctrls) {
                            for (var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) if ("" === children[i].value) {
                                selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                                break;
                            }
                            selectElement.empty();
                            var options, providedEmptyOption = !!selectCtrl.emptyOption;
                            jqLite(optionTemplate.cloneNode(!1)).val("?");
                            var ngOptions = function(optionsExp, selectElement, scope) {
                                var match = optionsExp.match(NG_OPTIONS_REGEXP);
                                if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                                var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), viewValueFn = selectAs && $parse(selectAs) || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                                    return trackByFn(scope, locals);
                                } : function(value) {
                                    return hashKey(value);
                                }, getTrackByValue = function(value, key) {
                                    return getTrackByValueFn(value, getLocals(value, key));
                                }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                                    return locals[keyName] = key, locals[valueName] = value, locals;
                                } : function(value) {
                                    return locals[valueName] = value, locals;
                                };
                                function Option(selectValue, viewValue, label, group, disabled) {
                                    this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, 
                                    this.group = group, this.disabled = disabled;
                                }
                                function getOptionValuesKeys(optionValues) {
                                    var optionValuesKeys;
                                    if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else for (var itemKey in optionValuesKeys = [], 
                                    optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                                    return optionValuesKeys;
                                }
                                return {
                                    trackBy,
                                    getTrackByValue,
                                    getWatchables: $parse(valuesFn, (function(optionValues) {
                                        for (var watchedArray = [], optionValuesKeys = getOptionValuesKeys(optionValues = optionValues || []), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                            var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), selectValue = getTrackByValueFn(value, locals);
                                            if (watchedArray.push(selectValue), match[2] || match[1]) {
                                                var label = displayFn(scope, locals);
                                                watchedArray.push(label);
                                            }
                                            if (match[4]) {
                                                var disableWhen = disableWhenFn(scope, locals);
                                                watchedArray.push(disableWhen);
                                            }
                                        }
                                        return watchedArray;
                                    })),
                                    getOptions: function() {
                                        for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                            var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), optionItem = new Option(selectValue, viewValue, displayFn(scope, locals), groupByFn(scope, locals), disableWhenFn(scope, locals));
                                            optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                                        }
                                        return {
                                            items: optionItems,
                                            selectValueMap,
                                            getOptionFromViewValue: function(value) {
                                                return selectValueMap[getTrackByValue(value)];
                                            },
                                            getViewValueFromOption: function(option) {
                                                return trackBy ? copy(option.viewValue) : option.viewValue;
                                            }
                                        };
                                    }
                                };
                            }(attr.ngOptions, selectElement, scope), listFragment = $document[0].createDocumentFragment();
                            function addOptionElement(option, parent) {
                                var optionElement = optionTemplate.cloneNode(!1);
                                parent.appendChild(optionElement), function(option, element) {
                                    option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, 
                                    element.textContent = option.label);
                                    element.value = option.selectValue;
                                }(option, optionElement);
                            }
                            function getAndUpdateSelectedOption(viewValue) {
                                var option = options.getOptionFromViewValue(viewValue), element = option && option.element;
                                return element && !element.selected && (element.selected = !0), option;
                            }
                            selectCtrl.generateUnknownOptionValue = function(val) {
                                return "?";
                            }, multiple ? (selectCtrl.writeValue = function(values) {
                                if (options) {
                                    var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                                    options.items.forEach((function(option) {
                                        option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1);
                                    }));
                                }
                            }, selectCtrl.readValue = function() {
                                var selectedValues = selectElement.val() || [], selections = [];
                                return forEach(selectedValues, (function(value) {
                                    var option = options.selectValueMap[value];
                                    option && !option.disabled && selections.push(options.getViewValueFromOption(option));
                                })), selections;
                            }, ngOptions.trackBy && scope.$watchCollection((function() {
                                if (isArray(ngModelCtrl.$viewValue)) return ngModelCtrl.$viewValue.map((function(value) {
                                    return ngOptions.getTrackByValue(value);
                                }));
                            }), (function() {
                                ngModelCtrl.$render();
                            }))) : (selectCtrl.writeValue = function(value) {
                                if (options) {
                                    var selectedOption = selectElement[0].options[selectElement[0].selectedIndex], option = options.getOptionFromViewValue(value);
                                    selectedOption && selectedOption.removeAttribute("selected"), option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(), 
                                    selectElement[0].value = option.selectValue, option.element.selected = !0), option.element.setAttribute("selected", "selected")) : selectCtrl.selectUnknownOrEmptyOption(value);
                                }
                            }, selectCtrl.readValue = function() {
                                var selectedOption = options.selectValueMap[selectElement.val()];
                                return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(), 
                                selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null;
                            }, ngOptions.trackBy && scope.$watch((function() {
                                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                            }), (function() {
                                ngModelCtrl.$render();
                            }))), providedEmptyOption && ($compile(selectCtrl.emptyOption)(scope), selectElement.prepend(selectCtrl.emptyOption), 
                            selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT ? (selectCtrl.hasEmptyOption = !1, 
                            selectCtrl.registerOption = function(optionScope, optionEl) {
                                "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl, 
                                selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", (function() {
                                    var needsRerender = selectCtrl.$isEmptyOptionSelected();
                                    selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0, needsRerender && ngModelCtrl.$render();
                                })));
                            }) : selectCtrl.emptyOption.removeClass("ng-scope")), scope.$watchCollection(ngOptions.getWatchables, (function() {
                                var previousValue = options && selectCtrl.readValue();
                                if (options) for (var i = options.items.length - 1; i >= 0; i--) {
                                    var option = options.items[i];
                                    isDefined(option.group) ? jqLiteRemove(option.element.parentNode) : jqLiteRemove(option.element);
                                }
                                options = ngOptions.getOptions();
                                var groupElementMap = {};
                                if (options.items.forEach((function(option) {
                                    var groupElement;
                                    isDefined(option.group) ? ((groupElement = groupElementMap[option.group]) || (groupElement = optGroupTemplate.cloneNode(!1), 
                                    listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, 
                                    groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment);
                                })), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                                    var nextValue = selectCtrl.readValue();
                                    (ngOptions.trackBy || multiple ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), 
                                    ngModelCtrl.$render());
                                }
                            }));
                        }
                    }
                };
            } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
                var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function(scope, element, attr) {
                        var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                        function updateElementText(newText) {
                            element.text(newText || "");
                        }
                        forEach(attr, (function(expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName]);
                            }
                        })), forEach(whens, (function(expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                        })), scope.$watch(numberExp, (function(newVal) {
                            var count = parseFloat(newVal), countIsNaN = isNumberNaN(count);
                            if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), 
                            !(count === lastCount || countIsNaN && isNumberNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), 
                                watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), 
                                lastCount = count;
                            }
                        }));
                    }
                };
            } ], ngRefMinErr = minErr("ngRef"), ngRefDirective = [ "$parse", function($parse) {
                return {
                    priority: -1,
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var controllerName = directiveNormalize(nodeName_(tElement)), getter = $parse(tAttrs.ngRef), setter = getter.assign || function() {
                            throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef);
                        };
                        return function(scope, element, attrs) {
                            var refValue;
                            if (attrs.hasOwnProperty("ngRefRead")) {
                                if ("$element" === attrs.ngRefRead) refValue = element; else if (!(refValue = element.data("$" + attrs.ngRefRead + "Controller"))) throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef);
                            } else refValue = element.data("$" + controllerName + "Controller");
                            setter(scope, refValue = refValue || element), element.on("$destroy", (function() {
                                getter(scope) === refValue && setter(scope, null);
                            }));
                        };
                    }
                };
            } ], ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
                var ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                    scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
                    scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
                    scope.$odd = !(scope.$even = !(1 & index));
                }, getBlockStart = function(block) {
                    return block.clone[0];
                }, getBlockEnd = function(block) {
                    return block.clone[block.clone.length - 1];
                }, trackByIdArrayFn = function($scope, key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function($scope, key) {
                    return key;
                };
                return {
                    restrict: "A",
                    multiElement: !0,
                    transclude: "element",
                    priority: 1e3,
                    terminal: !0,
                    $$tlb: !0,
                    compile: function($element, $attr) {
                        var expression = $attr.ngRepeat, ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                        var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                        if (!(match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/))) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                        var trackByIdExpFn, valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                        if (trackByExp) {
                            var hashFnLocals = {
                                $id: hashKey
                            }, trackByExpGetter = $parse(trackByExp);
                            trackByIdExpFn = function($scope, key, value, index) {
                                return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                                hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                            };
                        }
                        return function($scope, $element, $attr, ctrl, $transclude) {
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, (function(collection) {
                                var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                                if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                                trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else for (var itemKey in trackByIdFn = trackByIdExpFn || trackByIdObjFn, 
                                collectionKeys = [], collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                                for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                                index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                                value = collection[key], trackById = trackByIdFn($scope, key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                                delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                                    if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, (function(block) {
                                        block && block.scope && (lastBlockMap[block.id] = block);
                                    })), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                    nextBlockOrder[index] = {
                                        id: trackById,
                                        scope: void 0,
                                        clone: void 0
                                    }, nextBlockMap[trackById] = !0;
                                }
                                for (var blockKey in hashFnLocals && (hashFnLocals[valueIdentifier] = void 0), lastBlockMap) {
                                    if (elementsToRemove = getBlockNodes((block = lastBlockMap[blockKey]).clone), $animate.leave(elementsToRemove), 
                                    elementsToRemove[0].parentNode) for (index = 0, length = elementsToRemove.length; index < length; index++) elementsToRemove[index].$$NG_REMOVED = !0;
                                    block.scope.$destroy();
                                }
                                for (index = 0; index < collectionLength; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                                value = collection[key], (block = nextBlockOrder[index]).scope) {
                                    nextNode = previousNode;
                                    do {
                                        nextNode = nextNode.nextSibling;
                                    } while (nextNode && nextNode.$$NG_REMOVED);
                                    getBlockStart(block) !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), 
                                    previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                } else $transclude((function(clone, scope) {
                                    block.scope = scope;
                                    var endNode = ngRepeatEndComment.cloneNode(!1);
                                    clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, 
                                    block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                }));
                                lastBlockMap = nextBlockMap;
                            }));
                        };
                    }
                };
            } ], ngShowDirective = [ "$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngShow, (function(value) {
                            $animate[value ? "removeClass" : "addClass"](element, "ng-hide", {
                                tempClasses: "ng-hide-animate"
                            });
                        }));
                    }
                };
            } ], ngHideDirective = [ "$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngHide, (function(value) {
                            $animate[value ? "addClass" : "removeClass"](element, "ng-hide", {
                                tempClasses: "ng-hide-animate"
                            });
                        }));
                    }
                };
            } ], ngStyleDirective = ngDirective((function(scope, element, attr) {
                scope.$watchCollection(attr.ngStyle, (function(newStyles, oldStyles) {
                    oldStyles && newStyles !== oldStyles && forEach(oldStyles, (function(val, style) {
                        element.css(style, "");
                    })), newStyles && element.css(newStyles);
                }));
            })), ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
                return {
                    require: "ngSwitch",
                    controller: [ "$scope", function() {
                        this.cases = {};
                    } ],
                    link: function(scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                            return function(response) {
                                !1 !== response && array.splice(index, 1);
                            };
                        };
                        scope.$watch(watchExpr, (function(value) {
                            for (var i, ii; previousLeaveAnimations.length; ) $animate.cancel(previousLeaveAnimations.pop());
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy(), (previousLeaveAnimations[i] = $animate.leave(selected)).done(spliceFactory(previousLeaveAnimations, i));
                            }
                            selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, (function(selectedTransclude) {
                                selectedTransclude.transclude((function(caseElement, selectedScope) {
                                    selectedScopes.push(selectedScope);
                                    var anchor = selectedTransclude.element;
                                    caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                    var block = {
                                        clone: caseElement
                                    };
                                    selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                                }));
                            }));
                        }));
                    }
                };
            } ], ngSwitchWhenDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attrs, ctrl, $transclude) {
                    var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter((function(element, index, array) {
                        return array[index - 1] !== element;
                    }));
                    forEach(cases, (function(whenCase) {
                        ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                            transclude: $transclude,
                            element
                        });
                    }));
                }
            }), ngSwitchDefaultDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attr, ctrl, $transclude) {
                    ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                        transclude: $transclude,
                        element
                    });
                }
            }), ngTranscludeMinErr = minErr("ngTransclude"), ngTranscludeDirective = [ "$compile", function($compile) {
                return {
                    restrict: "EAC",
                    compile: function(tElement) {
                        var fallbackLinkFn = $compile(tElement.contents());
                        return tElement.empty(), function($scope, $element, $attrs, controller, $transclude) {
                            if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                            $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                            var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                            function useFallbackContent() {
                                fallbackLinkFn($scope, (function(clone) {
                                    $element.append(clone);
                                }));
                            }
                            $transclude((function(clone, transcludedScope) {
                                clone.length && function(nodes) {
                                    for (var i = 0, ii = nodes.length; i < ii; i++) {
                                        var node = nodes[i];
                                        if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0;
                                    }
                                }(clone) ? $element.append(clone) : (useFallbackContent(), transcludedScope.$destroy());
                            }), null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent();
                        };
                    }
                };
            } ], scriptDirective = [ "$templateCache", function($templateCache) {
                return {
                    restrict: "E",
                    terminal: !0,
                    compile: function(element, attr) {
                        if ("text/ng-template" === attr.type) {
                            var templateUrl = attr.id, text = element[0].text;
                            $templateCache.put(templateUrl, text);
                        }
                    }
                };
            } ], noopNgModelController = {
                $setViewValue: noop,
                $render: noop
            };
            function setOptionSelectedStatus(optionEl, value) {
                optionEl.prop("selected", value), optionEl.attr("selected", value);
            }
            var SelectController = [ "$element", "$scope", function($element, $scope) {
                var self = this, optionsMap = new NgMap;
                self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1, 
                self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1, 
                self.emptyOption = void 0, self.renderUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionSelectedStatus(self.unknownOption, !0), 
                    $element.val(unknownVal);
                }, self.updateUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), setOptionSelectedStatus(self.unknownOption, !0), 
                    $element.val(unknownVal);
                }, self.generateUnknownOptionValue = function(val) {
                    return "? " + hashKey(val) + " ?";
                }, self.removeUnknownOption = function() {
                    self.unknownOption.parent() && self.unknownOption.remove();
                }, self.selectEmptyOption = function() {
                    self.emptyOption && ($element.val(""), setOptionSelectedStatus(self.emptyOption, !0));
                }, self.unselectEmptyOption = function() {
                    self.hasEmptyOption && setOptionSelectedStatus(self.emptyOption, !1);
                }, $scope.$on("$destroy", (function() {
                    self.renderUnknownOption = noop;
                })), self.readValue = function() {
                    var val = $element.val(), realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
                    return self.hasOption(realVal) ? realVal : null;
                }, self.writeValue = function(value) {
                    var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
                    if (currentlySelectedOption && setOptionSelectedStatus(jqLite(currentlySelectedOption), !1), 
                    self.hasOption(value)) {
                        self.removeUnknownOption();
                        var hashedVal = hashKey(value);
                        $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                        var selectedOption = $element[0].options[$element[0].selectedIndex];
                        setOptionSelectedStatus(jqLite(selectedOption), !0);
                    } else self.selectUnknownOrEmptyOption(value);
                }, self.addOption = function(value, element) {
                    if (element[0].nodeType !== NODE_TYPE_COMMENT) {
                        assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.hasEmptyOption = !0, 
                        self.emptyOption = element);
                        var count = optionsMap.get(value) || 0;
                        optionsMap.set(value, count + 1), scheduleRender();
                    }
                }, self.removeOption = function(value) {
                    var count = optionsMap.get(value);
                    count && (1 === count ? (optionsMap.delete(value), "" === value && (self.hasEmptyOption = !1, 
                    self.emptyOption = void 0)) : optionsMap.set(value, count - 1));
                }, self.hasOption = function(value) {
                    return !!optionsMap.get(value);
                }, self.$hasEmptyOption = function() {
                    return self.hasEmptyOption;
                }, self.$isUnknownOptionSelected = function() {
                    return $element[0].options[0] === self.unknownOption[0];
                }, self.$isEmptyOptionSelected = function() {
                    return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0];
                }, self.selectUnknownOrEmptyOption = function(value) {
                    null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value);
                };
                var renderScheduled = !1;
                function scheduleRender() {
                    renderScheduled || (renderScheduled = !0, $scope.$$postDigest((function() {
                        renderScheduled = !1, self.ngModelCtrl.$render();
                    })));
                }
                var updateScheduled = !1;
                function scheduleViewValueUpdate(renderAfter) {
                    updateScheduled || (updateScheduled = !0, $scope.$$postDigest((function() {
                        $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()), 
                        renderAfter && self.ngModelCtrl.$render());
                    })));
                }
                self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    var oldVal, hashedVal;
                    optionAttrs.$attr.ngValue ? optionAttrs.$observe("value", (function(newVal) {
                        var removal, previouslySelected = optionElement.prop("selected");
                        isDefined(hashedVal) && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal], 
                        removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal, 
                        self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate();
                    })) : interpolateValueFn ? optionAttrs.$observe("value", (function(newVal) {
                        var removal;
                        self.readValue();
                        var previouslySelected = optionElement.prop("selected");
                        isDefined(oldVal) && (self.removeOption(oldVal), removal = !0), oldVal = newVal, 
                        self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate();
                    })) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, (function(newVal, oldVal) {
                        optionAttrs.$set("value", newVal);
                        var previouslySelected = optionElement.prop("selected");
                        oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement), 
                        oldVal && previouslySelected && scheduleViewValueUpdate();
                    })) : self.addOption(optionAttrs.value, optionElement);
                    optionAttrs.$observe("disabled", (function(newVal) {
                        ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null), 
                        self.ngModelCtrl.$render()));
                    })), optionElement.on("$destroy", (function() {
                        var currentValue = self.readValue(), removeValue = optionAttrs.value;
                        self.removeOption(removeValue), scheduleRender(), (self.multiple && currentValue && -1 !== currentValue.indexOf(removeValue) || currentValue === removeValue) && scheduleViewValueUpdate(!0);
                    }));
                };
            } ], selectDirective = function() {
                return {
                    restrict: "E",
                    require: [ "select", "?ngModel" ],
                    controller: SelectController,
                    priority: 1,
                    link: {
                        pre: function(scope, element, attr, ctrls) {
                            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                            if (!ngModelCtrl) return void (selectCtrl.registerOption = noop);
                            if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", (function() {
                                selectCtrl.removeUnknownOption(), scope.$apply((function() {
                                    ngModelCtrl.$setViewValue(selectCtrl.readValue());
                                }));
                            })), attr.multiple) {
                                selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                                    var array = [];
                                    return forEach(element.find("option"), (function(option) {
                                        if (option.selected && !option.disabled) {
                                            var val = option.value;
                                            array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                                        }
                                    })), array;
                                }, selectCtrl.writeValue = function(value) {
                                    forEach(element.find("option"), (function(option) {
                                        var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                                        shouldBeSelected !== option.selected && setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                                    }));
                                };
                                var lastView, lastViewRef = NaN;
                                scope.$watch((function() {
                                    lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), 
                                    ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                                })), ngModelCtrl.$isEmpty = function(value) {
                                    return !value || 0 === value.length;
                                };
                            }
                        },
                        post: function(scope, element, attrs, ctrls) {
                            var ngModelCtrl = ctrls[1];
                            if (!ngModelCtrl) return;
                            var selectCtrl = ctrls[0];
                            ngModelCtrl.$render = function() {
                                selectCtrl.writeValue(ngModelCtrl.$viewValue);
                            };
                        }
                    }
                };
            }, optionDirective = [ "$interpolate", function($interpolate) {
                return {
                    restrict: "E",
                    priority: 100,
                    compile: function(element, attr) {
                        var interpolateValueFn, interpolateTextFn;
                        return isDefined(attr.ngValue) || (isDefined(attr.value) ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0)) || attr.$set("value", element.text())), 
                        function(scope, element, attr) {
                            var parent = element.parent(), selectCtrl = parent.data("$selectController") || parent.parent().data("$selectController");
                            selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                        };
                    }
                };
            } ], requiredDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var value = attr.hasOwnProperty("required") || $parse(attr.ngRequired)(scope);
                            attr.ngRequired || (attr.required = !0), ctrl.$validators.required = function(modelValue, viewValue) {
                                return !value || !ctrl.$isEmpty(viewValue);
                            }, attr.$observe("required", (function(newVal) {
                                value !== newVal && (value = newVal, ctrl.$validate());
                            }));
                        }
                    }
                };
            } ], patternDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    compile: function(tElm, tAttr) {
                        var patternExp, parseFn;
                        return tAttr.ngPattern && (patternExp = tAttr.ngPattern, parseFn = "/" === tAttr.ngPattern.charAt(0) && REGEX_STRING_REGEXP.test(tAttr.ngPattern) ? function() {
                            return tAttr.ngPattern;
                        } : $parse(tAttr.ngPattern)), function(scope, elm, attr, ctrl) {
                            if (ctrl) {
                                var attrVal = attr.pattern;
                                attr.ngPattern ? attrVal = parseFn(scope) : patternExp = attr.pattern;
                                var regexp = parsePatternAttr(attrVal, patternExp, elm);
                                attr.$observe("pattern", (function(newVal) {
                                    var oldRegexp = regexp;
                                    regexp = parsePatternAttr(newVal, patternExp, elm), (oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString()) && ctrl.$validate();
                                })), ctrl.$validators.pattern = function(modelValue, viewValue) {
                                    return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                                };
                            }
                        };
                    }
                };
            } ], maxlengthDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope), maxlengthParsed = parseLength(maxlength);
                            attr.$observe("maxlength", (function(value) {
                                maxlength !== value && (maxlengthParsed = parseLength(value), maxlength = value, 
                                ctrl.$validate());
                            })), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                                return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed;
                            };
                        }
                    }
                };
            } ], minlengthDirective = [ "$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var minlength = attr.minlength || $parse(attr.ngMinlength)(scope), minlengthParsed = parseLength(minlength) || -1;
                            attr.$observe("minlength", (function(value) {
                                minlength !== value && (minlengthParsed = parseLength(value) || -1, minlength = value, 
                                ctrl.$validate());
                            })), ctrl.$validators.minlength = function(modelValue, viewValue) {
                                return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed;
                            };
                        }
                    }
                };
            } ];
            function parsePatternAttr(regex, patternExp, elm) {
                if (regex) {
                    if (isString(regex) && (regex = new RegExp("^" + regex + "$")), !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                    return regex;
                }
            }
            function parseLength(val) {
                var intVal = toInt(val);
                return isNumberNaN(intVal) ? -1 : intVal;
            }
            window.angular.bootstrap ? window.console && console.log("WARNING: Tried to load AngularJS more than once.") : (!function() {
                var originalCleanData;
                if (!bindJQueryFired) {
                    var jqName = jq();
                    (jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : void 0) && jQuery.fn.on ? (jqLite = jQuery, 
                    extend(jQuery.fn, {
                        scope: JQLitePrototype.scope,
                        isolateScope: JQLitePrototype.isolateScope,
                        controller: JQLitePrototype.controller,
                        injector: JQLitePrototype.injector,
                        inheritedData: JQLitePrototype.inheritedData
                    })) : jqLite = JQLite, originalCleanData = jqLite.cleanData, jqLite.cleanData = function(elems) {
                        for (var events, elem, i = 0; null != (elem = elems[i]); i++) (events = (jqLite._data(elem) || {}).events) && events.$destroy && jqLite(elem).triggerHandler("$destroy");
                        originalCleanData(elems);
                    }, angular.element = jqLite, bindJQueryFired = !0;
                }
            }(), function(angular) {
                extend(angular, {
                    errorHandlingConfig,
                    bootstrap,
                    copy,
                    extend,
                    merge,
                    equals,
                    element: jqLite,
                    forEach,
                    injector: createInjector,
                    noop,
                    bind,
                    toJson,
                    fromJson,
                    identity,
                    isUndefined,
                    isDefined,
                    isString,
                    isFunction,
                    isObject,
                    isNumber,
                    isElement,
                    isArray,
                    version,
                    isDate,
                    callbacks: {
                        $$counter: 0
                    },
                    getTestability,
                    reloadWithDebugInfo,
                    UNSAFE_restoreLegacyJqLiteXHTMLReplacement,
                    $$minErr: minErr,
                    $$csp: csp,
                    $$encodeUriSegment: encodeUriSegment,
                    $$encodeUriQuery: encodeUriQuery,
                    $$lowercase: lowercase,
                    $$stringify: stringify,
                    $$uppercase: uppercase
                }), angularModule = function(window) {
                    var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng");
                    function ensure(obj, name, factory) {
                        return obj[name] || (obj[name] = factory());
                    }
                    var angular = ensure(window, "angular", Object);
                    return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", (function() {
                        var modules = {};
                        return function(name, requires, configFn) {
                            var info = {};
                            return function(name) {
                                if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", "module");
                            }(name), requires && modules.hasOwnProperty(name) && (modules[name] = null), ensure(modules, name, (function() {
                                if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                                var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                                    _invokeQueue: invokeQueue,
                                    _configBlocks: configBlocks,
                                    _runBlocks: runBlocks,
                                    info: function(value) {
                                        if (isDefined(value)) {
                                            if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                            return info = value, this;
                                        }
                                        return info;
                                    },
                                    requires,
                                    name,
                                    provider: invokeLaterAndSetModuleName("$provide", "provider"),
                                    factory: invokeLaterAndSetModuleName("$provide", "factory"),
                                    service: invokeLaterAndSetModuleName("$provide", "service"),
                                    value: invokeLater("$provide", "value"),
                                    constant: invokeLater("$provide", "constant", "unshift"),
                                    decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                                    animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                                    filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                                    controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                                    directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                                    component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                                    config,
                                    run: function(block) {
                                        return runBlocks.push(block), this;
                                    }
                                };
                                return configFn && config(configFn), moduleInstance;
                                function invokeLater(provider, method, insertMethod, queue) {
                                    return queue || (queue = invokeQueue), function() {
                                        return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                                    };
                                }
                                function invokeLaterAndSetModuleName(provider, method, queue) {
                                    return queue || (queue = invokeQueue), function(recipeName, factoryFunction) {
                                        return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), 
                                        queue.push([ provider, method, arguments ]), moduleInstance;
                                    };
                                }
                            }));
                        };
                    }));
                }(window), angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
                    $provide.provider({
                        $$sanitizeUri: $$SanitizeUriProvider
                    }), $provide.provider("$compile", $CompileProvider).directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRef: ngRefDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        pattern: patternDirective,
                        ngPattern: patternDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        minlength: minlengthDirective,
                        ngMinlength: minlengthDirective,
                        maxlength: maxlengthDirective,
                        ngMaxlength: maxlengthDirective,
                        ngValue: ngValueDirective,
                        ngModelOptions: ngModelOptionsDirective
                    }).directive({
                        ngInclude: ngIncludeFillContentDirective,
                        input: hiddenInputBrowserCacheDirective
                    }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                        $anchorScroll: $AnchorScrollProvider,
                        $animate: $AnimateProvider,
                        $animateCss: $CoreAnimateCssProvider,
                        $$animateJs: $$CoreAnimateJsProvider,
                        $$animateQueue: $$CoreAnimateQueueProvider,
                        $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                        $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                        $browser: $BrowserProvider,
                        $cacheFactory: $CacheFactoryProvider,
                        $controller: $ControllerProvider,
                        $document: $DocumentProvider,
                        $$isDocumentHidden: $$IsDocumentHiddenProvider,
                        $exceptionHandler: $ExceptionHandlerProvider,
                        $filter: $FilterProvider,
                        $$forceReflow: $$ForceReflowProvider,
                        $interpolate: $InterpolateProvider,
                        $interval: $IntervalProvider,
                        $$intervalFactory: $$IntervalFactoryProvider,
                        $http: $HttpProvider,
                        $httpParamSerializer: $HttpParamSerializerProvider,
                        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                        $httpBackend: $HttpBackendProvider,
                        $xhrFactory: $xhrFactoryProvider,
                        $jsonpCallbacks: $jsonpCallbacksProvider,
                        $location: $LocationProvider,
                        $log: $LogProvider,
                        $parse: $ParseProvider,
                        $rootScope: $RootScopeProvider,
                        $q: $QProvider,
                        $$q: $$QProvider,
                        $sce: $SceProvider,
                        $sceDelegate: $SceDelegateProvider,
                        $sniffer: $SnifferProvider,
                        $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                        $templateCache: $TemplateCacheProvider,
                        $templateRequest: $TemplateRequestProvider,
                        $$testability: $$TestabilityProvider,
                        $timeout: $TimeoutProvider,
                        $window: $WindowProvider,
                        $$rAF: $$RAFProvider,
                        $$jqLite: $$jqLiteProvider,
                        $$Map: $$MapProvider,
                        $$cookieReader: $$CookieReaderProvider
                    });
                } ]).info({
                    angularVersion: "1.8.3"
                });
            }(angular), angular.module("ngLocale", [], [ "$provide", function($provide) {
                var PLURAL_CATEGORY_ONE = "one", PLURAL_CATEGORY_OTHER = "other";
                $provide.value("$locale", {
                    DATETIME_FORMATS: {
                        AMPMS: [ "AM", "PM" ],
                        DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                        ERANAMES: [ "Before Christ", "Anno Domini" ],
                        ERAS: [ "BC", "AD" ],
                        FIRSTDAYOFWEEK: 6,
                        MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                        SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                        SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                        STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                        WEEKENDRANGE: [ 5, 6 ],
                        fullDate: "EEEE, MMMM d, y",
                        longDate: "MMMM d, y",
                        medium: "MMM d, y h:mm:ss a",
                        mediumDate: "MMM d, y",
                        mediumTime: "h:mm:ss a",
                        short: "M/d/yy h:mm a",
                        shortDate: "M/d/yy",
                        shortTime: "h:mm a"
                    },
                    NUMBER_FORMATS: {
                        CURRENCY_SYM: "$",
                        DECIMAL_SEP: ".",
                        GROUP_SEP: ",",
                        PATTERNS: [ {
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 3,
                            minFrac: 0,
                            minInt: 1,
                            negPre: "-",
                            negSuf: "",
                            posPre: "",
                            posSuf: ""
                        }, {
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 2,
                            minFrac: 2,
                            minInt: 1,
                            negPre: "-",
                            negSuf: "",
                            posPre: "",
                            posSuf: ""
                        } ]
                    },
                    id: "en-us",
                    localeID: "en_US",
                    pluralCat: function(n, opt_precision) {
                        var i = 0 | n, vf = function(n, opt_precision) {
                            var v = opt_precision;
                            void 0 === v && (v = Math.min(function(n) {
                                var i = (n += "").indexOf(".");
                                return -1 == i ? 0 : n.length - i - 1;
                            }(n), 3));
                            var base = Math.pow(10, v);
                            return {
                                v,
                                f: (n * base | 0) % base
                            };
                        }(n, opt_precision);
                        return 1 == i && 0 == vf.v ? PLURAL_CATEGORY_ONE : PLURAL_CATEGORY_OTHER;
                    }
                });
            } ]), jqLite((function() {
                angularInit(window.document, bootstrap);
            })));
        }(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(window.angular.element("<style>").text('@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}'));
    },
    789: (module, __unused_webpack_exports, __webpack_require__) => {
        __webpack_require__(995), module.exports = angular;
    },
    100: (module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: () => __WEBPACK_DEFAULT_EXPORT__
        });
        var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(645), _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__), _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278), _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__), _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21), _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__), ___CSS_LOADER_URL_IMPORT_0___ = new URL(__webpack_require__(617), __webpack_require__.b), ___CSS_LOADER_URL_IMPORT_1___ = new URL(__webpack_require__(167), __webpack_require__.b), ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()), ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___), ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
        ___CSS_LOADER_EXPORT___.push([ module.id, `@charset "UTF-8";\n/*!\n * AngularJS Material Design\n * https://github.com/angular/material\n * @license MIT\n * v1.2.5\n */\nhtml, body {\n  height: 100%;\n  position: relative;\n}\n\nbody {\n  margin: 0;\n  padding: 0;\n}\n\n[tabindex="-1"]:focus {\n  outline: none;\n}\n\n.inset {\n  padding: 10px;\n}\n\na.md-no-style,\nbutton.md-no-style {\n  font-weight: normal;\n  background-color: inherit;\n  text-align: left;\n  border: none;\n  padding: 0;\n  margin: 0;\n}\n\nselect,\nbutton,\ntextarea,\ninput {\n  vertical-align: baseline;\n}\n\ninput[type=reset],\ninput[type=submit],\nhtml input[type=button],\nbutton {\n  cursor: pointer;\n  -webkit-appearance: button;\n}\ninput[type=reset][disabled],\ninput[type=submit][disabled],\nhtml input[type=button][disabled],\nbutton[disabled] {\n  cursor: default;\n}\n\ntextarea {\n  vertical-align: top;\n  overflow: auto;\n}\n\ninput[type=search] {\n  -webkit-appearance: textfield;\n  box-sizing: content-box;\n  -webkit-box-sizing: content-box;\n}\ninput[type=search]::-webkit-search-decoration, input[type=search]::-webkit-search-cancel-button {\n  -webkit-appearance: none;\n}\ninput:-webkit-autofill {\n  text-shadow: none;\n}\n\n.md-visually-hidden {\n  border: 0;\n  clip: rect(0 0 0 0);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  text-transform: none;\n  width: 1px;\n}\n\n.md-shadow {\n  position: absolute;\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  border-radius: inherit;\n  pointer-events: none;\n}\n\n.md-shadow-bottom-z-1 {\n  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);\n}\n\n.md-shadow-bottom-z-2 {\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.4);\n}\n\n.md-shadow-animated.md-shadow {\n  transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);\n}\n\n/*\n * A container inside of a rippling element (eg a button),\n * which contains all of the individual ripples\n */\n.md-ripple-container {\n  pointer-events: none;\n  position: absolute;\n  overflow: hidden;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  transition: all 0.55s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n\n.md-ripple {\n  position: absolute;\n  transform: translate(-50%, -50%) scale(0);\n  transform-origin: 50% 50%;\n  opacity: 0;\n  border-radius: 50%;\n}\n.md-ripple.md-ripple-placed {\n  transition: margin 0.9s cubic-bezier(0.25, 0.8, 0.25, 1), border 0.9s cubic-bezier(0.25, 0.8, 0.25, 1), width 0.9s cubic-bezier(0.25, 0.8, 0.25, 1), height 0.9s cubic-bezier(0.25, 0.8, 0.25, 1), opacity 0.9s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.9s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n.md-ripple.md-ripple-scaled {\n  transform: translate(-50%, -50%) scale(1);\n}\n.md-ripple.md-ripple-active, .md-ripple.md-ripple-full, .md-ripple.md-ripple-visible {\n  opacity: 0.2;\n}\n.md-ripple.md-ripple-remove {\n  -webkit-animation: md-remove-ripple 0.9s cubic-bezier(0.25, 0.8, 0.25, 1);\n          animation: md-remove-ripple 0.9s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n\n@-webkit-keyframes md-remove-ripple {\n  0% {\n    opacity: 0.15;\n  }\n  100% {\n    opacity: 0;\n  }\n}\n\n@keyframes md-remove-ripple {\n  0% {\n    opacity: 0.15;\n  }\n  100% {\n    opacity: 0;\n  }\n}\n.md-padding {\n  padding: 8px;\n}\n\n.md-margin {\n  margin: 8px;\n}\n\n.md-scroll-mask {\n  position: absolute;\n  background-color: transparent;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 50;\n}\n.md-scroll-mask > .md-scroll-mask-bar {\n  display: block;\n  position: absolute;\n  background-color: #fafafa;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  z-index: 65;\n  box-shadow: inset 0 0 1px rgba(0, 0, 0, 0.3);\n}\n\n.md-no-momentum {\n  -webkit-overflow-scrolling: auto;\n}\n\n.md-no-flicker {\n  -webkit-filter: blur(0px);\n}\n\n@media (min-width: 960px) {\n  .md-padding {\n    padding: 16px;\n  }\n}\nhtml[dir=rtl], html[dir=ltr], body[dir=rtl], body[dir=ltr] {\n  unicode-bidi: embed;\n}\n\nbdo[dir=rtl] {\n  direction: rtl;\n  unicode-bidi: bidi-override;\n}\n\nbdo[dir=ltr] {\n  direction: ltr;\n  unicode-bidi: bidi-override;\n}\n\n@media (max-width: 599px) {\n  .layout-row:not(.layout-xs-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-xs-row > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 16px;\n  }\n  [dir=rtl] .layout-row:not(.layout-xs-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-xs-row > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 0;\n    margin-right: 16px;\n  }\n}\n@media (min-width: 600px) and (max-width: 959px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-sm-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-xs-row:not(.layout-sm-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-sm-row:not(.layout-sm-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 16px;\n  }\n  [dir=rtl] .layout-row:not(.layout-gt-xs-column):not(.layout-sm-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-xs-row:not(.layout-sm-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-sm-row:not(.layout-sm-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 0;\n    margin-right: 16px;\n  }\n}\n@media (min-width: 960px) and (max-width: 1279px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-sm-row:not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-md-row:not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 16px;\n  }\n  [dir=rtl] .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-sm-row:not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-md-row:not(.layout-md-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 0;\n    margin-right: 16px;\n  }\n}\n@media (min-width: 1280px) and (max-width: 1919px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-md-row:not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-lg-row:not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 16px;\n  }\n  [dir=rtl] .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-md-row:not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-lg-row:not(.layout-lg-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 0;\n    margin-right: 16px;\n  }\n}\n@media (min-width: 1920px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-md-row:not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-gt-lg-row:not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n.layout-xl-row:not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 16px;\n  }\n  [dir=rtl] .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-md-row:not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-gt-lg-row:not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child),\n[dir=rtl] .layout-xl-row:not(.layout-gt-lg-column):not(.layout-xl-column) > .md-auto-horizontal-margin:not(:first-child) {\n    margin-left: 0;\n    margin-right: 16px;\n  }\n}\nhtml, body {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  -webkit-touch-callout: default;\n  min-height: 100%;\n  -webkit-text-size-adjust: 100%;\n  -ms-text-size-adjust: 100%;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n/************\n * Headings\n ************/\n.md-display-4 {\n  font-size: 112px;\n  font-weight: 300;\n  letter-spacing: -0.01em;\n  line-height: 112px;\n}\n\n.md-display-3 {\n  font-size: 56px;\n  font-weight: 400;\n  letter-spacing: -0.005em;\n  line-height: 56px;\n}\n\n.md-display-2 {\n  font-size: 45px;\n  font-weight: 400;\n  line-height: 64px;\n}\n\n.md-display-1 {\n  font-size: 34px;\n  font-weight: 400;\n  line-height: 40px;\n}\n\n.md-headline {\n  font-size: 24px;\n  font-weight: 400;\n  line-height: 32px;\n}\n\n.md-title {\n  font-size: 20px;\n  font-weight: 500;\n  letter-spacing: 0.005em;\n}\n\n.md-subhead {\n  font-size: 16px;\n  font-weight: 400;\n  letter-spacing: 0.01em;\n  line-height: 24px;\n}\n\n/************\n * Body Copy\n ************/\n.md-body-1 {\n  font-size: 14px;\n  font-weight: 400;\n  letter-spacing: 0.01em;\n  line-height: 20px;\n}\n\n.md-body-2 {\n  font-size: 14px;\n  font-weight: 500;\n  letter-spacing: 0.01em;\n  line-height: 24px;\n}\n\n.md-caption {\n  font-size: 12px;\n  letter-spacing: 0.02em;\n}\n\n.md-button {\n  letter-spacing: 0.01em;\n}\n\n/************\n * Defaults\n ************/\nbutton,\nselect,\nhtml,\ntextarea,\ninput {\n  font-family: Roboto, "Helvetica Neue", sans-serif;\n}\n\nselect,\nbutton,\ntextarea,\ninput {\n  font-size: 100%;\n}\n\n/*\n*  Responsive attributes\n*\n*  References:\n*  1) https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties#flex\n*  2) https://css-tricks.com/almanac/properties/f/flex/\n*  3) https://css-tricks.com/snippets/css/a-guide-to-flexbox/\n*  4) https://github.com/philipwalton/flexbugs#3-min-height-on-a-flex-container-wont-apply-to-its-flex-items\n*  5) http://godban.com.ua/projects/flexgrid\n*/\n.md-panel-outer-wrapper {\n  height: 100%;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n\n.md-panel-inner-wrapper {\n  position: fixed;\n}\n\n._md-panel-offscreen {\n  left: -9999px;\n}\n\n._md-panel-hidden {\n  display: none;\n}\n\n._md-panel-shown .md-panel {\n  opacity: 1;\n  transition: none;\n}\n\n.md-panel {\n  opacity: 0;\n  position: relative;\n}\n.md-panel._md-panel-shown {\n  opacity: 1;\n  transition: none;\n}\n.md-panel._md-panel-animate-enter {\n  opacity: 1;\n  transition: all 0.3s cubic-bezier(0, 0, 0.2, 1);\n}\n.md-panel._md-panel-animate-leave {\n  opacity: 1;\n  transition: all 0.3s cubic-bezier(0.4, 0, 1, 1);\n}\n.md-panel._md-panel-animate-scale-out, .md-panel._md-panel-animate-fade-out {\n  opacity: 0;\n}\n.md-panel._md-panel-backdrop {\n  height: 100%;\n  position: fixed;\n  width: 100%;\n}\n.md-panel._md-opaque-enter {\n  opacity: 0.48;\n  transition: opacity 0.3s cubic-bezier(0, 0, 0.2, 1);\n}\n.md-panel._md-opaque-leave {\n  transition: opacity 0.3s cubic-bezier(0.4, 0, 1, 1);\n}\n\n._md-panel-fullscreen {\n  border-radius: 0;\n  left: 0;\n  min-height: 100%;\n  min-width: 100%;\n  position: fixed;\n  top: 0;\n}\n\nmd-autocomplete {\n  border-radius: 2px;\n  display: block;\n  height: 40px;\n  position: relative;\n  overflow: visible;\n  min-width: 190px;\n}\nmd-autocomplete[disabled] input {\n  cursor: default;\n}\nmd-autocomplete[md-floating-label] {\n  border-radius: 0;\n  background: transparent;\n  height: auto;\n}\nmd-autocomplete[md-floating-label] md-input-container {\n  padding-bottom: 0;\n}\nmd-autocomplete[md-floating-label] md-autocomplete-wrap {\n  height: auto;\n}\nmd-autocomplete[md-floating-label] .md-show-clear-button button {\n  display: block;\n  position: absolute;\n  right: 0;\n  top: 20px;\n  width: 30px;\n  height: 30px;\n}\nmd-autocomplete[md-floating-label] .md-show-clear-button input {\n  padding-right: 30px;\n}\n[dir=rtl] md-autocomplete[md-floating-label] .md-show-clear-button input {\n  padding-right: 0;\n  padding-left: 30px;\n}\nmd-autocomplete md-autocomplete-wrap {\n  display: flex;\n  flex-direction: row;\n  box-sizing: border-box;\n  position: relative;\n  overflow: visible;\n  height: 40px;\n}\nmd-autocomplete md-autocomplete-wrap.md-menu-showing {\n  z-index: 51;\n}\nmd-autocomplete md-autocomplete-wrap md-input-container,\nmd-autocomplete md-autocomplete-wrap input {\n  flex: 1 1 0;\n  box-sizing: border-box;\n  min-width: 0;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear {\n  position: absolute;\n  bottom: -2px;\n  left: 0;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear.md-inline {\n  bottom: 40px;\n  right: 2px;\n  left: 2px;\n  width: auto;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 3px;\n  transition: none;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate .md-container {\n  transition: none;\n  height: 3px;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-enter {\n  transition: opacity 0.15s linear;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-enter.ng-enter-active {\n  opacity: 1;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-leave {\n  transition: opacity 0.15s linear;\n}\nmd-autocomplete md-autocomplete-wrap md-progress-linear .md-mode-indeterminate.ng-leave.ng-leave-active {\n  opacity: 0;\n}\nmd-autocomplete input:not(.md-input) {\n  font-size: 14px;\n  box-sizing: border-box;\n  border: none;\n  box-shadow: none;\n  outline: none;\n  background: transparent;\n  width: 100%;\n  padding: 0 15px;\n  line-height: 40px;\n  height: 40px;\n}\nmd-autocomplete input:not(.md-input)::-ms-clear {\n  display: none;\n}\nmd-autocomplete .md-show-clear-button button {\n  position: relative;\n  line-height: 20px;\n  text-align: center;\n  width: 30px;\n  height: 30px;\n  cursor: pointer;\n  border: none;\n  border-radius: 50%;\n  padding: 0;\n  font-size: 12px;\n  background: transparent;\n  margin: auto 5px;\n}\nmd-autocomplete .md-show-clear-button button:after {\n  content: "";\n  position: absolute;\n  top: -6px;\n  right: -6px;\n  bottom: -6px;\n  left: -6px;\n  border-radius: 50%;\n  transform: scale(0);\n  opacity: 0;\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\nmd-autocomplete .md-show-clear-button button:focus {\n  outline: none;\n}\nmd-autocomplete .md-show-clear-button button:focus:after {\n  transform: scale(1);\n  opacity: 1;\n}\nmd-autocomplete .md-show-clear-button button md-icon {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate3d(-50%, -50%, 0) scale(0.9);\n}\nmd-autocomplete .md-show-clear-button button md-icon path {\n  stroke-width: 0;\n}\nmd-autocomplete .md-show-clear-button button.ng-enter {\n  transform: scale(0);\n  transition: transform 0.15s ease-out;\n}\nmd-autocomplete .md-show-clear-button button.ng-enter.ng-enter-active {\n  transform: scale(1);\n}\nmd-autocomplete .md-show-clear-button button.ng-leave {\n  transition: transform 0.15s ease-out;\n}\nmd-autocomplete .md-show-clear-button button.ng-leave.ng-leave-active {\n  transform: scale(0);\n}\n@media screen and (-ms-high-contrast: active) {\n  md-autocomplete input {\n    border: 1px solid #fff;\n  }\n  md-autocomplete .md-autocomplete-suggestion:focus {\n    color: #fff;\n  }\n}\n\n.md-virtual-repeat-container.md-autocomplete-suggestions-container,\n.md-standard-list-container.md-autocomplete-suggestions-container {\n  position: absolute;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.25);\n  z-index: 100;\n  height: 100%;\n}\n.md-virtual-repeat-container.md-autocomplete-suggestions-container .highlight,\n.md-standard-list-container.md-autocomplete-suggestions-container .highlight {\n  font-weight: bold;\n}\n\n.md-standard-list-container {\n  box-sizing: border-box;\n  display: block;\n  margin: 0;\n  overflow: hidden;\n  overflow-y: auto;\n  padding: 0;\n}\n\n.md-virtual-repeat-container.md-not-found,\n.md-standard-list-container.md-not-found {\n  height: 48px;\n}\n\n.md-autocomplete-suggestions {\n  margin: 0;\n  list-style: none;\n  padding: 0;\n}\n.md-autocomplete-suggestions .md-autocomplete-suggestion {\n  font-size: 14px;\n  overflow: hidden;\n  padding: 0 15px;\n  line-height: 48px;\n  height: 48px;\n  transition: background 0.15s linear;\n  margin: 0;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.md-autocomplete-suggestions .md-autocomplete-suggestion:focus {\n  outline: none;\n}\n.md-autocomplete-suggestions .md-autocomplete-suggestion:not(.md-not-found-wrapper) {\n  cursor: pointer;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-autocomplete,\n.md-autocomplete-suggestions {\n    border: 1px solid #fff;\n  }\n}\nmd-backdrop {\n  transition: opacity 450ms;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 50;\n}\nmd-backdrop.md-menu-backdrop {\n  position: fixed !important;\n  z-index: 99;\n}\nmd-backdrop.md-select-backdrop {\n  z-index: 81;\n  transition-duration: 0;\n}\nmd-backdrop.md-dialog-backdrop {\n  z-index: 79;\n}\nmd-backdrop.md-bottom-sheet-backdrop {\n  z-index: 69;\n}\nmd-backdrop.md-sidenav-backdrop {\n  z-index: 59;\n}\nmd-backdrop.md-click-catcher {\n  position: absolute;\n}\nmd-backdrop.md-opaque {\n  opacity: 0.48;\n}\nmd-backdrop.md-opaque.ng-enter {\n  opacity: 0;\n}\nmd-backdrop.md-opaque.ng-enter.md-opaque.ng-enter-active {\n  opacity: 0.48;\n}\nmd-backdrop.md-opaque.ng-leave {\n  opacity: 0.48;\n  transition: opacity 400ms;\n}\nmd-backdrop.md-opaque.ng-leave.md-opaque.ng-leave-active {\n  opacity: 0;\n}\n\nmd-bottom-sheet {\n  position: absolute;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  padding: 8px 16px 88px 16px;\n  z-index: 70;\n  border-top-width: 1px;\n  border-top-style: solid;\n  transform: translate3d(0, 80px, 0);\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-property: transform;\n}\nmd-bottom-sheet.md-has-header {\n  padding-top: 0;\n}\nmd-bottom-sheet.ng-enter {\n  opacity: 0;\n  transform: translate3d(0, 100%, 0);\n}\nmd-bottom-sheet.ng-enter-active {\n  opacity: 1;\n  display: block;\n  transform: translate3d(0, 80px, 0) !important;\n}\nmd-bottom-sheet.ng-leave-active {\n  transform: translate3d(0, 100%, 0) !important;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n}\nmd-bottom-sheet .md-subheader {\n  background-color: transparent;\n  font-family: Roboto, "Helvetica Neue", sans-serif;\n  line-height: 56px;\n  padding: 0;\n  white-space: nowrap;\n}\nmd-bottom-sheet md-inline-icon {\n  display: inline-block;\n  height: 24px;\n  width: 24px;\n  fill: #444;\n}\nmd-bottom-sheet md-list-item {\n  display: flex;\n  outline: none;\n}\nmd-bottom-sheet md-list-item:hover {\n  cursor: pointer;\n}\nmd-bottom-sheet.md-list md-list-item {\n  padding: 0;\n  align-items: center;\n  height: 48px;\n}\nmd-bottom-sheet.md-grid {\n  padding-left: 24px;\n  padding-right: 24px;\n  padding-top: 0;\n}\nmd-bottom-sheet.md-grid md-list {\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  transition: all 0.5s;\n  align-items: center;\n}\nmd-bottom-sheet.md-grid md-list-item {\n  flex-direction: column;\n  align-items: center;\n  transition: all 0.5s;\n  height: 96px;\n  margin-top: 8px;\n  margin-bottom: 8px;\n  /* Mixin for how many grid items to show per row */\n}\n@media (max-width: 960px) {\n  md-bottom-sheet.md-grid md-list-item {\n    flex: 1 1 33.3333333333%;\n    max-width: 33.3333333333%;\n  }\n  md-bottom-sheet.md-grid md-list-item:nth-of-type(3n + 1) {\n    align-items: flex-start;\n  }\n  md-bottom-sheet.md-grid md-list-item:nth-of-type(3n) {\n    align-items: flex-end;\n  }\n}\n@media (min-width: 960px) and (max-width: 1279px) {\n  md-bottom-sheet.md-grid md-list-item {\n    flex: 1 1 25%;\n    max-width: 25%;\n  }\n}\n@media (min-width: 1280px) and (max-width: 1919px) {\n  md-bottom-sheet.md-grid md-list-item {\n    flex: 1 1 16.6666666667%;\n    max-width: 16.6666666667%;\n  }\n}\n@media (min-width: 1920px) {\n  md-bottom-sheet.md-grid md-list-item {\n    flex: 1 1 14.2857142857%;\n    max-width: 14.2857142857%;\n  }\n}\nmd-bottom-sheet.md-grid md-list-item::before {\n  display: none;\n}\nmd-bottom-sheet.md-grid md-list-item .md-list-item-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 48px;\n  padding-bottom: 16px;\n}\nmd-bottom-sheet.md-grid md-list-item .md-grid-item-content {\n  border: 1px solid transparent;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 80px;\n}\nmd-bottom-sheet.md-grid md-list-item .md-grid-text {\n  font-weight: 400;\n  line-height: 16px;\n  font-size: 13px;\n  margin: 0;\n  white-space: nowrap;\n  width: 64px;\n  text-align: center;\n  text-transform: none;\n  padding-top: 8px;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-bottom-sheet {\n    border: 1px solid #fff;\n  }\n}\nbutton.md-button::-moz-focus-inner {\n  border: 0;\n}\n\n.md-button {\n  display: inline-block;\n  position: relative;\n  cursor: pointer;\n  /** Alignment adjustments */\n  min-height: 36px;\n  min-width: 88px;\n  line-height: 36px;\n  vertical-align: middle;\n  align-items: center;\n  text-align: center;\n  border-radius: 2px;\n  box-sizing: border-box;\n  /* Reset default button appearance */\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  outline: none;\n  border: 0;\n  /** Custom styling for button */\n  padding: 0 8px;\n  margin: 6px 8px;\n  background: transparent;\n  color: currentColor;\n  white-space: nowrap;\n  /* Uppercase text content */\n  text-transform: uppercase;\n  font-weight: 500;\n  font-size: 14px;\n  font-style: inherit;\n  font-variant: inherit;\n  font-family: inherit;\n  text-decoration: none;\n  overflow: hidden;\n  transition: box-shadow 0.4s cubic-bezier(0.25, 0.8, 0.25, 1), background-color 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n.md-dense > .md-button:not(.md-dense-disabled), .md-dense :not(.md-dense-disabled) .md-button:not(.md-dense-disabled) {\n  min-height: 32px;\n}\n.md-dense > .md-button:not(.md-dense-disabled), .md-dense :not(.md-dense-disabled) .md-button:not(.md-dense-disabled) {\n  line-height: 32px;\n}\n.md-dense > .md-button:not(.md-dense-disabled), .md-dense :not(.md-dense-disabled) .md-button:not(.md-dense-disabled) {\n  font-size: 13px;\n}\n.md-button:focus {\n  outline: none;\n}\n.md-button:hover, .md-button:focus {\n  text-decoration: none;\n}\n.md-button.ng-hide, .md-button.ng-leave {\n  transition: none;\n}\n.md-button.md-cornered {\n  border-radius: 0;\n}\n.md-button.md-icon {\n  padding: 0;\n  background: none;\n}\n.md-button.md-raised:not([disabled]) {\n  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);\n}\n.md-button.md-icon-button {\n  margin: 0 6px;\n  height: 40px;\n  min-width: 0;\n  line-height: 24px;\n  padding: 8px;\n  width: 40px;\n  border-radius: 50%;\n}\n.md-button.md-fab {\n  z-index: 20;\n  line-height: 56px;\n  min-width: 0;\n  width: 56px;\n  height: 56px;\n  vertical-align: middle;\n  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);\n  border-radius: 50%;\n  background-clip: padding-box;\n  overflow: hidden;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-property: background-color, box-shadow, transform;\n}\n.md-button.md-fab.md-fab-bottom-right {\n  top: auto;\n  right: 20px;\n  bottom: 20px;\n  left: auto;\n  position: absolute;\n}\n.md-button.md-fab.md-fab-bottom-left {\n  top: auto;\n  right: auto;\n  bottom: 20px;\n  left: 20px;\n  position: absolute;\n}\n.md-button.md-fab.md-fab-top-right {\n  top: 20px;\n  right: 20px;\n  bottom: auto;\n  left: auto;\n  position: absolute;\n}\n.md-button.md-fab.md-fab-top-left {\n  top: 20px;\n  right: auto;\n  bottom: auto;\n  left: 20px;\n  position: absolute;\n}\n.md-button.md-fab.md-mini {\n  line-height: 40px;\n  width: 40px;\n  height: 40px;\n}\n.md-button.md-fab.ng-hide, .md-button.md-fab.ng-leave {\n  transition: none;\n}\n.md-button.md-fab[disabled] {\n  box-shadow: none;\n}\n.md-button:not([disabled]).md-raised.md-focused, .md-button:not([disabled]).md-fab.md-focused {\n  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);\n}\n.md-button:not([disabled]).md-raised:active, .md-button:not([disabled]).md-fab:active {\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.4);\n}\n.md-button .md-ripple-container {\n  border-radius: inherit;\n  background-clip: padding-box;\n  overflow: hidden;\n  -webkit-transform: translateZ(0);\n}\n\n.md-button.md-icon-button md-icon,\nbutton.md-button.md-fab md-icon {\n  display: block;\n}\n\n.md-toast-open-top .md-button.md-fab-top-left,\n.md-toast-open-top .md-button.md-fab-top-right {\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transform: translate3d(0, 42px, 0);\n}\n.md-toast-open-top .md-button.md-fab-top-left:not([disabled]).md-focused, .md-toast-open-top .md-button.md-fab-top-left:not([disabled]):hover,\n.md-toast-open-top .md-button.md-fab-top-right:not([disabled]).md-focused,\n.md-toast-open-top .md-button.md-fab-top-right:not([disabled]):hover {\n  transform: translate3d(0, 41px, 0);\n}\n\n.md-toast-open-bottom .md-button.md-fab-bottom-left,\n.md-toast-open-bottom .md-button.md-fab-bottom-right {\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transform: translate3d(0, -42px, 0);\n}\n.md-toast-open-bottom .md-button.md-fab-bottom-left:not([disabled]).md-focused, .md-toast-open-bottom .md-button.md-fab-bottom-left:not([disabled]):hover,\n.md-toast-open-bottom .md-button.md-fab-bottom-right:not([disabled]).md-focused,\n.md-toast-open-bottom .md-button.md-fab-bottom-right:not([disabled]):hover {\n  transform: translate3d(0, -43px, 0);\n}\n\n.md-button-group {\n  display: flex;\n  flex: 1;\n  width: 100%;\n}\n.md-button-group > .md-button {\n  flex: 1;\n  display: block;\n  overflow: hidden;\n  width: 0;\n  border-width: 1px 0px 1px 1px;\n  border-radius: 0;\n  text-align: center;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n.md-button-group > .md-button:first-child {\n  border-radius: 2px 0px 0px 2px;\n}\n.md-button-group > .md-button:last-child {\n  border-right-width: 1px;\n  border-radius: 0px 2px 2px 0px;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  .md-button.md-raised,\n.md-button.md-fab {\n    border: 1px solid #fff;\n  }\n}\nmd-card {\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  margin: 8px;\n  box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 2px 1px -1px rgba(0, 0, 0, 0.12);\n}\nmd-card md-card-header {\n  padding: 16px;\n  display: flex;\n  flex-direction: row;\n}\nmd-card md-card-header:first-child md-card-avatar {\n  margin-right: 12px;\n}\n[dir=rtl] md-card md-card-header:first-child md-card-avatar {\n  margin-right: auto;\n  margin-left: 12px;\n}\nmd-card md-card-header:last-child md-card-avatar {\n  margin-left: 12px;\n}\n[dir=rtl] md-card md-card-header:last-child md-card-avatar {\n  margin-left: auto;\n  margin-right: 12px;\n}\nmd-card md-card-header md-card-avatar {\n  width: 40px;\n  height: 40px;\n}\nmd-card md-card-header md-card-avatar .md-user-avatar,\nmd-card md-card-header md-card-avatar md-icon {\n  border-radius: 50%;\n}\nmd-card md-card-header md-card-avatar md-icon {\n  padding: 8px;\n}\nmd-card md-card-header md-card-avatar md-icon > svg {\n  height: inherit;\n  width: inherit;\n}\nmd-card md-card-header md-card-avatar + md-card-header-text {\n  max-height: 40px;\n}\nmd-card md-card-header md-card-avatar + md-card-header-text .md-title {\n  font-size: 14px;\n}\nmd-card md-card-header md-card-header-text {\n  display: flex;\n  flex: 1;\n  flex-direction: column;\n}\nmd-card md-card-header md-card-header-text .md-subhead {\n  font-size: 14px;\n}\nmd-card > img,\nmd-card > md-card-header img,\nmd-card md-card-title-media img {\n  box-sizing: border-box;\n  display: flex;\n  flex: 0 0 auto;\n  width: 100%;\n  height: auto;\n}\nmd-card md-card-title {\n  padding: 24px 16px 16px;\n  display: flex;\n  flex: 1 1 auto;\n  flex-direction: row;\n}\nmd-card md-card-title + md-card-content {\n  padding-top: 0;\n}\nmd-card md-card-title md-card-title-text {\n  flex: 1;\n  flex-direction: column;\n  display: flex;\n}\nmd-card md-card-title md-card-title-text .md-subhead {\n  padding-top: 0;\n  font-size: 14px;\n}\nmd-card md-card-title md-card-title-text:only-child .md-subhead {\n  padding-top: 12px;\n}\nmd-card md-card-title md-card-title-media {\n  margin-top: -8px;\n}\nmd-card md-card-title md-card-title-media .md-media-sm {\n  height: 80px;\n  width: 80px;\n}\nmd-card md-card-title md-card-title-media .md-media-md {\n  height: 112px;\n  width: 112px;\n}\nmd-card md-card-title md-card-title-media .md-media-lg {\n  height: 152px;\n  width: 152px;\n}\nmd-card md-card-content {\n  display: block;\n  padding: 16px;\n}\nmd-card md-card-content > p:first-child {\n  margin-top: 0;\n}\nmd-card md-card-content > p:last-child {\n  margin-bottom: 0;\n}\nmd-card md-card-content .md-media-xl {\n  height: 240px;\n  width: 240px;\n}\nmd-card md-card-actions {\n  margin: 8px;\n}\nmd-card md-card-actions.layout-column .md-button:not(.md-icon-button) {\n  margin: 2px 0;\n}\nmd-card md-card-actions.layout-column .md-button:not(.md-icon-button):first-of-type {\n  margin-top: 0;\n}\nmd-card md-card-actions.layout-column .md-button:not(.md-icon-button):last-of-type {\n  margin-bottom: 0;\n}\nmd-card md-card-actions.layout-column .md-button.md-icon-button {\n  margin-top: 6px;\n  margin-bottom: 6px;\n}\nmd-card md-card-actions md-card-icon-actions {\n  flex: 1;\n  justify-content: flex-start;\n  display: flex;\n  flex-direction: row;\n}\nmd-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button) {\n  margin: 0 4px;\n}\nmd-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button):first-of-type {\n  margin-left: 0;\n}\n[dir=rtl] md-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button):first-of-type {\n  margin-left: auto;\n  margin-right: 0;\n}\nmd-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button):last-of-type {\n  margin-right: 0;\n}\n[dir=rtl] md-card md-card-actions:not(.layout-column) .md-button:not(.md-icon-button):last-of-type {\n  margin-right: auto;\n  margin-left: 0;\n}\nmd-card md-card-actions:not(.layout-column) .md-button.md-icon-button {\n  margin-left: 6px;\n  margin-right: 6px;\n}\nmd-card md-card-actions:not(.layout-column) .md-button.md-icon-button:first-of-type {\n  margin-left: 12px;\n}\n[dir=rtl] md-card md-card-actions:not(.layout-column) .md-button.md-icon-button:first-of-type {\n  margin-left: auto;\n  margin-right: 12px;\n}\nmd-card md-card-actions:not(.layout-column) .md-button.md-icon-button:last-of-type {\n  margin-right: 12px;\n}\n[dir=rtl] md-card md-card-actions:not(.layout-column) .md-button.md-icon-button:last-of-type {\n  margin-right: auto;\n  margin-left: 12px;\n}\nmd-card md-card-actions:not(.layout-column) .md-button + md-card-icon-actions {\n  flex: 1;\n  justify-content: flex-end;\n  display: flex;\n  flex-direction: row;\n}\nmd-card md-card-footer {\n  margin-top: auto;\n  padding: 16px;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-card {\n    border: 1px solid #fff;\n  }\n}\n.md-image-no-fill > img {\n  width: auto;\n  height: auto;\n}\n\n.md-inline-form md-checkbox {\n  margin-top: 14px;\n  margin-bottom: auto;\n}\n\nmd-checkbox {\n  box-sizing: border-box;\n  display: inline-block;\n  white-space: nowrap;\n  cursor: pointer;\n  outline: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  position: relative;\n  min-width: 18px;\n  min-height: 48px;\n}\n.md-dense > md-checkbox:not(.md-dense-disabled), .md-dense :not(.md-dense-disabled) md-checkbox:not(.md-dense-disabled) {\n  min-height: 36px;\n}\nmd-checkbox.md-focused:not([disabled]) .md-container:before {\n  left: -8px;\n  top: -8px;\n  right: -8px;\n  bottom: -8px;\n}\nmd-checkbox.md-focused:not([disabled]):not(.md-checked) .md-container:before {\n  background-color: rgba(0, 0, 0, 0.12);\n}\nmd-checkbox .md-container {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  box-sizing: border-box;\n  display: inline-block;\n  width: 18px;\n  height: 18px;\n  left: 0;\n  right: auto;\n}\n[dir=rtl] md-checkbox .md-container {\n  left: auto;\n}\n[dir=rtl] md-checkbox .md-container {\n  right: 0;\n}\nmd-checkbox .md-container:before {\n  box-sizing: border-box;\n  background-color: transparent;\n  border-radius: 50%;\n  content: "";\n  position: absolute;\n  display: block;\n  height: auto;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  transition: all 0.5s;\n  width: auto;\n}\nmd-checkbox .md-container:after {\n  box-sizing: border-box;\n  content: "";\n  position: absolute;\n  top: -10px;\n  right: -10px;\n  bottom: -10px;\n  left: -10px;\n}\nmd-checkbox .md-container .md-ripple-container {\n  position: absolute;\n  display: block;\n  width: auto;\n  height: auto;\n  left: -15px;\n  top: -15px;\n  right: -15px;\n  bottom: -15px;\n}\nmd-checkbox .md-icon {\n  box-sizing: border-box;\n  transition: 240ms;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 18px;\n  height: 18px;\n  border-width: 2px;\n  border-style: solid;\n  border-radius: 2px;\n}\nmd-checkbox.md-checked .md-icon {\n  border-color: transparent;\n}\nmd-checkbox.md-checked .md-icon:after {\n  box-sizing: border-box;\n  transform: rotate(45deg);\n  position: absolute;\n  left: 4px;\n  top: 0px;\n  display: table;\n  width: 6px;\n  height: 12px;\n  border-width: 2px;\n  border-style: solid;\n  border-top: 0;\n  border-left: 0;\n  content: "";\n}\nmd-checkbox[disabled] {\n  cursor: default;\n}\nmd-checkbox.md-indeterminate .md-icon:after {\n  box-sizing: border-box;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  display: table;\n  width: 10.8px;\n  height: 2px;\n  border-width: 2px;\n  border-style: solid;\n  border-top: 0;\n  border-left: 0;\n  content: "";\n}\nmd-checkbox .md-container {\n  top: auto;\n  left: auto;\n  right: auto;\n  margin: 3px;\n  margin-top: 21px;\n}\nmd-checkbox .md-label {\n  box-sizing: border-box;\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  white-space: normal;\n  -webkit-user-select: text;\n     -moz-user-select: text;\n      -ms-user-select: text;\n          user-select: text;\n  margin-top: 10px;\n  margin-bottom: auto;\n  margin-left: 36px;\n}\n[dir=rtl] md-checkbox .md-label {\n  margin-left: 0;\n  margin-right: 36px;\n}\nmd-checkbox .md-label:empty {\n  margin-left: 24px;\n  margin-right: 0;\n}\n[dir=rtl] md-checkbox .md-label:empty {\n  margin-left: 0;\n}\n[dir=rtl] md-checkbox .md-label:empty {\n  margin-right: 24px;\n}\n\nmd-input-container .md-checkbox-link-label {\n  box-sizing: border-box;\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  white-space: normal;\n  -webkit-user-select: text;\n     -moz-user-select: text;\n      -ms-user-select: text;\n          user-select: text;\n  cursor: pointer;\n  top: -21px;\n  margin-left: 18px;\n  margin-right: 0;\n}\n[dir=rtl] md-input-container .md-checkbox-link-label {\n  margin-left: 0;\n}\n[dir=rtl] md-input-container .md-checkbox-link-label {\n  margin-right: 18px;\n}\n\n.md-contact-chips .md-chips md-chip {\n  padding: 0 25px 0 0;\n}\n[dir=rtl] .md-contact-chips .md-chips md-chip {\n  padding: 0 0 0 25px;\n}\n.md-contact-chips .md-chips md-chip .md-contact-avatar {\n  float: left;\n}\n[dir=rtl] .md-contact-chips .md-chips md-chip .md-contact-avatar {\n  float: right;\n}\n.md-contact-chips .md-chips md-chip .md-contact-avatar img {\n  height: 32px;\n  border-radius: 16px;\n}\n.md-contact-chips .md-chips md-chip .md-contact-name {\n  display: inline-block;\n  height: 32px;\n  margin-left: 8px;\n}\n[dir=rtl] .md-contact-chips .md-chips md-chip .md-contact-name {\n  margin-left: auto;\n  margin-right: 8px;\n}\n\n.md-contact-suggestion {\n  height: 56px;\n}\n.md-contact-suggestion img {\n  height: 40px;\n  border-radius: 20px;\n  margin-top: 8px;\n}\n.md-contact-suggestion .md-contact-name {\n  margin-left: 8px;\n  width: 120px;\n}\n[dir=rtl] .md-contact-suggestion .md-contact-name {\n  margin-left: auto;\n  margin-right: 8px;\n}\n.md-contact-suggestion .md-contact-name, .md-contact-suggestion .md-contact-email {\n  display: inline-block;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.md-contact-chips-suggestions li {\n  height: 100%;\n}\n\nmd-chips {\n  display: flex;\n}\n\n.md-chips {\n  display: flex;\n  flex-wrap: wrap;\n  flex-grow: 1;\n  font-family: Roboto, "Helvetica Neue", sans-serif;\n  font-size: 13px;\n  padding: 0 0 8px 3px;\n  vertical-align: middle;\n}\n.md-chips:after {\n  content: "";\n  display: table;\n  clear: both;\n}\n[dir=rtl] .md-chips {\n  padding: 0 3px 8px 0;\n}\n.md-chips.md-readonly .md-chip-input-container {\n  min-height: 32px;\n}\n.md-chips:not(.md-readonly) {\n  cursor: text;\n}\n.md-chips.md-removable md-chip {\n  padding-right: 28px;\n}\n[dir=rtl] .md-chips.md-removable md-chip {\n  padding-right: 0;\n  padding-left: 28px;\n}\n.md-chips.md-removable md-chip .md-chip-content {\n  padding-right: 4px;\n}\n[dir=rtl] .md-chips.md-removable md-chip .md-chip-content {\n  padding-right: 0;\n  padding-left: 4px;\n}\n.md-chips md-chip {\n  cursor: default;\n  border-radius: 16px;\n  display: block;\n  height: 32px;\n  line-height: 32px;\n  margin: 8px 8px 0 0;\n  padding: 0 12px 0 12px;\n  float: left;\n  box-sizing: border-box;\n  max-width: 100%;\n  position: relative;\n}\n[dir=rtl] .md-chips md-chip {\n  margin: 8px 0 0 8px;\n}\n[dir=rtl] .md-chips md-chip {\n  float: right;\n}\n.md-chips md-chip .md-chip-content {\n  display: block;\n  float: left;\n  white-space: nowrap;\n  max-width: 100%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n[dir=rtl] .md-chips md-chip .md-chip-content {\n  float: right;\n}\n.md-chips md-chip .md-chip-content:focus {\n  outline: none;\n}\n.md-chips md-chip._md-chip-content-edit-is-enabled {\n  -webkit-user-select: none;\n  /* webkit (safari, chrome) browsers */\n  -moz-user-select: none;\n  /* mozilla browsers */\n  -khtml-user-select: none;\n  /* webkit (konqueror) browsers */\n  -ms-user-select: none;\n  /* IE10+ */\n}\n.md-chips md-chip .md-chip-remove-container {\n  position: absolute;\n  right: 0;\n  line-height: 22px;\n}\n[dir=rtl] .md-chips md-chip .md-chip-remove-container {\n  right: auto;\n  left: 0;\n}\n.md-chips md-chip .md-chip-remove {\n  text-align: center;\n  width: 32px;\n  height: 32px;\n  min-width: 0;\n  padding: 0;\n  background: transparent;\n  border: none;\n  box-shadow: none;\n  margin: 0;\n  position: relative;\n}\n.md-chips md-chip .md-chip-remove md-icon {\n  height: 18px;\n  width: 18px;\n  min-height: 18px;\n  min-width: 18px;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate3d(-50%, -50%, 0);\n}\n.md-chips .md-chip-input-container {\n  display: block;\n  line-height: 32px;\n  margin: 8px 8px 0 0;\n  padding: 0;\n  flex-grow: 1;\n  float: left;\n}\n[dir=rtl] .md-chips .md-chip-input-container {\n  margin: 8px 0 0 8px;\n}\n[dir=rtl] .md-chips .md-chip-input-container {\n  float: right;\n}\n.md-chips .md-chip-input-container input {\n  width: 100%;\n}\n.md-chips .md-chip-input-container input:not([type]), .md-chips .md-chip-input-container input[type=email], .md-chips .md-chip-input-container input[type=number], .md-chips .md-chip-input-container input[type=tel], .md-chips .md-chip-input-container input[type=url], .md-chips .md-chip-input-container input[type=text] {\n  border: 0;\n  height: 32px;\n  line-height: 32px;\n  padding: 0;\n}\n.md-chips .md-chip-input-container input:not([type]):focus, .md-chips .md-chip-input-container input[type=email]:focus, .md-chips .md-chip-input-container input[type=number]:focus, .md-chips .md-chip-input-container input[type=tel]:focus, .md-chips .md-chip-input-container input[type=url]:focus, .md-chips .md-chip-input-container input[type=text]:focus {\n  outline: none;\n}\n.md-chips .md-chip-input-container md-autocomplete, .md-chips .md-chip-input-container md-autocomplete-wrap {\n  background: transparent;\n  height: 32px;\n}\n.md-chips .md-chip-input-container md-autocomplete md-autocomplete-wrap {\n  box-shadow: none;\n}\n.md-chips .md-chip-input-container md-autocomplete input {\n  position: relative;\n}\n.md-chips .md-chip-input-container input {\n  border: 0;\n  height: 32px;\n  line-height: 32px;\n  padding: 0;\n}\n.md-chips .md-chip-input-container input:focus {\n  outline: none;\n}\n.md-chips .md-chip-input-container md-autocomplete, .md-chips .md-chip-input-container md-autocomplete-wrap {\n  height: 32px;\n}\n.md-chips .md-chip-input-container md-autocomplete {\n  box-shadow: none;\n}\n.md-chips .md-chip-input-container md-autocomplete input {\n  position: relative;\n}\n.md-chips .md-chip-input-container:not(:first-child) {\n  margin: 8px 8px 0 0;\n}\n[dir=rtl] .md-chips .md-chip-input-container:not(:first-child) {\n  margin: 8px 0 0 8px;\n}\n.md-chips .md-chip-input-container input {\n  background: transparent;\n  border-width: 0;\n}\n.md-chips md-autocomplete button {\n  display: none;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  .md-chip-input-container,\nmd-chip {\n    border: 1px solid #fff;\n  }\n\n  .md-chip-input-container md-autocomplete {\n    border: none;\n  }\n}\nmd-content {\n  display: block;\n  position: relative;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\nmd-content[md-scroll-y] {\n  overflow-y: auto;\n  overflow-x: hidden;\n}\nmd-content[md-scroll-x] {\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n@media print {\n  md-content {\n    overflow: visible !important;\n  }\n}\n\n/** Styles for mdCalendar. */\nmd-calendar {\n  font-size: 13px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n\n.md-calendar-scroll-mask {\n  display: inline-block;\n  overflow: hidden;\n  height: 308px;\n}\n.md-calendar-scroll-mask .md-virtual-repeat-scroller {\n  overflow-y: scroll;\n  -webkit-overflow-scrolling: touch;\n}\n.md-calendar-scroll-mask .md-virtual-repeat-scroller::-webkit-scrollbar {\n  display: none;\n}\n.md-calendar-scroll-mask .md-virtual-repeat-offsetter {\n  width: 100%;\n}\n\n.md-calendar-scroll-container {\n  box-shadow: inset -3px 3px 6px rgba(0, 0, 0, 0.2);\n  display: inline-block;\n  height: 308px;\n  width: 346px;\n}\n\n.md-calendar-date {\n  height: 44px;\n  width: 44px;\n  text-align: center;\n  padding: 0;\n  border: none;\n  box-sizing: content-box;\n}\n.md-calendar-date:first-child {\n  padding-left: 16px;\n}\n[dir=rtl] .md-calendar-date:first-child {\n  padding-left: 0;\n  padding-right: 16px;\n}\n.md-calendar-date:last-child {\n  padding-right: 16px;\n}\n[dir=rtl] .md-calendar-date:last-child {\n  padding-right: 0;\n  padding-left: 16px;\n}\n.md-calendar-date.md-calendar-date-disabled {\n  cursor: default;\n}\n\n.md-calendar-date-selection-indicator {\n  transition: background-color, color 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  border-radius: 50%;\n  display: inline-block;\n  width: 40px;\n  height: 40px;\n  line-height: 40px;\n}\n.md-calendar-date:not(.md-disabled) .md-calendar-date-selection-indicator {\n  cursor: pointer;\n}\n\n.md-calendar-month-label {\n  height: 44px;\n  font-size: 14px;\n  font-weight: 500;\n  padding: 0 0 0 24px;\n}\n[dir=rtl] .md-calendar-month-label {\n  padding: 0 24px 0 0;\n}\n.md-calendar-month-label.md-calendar-label-clickable {\n  cursor: pointer;\n}\n.md-calendar-month-label md-icon {\n  transform: rotate(180deg);\n}\n[dir=rtl] .md-calendar-month-label md-icon {\n  transform: none;\n}\n.md-calendar-month-label span {\n  vertical-align: middle;\n}\n\n.md-calendar-day-header {\n  table-layout: fixed;\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n.md-calendar-day-header th {\n  height: 40px;\n  width: 44px;\n  text-align: center;\n  padding: 0;\n  border: none;\n  box-sizing: content-box;\n  font-weight: normal;\n}\n.md-calendar-day-header th:first-child {\n  padding-left: 16px;\n}\n[dir=rtl] .md-calendar-day-header th:first-child {\n  padding-left: 0;\n  padding-right: 16px;\n}\n.md-calendar-day-header th:last-child {\n  padding-right: 16px;\n}\n[dir=rtl] .md-calendar-day-header th:last-child {\n  padding-right: 0;\n  padding-left: 16px;\n}\n\n.md-calendar {\n  table-layout: fixed;\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n.md-calendar tr:last-child td {\n  border-bottom-width: 1px;\n  border-bottom-style: solid;\n}\n.md-calendar:first-child {\n  border-top: 1px solid transparent;\n}\n.md-calendar tbody, .md-calendar td, .md-calendar tr {\n  vertical-align: middle;\n  box-sizing: content-box;\n}\n\n/** Styles for mdDatepicker. */\nmd-datepicker {\n  white-space: nowrap;\n  overflow: hidden;\n  vertical-align: middle;\n}\n\n.md-inline-form md-datepicker {\n  margin-top: 12px;\n}\n\n.md-datepicker-button {\n  display: inline-block;\n  box-sizing: border-box;\n  background: none;\n  vertical-align: middle;\n  position: relative;\n}\n.md-datepicker-button:before {\n  top: 0;\n  left: 0;\n  bottom: 0;\n  right: 0;\n  position: absolute;\n  content: "";\n  speak: none;\n}\n\n.md-datepicker-input {\n  font-size: 14px;\n  box-sizing: border-box;\n  border: none;\n  box-shadow: none;\n  outline: none;\n  background: transparent;\n  min-width: 120px;\n  max-width: 328px;\n  padding: 0 0 5px;\n}\n.md-datepicker-input::-ms-clear {\n  display: none;\n}\n\n._md-datepicker-floating-label > md-datepicker {\n  overflow: visible;\n}\n._md-datepicker-floating-label > md-datepicker .md-datepicker-input-container {\n  border: none;\n}\n._md-datepicker-floating-label > md-datepicker .md-datepicker-button {\n  float: left;\n  margin-top: -16px;\n  top: 13.5px;\n}\n[dir=rtl] ._md-datepicker-floating-label > md-datepicker .md-datepicker-button {\n  float: right;\n}\n._md-datepicker-floating-label .md-input {\n  float: none;\n}\n._md-datepicker-floating-label._md-datepicker-has-calendar-icon > label:not(.md-no-float):not(.md-container-ignore) {\n  right: 18px;\n  left: auto;\n  width: calc(100% - 84px);\n}\n[dir=rtl] ._md-datepicker-floating-label._md-datepicker-has-calendar-icon > label:not(.md-no-float):not(.md-container-ignore) {\n  right: auto;\n}\n[dir=rtl] ._md-datepicker-floating-label._md-datepicker-has-calendar-icon > label:not(.md-no-float):not(.md-container-ignore) {\n  left: 18px;\n}\n._md-datepicker-floating-label._md-datepicker-has-calendar-icon .md-input-message-animation {\n  margin-left: 64px;\n}\n[dir=rtl] ._md-datepicker-floating-label._md-datepicker-has-calendar-icon .md-input-message-animation {\n  margin-left: auto;\n  margin-right: 64px;\n}\n\n._md-datepicker-has-triangle-icon {\n  padding-right: 18px;\n  margin-right: -18px;\n}\n[dir=rtl] ._md-datepicker-has-triangle-icon {\n  padding-right: 0;\n  padding-left: 18px;\n}\n[dir=rtl] ._md-datepicker-has-triangle-icon {\n  margin-right: auto;\n  margin-left: -18px;\n}\n\n.md-datepicker-input-container {\n  position: relative;\n  border-bottom-width: 1px;\n  border-bottom-style: solid;\n  display: inline-block;\n  width: auto;\n}\n.md-icon-button + .md-datepicker-input-container {\n  margin-left: 12px;\n}\n[dir=rtl] .md-icon-button + .md-datepicker-input-container {\n  margin-left: auto;\n  margin-right: 12px;\n}\n.md-datepicker-input-container.md-datepicker-focused {\n  border-bottom-width: 2px;\n}\n\n.md-datepicker-is-showing .md-scroll-mask {\n  z-index: 99;\n}\n\n.md-datepicker-calendar-pane {\n  position: absolute;\n  top: 0;\n  left: -100%;\n  z-index: 100;\n  border-width: 1px;\n  border-style: solid;\n  background: transparent;\n  transform: scale(0);\n  transform-origin: 0 0;\n  transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n.md-datepicker-calendar-pane.md-pane-open {\n  transform: scale(1);\n}\n\n.md-datepicker-input-mask {\n  height: 40px;\n  width: 340px;\n  position: relative;\n  overflow: hidden;\n  background: transparent;\n  pointer-events: none;\n  cursor: text;\n}\n\n.md-datepicker-calendar {\n  opacity: 0;\n  transition: opacity 0.2s cubic-bezier(0.5, 0, 0.25, 1);\n}\n.md-pane-open .md-datepicker-calendar {\n  opacity: 1;\n}\n.md-datepicker-calendar md-calendar:focus {\n  outline: none;\n}\n\n.md-datepicker-expand-triangle {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 0;\n  height: 0;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  border-top: 5px solid;\n}\n\n.md-datepicker-triangle-button {\n  position: absolute;\n  right: 0;\n  bottom: -2.5px;\n  transform: translateX(45%);\n}\n[dir=rtl] .md-datepicker-triangle-button {\n  right: auto;\n  left: 0;\n}\n[dir=rtl] .md-datepicker-triangle-button {\n  transform: translateX(-45%);\n}\n\n.md-datepicker-triangle-button.md-button.md-icon-button {\n  height: 36px;\n  width: 36px;\n  position: absolute;\n  padding: 8px;\n}\n\nmd-datepicker[disabled] .md-datepicker-input-container {\n  border-bottom-color: transparent;\n}\nmd-datepicker[disabled] .md-datepicker-triangle-button {\n  display: none;\n}\n\n.md-datepicker-open {\n  overflow: hidden;\n}\n.md-datepicker-open .md-datepicker-input-container,\n.md-datepicker-open input.md-input {\n  border-bottom-color: transparent;\n}\n.md-datepicker-open .md-datepicker-triangle-button, .md-datepicker-open.md-input-has-value > label, .md-datepicker-open.md-input-has-placeholder > label {\n  display: none;\n}\n\n.md-datepicker-pos-adjusted .md-datepicker-input-mask {\n  display: none;\n}\n\n.md-datepicker-calendar-pane .md-calendar {\n  transform: translateY(-85px);\n  transition: transform 0.65s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-delay: 0.125s;\n}\n.md-datepicker-calendar-pane.md-pane-open .md-calendar {\n  transform: translateY(0);\n}\n\n.md-dialog-is-showing {\n  max-height: 100%;\n}\n\n.md-dialog-container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 80;\n  overflow: hidden;\n}\n\nmd-dialog {\n  opacity: 0;\n  min-width: 240px;\n  max-width: 80%;\n  max-height: 80%;\n  position: relative;\n  overflow: auto;\n  box-shadow: 0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 13px 19px 2px rgba(0, 0, 0, 0.14), 0px 5px 24px 4px rgba(0, 0, 0, 0.12);\n  display: flex;\n  flex-direction: column;\n}\nmd-dialog.md-transition-in {\n  opacity: 1;\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transform: translate(0, 0) scale(1);\n}\nmd-dialog.md-transition-out {\n  opacity: 0;\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transform: translate(0, 100%) scale(0.2);\n}\nmd-dialog > form {\n  display: flex;\n  flex-direction: column;\n  overflow: auto;\n}\nmd-dialog .md-dialog-content {\n  padding: 24px;\n}\nmd-dialog md-dialog-content {\n  order: 1;\n  flex-direction: column;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\nmd-dialog md-dialog-content:not([layout=row]) > *:first-child:not(.md-subheader) {\n  margin-top: 0;\n}\nmd-dialog md-dialog-content:focus {\n  outline: none;\n}\nmd-dialog md-dialog-content .md-subheader {\n  margin: 0;\n}\nmd-dialog md-dialog-content .md-dialog-content-body {\n  width: 100%;\n}\nmd-dialog md-dialog-content .md-prompt-input-container {\n  width: 100%;\n  box-sizing: border-box;\n}\nmd-dialog md-dialog-actions {\n  display: flex;\n  order: 2;\n  box-sizing: border-box;\n  align-items: center;\n  justify-content: flex-end;\n  margin-bottom: 0;\n  padding-right: 8px;\n  padding-left: 16px;\n  min-height: 52px;\n  overflow: hidden;\n}\n[dir=rtl] md-dialog md-dialog-actions {\n  padding-right: 16px;\n}\n[dir=rtl] md-dialog md-dialog-actions {\n  padding-left: 8px;\n}\nmd-dialog md-dialog-actions .md-button {\n  margin-bottom: 8px;\n  margin-left: 8px;\n  margin-right: 0;\n  margin-top: 8px;\n}\n[dir=rtl] md-dialog md-dialog-actions .md-button {\n  margin-left: 0;\n}\n[dir=rtl] md-dialog md-dialog-actions .md-button {\n  margin-right: 8px;\n}\nmd-dialog.md-content-overflow md-dialog-actions {\n  border-top-width: 1px;\n  border-top-style: solid;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-dialog {\n    border: 1px solid #fff;\n  }\n}\n@media (max-width: 959px) {\n  md-dialog.md-dialog-fullscreen {\n    min-height: 100%;\n    min-width: 100%;\n    border-radius: 0;\n  }\n}\nmd-divider {\n  display: block;\n  border-top-width: 1px;\n  border-top-style: solid;\n  margin: 0;\n}\nmd-divider[md-inset] {\n  margin-left: 80px;\n}\n[dir=rtl] md-divider[md-inset] {\n  margin-left: auto;\n  margin-right: 80px;\n}\n\n@media (max-width: 599px) {\n  .layout-row:not(.layout-xs-column) > md-divider,\n.layout-xs-row > md-divider {\n    border-top-width: 0;\n    border-right-width: 1px;\n    border-right-style: solid;\n  }\n}\n@media (min-width: 600px) and (max-width: 959px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-sm-column) > md-divider,\n.layout-gt-xs-row:not(.layout-sm-column) > md-divider,\n.layout-sm-row:not(.layout-sm-column) > md-divider {\n    border-top-width: 0;\n    border-right-width: 1px;\n    border-right-style: solid;\n  }\n}\n@media (min-width: 960px) and (max-width: 1279px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-md-column) > md-divider,\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-md-column) > md-divider,\n.layout-gt-sm-row:not(.layout-md-column) > md-divider,\n.layout-md-row:not(.layout-md-column) > md-divider {\n    border-top-width: 0;\n    border-right-width: 1px;\n    border-right-style: solid;\n  }\n}\n@media (min-width: 1280px) and (max-width: 1919px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > md-divider,\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > md-divider,\n.layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-lg-column) > md-divider,\n.layout-gt-md-row:not(.layout-lg-column) > md-divider,\n.layout-lg-row:not(.layout-lg-column) > md-divider {\n    border-top-width: 0;\n    border-right-width: 1px;\n    border-right-style: solid;\n  }\n}\n@media (min-width: 1920px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > md-divider,\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > md-divider,\n.layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > md-divider,\n.layout-gt-md-row:not(.layout-gt-lg-column):not(.layout-xl-column) > md-divider,\n.layout-gt-lg-row:not(.layout-gt-lg-column):not(.layout-xl-column) > md-divider,\n.layout-xl-row:not(.layout-gt-lg-column):not(.layout-xl-column) > md-divider {\n    border-top-width: 0;\n    border-right-width: 1px;\n    border-right-style: solid;\n  }\n}\nmd-fab-speed-dial {\n  position: relative;\n  display: flex;\n  align-items: center;\n  z-index: 20;\n  /*\n   * Hide some graphics glitches if switching animation types\n   */\n  /*\n   * Handle the animations\n   */\n}\nmd-fab-speed-dial.md-fab-bottom-right {\n  top: auto;\n  right: 20px;\n  bottom: 20px;\n  left: auto;\n  position: absolute;\n}\nmd-fab-speed-dial.md-fab-bottom-left {\n  top: auto;\n  right: auto;\n  bottom: 20px;\n  left: 20px;\n  position: absolute;\n}\nmd-fab-speed-dial.md-fab-top-right {\n  top: 20px;\n  right: 20px;\n  bottom: auto;\n  left: auto;\n  position: absolute;\n}\nmd-fab-speed-dial.md-fab-top-left {\n  top: 20px;\n  right: auto;\n  bottom: auto;\n  left: 20px;\n  position: absolute;\n}\nmd-fab-speed-dial:not(.md-hover-full) {\n  pointer-events: none;\n}\nmd-fab-speed-dial:not(.md-hover-full) md-fab-trigger, md-fab-speed-dial:not(.md-hover-full) .md-fab-action-item {\n  pointer-events: auto;\n}\nmd-fab-speed-dial:not(.md-hover-full).md-is-open {\n  pointer-events: auto;\n}\nmd-fab-speed-dial ._md-css-variables {\n  z-index: 20;\n}\nmd-fab-speed-dial.md-is-open .md-fab-action-item {\n  align-items: center;\n}\nmd-fab-speed-dial md-fab-actions {\n  display: flex;\n  height: auto;\n}\nmd-fab-speed-dial md-fab-actions .md-fab-action-item {\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n}\nmd-fab-speed-dial.md-down {\n  flex-direction: column;\n}\nmd-fab-speed-dial.md-down md-fab-trigger {\n  order: 1;\n}\nmd-fab-speed-dial.md-down md-fab-actions {\n  flex-direction: column;\n  order: 2;\n}\nmd-fab-speed-dial.md-up {\n  flex-direction: column;\n}\nmd-fab-speed-dial.md-up md-fab-trigger {\n  order: 2;\n}\nmd-fab-speed-dial.md-up md-fab-actions {\n  flex-direction: column-reverse;\n  order: 1;\n}\nmd-fab-speed-dial.md-left {\n  flex-direction: row;\n}\nmd-fab-speed-dial.md-left md-fab-trigger {\n  order: 2;\n}\nmd-fab-speed-dial.md-left md-fab-actions {\n  flex-direction: row-reverse;\n  order: 1;\n}\nmd-fab-speed-dial.md-left md-fab-actions .md-fab-action-item {\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n}\nmd-fab-speed-dial.md-right {\n  flex-direction: row;\n}\nmd-fab-speed-dial.md-right md-fab-trigger {\n  order: 1;\n}\nmd-fab-speed-dial.md-right md-fab-actions {\n  flex-direction: row;\n  order: 2;\n}\nmd-fab-speed-dial.md-right md-fab-actions .md-fab-action-item {\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n}\nmd-fab-speed-dial.md-fling-remove .md-fab-action-item > *, md-fab-speed-dial.md-scale-remove .md-fab-action-item > * {\n  visibility: hidden;\n}\nmd-fab-speed-dial.md-fling .md-fab-action-item {\n  opacity: 1;\n}\nmd-fab-speed-dial.md-fling.md-animations-waiting .md-fab-action-item {\n  opacity: 0;\n  transition-duration: 0s;\n}\nmd-fab-speed-dial.md-scale .md-fab-action-item {\n  transform: scale(0);\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-duration: 0.1428571429s;\n}\n\nmd-fab-toolbar {\n  display: block;\n  /*\n   * Closed styling\n   */\n  /*\n   * Open styling\n   */\n}\nmd-fab-toolbar.md-fab-bottom-right {\n  top: auto;\n  right: 20px;\n  bottom: 20px;\n  left: auto;\n  position: absolute;\n}\nmd-fab-toolbar.md-fab-bottom-left {\n  top: auto;\n  right: auto;\n  bottom: 20px;\n  left: 20px;\n  position: absolute;\n}\nmd-fab-toolbar.md-fab-top-right {\n  top: 20px;\n  right: 20px;\n  bottom: auto;\n  left: auto;\n  position: absolute;\n}\nmd-fab-toolbar.md-fab-top-left {\n  top: 20px;\n  right: auto;\n  bottom: auto;\n  left: 20px;\n  position: absolute;\n}\nmd-fab-toolbar .md-fab-toolbar-wrapper {\n  display: block;\n  position: relative;\n  overflow: hidden;\n  height: 68px;\n}\nmd-fab-toolbar md-fab-trigger {\n  position: absolute;\n  z-index: 20;\n}\nmd-fab-toolbar md-fab-trigger button {\n  overflow: visible !important;\n}\nmd-fab-toolbar md-fab-trigger .md-fab-toolbar-background {\n  display: block;\n  position: absolute;\n  z-index: 21;\n  opacity: 1;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n}\nmd-fab-toolbar md-fab-trigger md-icon {\n  position: relative;\n  z-index: 22;\n  opacity: 1;\n  transition: all 200ms ease-in;\n}\nmd-fab-toolbar.md-left md-fab-trigger {\n  right: 0;\n}\n[dir=rtl] md-fab-toolbar.md-left md-fab-trigger {\n  right: auto;\n  left: 0;\n}\nmd-fab-toolbar.md-left .md-toolbar-tools {\n  flex-direction: row-reverse;\n}\nmd-fab-toolbar.md-left .md-toolbar-tools > .md-button:first-child {\n  margin-right: 0.6rem;\n}\n[dir=rtl] md-fab-toolbar.md-left .md-toolbar-tools > .md-button:first-child {\n  margin-right: auto;\n  margin-left: 0.6rem;\n}\nmd-fab-toolbar.md-left .md-toolbar-tools > .md-button:first-child {\n  margin-left: -0.8rem;\n}\n[dir=rtl] md-fab-toolbar.md-left .md-toolbar-tools > .md-button:first-child {\n  margin-left: auto;\n  margin-right: -0.8rem;\n}\nmd-fab-toolbar.md-left .md-toolbar-tools > .md-button:last-child {\n  margin-right: 8px;\n}\n[dir=rtl] md-fab-toolbar.md-left .md-toolbar-tools > .md-button:last-child {\n  margin-right: auto;\n  margin-left: 8px;\n}\nmd-fab-toolbar.md-right md-fab-trigger {\n  left: 0;\n}\n[dir=rtl] md-fab-toolbar.md-right md-fab-trigger {\n  left: auto;\n  right: 0;\n}\nmd-fab-toolbar.md-right .md-toolbar-tools {\n  flex-direction: row;\n}\nmd-fab-toolbar md-toolbar {\n  background-color: transparent !important;\n  pointer-events: none;\n  z-index: 23;\n}\nmd-fab-toolbar md-toolbar .md-toolbar-tools {\n  padding: 0 20px;\n  margin-top: 3px;\n}\nmd-fab-toolbar md-toolbar .md-fab-action-item {\n  opacity: 0;\n  transform: scale(0);\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-duration: 0.15s;\n}\nmd-fab-toolbar.md-is-open md-fab-trigger > button {\n  box-shadow: none;\n}\nmd-fab-toolbar.md-is-open md-fab-trigger > button md-icon {\n  opacity: 0;\n}\nmd-fab-toolbar.md-is-open .md-fab-action-item {\n  opacity: 1;\n  transform: scale(1);\n}\n\nmd-grid-list {\n  box-sizing: border-box;\n  display: block;\n  position: relative;\n}\nmd-grid-list md-grid-tile,\nmd-grid-list md-grid-tile > figure,\nmd-grid-list md-grid-tile-header,\nmd-grid-list md-grid-tile-footer {\n  box-sizing: border-box;\n}\nmd-grid-list md-grid-tile {\n  display: block;\n  position: absolute;\n}\nmd-grid-list md-grid-tile figure {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  padding: 0;\n  margin: 0;\n}\nmd-grid-list md-grid-tile md-grid-tile-header,\nmd-grid-list md-grid-tile md-grid-tile-footer {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  height: 48px;\n  color: #fff;\n  background: rgba(0, 0, 0, 0.18);\n  overflow: hidden;\n  position: absolute;\n  left: 0;\n  right: 0;\n}\nmd-grid-list md-grid-tile md-grid-tile-header h3,\nmd-grid-list md-grid-tile md-grid-tile-header h4,\nmd-grid-list md-grid-tile md-grid-tile-footer h3,\nmd-grid-list md-grid-tile md-grid-tile-footer h4 {\n  font-weight: 400;\n  margin: 0 0 0 16px;\n}\nmd-grid-list md-grid-tile md-grid-tile-header h3,\nmd-grid-list md-grid-tile md-grid-tile-footer h3 {\n  font-size: 14px;\n}\nmd-grid-list md-grid-tile md-grid-tile-header h4,\nmd-grid-list md-grid-tile md-grid-tile-footer h4 {\n  font-size: 12px;\n}\nmd-grid-list md-grid-tile md-grid-tile-header {\n  top: 0;\n}\nmd-grid-list md-grid-tile md-grid-tile-footer {\n  bottom: 0;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-grid-tile {\n    border: 1px solid #fff;\n  }\n\n  md-grid-tile-footer {\n    border-top: 1px solid #fff;\n  }\n}\nmd-icon {\n  margin: auto;\n  background-repeat: no-repeat no-repeat;\n  display: inline-block;\n  vertical-align: middle;\n  fill: currentColor;\n  height: 24px;\n  width: 24px;\n  min-height: 24px;\n  min-width: 24px;\n}\nmd-icon svg {\n  pointer-events: none;\n  display: block;\n}\nmd-icon[md-font-icon] {\n  line-height: 24px;\n  width: auto;\n}\n\nmd-input-container {\n  display: inline-block;\n  position: relative;\n  padding: 2px;\n  margin: 18px 0px;\n  vertical-align: middle;\n  /*\n   * The .md-input class is added to the input/textarea\n   */\n}\nmd-input-container:after {\n  content: "";\n  display: table;\n  clear: both;\n}\nmd-input-container.md-block {\n  display: block;\n}\nmd-input-container .md-errors-spacer {\n  float: right;\n  min-height: 24px;\n  min-width: 1px;\n}\n[dir=rtl] md-input-container .md-errors-spacer {\n  float: left;\n}\nmd-input-container > md-icon {\n  position: absolute;\n  top: 8px;\n  left: 2px;\n  right: auto;\n}\n[dir=rtl] md-input-container > md-icon {\n  left: auto;\n}\n[dir=rtl] md-input-container > md-icon {\n  right: 2px;\n}\nmd-input-container textarea,\nmd-input-container input[type=text],\nmd-input-container input[type=password],\nmd-input-container input[type=datetime],\nmd-input-container input[type=datetime-local],\nmd-input-container input[type=date],\nmd-input-container input[type=month],\nmd-input-container input[type=time],\nmd-input-container input[type=week],\nmd-input-container input[type=number],\nmd-input-container input[type=email],\nmd-input-container input[type=url],\nmd-input-container input[type=search],\nmd-input-container input[type=tel],\nmd-input-container input[type=color] {\n  /* remove default appearance from all input/textarea */\n  -moz-appearance: none;\n  -webkit-appearance: none;\n}\nmd-input-container input[type=date],\nmd-input-container input[type=datetime-local],\nmd-input-container input[type=month],\nmd-input-container input[type=time],\nmd-input-container input[type=week] {\n  min-height: 30px;\n}\nmd-input-container textarea {\n  resize: none;\n  overflow: hidden;\n}\nmd-input-container textarea.md-input {\n  min-height: 30px;\n  -ms-flex-preferred-size: auto;\n}\nmd-input-container textarea[md-no-autogrow] {\n  height: auto;\n  overflow: auto;\n}\nmd-input-container label:not(.md-container-ignore) {\n  position: absolute;\n  bottom: 100%;\n  left: 0;\n  right: auto;\n}\n[dir=rtl] md-input-container label:not(.md-container-ignore) {\n  left: auto;\n}\n[dir=rtl] md-input-container label:not(.md-container-ignore) {\n  right: 0;\n}\nmd-input-container label:not(.md-container-ignore).md-required:after {\n  content: " *";\n  font-size: 13px;\n  vertical-align: top;\n}\nmd-input-container label:not(.md-no-float):not(.md-container-ignore),\nmd-input-container .md-placeholder {\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  width: 100%;\n  order: 1;\n  pointer-events: none;\n  -webkit-font-smoothing: antialiased;\n  padding-left: 2px;\n  padding-right: 0;\n  z-index: 1;\n  transform: translate3d(0, 28px, 0) scale(1);\n  transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  max-width: 100%;\n  transform-origin: left top;\n}\n[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore),\n[dir=rtl] md-input-container .md-placeholder {\n  padding-left: 0;\n}\n[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore),\n[dir=rtl] md-input-container .md-placeholder {\n  padding-right: 2px;\n}\n[dir=rtl] md-input-container label:not(.md-no-float):not(.md-container-ignore),\n[dir=rtl] md-input-container .md-placeholder {\n  transform-origin: right top;\n}\nmd-input-container.md-input-has-value label:not(.md-no-float):not(.md-container-ignore),\nmd-input-container.md-input-has-value .md-placeholder {\n  padding-left: 3px;\n  padding-right: 0;\n}\n[dir=rtl] md-input-container.md-input-has-value label:not(.md-no-float):not(.md-container-ignore),\n[dir=rtl] md-input-container.md-input-has-value .md-placeholder {\n  padding-left: 0;\n}\n[dir=rtl] md-input-container.md-input-has-value label:not(.md-no-float):not(.md-container-ignore),\n[dir=rtl] md-input-container.md-input-has-value .md-placeholder {\n  padding-right: 3px;\n}\nmd-input-container .md-placeholder {\n  position: absolute;\n  top: 0;\n  opacity: 0;\n  transition-property: opacity, transform;\n  transform: translate3d(0, 30px, 0);\n}\nmd-input-container.md-input-focused .md-placeholder {\n  opacity: 1;\n  transform: translate3d(0, 24px, 0);\n}\nmd-input-container.md-input-has-value .md-placeholder {\n  transition: none;\n  opacity: 0;\n}\nmd-input-container:not(.md-input-has-value):not(.md-input-has-placeholder) input:not(:focus) {\n  color: transparent;\n}\nmd-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-ampm-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-day-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-hour-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-millisecond-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-minute-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-month-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-second-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-week-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-year-field, md-input-container:not(.md-input-has-value) input:not(:focus)::-webkit-datetime-edit-text {\n  color: transparent;\n}\nmd-input-container .md-input {\n  order: 2;\n  display: block;\n  margin-top: 0;\n  background: none;\n  padding-top: 2px;\n  padding-bottom: 1px;\n  padding-left: 0;\n  padding-right: 2px;\n  border-width: 0 0 1px 0;\n  line-height: 26px;\n  height: 30px;\n  -ms-flex-preferred-size: 26px;\n  border-radius: 0;\n  border-style: solid;\n  transition: border-color 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  width: 100%;\n  box-sizing: border-box;\n  float: left;\n}\n[dir=rtl] md-input-container .md-input {\n  padding-left: 2px;\n}\n[dir=rtl] md-input-container .md-input {\n  padding-right: 0;\n}\n[dir=rtl] md-input-container .md-input {\n  float: right;\n}\nmd-input-container .md-input:focus {\n  outline: none;\n}\nmd-input-container .md-input:invalid {\n  outline: none;\n  box-shadow: none;\n}\nmd-input-container .md-input.md-no-flex {\n  flex: none !important;\n}\nmd-input-container .md-char-counter {\n  text-align: right;\n  padding-right: 2px;\n  padding-left: 0;\n}\n[dir=rtl] md-input-container .md-char-counter {\n  text-align: left;\n}\n[dir=rtl] md-input-container .md-char-counter {\n  padding-right: 0;\n}\n[dir=rtl] md-input-container .md-char-counter {\n  padding-left: 2px;\n}\nmd-input-container .md-input-messages-animation {\n  position: relative;\n  order: 4;\n  overflow: hidden;\n  clear: left;\n}\n[dir=rtl] md-input-container .md-input-messages-animation {\n  clear: right;\n}\nmd-input-container .md-input-message-animation, md-input-container .md-char-counter {\n  font-size: 12px;\n  line-height: 14px;\n  overflow: hidden;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  opacity: 1;\n  margin-top: 0;\n  padding-top: 8px;\n}\nmd-input-container .md-input-message-animation:not(.md-char-counter), md-input-container .md-char-counter:not(.md-char-counter) {\n  padding-right: 5px;\n  padding-left: 0;\n}\n[dir=rtl] md-input-container .md-input-message-animation:not(.md-char-counter), [dir=rtl] md-input-container .md-char-counter:not(.md-char-counter) {\n  padding-right: 0;\n}\n[dir=rtl] md-input-container .md-input-message-animation:not(.md-char-counter), [dir=rtl] md-input-container .md-char-counter:not(.md-char-counter) {\n  padding-left: 5px;\n}\nmd-input-container:not(.md-input-invalid) .md-auto-hide .md-input-message-animation {\n  opacity: 0;\n  margin-top: -100px;\n}\nmd-input-container .md-input-message-animation.ng-enter-prepare {\n  opacity: 0;\n  margin-top: -100px;\n}\nmd-input-container .md-input-message-animation.ng-enter:not(.ng-enter-active) {\n  opacity: 0;\n  margin-top: -100px;\n}\nmd-input-container.md-input-focused label:not(.md-no-float), md-input-container.md-input-has-placeholder label:not(.md-no-float), md-input-container.md-input-has-value label:not(.md-no-float) {\n  transform: translate3d(0, 6px, 0) scale(0.75);\n  transition: transform cubic-bezier(0.25, 0.8, 0.25, 1) 0.4s, width cubic-bezier(0.25, 0.8, 0.25, 1) 0.4s;\n}\nmd-input-container.md-input-has-value label {\n  transition: none;\n}\nmd-input-container.md-input-focused .md-input,\nmd-input-container .md-input.ng-invalid.ng-dirty, md-input-container.md-input-resized .md-input {\n  padding-bottom: 0;\n  border-width: 0 0 2px 0;\n}\nmd-input-container .md-input[disabled], [disabled] md-input-container .md-input {\n  background-position: bottom -1px left 0;\n  background-size: 4px 1px;\n  background-repeat: repeat-x;\n}\nmd-input-container.md-icon-float {\n  transition: margin-top 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\nmd-input-container.md-icon-float > label {\n  pointer-events: none;\n  position: absolute;\n}\nmd-input-container.md-icon-float > md-icon {\n  top: 8px;\n  left: 2px;\n  right: auto;\n}\n[dir=rtl] md-input-container.md-icon-float > md-icon {\n  left: auto;\n}\n[dir=rtl] md-input-container.md-icon-float > md-icon {\n  right: 2px;\n}\nmd-input-container.md-icon-left > label:not(.md-no-float):not(.md-container-ignore),\nmd-input-container.md-icon-left > label .md-placeholder, md-input-container.md-icon-right > label:not(.md-no-float):not(.md-container-ignore),\nmd-input-container.md-icon-right > label .md-placeholder {\n  width: calc(100% - 36px);\n  padding: 0;\n}\nmd-input-container.md-icon-left {\n  padding-left: 36px;\n  padding-right: 0;\n}\n[dir=rtl] md-input-container.md-icon-left {\n  padding-left: 0;\n}\n[dir=rtl] md-input-container.md-icon-left {\n  padding-right: 36px;\n}\nmd-input-container.md-icon-left > label {\n  left: 36px;\n  right: auto;\n}\n[dir=rtl] md-input-container.md-icon-left > label {\n  left: auto;\n}\n[dir=rtl] md-input-container.md-icon-left > label {\n  right: 36px;\n}\nmd-input-container.md-icon-right {\n  padding-left: 0;\n  padding-right: 36px;\n}\n[dir=rtl] md-input-container.md-icon-right {\n  padding-left: 36px;\n}\n[dir=rtl] md-input-container.md-icon-right {\n  padding-right: 0;\n}\nmd-input-container.md-icon-right > md-icon:last-of-type {\n  margin: 0;\n  right: 2px;\n  left: auto;\n}\n[dir=rtl] md-input-container.md-icon-right > md-icon:last-of-type {\n  right: auto;\n}\n[dir=rtl] md-input-container.md-icon-right > md-icon:last-of-type {\n  left: 2px;\n}\nmd-input-container.md-icon-left.md-icon-right {\n  padding-left: 36px;\n  padding-right: 36px;\n}\nmd-input-container.md-icon-left.md-icon-right > label:not(.md-no-float):not(.md-container-ignore),\nmd-input-container.md-icon-left.md-icon-right > label .md-placeholder {\n  width: calc(100% - (36px * 2));\n}\n\n.md-resize-wrapper {\n  position: relative;\n}\n.md-resize-wrapper:after {\n  content: "";\n  display: table;\n  clear: both;\n}\n\n.md-resize-handle {\n  position: absolute;\n  bottom: -5px;\n  left: 0;\n  height: 10px;\n  background: transparent;\n  width: 100%;\n  cursor: ns-resize;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-input-container.md-default-theme > md-icon {\n    fill: #fff;\n  }\n}\nmd-list {\n  display: block;\n  padding: 8px 0px 8px 0px;\n}\nmd-list .md-subheader {\n  font-size: 14px;\n  font-weight: 500;\n  letter-spacing: 0.01em;\n  line-height: 1.2em;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner {\n  min-height: 40px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item::before,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner::before {\n  content: "";\n  min-height: 40px;\n  visibility: hidden;\n  display: inline-block;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item md-icon:first-child,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner md-icon:first-child {\n  width: 20px;\n  height: 20px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item > md-icon:first-child:not(.md-avatar-icon),\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner > md-icon:first-child:not(.md-avatar-icon) {\n  margin-right: 36px;\n  margin-top: 4px;\n  margin-bottom: 4px;\n}\n[dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item > md-icon:first-child:not(.md-avatar-icon),\n[dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner > md-icon:first-child:not(.md-avatar-icon) {\n  margin-right: auto;\n  margin-left: 36px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-avatar, md-list.md-dense:not(.md-dense-disabled) md-list-item .md-avatar-icon,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner .md-avatar,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner .md-avatar-icon {\n  margin-right: 20px;\n  margin-top: 6px;\n  margin-bottom: 6px;\n}\n[dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item .md-avatar, [dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item .md-avatar-icon,\n[dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner .md-avatar,\n[dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner .md-avatar-icon {\n  margin-right: auto;\n  margin-left: 20px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-avatar,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner .md-avatar {\n  flex: none;\n  width: 36px;\n  height: 36px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-secondary-container .md-secondary.md-button,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner .md-secondary-container .md-secondary.md-button {\n  margin-top: 4px;\n  margin-bottom: 4px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-secondary-container md-checkbox:not(.md-dense-disabled),\nmd-list.md-dense:not(.md-dense-disabled) md-list-item .md-list-item-inner .md-secondary-container md-checkbox:not(.md-dense-disabled) {\n  min-height: 40px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line .md-list-item-text.md-offset, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style .md-list-item-text.md-offset, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line .md-list-item-text.md-offset, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style .md-list-item-text.md-offset {\n  margin-left: 56px;\n}\n[dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line .md-list-item-text.md-offset, [dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style .md-list-item-text.md-offset, [dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line .md-list-item-text.md-offset, [dir=rtl] md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style .md-list-item-text.md-offset {\n  margin-left: auto;\n  margin-right: 56px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line .md-list-item-text h3,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line .md-list-item-text h4,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line .md-list-item-text p, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style .md-list-item-text h3,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style .md-list-item-text h4,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style .md-list-item-text p, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line .md-list-item-text h3,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line .md-list-item-text h4,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line .md-list-item-text p, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style .md-list-item-text h3,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style .md-list-item-text h4,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style .md-list-item-text p {\n  line-height: 1.05;\n  font-size: 12px;\n  padding-bottom: 4px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line .md-list-item-text h3, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style .md-list-item-text h3, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line .md-list-item-text h3, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style .md-list-item-text h3 {\n  font-size: 13px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style {\n  min-height: 60px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line::before, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style::before {\n  content: "";\n  min-height: 60px;\n  visibility: hidden;\n  display: inline-block;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-avatar, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line .md-avatar-icon, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style > .md-avatar, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-2-line > .md-no-style .md-avatar-icon {\n  margin-top: 12px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style {\n  min-height: 76px;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line::before, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style::before {\n  content: "";\n  min-height: 76px;\n  visibility: hidden;\n  display: inline-block;\n}\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > md-icon:first-child,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-avatar, md-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style > md-icon:first-child,\nmd-list.md-dense:not(.md-dense-disabled) md-list-item.md-3-line > .md-no-style > .md-avatar {\n  margin-top: 16px;\n}\nmd-list.md-dense:not(.md-dense-disabled) .md-subheader-inner {\n  padding-top: 12px;\n  padding-bottom: 12px;\n}\n\nmd-list-item {\n  position: relative;\n}\nmd-list-item.md-proxy-focus.md-focused .md-no-style {\n  transition: background-color 0.15s linear;\n}\nmd-list-item._md-button-wrap {\n  position: relative;\n}\nmd-list-item._md-button-wrap > div.md-button:first-child {\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n  padding: 0px 16px;\n  margin: 0;\n  font-weight: 400;\n  text-align: left;\n  border: medium none;\n}\n[dir=rtl] md-list-item._md-button-wrap > div.md-button:first-child {\n  text-align: right;\n}\nmd-list-item._md-button-wrap > div.md-button:first-child > .md-button:first-child {\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n}\nmd-list-item._md-button-wrap > div.md-button:first-child .md-list-item-inner {\n  width: 100%;\n}\nmd-list-item._md-button-wrap > div.md-button:first-child .md-list-item-inner::before {\n  content: "";\n  min-height: inherit;\n  visibility: hidden;\n  display: inline-block;\n}\nmd-list-item.md-no-proxy,\nmd-list-item .md-no-style {\n  position: relative;\n  padding: 0px 16px;\n  flex: 1 1 auto;\n}\nmd-list-item.md-no-proxy.md-button,\nmd-list-item .md-no-style.md-button {\n  font-size: inherit;\n  height: inherit;\n  text-align: left;\n  text-transform: none;\n  width: 100%;\n  white-space: normal;\n  flex-direction: inherit;\n  align-items: inherit;\n  border-radius: 0;\n  margin: 0;\n}\n[dir=rtl] md-list-item.md-no-proxy.md-button,\n[dir=rtl] md-list-item .md-no-style.md-button {\n  text-align: right;\n}\nmd-list-item.md-no-proxy.md-button > .md-ripple-container,\nmd-list-item .md-no-style.md-button > .md-ripple-container {\n  border-radius: 0;\n}\nmd-list-item.md-no-proxy:focus,\nmd-list-item .md-no-style:focus {\n  outline: none;\n}\nmd-list-item.md-clickable:hover {\n  cursor: pointer;\n}\nmd-list-item md-divider {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n}\n[dir=rtl] md-list-item md-divider {\n  left: auto;\n  right: 0;\n}\nmd-list-item md-divider[md-inset] {\n  left: 72px;\n  width: calc(100% - 72px);\n  margin: 0 !important;\n}\n[dir=rtl] md-list-item md-divider[md-inset] {\n  left: auto;\n  right: 72px;\n}\nmd-list-item,\nmd-list-item .md-list-item-inner {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  min-height: 48px;\n  height: auto;\n}\nmd-list-item::before,\nmd-list-item .md-list-item-inner::before {\n  content: "";\n  min-height: 48px;\n  visibility: hidden;\n  display: inline-block;\n}\nmd-list-item > div.md-primary > md-icon:not(.md-avatar-icon), md-list-item > div.md-secondary > md-icon:not(.md-avatar-icon), md-list-item > md-icon:first-child:not(.md-avatar-icon),\nmd-list-item > md-icon.md-secondary:not(.md-avatar-icon),\nmd-list-item .md-list-item-inner > div.md-primary > md-icon:not(.md-avatar-icon),\nmd-list-item .md-list-item-inner > div.md-secondary > md-icon:not(.md-avatar-icon),\nmd-list-item .md-list-item-inner > md-icon:first-child:not(.md-avatar-icon),\nmd-list-item .md-list-item-inner > md-icon.md-secondary:not(.md-avatar-icon) {\n  width: 24px;\n  margin-top: 16px;\n  margin-bottom: 12px;\n  box-sizing: content-box;\n}\nmd-list-item > div.md-primary > md-checkbox, md-list-item > div.md-secondary > md-checkbox, md-list-item > md-checkbox,\nmd-list-item md-checkbox.md-secondary,\nmd-list-item .md-list-item-inner > div.md-primary > md-checkbox,\nmd-list-item .md-list-item-inner > div.md-secondary > md-checkbox,\nmd-list-item .md-list-item-inner > md-checkbox,\nmd-list-item .md-list-item-inner md-checkbox.md-secondary {\n  align-self: center;\n}\nmd-list-item > div.md-primary > md-checkbox .md-label, md-list-item > div.md-secondary > md-checkbox .md-label, md-list-item > md-checkbox .md-label,\nmd-list-item md-checkbox.md-secondary .md-label,\nmd-list-item .md-list-item-inner > div.md-primary > md-checkbox .md-label,\nmd-list-item .md-list-item-inner > div.md-secondary > md-checkbox .md-label,\nmd-list-item .md-list-item-inner > md-checkbox .md-label,\nmd-list-item .md-list-item-inner md-checkbox.md-secondary .md-label {\n  display: none;\n}\nmd-list-item > md-icon:first-child:not(.md-avatar-icon),\nmd-list-item .md-list-item-inner > md-icon:first-child:not(.md-avatar-icon) {\n  margin-right: 32px;\n}\n[dir=rtl] md-list-item > md-icon:first-child:not(.md-avatar-icon),\n[dir=rtl] md-list-item .md-list-item-inner > md-icon:first-child:not(.md-avatar-icon) {\n  margin-right: auto;\n  margin-left: 32px;\n}\nmd-list-item .md-avatar, md-list-item .md-avatar-icon,\nmd-list-item .md-list-item-inner .md-avatar,\nmd-list-item .md-list-item-inner .md-avatar-icon {\n  margin-top: 8px;\n  margin-bottom: 8px;\n  margin-right: 16px;\n  border-radius: 50%;\n  box-sizing: content-box;\n}\n[dir=rtl] md-list-item .md-avatar, [dir=rtl] md-list-item .md-avatar-icon,\n[dir=rtl] md-list-item .md-list-item-inner .md-avatar,\n[dir=rtl] md-list-item .md-list-item-inner .md-avatar-icon {\n  margin-right: auto;\n  margin-left: 16px;\n}\nmd-list-item .md-avatar,\nmd-list-item .md-list-item-inner .md-avatar {\n  flex: none;\n  width: 40px;\n  height: 40px;\n}\nmd-list-item .md-avatar-icon,\nmd-list-item .md-list-item-inner .md-avatar-icon {\n  padding: 8px;\n}\nmd-list-item .md-avatar-icon svg,\nmd-list-item .md-list-item-inner .md-avatar-icon svg {\n  width: 24px;\n  height: 24px;\n}\nmd-list-item > md-checkbox,\nmd-list-item .md-list-item-inner > md-checkbox {\n  width: 24px;\n  min-height: 40px;\n  margin-left: 0px;\n  margin-right: 29px;\n}\n[dir=rtl] md-list-item > md-checkbox,\n[dir=rtl] md-list-item .md-list-item-inner > md-checkbox {\n  margin-left: 29px;\n}\n[dir=rtl] md-list-item > md-checkbox,\n[dir=rtl] md-list-item .md-list-item-inner > md-checkbox {\n  margin-right: 0px;\n}\nmd-list-item .md-secondary-container,\nmd-list-item .md-list-item-inner .md-secondary-container {\n  display: flex;\n  align-items: center;\n  position: relative;\n  flex-shrink: 0;\n  margin: auto;\n  margin-right: 0;\n  margin-left: auto;\n}\n[dir=rtl] md-list-item .md-secondary-container,\n[dir=rtl] md-list-item .md-list-item-inner .md-secondary-container {\n  margin-right: auto;\n}\n[dir=rtl] md-list-item .md-secondary-container,\n[dir=rtl] md-list-item .md-list-item-inner .md-secondary-container {\n  margin-left: 0;\n}\nmd-list-item .md-secondary-container .md-button:last-of-type, md-list-item .md-secondary-container .md-icon-button:last-of-type,\nmd-list-item .md-list-item-inner .md-secondary-container .md-button:last-of-type,\nmd-list-item .md-list-item-inner .md-secondary-container .md-icon-button:last-of-type {\n  margin-right: 0;\n}\n[dir=rtl] md-list-item .md-secondary-container .md-button:last-of-type, [dir=rtl] md-list-item .md-secondary-container .md-icon-button:last-of-type,\n[dir=rtl] md-list-item .md-list-item-inner .md-secondary-container .md-button:last-of-type,\n[dir=rtl] md-list-item .md-list-item-inner .md-secondary-container .md-icon-button:last-of-type {\n  margin-right: auto;\n  margin-left: 0;\n}\nmd-list-item .md-secondary-container md-checkbox,\nmd-list-item .md-list-item-inner .md-secondary-container md-checkbox {\n  margin: 0 6px;\n  padding: 0 8px;\n  min-height: 40px;\n}\nmd-list-item .md-secondary-container md-checkbox:last-child,\nmd-list-item .md-list-item-inner .md-secondary-container md-checkbox:last-child {\n  width: 40px;\n  margin-right: 0;\n}\n[dir=rtl] md-list-item .md-secondary-container md-checkbox:last-child,\n[dir=rtl] md-list-item .md-list-item-inner .md-secondary-container md-checkbox:last-child {\n  margin-right: auto;\n  margin-left: 0;\n}\nmd-list-item .md-secondary-container md-switch,\nmd-list-item .md-list-item-inner .md-secondary-container md-switch {\n  margin-top: 0;\n  margin-bottom: 0;\n  margin-right: -6px;\n}\n[dir=rtl] md-list-item .md-secondary-container md-switch,\n[dir=rtl] md-list-item .md-list-item-inner .md-secondary-container md-switch {\n  margin-right: auto;\n  margin-left: -6px;\n}\nmd-list-item > p, md-list-item > .md-list-item-inner > p,\nmd-list-item .md-list-item-inner > p,\nmd-list-item .md-list-item-inner > .md-list-item-inner > p {\n  flex: 1 1 auto;\n  margin: 0;\n}\nmd-list-item.md-2-line, md-list-item.md-2-line > .md-no-style, md-list-item.md-3-line, md-list-item.md-3-line > .md-no-style {\n  align-items: flex-start;\n  justify-content: center;\n}\nmd-list-item.md-2-line.md-long-text, md-list-item.md-2-line > .md-no-style.md-long-text, md-list-item.md-3-line.md-long-text, md-list-item.md-3-line > .md-no-style.md-long-text {\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\nmd-list-item.md-2-line .md-list-item-text, md-list-item.md-2-line > .md-no-style .md-list-item-text, md-list-item.md-3-line .md-list-item-text, md-list-item.md-3-line > .md-no-style .md-list-item-text {\n  flex: 1 1 auto;\n  margin: auto;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\nmd-list-item.md-2-line .md-list-item-text.md-offset, md-list-item.md-2-line > .md-no-style .md-list-item-text.md-offset, md-list-item.md-3-line .md-list-item-text.md-offset, md-list-item.md-3-line > .md-no-style .md-list-item-text.md-offset {\n  margin-left: 56px;\n}\n[dir=rtl] md-list-item.md-2-line .md-list-item-text.md-offset, [dir=rtl] md-list-item.md-2-line > .md-no-style .md-list-item-text.md-offset, [dir=rtl] md-list-item.md-3-line .md-list-item-text.md-offset, [dir=rtl] md-list-item.md-3-line > .md-no-style .md-list-item-text.md-offset {\n  margin-left: auto;\n  margin-right: 56px;\n}\nmd-list-item.md-2-line .md-list-item-text h3, md-list-item.md-2-line > .md-no-style .md-list-item-text h3, md-list-item.md-3-line .md-list-item-text h3, md-list-item.md-3-line > .md-no-style .md-list-item-text h3 {\n  font-size: 16px;\n  font-weight: 400;\n  letter-spacing: 0.01em;\n  margin: 0 0 0 0;\n  line-height: 1.2em;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\nmd-list-item.md-2-line .md-list-item-text h4, md-list-item.md-2-line > .md-no-style .md-list-item-text h4, md-list-item.md-3-line .md-list-item-text h4, md-list-item.md-3-line > .md-no-style .md-list-item-text h4 {\n  font-size: 14px;\n  letter-spacing: 0.01em;\n  margin: 3px 0 1px 0;\n  font-weight: 400;\n  line-height: 1.2em;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\nmd-list-item.md-2-line .md-list-item-text p, md-list-item.md-2-line > .md-no-style .md-list-item-text p, md-list-item.md-3-line .md-list-item-text p, md-list-item.md-3-line > .md-no-style .md-list-item-text p {\n  font-size: 14px;\n  font-weight: 500;\n  letter-spacing: 0.01em;\n  margin: 0 0 0 0;\n  line-height: 1.6em;\n}\nmd-list-item.md-2-line, md-list-item.md-2-line > .md-no-style {\n  height: auto;\n  min-height: 72px;\n}\nmd-list-item.md-2-line::before, md-list-item.md-2-line > .md-no-style::before {\n  content: "";\n  min-height: 72px;\n  visibility: hidden;\n  display: inline-block;\n}\nmd-list-item.md-2-line > .md-avatar, md-list-item.md-2-line .md-avatar-icon, md-list-item.md-2-line > .md-no-style > .md-avatar, md-list-item.md-2-line > .md-no-style .md-avatar-icon {\n  margin-top: 12px;\n}\nmd-list-item.md-2-line > md-icon:first-child, md-list-item.md-2-line > .md-no-style > md-icon:first-child {\n  align-self: flex-start;\n}\nmd-list-item.md-2-line .md-list-item-text, md-list-item.md-2-line > .md-no-style .md-list-item-text {\n  flex: 1 1 auto;\n}\nmd-list-item.md-3-line, md-list-item.md-3-line > .md-no-style {\n  height: auto;\n  min-height: 88px;\n}\nmd-list-item.md-3-line::before, md-list-item.md-3-line > .md-no-style::before {\n  content: "";\n  min-height: 88px;\n  visibility: hidden;\n  display: inline-block;\n}\nmd-list-item.md-3-line > md-icon:first-child,\nmd-list-item.md-3-line > .md-avatar, md-list-item.md-3-line > .md-no-style > md-icon:first-child,\nmd-list-item.md-3-line > .md-no-style > .md-avatar {\n  margin-top: 16px;\n}\n\n.md-open-menu-container {\n  position: fixed;\n  left: 0;\n  top: 0;\n  z-index: 100;\n  opacity: 0;\n  border-radius: 2px;\n  max-height: calc(100vh - 10px);\n  overflow: auto;\n}\n.md-open-menu-container md-menu-divider {\n  margin-top: 4px;\n  margin-bottom: 4px;\n  height: 1px;\n  min-height: 1px;\n  max-height: 1px;\n  width: 100%;\n}\n.md-open-menu-container md-menu-content > * {\n  opacity: 0;\n}\n.md-open-menu-container:not(.md-clickable) {\n  pointer-events: none;\n}\n.md-open-menu-container.md-active {\n  opacity: 1;\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-duration: 200ms;\n}\n.md-open-menu-container.md-active > md-menu-content > * {\n  opacity: 1;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-duration: 200ms;\n  transition-delay: 100ms;\n}\n.md-open-menu-container.md-leave {\n  opacity: 0;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-duration: 250ms;\n}\n\nmd-menu-content {\n  display: flex;\n  flex-direction: column;\n  padding: 8px 0;\n  max-height: 304px;\n  overflow-y: auto;\n}\nmd-menu-content.md-dense {\n  max-height: 208px;\n}\nmd-menu-content.md-dense md-menu-item {\n  height: 32px;\n  min-height: 32px;\n}\n\nmd-menu-item {\n  display: flex;\n  flex-direction: row;\n  min-height: 48px;\n  height: 48px;\n  align-content: center;\n  justify-content: flex-start;\n  /*\n   * We cannot use flex on <button> elements due to a bug in Firefox, so we also can't use it on\n   * <a> elements. Add some top padding to fix alignment since buttons automatically align their\n   * text vertically.\n   */\n}\nmd-menu-item > * {\n  width: 100%;\n  margin: auto 0;\n  padding-left: 16px;\n  padding-right: 16px;\n}\nmd-menu-item > a.md-button {\n  padding-top: 5px;\n}\nmd-menu-item > .md-button {\n  text-align: left;\n  display: inline-block;\n  border-radius: 0;\n  margin: auto 0;\n  font-size: 15px;\n  text-transform: none;\n  font-weight: 400;\n  height: 100%;\n  padding-left: 16px;\n  padding-right: 16px;\n  width: 100%;\n}\nmd-menu-item > .md-button::-moz-focus-inner {\n  padding: 0;\n  border: 0;\n}\n[dir=rtl] md-menu-item > .md-button {\n  text-align: right;\n}\nmd-menu-item > .md-button md-icon {\n  margin: auto 16px auto 0;\n}\n[dir=rtl] md-menu-item > .md-button md-icon {\n  margin: auto 0 auto 16px;\n}\nmd-menu-item > .md-button p {\n  display: inline-block;\n  margin: auto;\n}\nmd-menu-item > .md-button span {\n  margin-top: auto;\n  margin-bottom: auto;\n}\nmd-menu-item > .md-button .md-ripple-container {\n  border-radius: inherit;\n}\n\nmd-toolbar .md-menu {\n  height: auto;\n  margin: auto;\n  padding: 0;\n}\n\n@media (max-width: 959px) {\n  md-menu-content {\n    min-width: 112px;\n  }\n\n  md-menu-content[width="3"] {\n    min-width: 168px;\n  }\n\n  md-menu-content[width="4"] {\n    min-width: 224px;\n  }\n\n  md-menu-content[width="5"] {\n    min-width: 280px;\n  }\n\n  md-menu-content[width="6"] {\n    min-width: 336px;\n  }\n\n  md-menu-content[width="7"] {\n    min-width: 392px;\n  }\n}\n@media (min-width: 960px) {\n  md-menu-content {\n    min-width: 96px;\n  }\n\n  md-menu-content[width="3"] {\n    min-width: 192px;\n  }\n\n  md-menu-content[width="4"] {\n    min-width: 256px;\n  }\n\n  md-menu-content[width="5"] {\n    min-width: 320px;\n  }\n\n  md-menu-content[width="6"] {\n    min-width: 384px;\n  }\n\n  md-menu-content[width="7"] {\n    min-width: 448px;\n  }\n}\nmd-toolbar.md-menu-toolbar h2.md-toolbar-tools {\n  line-height: 1rem;\n  height: auto;\n  padding: 28px;\n  padding-bottom: 12px;\n}\nmd-toolbar.md-has-open-menu {\n  position: relative;\n  z-index: 100;\n}\n\nmd-menu-bar {\n  padding: 0 20px;\n  display: block;\n  position: relative;\n  z-index: 2;\n}\nmd-menu-bar .md-menu {\n  display: inline-block;\n  padding: 0;\n  position: relative;\n}\nmd-menu-bar button {\n  font-size: 14px;\n  padding: 0 10px;\n  margin: 0;\n  border: 0;\n  background-color: transparent;\n  height: 40px;\n}\nmd-menu-bar md-backdrop.md-menu-backdrop {\n  z-index: -2;\n}\n\nmd-menu-content.md-menu-bar-menu.md-dense {\n  max-height: none;\n  padding: 16px 0;\n}\nmd-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent {\n  position: relative;\n}\nmd-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent > md-icon {\n  position: absolute;\n  padding: 0;\n  width: 24px;\n  top: 6px;\n  left: 24px;\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent > md-icon {\n  left: auto;\n  right: 24px;\n}\nmd-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent > .md-button, md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent .md-menu > .md-button {\n  padding: 0 32px 0 64px;\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent > .md-button, [dir=rtl] md-menu-content.md-menu-bar-menu.md-dense md-menu-item.md-indent .md-menu > .md-button {\n  padding: 0 64px 0 32px;\n}\nmd-menu-content.md-menu-bar-menu.md-dense .md-button {\n  min-height: 0;\n  height: 32px;\n}\nmd-menu-content.md-menu-bar-menu.md-dense .md-button span {\n  float: left;\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense .md-button span {\n  float: right;\n}\nmd-menu-content.md-menu-bar-menu.md-dense .md-button span.md-alt-text {\n  float: right;\n  margin: 0 8px;\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense .md-button span.md-alt-text {\n  float: left;\n}\nmd-menu-content.md-menu-bar-menu.md-dense md-menu-divider {\n  margin: 8px 0;\n}\nmd-menu-content.md-menu-bar-menu.md-dense md-menu-item > .md-button, md-menu-content.md-menu-bar-menu.md-dense .md-menu > .md-button {\n  text-align: left;\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense md-menu-item > .md-button, [dir=rtl] md-menu-content.md-menu-bar-menu.md-dense .md-menu > .md-button {\n  text-align: right;\n}\nmd-menu-content.md-menu-bar-menu.md-dense .md-menu {\n  padding: 0;\n}\nmd-menu-content.md-menu-bar-menu.md-dense .md-menu > .md-button {\n  position: relative;\n  margin: 0;\n  width: 100%;\n  text-transform: none;\n  font-weight: normal;\n  border-radius: 0px;\n  padding-left: 16px;\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense .md-menu > .md-button {\n  padding-left: 0;\n  padding-right: 16px;\n}\nmd-menu-content.md-menu-bar-menu.md-dense .md-menu > .md-button:after {\n  display: block;\n  content: "";\n  position: absolute;\n  top: 0px;\n  speak: none;\n  transform: rotate(270deg) scaleY(0.45) scaleX(0.9);\n  right: 28px;\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense .md-menu > .md-button:after {\n  transform: rotate(90deg) scaleY(0.45) scaleX(0.9);\n}\n[dir=rtl] md-menu-content.md-menu-bar-menu.md-dense .md-menu > .md-button:after {\n  right: auto;\n  left: 28px;\n}\n\n/** Matches "md-tabs md-tabs-wrapper" style. */\n.md-nav-bar {\n  border-style: solid;\n  border-width: 0 0 1px;\n  height: 48px;\n  position: relative;\n}\n\n._md-nav-bar-list {\n  outline: none;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: row;\n}\n\n.md-nav-item:first-of-type {\n  margin-left: 8px;\n}\n\n.md-button._md-nav-button {\n  line-height: 24px;\n  margin: 0 4px;\n  padding: 12px 16px;\n  transition: background-color 0.35s cubic-bezier(0.35, 0, 0.25, 1);\n}\n.md-button._md-nav-button:focus {\n  outline: none;\n}\n\nmd-nav-ink-bar {\n  background-color: black;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 2px;\n  transform-origin: left top;\n  will-change: transform;\n  transition: transform 0.125s cubic-bezier(0.35, 0, 0.25, 1);\n}\nmd-nav-ink-bar.ng-animate {\n  transition: none;\n}\n\nmd-nav-extra-content {\n  min-height: 48px;\n  padding-right: 12px;\n}\n\n@-webkit-keyframes indeterminate-rotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes indeterminate-rotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\nmd-progress-circular {\n  position: relative;\n  display: block;\n  transform: scale(1, 1);\n}\n[dir=rtl] md-progress-circular {\n  transform: scale(-1, 1);\n}\nmd-progress-circular._md-progress-circular-disabled {\n  visibility: hidden;\n}\nmd-progress-circular.md-mode-indeterminate svg {\n  -webkit-animation: indeterminate-rotate 1568.63ms linear infinite;\n          animation: indeterminate-rotate 1568.63ms linear infinite;\n}\nmd-progress-circular svg {\n  position: absolute;\n  overflow: visible;\n  top: 0;\n  left: 0;\n}\n\nmd-progress-linear {\n  display: block;\n  position: relative;\n  width: 100%;\n  height: 5px;\n  padding-top: 0 !important;\n  margin-bottom: 0 !important;\n  transform: scale(1, 1);\n}\n[dir=rtl] md-progress-linear {\n  transform: scale(-1, 1);\n}\nmd-progress-linear._md-progress-linear-disabled {\n  visibility: hidden;\n}\nmd-progress-linear .md-container {\n  display: block;\n  position: relative;\n  overflow: hidden;\n  width: 100%;\n  height: 5px;\n  transform: translate(0, 0) scale(1, 1);\n}\nmd-progress-linear .md-container .md-bar {\n  position: absolute;\n  left: 0;\n  top: 0;\n  bottom: 0;\n  width: 100%;\n  height: 5px;\n}\nmd-progress-linear .md-container .md-dashed:before {\n  content: "";\n  display: none;\n  position: absolute;\n  margin-top: 0;\n  height: 5px;\n  width: 100%;\n  background-color: transparent;\n  background-size: 10px 10px !important;\n  background-position: 0px -23px;\n}\nmd-progress-linear .md-container .md-bar1, md-progress-linear .md-container .md-bar2 {\n  transition: transform 0.2s linear;\n}\nmd-progress-linear .md-container.md-mode-query .md-bar1 {\n  display: none;\n}\nmd-progress-linear .md-container.md-mode-query .md-bar2 {\n  transition: all 0.2s linear;\n  -webkit-animation: query 0.8s infinite cubic-bezier(0.39, 0.575, 0.565, 1);\n          animation: query 0.8s infinite cubic-bezier(0.39, 0.575, 0.565, 1);\n}\nmd-progress-linear .md-container.md-mode-determinate .md-bar1 {\n  display: none;\n}\nmd-progress-linear .md-container.md-mode-indeterminate .md-bar1 {\n  -webkit-animation: md-progress-linear-indeterminate-scale-1 4s infinite, md-progress-linear-indeterminate-1 4s infinite;\n          animation: md-progress-linear-indeterminate-scale-1 4s infinite, md-progress-linear-indeterminate-1 4s infinite;\n}\nmd-progress-linear .md-container.md-mode-indeterminate .md-bar2 {\n  -webkit-animation: md-progress-linear-indeterminate-scale-2 4s infinite, md-progress-linear-indeterminate-2 4s infinite;\n          animation: md-progress-linear-indeterminate-scale-2 4s infinite, md-progress-linear-indeterminate-2 4s infinite;\n}\nmd-progress-linear .md-container.ng-hide ._md-progress-linear-disabled md-progress-linear .md-container {\n  -webkit-animation: none;\n          animation: none;\n}\nmd-progress-linear .md-container.ng-hide ._md-progress-linear-disabled md-progress-linear .md-container .md-bar1 {\n  -webkit-animation-name: none;\n          animation-name: none;\n}\nmd-progress-linear .md-container.ng-hide ._md-progress-linear-disabled md-progress-linear .md-container .md-bar2 {\n  -webkit-animation-name: none;\n          animation-name: none;\n}\nmd-progress-linear .md-container.md-mode-buffer {\n  background-color: transparent !important;\n  transition: all 0.2s linear;\n}\nmd-progress-linear .md-container.md-mode-buffer .md-dashed:before {\n  display: block;\n  -webkit-animation: buffer 3s infinite linear;\n          animation: buffer 3s infinite linear;\n}\n\n@-webkit-keyframes query {\n  0% {\n    opacity: 1;\n    transform: translateX(35%) scale(0.3, 1);\n  }\n  100% {\n    opacity: 0;\n    transform: translateX(-50%) scale(0, 1);\n  }\n}\n\n@keyframes query {\n  0% {\n    opacity: 1;\n    transform: translateX(35%) scale(0.3, 1);\n  }\n  100% {\n    opacity: 0;\n    transform: translateX(-50%) scale(0, 1);\n  }\n}\n@-webkit-keyframes buffer {\n  0% {\n    opacity: 1;\n    background-position: 0px -23px;\n  }\n  50% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n    background-position: -200px -23px;\n  }\n}\n@keyframes buffer {\n  0% {\n    opacity: 1;\n    background-position: 0px -23px;\n  }\n  50% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n    background-position: -200px -23px;\n  }\n}\n@-webkit-keyframes md-progress-linear-indeterminate-scale-1 {\n  0% {\n    transform: scaleX(0.1);\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n  }\n  36.6% {\n    transform: scaleX(0.1);\n    -webkit-animation-timing-function: cubic-bezier(0.334731432, 0.124819821, 0.785843996, 1);\n            animation-timing-function: cubic-bezier(0.334731432, 0.124819821, 0.785843996, 1);\n  }\n  69.15% {\n    transform: scaleX(0.83);\n    -webkit-animation-timing-function: cubic-bezier(0.225732004, 0, 0.233648906, 1.3709798);\n            animation-timing-function: cubic-bezier(0.225732004, 0, 0.233648906, 1.3709798);\n  }\n  100% {\n    transform: scaleX(0.1);\n  }\n}\n@keyframes md-progress-linear-indeterminate-scale-1 {\n  0% {\n    transform: scaleX(0.1);\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n  }\n  36.6% {\n    transform: scaleX(0.1);\n    -webkit-animation-timing-function: cubic-bezier(0.334731432, 0.124819821, 0.785843996, 1);\n            animation-timing-function: cubic-bezier(0.334731432, 0.124819821, 0.785843996, 1);\n  }\n  69.15% {\n    transform: scaleX(0.83);\n    -webkit-animation-timing-function: cubic-bezier(0.225732004, 0, 0.233648906, 1.3709798);\n            animation-timing-function: cubic-bezier(0.225732004, 0, 0.233648906, 1.3709798);\n  }\n  100% {\n    transform: scaleX(0.1);\n  }\n}\n@-webkit-keyframes md-progress-linear-indeterminate-1 {\n  0% {\n    left: -105.1666666667%;\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n  }\n  20% {\n    left: -105.1666666667%;\n    -webkit-animation-timing-function: cubic-bezier(0.5, 0, 0.701732, 0.495818703);\n            animation-timing-function: cubic-bezier(0.5, 0, 0.701732, 0.495818703);\n  }\n  69.15% {\n    left: 21.5%;\n    -webkit-animation-timing-function: cubic-bezier(0.302435, 0.38135197, 0.55, 0.956352125);\n            animation-timing-function: cubic-bezier(0.302435, 0.38135197, 0.55, 0.956352125);\n  }\n  100% {\n    left: 95.4444444444%;\n  }\n}\n@keyframes md-progress-linear-indeterminate-1 {\n  0% {\n    left: -105.1666666667%;\n    -webkit-animation-timing-function: linear;\n            animation-timing-function: linear;\n  }\n  20% {\n    left: -105.1666666667%;\n    -webkit-animation-timing-function: cubic-bezier(0.5, 0, 0.701732, 0.495818703);\n            animation-timing-function: cubic-bezier(0.5, 0, 0.701732, 0.495818703);\n  }\n  69.15% {\n    left: 21.5%;\n    -webkit-animation-timing-function: cubic-bezier(0.302435, 0.38135197, 0.55, 0.956352125);\n            animation-timing-function: cubic-bezier(0.302435, 0.38135197, 0.55, 0.956352125);\n  }\n  100% {\n    left: 95.4444444444%;\n  }\n}\n@-webkit-keyframes md-progress-linear-indeterminate-scale-2 {\n  0% {\n    transform: scaleX(0.1);\n    -webkit-animation-timing-function: cubic-bezier(0.205028172, 0.057050836, 0.57660995, 0.453970841);\n            animation-timing-function: cubic-bezier(0.205028172, 0.057050836, 0.57660995, 0.453970841);\n  }\n  19.15% {\n    transform: scaleX(0.57);\n    -webkit-animation-timing-function: cubic-bezier(0.152312994, 0.196431957, 0.648373778, 1.00431535);\n            animation-timing-function: cubic-bezier(0.152312994, 0.196431957, 0.648373778, 1.00431535);\n  }\n  44.15% {\n    transform: scaleX(0.91);\n    -webkit-animation-timing-function: cubic-bezier(0.25775882, -0.003163357, 0.211761916, 1.38178961);\n            animation-timing-function: cubic-bezier(0.25775882, -0.003163357, 0.211761916, 1.38178961);\n  }\n  100% {\n    transform: scaleX(0.1);\n  }\n}\n@keyframes md-progress-linear-indeterminate-scale-2 {\n  0% {\n    transform: scaleX(0.1);\n    -webkit-animation-timing-function: cubic-bezier(0.205028172, 0.057050836, 0.57660995, 0.453970841);\n            animation-timing-function: cubic-bezier(0.205028172, 0.057050836, 0.57660995, 0.453970841);\n  }\n  19.15% {\n    transform: scaleX(0.57);\n    -webkit-animation-timing-function: cubic-bezier(0.152312994, 0.196431957, 0.648373778, 1.00431535);\n            animation-timing-function: cubic-bezier(0.152312994, 0.196431957, 0.648373778, 1.00431535);\n  }\n  44.15% {\n    transform: scaleX(0.91);\n    -webkit-animation-timing-function: cubic-bezier(0.25775882, -0.003163357, 0.211761916, 1.38178961);\n            animation-timing-function: cubic-bezier(0.25775882, -0.003163357, 0.211761916, 1.38178961);\n  }\n  100% {\n    transform: scaleX(0.1);\n  }\n}\n@-webkit-keyframes md-progress-linear-indeterminate-2 {\n  0% {\n    left: -54.8888888889%;\n    -webkit-animation-timing-function: cubic-bezier(0.15, 0, 0.5150584, 0.409684966);\n            animation-timing-function: cubic-bezier(0.15, 0, 0.5150584, 0.409684966);\n  }\n  25% {\n    left: -17.25%;\n    -webkit-animation-timing-function: cubic-bezier(0.3103299, 0.284057684, 0.8, 0.733718979);\n            animation-timing-function: cubic-bezier(0.3103299, 0.284057684, 0.8, 0.733718979);\n  }\n  48.35% {\n    left: 29.5%;\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0.627034903, 0.6, 0.902025796);\n            animation-timing-function: cubic-bezier(0.4, 0.627034903, 0.6, 0.902025796);\n  }\n  100% {\n    left: 117.3888888889%;\n  }\n}\n@keyframes md-progress-linear-indeterminate-2 {\n  0% {\n    left: -54.8888888889%;\n    -webkit-animation-timing-function: cubic-bezier(0.15, 0, 0.5150584, 0.409684966);\n            animation-timing-function: cubic-bezier(0.15, 0, 0.5150584, 0.409684966);\n  }\n  25% {\n    left: -17.25%;\n    -webkit-animation-timing-function: cubic-bezier(0.3103299, 0.284057684, 0.8, 0.733718979);\n            animation-timing-function: cubic-bezier(0.3103299, 0.284057684, 0.8, 0.733718979);\n  }\n  48.35% {\n    left: 29.5%;\n    -webkit-animation-timing-function: cubic-bezier(0.4, 0.627034903, 0.6, 0.902025796);\n            animation-timing-function: cubic-bezier(0.4, 0.627034903, 0.6, 0.902025796);\n  }\n  100% {\n    left: 117.3888888889%;\n  }\n}\nmd-radio-button {\n  box-sizing: border-box;\n  display: block;\n  margin-bottom: 16px;\n  white-space: nowrap;\n  cursor: pointer;\n  position: relative;\n}\nmd-radio-button[disabled] {\n  cursor: default;\n}\nmd-radio-button[disabled] .md-container {\n  cursor: default;\n}\nmd-radio-button .md-container {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  box-sizing: border-box;\n  display: inline-block;\n  width: 20px;\n  height: 20px;\n  cursor: pointer;\n  left: 0;\n  right: auto;\n}\n[dir=rtl] md-radio-button .md-container {\n  left: auto;\n}\n[dir=rtl] md-radio-button .md-container {\n  right: 0;\n}\nmd-radio-button .md-container .md-ripple-container {\n  position: absolute;\n  display: block;\n  width: auto;\n  height: auto;\n  left: -15px;\n  top: -15px;\n  right: -15px;\n  bottom: -15px;\n}\nmd-radio-button .md-container:before {\n  box-sizing: border-box;\n  background-color: transparent;\n  border-radius: 50%;\n  content: "";\n  position: absolute;\n  display: block;\n  height: auto;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  transition: all 0.5s;\n  width: auto;\n}\nmd-radio-button.md-align-top-left > div.md-container {\n  top: 12px;\n}\nmd-radio-button .md-off {\n  box-sizing: border-box;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 20px;\n  height: 20px;\n  border-style: solid;\n  border-width: 2px;\n  border-radius: 50%;\n  transition: border-color ease 0.28s;\n}\nmd-radio-button .md-on {\n  box-sizing: border-box;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 20px;\n  height: 20px;\n  border-radius: 50%;\n  transition: transform ease 0.28s;\n  transform: scale(0);\n}\nmd-radio-button.md-checked .md-on {\n  transform: scale(0.5);\n}\nmd-radio-button .md-label {\n  box-sizing: border-box;\n  position: relative;\n  display: inline-block;\n  margin-left: 30px;\n  margin-right: 0;\n  vertical-align: middle;\n  white-space: normal;\n  pointer-events: none;\n  width: auto;\n}\n[dir=rtl] md-radio-button .md-label {\n  margin-left: 0;\n}\n[dir=rtl] md-radio-button .md-label {\n  margin-right: 30px;\n}\n\nmd-radio-group:focus {\n  outline: none;\n}\nmd-radio-group.md-focused.ng-not-empty .md-checked .md-container:before {\n  left: -8px;\n  top: -8px;\n  right: -8px;\n  bottom: -8px;\n}\nmd-radio-group.md-focused.ng-empty > md-radio-button:first-child .md-container:before {\n  left: -8px;\n  top: -8px;\n  right: -8px;\n  bottom: -8px;\n}\nmd-radio-group[disabled] md-radio-button {\n  cursor: default;\n}\nmd-radio-group[disabled] md-radio-button .md-container {\n  cursor: default;\n}\n\n@media (max-width: 599px) {\n  .layout-row:not(.layout-xs-column) > md-radio-button,\n.layout-xs-row > md-radio-button {\n    margin-bottom: 0;\n  }\n}\n@media (min-width: 600px) and (max-width: 959px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-sm-column) > md-radio-button,\n.layout-gt-xs-row:not(.layout-sm-column) > md-radio-button,\n.layout-sm-row:not(.layout-sm-column) > md-radio-button {\n    margin-bottom: 0;\n  }\n}\n@media (min-width: 960px) and (max-width: 1279px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-md-column) > md-radio-button,\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-md-column) > md-radio-button,\n.layout-gt-sm-row:not(.layout-md-column) > md-radio-button,\n.layout-md-row:not(.layout-md-column) > md-radio-button {\n    margin-bottom: 0;\n  }\n}\n@media (min-width: 1280px) and (max-width: 1919px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > md-radio-button,\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-lg-column) > md-radio-button,\n.layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-lg-column) > md-radio-button,\n.layout-gt-md-row:not(.layout-lg-column) > md-radio-button,\n.layout-lg-row:not(.layout-lg-column) > md-radio-button {\n    margin-bottom: 0;\n  }\n}\n@media (min-width: 1920px) {\n  .layout-row:not(.layout-gt-xs-column):not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > md-radio-button,\n.layout-gt-xs-row:not(.layout-gt-sm-column):not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > md-radio-button,\n.layout-gt-sm-row:not(.layout-gt-md-column):not(.layout-gt-lg-column):not(.layout-xl-column) > md-radio-button,\n.layout-gt-md-row:not(.layout-gt-lg-column):not(.layout-xl-column) > md-radio-button,\n.layout-gt-lg-row:not(.layout-gt-lg-column):not(.layout-xl-column) > md-radio-button,\n.layout-xl-row:not(.layout-gt-lg-column):not(.layout-xl-column) > md-radio-button {\n    margin-bottom: 0;\n  }\n}\n.md-inline-form md-radio-group {\n  margin: 18px 0 19px;\n}\n.md-inline-form md-radio-group md-radio-button {\n  display: inline-block;\n  height: 30px;\n  padding: 2px 10px 2px 6px;\n  box-sizing: border-box;\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.md-inline-form md-radio-group md-radio-button .md-label {\n  top: 4px;\n}\n.md-inline-form md-radio-group md-radio-button .md-container {\n  margin-top: 2px;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-radio-button.md-default-theme .md-on {\n    background-color: #fff;\n  }\n}\nmd-input-container:not([md-no-float]) .md-select-placeholder span:first-child {\n  transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transform-origin: left top;\n}\n[dir=rtl] md-input-container:not([md-no-float]) .md-select-placeholder span:first-child {\n  transform-origin: right top;\n}\nmd-input-container.md-input-focused:not([md-no-float]) md-select:not([placeholder]) .md-select-placeholder span:first-child {\n  transform: translate(-2px, -22px) scale(0.75);\n}\n\n.md-select-menu-container {\n  position: fixed;\n  left: 0;\n  top: 0;\n  z-index: 90;\n  opacity: 0;\n  display: none;\n  transform: translateY(-1px);\n}\n.md-select-menu-container:not(.md-clickable) {\n  pointer-events: none;\n}\n.md-select-menu-container md-progress-circular {\n  display: table;\n  margin: 24px auto !important;\n}\n.md-select-menu-container.md-active {\n  display: block;\n  opacity: 1;\n}\n.md-select-menu-container.md-active md-select-menu {\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-duration: 150ms;\n}\n.md-select-menu-container.md-active md-select-menu > * {\n  opacity: 1;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-duration: 150ms;\n  transition-delay: 100ms;\n}\n.md-select-menu-container.md-leave {\n  opacity: 0;\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-duration: 250ms;\n}\n\n.md-inline-form md-select {\n  margin-top: 20px;\n}\n\nmd-input-container > md-select, .md-inline-form md-input-container > md-select {\n  margin-top: 0px;\n}\nmd-input-container > md-select {\n  order: 2;\n}\n\nmd-input-container:not(.md-input-has-value) md-select[required]:not(.md-no-asterisk) .md-select-value span:first-child:after, md-input-container:not(.md-input-has-value) md-select.ng-required:not(.md-no-asterisk) .md-select-value span:first-child:after {\n  content: " *";\n  font-size: 13px;\n  vertical-align: top;\n}\n\nmd-input-container.md-input-invalid md-select .md-select-value {\n  border-bottom-style: solid;\n  padding-bottom: 1px;\n}\n\nmd-select {\n  display: flex;\n}\nmd-select[required].ng-empty.ng-invalid:not(.md-no-asterisk) .md-select-value span:first-child:after, md-select.ng-required.ng-empty.ng-invalid:not(.md-no-asterisk) .md-select-value span:first-child:after {\n  content: " *";\n  font-size: 13px;\n  vertical-align: top;\n}\nmd-select[disabled] .md-select-value {\n  background-position: bottom -1px left 0;\n  background-size: 4px 1px;\n  background-repeat: repeat-x;\n  padding-bottom: 2px;\n  padding-top: 1px;\n  transform: translateY(1px);\n}\nmd-select:focus {\n  outline: none;\n}\nmd-select[disabled]:hover {\n  cursor: default;\n}\nmd-select:not([disabled]):hover {\n  cursor: pointer;\n}\nmd-select:not([disabled]):focus .md-select-value {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  padding-bottom: 0px;\n}\n\nmd-input-container md-select:not([disabled]):focus .md-select-value {\n  border-bottom-width: 2px;\n}\nmd-input-container md-select[disabled] .md-select-value {\n  background-position: bottom -1px left 0;\n}\nmd-input-container md-select .md-select-value {\n  min-height: 26px;\n  border-bottom-width: 1px;\n  padding-bottom: 1px;\n}\nmd-input-container md-select .md-select-value.md-select-placeholder {\n  padding-left: 0;\n  padding-right: 2px;\n}\n[dir=rtl] md-input-container md-select .md-select-value.md-select-placeholder {\n  padding-left: 2px;\n}\n[dir=rtl] md-input-container md-select .md-select-value.md-select-placeholder {\n  padding-right: 0;\n}\n\n.md-select-value {\n  display: flex;\n  align-items: center;\n  padding-top: 2px;\n  padding-bottom: 1px;\n  padding-left: 0;\n  padding-right: 2px;\n  border-bottom-width: 1px;\n  border-bottom-style: solid;\n  background-color: rgba(0, 0, 0, 0);\n  position: relative;\n  box-sizing: content-box;\n  min-width: 88px;\n  min-height: 26px;\n  margin-bottom: auto;\n  -ms-flex-item-align: start;\n  flex-grow: 1;\n}\n[dir=rtl] .md-select-value {\n  padding-left: 2px;\n}\n[dir=rtl] .md-select-value {\n  padding-right: 0;\n}\n.md-select-value > span:not(.md-select-icon) {\n  max-width: 100%;\n  flex: 1 1 auto;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n}\n.md-select-value > span:not(.md-select-icon) .md-text {\n  display: inline;\n}\n.md-select-value .md-select-icon {\n  display: block;\n  align-items: flex-end;\n  text-align: right;\n  width: 24px;\n  transform: translateY(-2px);\n  font-size: 1.2rem;\n}\n[dir=rtl] .md-select-value .md-select-icon {\n  align-items: flex-start;\n}\n[dir=rtl] .md-select-value .md-select-icon {\n  text-align: left;\n}\n.md-select-value .md-select-icon:after {\n  display: block;\n  content: "";\n  position: relative;\n  top: 2px;\n  right: -4px;\n  left: auto;\n  speak: none;\n  font-size: 13px;\n  transform: scaleY(0.5);\n}\n[dir=rtl] .md-select-value .md-select-icon:after {\n  right: auto;\n}\n[dir=rtl] .md-select-value .md-select-icon:after {\n  left: -4px;\n}\n.md-select-value.md-select-placeholder {\n  display: flex;\n  order: 1;\n  pointer-events: none;\n  -webkit-font-smoothing: antialiased;\n  z-index: 1;\n}\n\nmd-select-menu {\n  display: flex;\n  flex-direction: column;\n  box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 2px 1px -1px rgba(0, 0, 0, 0.12);\n  max-height: 256px;\n  min-height: 48px;\n  overflow-y: hidden;\n  transform-origin: left top;\n  transform: scale(1);\n}\nmd-select-menu.md-reverse {\n  flex-direction: column-reverse;\n}\nmd-select-menu:not(.md-overflow) md-content {\n  padding-top: 8px;\n  padding-bottom: 8px;\n}\n[dir=rtl] md-select-menu {\n  transform-origin: right top;\n}\nmd-select-menu md-content {\n  min-width: 136px;\n  min-height: 48px;\n  max-height: 256px;\n  overflow-y: auto;\n}\nmd-select-menu > * {\n  opacity: 0;\n}\n\nmd-option {\n  cursor: pointer;\n  position: relative;\n  display: flex;\n  align-items: center;\n  width: auto;\n  transition: background 0.15s linear;\n  padding: 0 16px 0 16px;\n  height: 48px;\n}\nmd-option[disabled] {\n  cursor: default;\n}\nmd-option:focus {\n  outline: none;\n}\nmd-option .md-text {\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  width: auto;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\nmd-optgroup {\n  display: block;\n}\nmd-optgroup label {\n  display: block;\n  font-size: 14px;\n  text-transform: uppercase;\n  padding: 16px;\n  font-weight: 500;\n}\nmd-optgroup md-option {\n  padding-left: 32px;\n  padding-right: 32px;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  .md-select-backdrop {\n    background-color: transparent;\n  }\n\n  md-select-menu {\n    border: 1px solid #fff;\n  }\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled {\n  padding-left: 40px;\n  padding-right: 16px;\n}\n[dir=rtl] md-select-menu[multiple] md-option.md-checkbox-enabled {\n  padding-left: 16px;\n}\n[dir=rtl] md-select-menu[multiple] md-option.md-checkbox-enabled {\n  padding-right: 40px;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled .md-container {\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  box-sizing: border-box;\n  display: inline-block;\n  width: 18px;\n  height: 18px;\n  left: 0;\n  right: auto;\n}\n[dir=rtl] md-select-menu[multiple] md-option.md-checkbox-enabled .md-container {\n  left: auto;\n}\n[dir=rtl] md-select-menu[multiple] md-option.md-checkbox-enabled .md-container {\n  right: 0;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled .md-container:before {\n  box-sizing: border-box;\n  background-color: transparent;\n  border-radius: 50%;\n  content: "";\n  position: absolute;\n  display: block;\n  height: auto;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  transition: all 0.5s;\n  width: auto;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled .md-container:after {\n  box-sizing: border-box;\n  content: "";\n  position: absolute;\n  top: -10px;\n  right: -10px;\n  bottom: -10px;\n  left: -10px;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled .md-container .md-ripple-container {\n  position: absolute;\n  display: block;\n  width: auto;\n  height: auto;\n  left: -15px;\n  top: -15px;\n  right: -15px;\n  bottom: -15px;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled .md-icon {\n  box-sizing: border-box;\n  transition: 240ms;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 18px;\n  height: 18px;\n  border-width: 2px;\n  border-style: solid;\n  border-radius: 2px;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled[selected] .md-icon {\n  border-color: transparent;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled[selected] .md-icon:after {\n  box-sizing: border-box;\n  transform: rotate(45deg);\n  position: absolute;\n  left: 4px;\n  top: 0px;\n  display: table;\n  width: 6px;\n  height: 12px;\n  border-width: 2px;\n  border-style: solid;\n  border-top: 0;\n  border-left: 0;\n  content: "";\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled[disabled] {\n  cursor: default;\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled.md-indeterminate .md-icon:after {\n  box-sizing: border-box;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  display: table;\n  width: 10.8px;\n  height: 2px;\n  border-width: 2px;\n  border-style: solid;\n  border-top: 0;\n  border-left: 0;\n  content: "";\n}\nmd-select-menu[multiple] md-option.md-checkbox-enabled .md-container {\n  margin-left: 10.6666666667px;\n  margin-right: auto;\n}\n[dir=rtl] md-select-menu[multiple] md-option.md-checkbox-enabled .md-container {\n  margin-left: auto;\n}\n[dir=rtl] md-select-menu[multiple] md-option.md-checkbox-enabled .md-container {\n  margin-right: 10.6666666667px;\n}\n\nmd-sidenav {\n  box-sizing: border-box;\n  position: absolute;\n  flex-direction: column;\n  z-index: 60;\n  width: 320px;\n  max-width: 320px;\n  bottom: 0;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\nmd-sidenav ul {\n  list-style: none;\n}\nmd-sidenav.md-closed {\n  display: none;\n}\nmd-sidenav.md-closed-add, md-sidenav.md-closed-remove {\n  display: flex;\n  transition: 0.2s ease-in all;\n}\nmd-sidenav.md-closed-add.md-closed-add-active, md-sidenav.md-closed-remove.md-closed-remove-active {\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\nmd-sidenav.md-locked-open-add, md-sidenav.md-locked-open-remove {\n  position: static;\n  display: flex;\n  transform: translate3d(0, 0, 0);\n}\nmd-sidenav.md-locked-open, md-sidenav.md-locked-open.md-closed, md-sidenav.md-locked-open.md-closed.md-sidenav-left, md-sidenav.md-locked-open.md-closed.md-sidenav-right {\n  position: static;\n  display: flex;\n  transform: translate3d(0, 0, 0);\n}\nmd-sidenav.md-locked-open-remove.md-closed {\n  position: static;\n  display: flex;\n  transform: translate3d(0, 0, 0);\n}\nmd-sidenav.md-closed.md-locked-open-add {\n  position: static;\n  display: flex;\n  transform: translate3d(0%, 0, 0);\n}\nmd-sidenav.md-closed.md-locked-open-add:not(.md-locked-open-add-active) {\n  transition: width 0.3s cubic-bezier(0.55, 0, 0.55, 0.2), min-width 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  width: 0 !important;\n  min-width: 0 !important;\n}\nmd-sidenav.md-closed.md-locked-open-add-active {\n  transition: width 0.3s cubic-bezier(0.55, 0, 0.55, 0.2), min-width 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n}\nmd-sidenav.md-locked-open-remove-active {\n  transition: width 0.3s cubic-bezier(0.55, 0, 0.55, 0.2), min-width 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  width: 0 !important;\n  min-width: 0 !important;\n}\n\n.md-sidenav-backdrop.md-locked-open {\n  display: none;\n}\n\n.md-sidenav-left, md-sidenav {\n  left: 0;\n  top: 0;\n  transform: translate3d(0%, 0, 0);\n}\n.md-sidenav-left.md-closed, md-sidenav.md-closed {\n  transform: translate3d(-100%, 0, 0);\n}\n\n.md-sidenav-right {\n  left: 100%;\n  top: 0;\n  transform: translate(-100%, 0);\n}\n.md-sidenav-right.md-closed {\n  transform: translate(0%, 0);\n}\n\n@media (min-width: 600px) {\n  md-sidenav {\n    max-width: 400px;\n  }\n}\n@media (max-width: 456px) {\n  md-sidenav {\n    width: calc(100% - 56px);\n    min-width: calc(100% - 56px);\n    max-width: calc(100% - 56px);\n  }\n}\n@media screen and (-ms-high-contrast: active) {\n  .md-sidenav-left, md-sidenav {\n    border-right: 1px solid #fff;\n  }\n\n  .md-sidenav-right {\n    border-left: 1px solid #fff;\n  }\n}\n@-webkit-keyframes sliderFocusThumb {\n  0% {\n    transform: scale(0.7);\n  }\n  30% {\n    transform: scale(1);\n  }\n  100% {\n    transform: scale(0.7);\n  }\n}\n@keyframes sliderFocusThumb {\n  0% {\n    transform: scale(0.7);\n  }\n  30% {\n    transform: scale(1);\n  }\n  100% {\n    transform: scale(0.7);\n  }\n}\n@-webkit-keyframes sliderDiscreteFocusThumb {\n  0% {\n    transform: scale(0.7);\n  }\n  50% {\n    transform: scale(0.8);\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n@keyframes sliderDiscreteFocusThumb {\n  0% {\n    transform: scale(0.7);\n  }\n  50% {\n    transform: scale(0.8);\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n@-webkit-keyframes sliderDiscreteFocusRing {\n  0% {\n    transform: scale(0.7);\n    opacity: 0;\n  }\n  50% {\n    transform: scale(1);\n    opacity: 1;\n  }\n  100% {\n    transform: scale(0);\n  }\n}\n@keyframes sliderDiscreteFocusRing {\n  0% {\n    transform: scale(0.7);\n    opacity: 0;\n  }\n  50% {\n    transform: scale(1);\n    opacity: 1;\n  }\n  100% {\n    transform: scale(0);\n  }\n}\nmd-slider {\n  height: 48px;\n  min-width: 128px;\n  position: relative;\n  margin-left: 4px;\n  margin-right: 4px;\n  padding: 0;\n  display: block;\n  flex-direction: row;\n  /**\n   * Track\n   */\n  /**\n   * Slider thumb\n   */\n  /* The sign that's focused in discrete mode */\n  /**\n   * The border/background that comes in when focused in non-discrete mode\n   */\n  /* Don't animate left/right while panning */\n}\nmd-slider *, md-slider *:after {\n  box-sizing: border-box;\n}\nmd-slider .md-slider-wrapper {\n  outline: none;\n  width: 100%;\n  height: 100%;\n}\nmd-slider .md-slider-content {\n  position: relative;\n}\nmd-slider .md-track-container {\n  width: 100%;\n  position: absolute;\n  top: 23px;\n  height: 2px;\n}\nmd-slider .md-track {\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 100%;\n}\nmd-slider .md-track-fill {\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-property: width, height;\n}\nmd-slider .md-track-ticks {\n  position: absolute;\n  left: 0;\n  right: 0;\n  height: 100%;\n}\nmd-slider .md-track-ticks canvas {\n  width: 100%;\n  height: 100%;\n}\nmd-slider .md-thumb-container {\n  position: absolute;\n  left: 0;\n  top: 50%;\n  transform: translate3d(-50%, -50%, 0);\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-property: left, right, bottom;\n}\n[dir=rtl] md-slider .md-thumb-container {\n  left: auto;\n  right: 0;\n}\nmd-slider .md-thumb {\n  z-index: 1;\n  position: absolute;\n  left: -10px;\n  top: 14px;\n  width: 20px;\n  height: 20px;\n  border-radius: 20px;\n  transform: scale(0.7);\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\n[dir=rtl] md-slider .md-thumb {\n  left: auto;\n  right: -10px;\n}\nmd-slider .md-thumb:after {\n  content: "";\n  position: absolute;\n  width: 20px;\n  height: 20px;\n  border-radius: 20px;\n  border-width: 3px;\n  border-style: solid;\n  transition: inherit;\n}\nmd-slider .md-sign {\n  /* Center the children (slider-thumb-text) */\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  left: -14px;\n  top: -17px;\n  width: 28px;\n  height: 28px;\n  border-radius: 28px;\n  transform: scale(0.4) translate3d(0, 67.5px, 0);\n  transition: all 0.3s cubic-bezier(0.35, 0, 0.25, 1);\n  /* The arrow pointing down under the sign */\n}\nmd-slider .md-sign:after {\n  position: absolute;\n  content: "";\n  left: 0px;\n  border-radius: 16px;\n  top: 19px;\n  border-left: 14px solid transparent;\n  border-right: 14px solid transparent;\n  border-top-width: 16px;\n  border-top-style: solid;\n  opacity: 0;\n  transform: translate3d(0, -8px, 0);\n  transition: all 0.2s cubic-bezier(0.35, 0, 0.25, 1);\n}\n[dir=rtl] md-slider .md-sign:after {\n  left: auto;\n  right: 0px;\n}\nmd-slider .md-sign .md-thumb-text {\n  z-index: 1;\n  font-size: 12px;\n  font-weight: bold;\n}\nmd-slider .md-focus-ring {\n  position: absolute;\n  left: -17px;\n  top: 7px;\n  width: 34px;\n  height: 34px;\n  border-radius: 34px;\n  transform: scale(0.7);\n  opacity: 0;\n  transition: all 0.35s cubic-bezier(0.35, 0, 0.25, 1);\n}\n[dir=rtl] md-slider .md-focus-ring {\n  left: auto;\n  right: -17px;\n}\nmd-slider .md-disabled-thumb {\n  position: absolute;\n  left: -14px;\n  top: 10px;\n  width: 28px;\n  height: 28px;\n  border-radius: 28px;\n  transform: scale(0.5);\n  border-width: 4px;\n  border-style: solid;\n  display: none;\n}\n[dir=rtl] md-slider .md-disabled-thumb {\n  left: auto;\n  right: -14px;\n}\nmd-slider.md-min .md-sign {\n  opacity: 0;\n}\nmd-slider:focus {\n  outline: none;\n}\nmd-slider.md-dragging .md-thumb-container,\nmd-slider.md-dragging .md-track-fill {\n  transition: none;\n}\nmd-slider:not([md-discrete]) {\n  /* Hide the sign and ticks in non-discrete mode */\n}\nmd-slider:not([md-discrete]) .md-track-ticks,\nmd-slider:not([md-discrete]) .md-sign {\n  display: none;\n}\nmd-slider:not([md-discrete]):not([disabled]) .md-slider-wrapper .md-thumb:hover {\n  transform: scale(0.8);\n}\nmd-slider:not([md-discrete]):not([disabled]) .md-slider-wrapper.md-focused .md-focus-ring {\n  transform: scale(1);\n  opacity: 1;\n}\nmd-slider:not([md-discrete]):not([disabled]) .md-slider-wrapper.md-focused .md-thumb {\n  -webkit-animation: sliderFocusThumb 0.7s cubic-bezier(0.35, 0, 0.25, 1);\n          animation: sliderFocusThumb 0.7s cubic-bezier(0.35, 0, 0.25, 1);\n}\nmd-slider:not([md-discrete]):not([disabled]).md-active .md-slider-wrapper .md-thumb {\n  transform: scale(1);\n}\nmd-slider[md-discrete]:not([disabled]) .md-slider-wrapper.md-focused .md-focus-ring {\n  transform: scale(0);\n  -webkit-animation: sliderDiscreteFocusRing 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n          animation: sliderDiscreteFocusRing 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n}\nmd-slider[md-discrete]:not([disabled]) .md-slider-wrapper.md-focused .md-thumb {\n  -webkit-animation: sliderDiscreteFocusThumb 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n          animation: sliderDiscreteFocusThumb 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n}\nmd-slider[md-discrete]:not([disabled]) .md-slider-wrapper.md-focused .md-thumb, md-slider[md-discrete]:not([disabled]).md-active .md-thumb {\n  transform: scale(0);\n}\nmd-slider[md-discrete]:not([disabled]) .md-slider-wrapper.md-focused .md-sign,\nmd-slider[md-discrete]:not([disabled]) .md-slider-wrapper.md-focused .md-sign:after, md-slider[md-discrete]:not([disabled]).md-active .md-sign,\nmd-slider[md-discrete]:not([disabled]).md-active .md-sign:after {\n  opacity: 1;\n  transform: translate3d(0, 0, 0) scale(1);\n}\nmd-slider[md-discrete][disabled][readonly] .md-thumb {\n  transform: scale(0);\n}\nmd-slider[md-discrete][disabled][readonly] .md-sign,\nmd-slider[md-discrete][disabled][readonly] .md-sign:after {\n  opacity: 1;\n  transform: translate3d(0, 0, 0) scale(1);\n}\nmd-slider[disabled] .md-track-fill {\n  display: none;\n}\nmd-slider[disabled] .md-track-ticks {\n  opacity: 0;\n}\nmd-slider[disabled]:not([readonly]) .md-sign {\n  opacity: 0;\n}\nmd-slider[disabled] .md-thumb {\n  transform: scale(0.5);\n}\nmd-slider[disabled] .md-disabled-thumb {\n  display: block;\n}\nmd-slider[md-vertical] {\n  flex-direction: column;\n  min-height: 128px;\n  min-width: 0;\n}\nmd-slider[md-vertical] .md-slider-wrapper {\n  flex: 1;\n  padding-top: 12px;\n  padding-bottom: 12px;\n  width: 48px;\n  align-self: center;\n  display: flex;\n  justify-content: center;\n}\nmd-slider[md-vertical] .md-track-container {\n  height: 100%;\n  width: 2px;\n  top: 0;\n  left: calc(50% - (2px / 2));\n}\nmd-slider[md-vertical] .md-thumb-container {\n  top: auto;\n  margin-bottom: 23px;\n  left: calc(50% - 1px);\n  bottom: 0;\n}\nmd-slider[md-vertical] .md-thumb-container .md-thumb:after {\n  left: 1px;\n}\nmd-slider[md-vertical] .md-thumb-container .md-focus-ring {\n  left: -16px;\n}\nmd-slider[md-vertical] .md-track-fill {\n  bottom: 0;\n}\nmd-slider[md-vertical][md-discrete] .md-sign {\n  left: -40px;\n  top: 9.5px;\n  transform: scale(0.4) translate3d(67.5px, 0, 0);\n  /* The arrow pointing left next the sign */\n}\nmd-slider[md-vertical][md-discrete] .md-sign:after {\n  top: 9.5px;\n  left: 19px;\n  border-top: 14px solid transparent;\n  border-right: 0;\n  border-bottom: 14px solid transparent;\n  border-left-width: 16px;\n  border-left-style: solid;\n  opacity: 0;\n  transform: translate3d(0, -8px, 0);\n  transition: all 0.2s ease-in-out;\n}\nmd-slider[md-vertical][md-discrete] .md-sign .md-thumb-text {\n  z-index: 1;\n  font-size: 12px;\n  font-weight: bold;\n}\nmd-slider[md-vertical][md-discrete].md-active .md-sign:after,\nmd-slider[md-vertical][md-discrete] .md-focused .md-sign:after, md-slider[md-vertical][md-discrete][disabled][readonly] .md-sign:after {\n  top: 0;\n}\nmd-slider[md-vertical][disabled][readonly] .md-thumb {\n  transform: scale(0);\n}\nmd-slider[md-vertical][disabled][readonly] .md-sign,\nmd-slider[md-vertical][disabled][readonly] .md-sign:after {\n  opacity: 1;\n  transform: translate3d(0, 0, 0) scale(1);\n}\nmd-slider[md-invert]:not([md-vertical]) .md-track-fill {\n  left: auto;\n  right: 0;\n}\n[dir=rtl] md-slider[md-invert]:not([md-vertical]) .md-track-fill {\n  left: 0;\n}\n[dir=rtl] md-slider[md-invert]:not([md-vertical]) .md-track-fill {\n  right: auto;\n}\nmd-slider[md-invert][md-vertical] .md-track-fill {\n  bottom: auto;\n  top: 0;\n}\n\nmd-slider-container {\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n}\nmd-slider-container > *:first-child:not(md-slider), md-slider-container > *:last-child:not(md-slider) {\n  min-width: 25px;\n  max-width: 42px;\n  height: 25px;\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-property: color, max-width;\n}\nmd-slider-container > *:first-child:not(md-slider) {\n  margin-right: 16px;\n}\n[dir=rtl] md-slider-container > *:first-child:not(md-slider) {\n  margin-right: auto;\n  margin-left: 16px;\n}\nmd-slider-container > *:last-child:not(md-slider) {\n  margin-left: 16px;\n}\n[dir=rtl] md-slider-container > *:last-child:not(md-slider) {\n  margin-left: auto;\n  margin-right: 16px;\n}\nmd-slider-container[md-vertical] {\n  flex-direction: column;\n}\nmd-slider-container[md-vertical] > *:first-child:not(md-slider), md-slider-container[md-vertical] > *:last-child:not(md-slider) {\n  margin-right: 0;\n  margin-left: 0;\n  text-align: center;\n}\nmd-slider-container md-input-container input[type=number] {\n  text-align: center;\n  padding-left: 15px;\n  height: 50px;\n  margin-top: -25px;\n}\n[dir=rtl] md-slider-container md-input-container input[type=number] {\n  padding-left: 0;\n  padding-right: 15px;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-slider.md-default-theme .md-track {\n    border-bottom: 1px solid #fff;\n  }\n}\n.md-sticky-clone {\n  z-index: 2;\n  top: 0;\n  left: 0;\n  right: 0;\n  position: absolute !important;\n  transform: translate3d(-9999px, -9999px, 0);\n}\n.md-sticky-clone[sticky-state=active] {\n  transform: translate3d(0, 0, 0);\n}\n.md-sticky-clone[sticky-state=active]:not(.md-sticky-no-effect) .md-subheader-inner {\n  -webkit-animation: subheaderStickyHoverIn 0.3s ease-out both;\n          animation: subheaderStickyHoverIn 0.3s ease-out both;\n}\n\n@-webkit-keyframes subheaderStickyHoverIn {\n  0% {\n    box-shadow: 0 0 0 0 transparent;\n  }\n  100% {\n    box-shadow: 0px 2px 4px 0 rgba(0, 0, 0, 0.16);\n  }\n}\n\n@keyframes subheaderStickyHoverIn {\n  0% {\n    box-shadow: 0 0 0 0 transparent;\n  }\n  100% {\n    box-shadow: 0px 2px 4px 0 rgba(0, 0, 0, 0.16);\n  }\n}\n@-webkit-keyframes subheaderStickyHoverOut {\n  0% {\n    box-shadow: 0px 2px 4px 0 rgba(0, 0, 0, 0.16);\n  }\n  100% {\n    box-shadow: 0 0 0 0 transparent;\n  }\n}\n@keyframes subheaderStickyHoverOut {\n  0% {\n    box-shadow: 0px 2px 4px 0 rgba(0, 0, 0, 0.16);\n  }\n  100% {\n    box-shadow: 0 0 0 0 transparent;\n  }\n}\n.md-subheader-wrapper:not(.md-sticky-no-effect) {\n  transition: 0.2s ease-out margin;\n}\n.md-subheader-wrapper:not(.md-sticky-no-effect) .md-subheader {\n  margin: 0;\n}\n.md-subheader-wrapper:not(.md-sticky-no-effect).md-sticky-clone {\n  z-index: 2;\n}\n.md-subheader-wrapper:not(.md-sticky-no-effect)[sticky-state=active] {\n  margin-top: -2px;\n}\n.md-subheader-wrapper:not(.md-sticky-no-effect):not(.md-sticky-clone)[sticky-prev-state=active] .md-subheader-inner:after {\n  -webkit-animation: subheaderStickyHoverOut 0.3s ease-out both;\n          animation: subheaderStickyHoverOut 0.3s ease-out both;\n}\n\n.md-subheader {\n  display: block;\n  font-size: 14px;\n  font-weight: 500;\n  line-height: 1em;\n  margin: 0 0 0 0;\n  position: relative;\n}\n.md-subheader .md-subheader-inner {\n  display: block;\n  padding: 16px;\n}\n.md-subheader .md-subheader-content {\n  display: block;\n  z-index: 1;\n  position: relative;\n}\n\n[md-swipe-left], [md-swipe-right] {\n  touch-action: pan-y;\n}\n\n[md-swipe-up], [md-swipe-down] {\n  touch-action: pan-x;\n}\n\n.md-inline-form md-switch {\n  margin-top: 18px;\n  margin-bottom: 19px;\n}\n\nmd-switch {\n  margin: 16px 0;\n  white-space: nowrap;\n  cursor: pointer;\n  outline: none;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  height: 30px;\n  line-height: 28px;\n  align-items: center;\n  display: flex;\n  margin-left: inherit;\n  margin-right: 16px;\n}\n[dir=rtl] md-switch {\n  margin-left: 16px;\n}\n[dir=rtl] md-switch {\n  margin-right: inherit;\n}\nmd-switch:last-of-type {\n  margin-left: inherit;\n  margin-right: 0;\n}\n[dir=rtl] md-switch:last-of-type {\n  margin-left: 0;\n}\n[dir=rtl] md-switch:last-of-type {\n  margin-right: inherit;\n}\nmd-switch[disabled] {\n  cursor: default;\n}\nmd-switch[disabled] .md-container {\n  cursor: default;\n}\nmd-switch .md-container {\n  cursor: -webkit-grab;\n  cursor: grab;\n  width: 36px;\n  height: 24px;\n  position: relative;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  margin-right: 8px;\n  float: left;\n}\n[dir=rtl] md-switch .md-container {\n  margin-right: 0px;\n  margin-left: 8px;\n}\nmd-switch.md-inverted .md-container {\n  margin-right: initial;\n  margin-left: 8px;\n}\n[dir=rtl] md-switch.md-inverted .md-container {\n  margin-right: 8px;\n}\n[dir=rtl] md-switch.md-inverted .md-container {\n  margin-left: initial;\n}\nmd-switch:not([disabled]) .md-dragging, md-switch:not([disabled]).md-dragging .md-container {\n  cursor: -webkit-grabbing;\n  cursor: grabbing;\n}\nmd-switch.md-focused .md-thumb:before {\n  left: -8px;\n  top: -8px;\n  right: -8px;\n  bottom: -8px;\n}\nmd-switch .md-label {\n  border-color: transparent;\n  border-width: 0;\n  float: left;\n}\nmd-switch .md-bar {\n  left: 1px;\n  width: 34px;\n  top: 5px;\n  height: 14px;\n  border-radius: 8px;\n  position: absolute;\n}\nmd-switch .md-thumb-container {\n  top: 2px;\n  left: 0;\n  width: 16px;\n  position: absolute;\n  transform: translate3d(0, 0, 0);\n  z-index: 1;\n}\nmd-switch.md-checked .md-thumb-container {\n  transform: translate3d(100%, 0, 0);\n}\nmd-switch .md-thumb {\n  position: absolute;\n  margin: 0;\n  left: 0;\n  top: 0;\n  outline: none;\n  height: 20px;\n  width: 20px;\n  border-radius: 50%;\n  box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 2px 1px -1px rgba(0, 0, 0, 0.12);\n}\nmd-switch .md-thumb:before {\n  background-color: transparent;\n  border-radius: 50%;\n  content: "";\n  position: absolute;\n  display: block;\n  height: auto;\n  left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  transition: all 0.5s;\n  width: auto;\n}\nmd-switch .md-thumb .md-ripple-container {\n  position: absolute;\n  display: block;\n  width: auto;\n  height: auto;\n  left: -20px;\n  top: -20px;\n  right: -20px;\n  bottom: -20px;\n}\nmd-switch:not(.md-dragging) .md-bar,\nmd-switch:not(.md-dragging) .md-thumb-container,\nmd-switch:not(.md-dragging) .md-thumb {\n  transition: all 0.08s linear;\n  transition-property: transform, background-color;\n}\nmd-switch:not(.md-dragging) .md-bar,\nmd-switch:not(.md-dragging) .md-thumb {\n  transition-delay: 0.05s;\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-switch.md-default-theme .md-bar {\n    background-color: #666;\n  }\n\n  md-switch.md-default-theme.md-checked .md-bar {\n    background-color: #9E9E9E;\n  }\n\n  md-switch.md-default-theme .md-thumb {\n    background-color: #fff;\n  }\n}\n@-webkit-keyframes md-tab-content-hide {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 1;\n  }\n  100% {\n    opacity: 0;\n  }\n}\n@keyframes md-tab-content-hide {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 1;\n  }\n  100% {\n    opacity: 0;\n  }\n}\nmd-tab-data {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  z-index: -1;\n  opacity: 0;\n}\n\nmd-tabs {\n  display: block;\n  margin: 0;\n  border-radius: 2px;\n  overflow: hidden;\n  position: relative;\n  flex-shrink: 0;\n}\nmd-tabs:not(.md-no-tab-content):not(.md-dynamic-height) {\n  min-height: 248px;\n}\nmd-tabs[md-align-tabs=bottom] {\n  padding-bottom: 48px;\n}\nmd-tabs[md-align-tabs=bottom] > md-tabs-wrapper {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  height: 48px;\n  z-index: 2;\n}\nmd-tabs[md-align-tabs=bottom] > md-tabs-content-wrapper {\n  top: 0;\n  bottom: 48px;\n}\nmd-tabs.md-dynamic-height md-tabs-content-wrapper {\n  min-height: 0;\n  position: relative;\n  top: auto;\n  left: auto;\n  right: auto;\n  bottom: auto;\n  overflow: visible;\n}\nmd-tabs.md-dynamic-height md-tab-content.md-active {\n  position: relative;\n}\nmd-tabs[md-border-bottom] md-tabs-wrapper {\n  border-width: 0 0 1px;\n  border-style: solid;\n}\nmd-tabs[md-border-bottom]:not(.md-dynamic-height) md-tabs-content-wrapper {\n  top: 49px;\n}\n\nmd-tabs-wrapper {\n  display: block;\n  position: relative;\n  transform: translate(0, 0);\n}\nmd-tabs-wrapper md-prev-button, md-tabs-wrapper md-next-button {\n  height: 100%;\n  width: 32px;\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n  line-height: 1em;\n  z-index: 2;\n  cursor: pointer;\n  font-size: 16px;\n  background: transparent no-repeat center center;\n  transition: all 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n}\nmd-tabs-wrapper md-prev-button:focus, md-tabs-wrapper md-next-button:focus {\n  outline: none;\n}\nmd-tabs-wrapper md-prev-button.md-disabled, md-tabs-wrapper md-next-button.md-disabled {\n  opacity: 0.25;\n  cursor: default;\n}\nmd-tabs-wrapper md-prev-button.ng-leave, md-tabs-wrapper md-next-button.ng-leave {\n  transition: none;\n}\nmd-tabs-wrapper md-prev-button md-icon, md-tabs-wrapper md-next-button md-icon {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n[dir=rtl] md-tabs-wrapper md-prev-button, [dir=rtl] md-tabs-wrapper md-next-button {\n  transform: rotateY(180deg) translateY(-50%);\n}\nmd-tabs-wrapper md-prev-button {\n  left: 0;\n  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\n}\n[dir=rtl] md-tabs-wrapper md-prev-button {\n  left: auto;\n  right: 0;\n}\nmd-tabs-wrapper md-next-button {\n  right: 0;\n  background-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});\n}\n[dir=rtl] md-tabs-wrapper md-next-button {\n  right: auto;\n  left: 0;\n}\nmd-tabs-wrapper md-next-button md-icon {\n  transform: translate(-50%, -50%) rotate(180deg);\n}\nmd-tabs-wrapper.md-stretch-tabs md-pagination-wrapper {\n  width: 100%;\n  flex-direction: row;\n}\nmd-tabs-wrapper.md-stretch-tabs md-pagination-wrapper md-tab-item {\n  flex-grow: 1;\n}\n\nmd-tabs-canvas {\n  position: relative;\n  overflow: hidden;\n  display: block;\n  height: 48px;\n}\nmd-tabs-canvas:after {\n  content: "";\n  display: table;\n  clear: both;\n}\nmd-tabs-canvas .md-dummy-wrapper {\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n[dir=rtl] md-tabs-canvas .md-dummy-wrapper {\n  left: auto;\n  right: 0;\n}\nmd-tabs-canvas.md-paginated {\n  margin: 0 32px;\n}\nmd-tabs-canvas.md-center-tabs {\n  display: flex;\n  flex-direction: column;\n  text-align: center;\n}\nmd-tabs-canvas.md-center-tabs .md-tab {\n  float: none;\n  display: inline-block;\n}\n\nmd-pagination-wrapper {\n  height: 48px;\n  display: flex;\n  transition: transform 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n  position: absolute;\n  left: 0;\n  transform: translate(0, 0);\n}\nmd-pagination-wrapper:after {\n  content: "";\n  display: table;\n  clear: both;\n}\n[dir=rtl] md-pagination-wrapper {\n  left: auto;\n  right: 0;\n}\nmd-pagination-wrapper.md-center-tabs {\n  position: relative;\n  justify-content: center;\n}\nmd-pagination-wrapper md-tab-item {\n  min-width: 72px;\n}\n@media (min-width: 600px) {\n  md-pagination-wrapper md-tab-item {\n    min-width: 160px;\n  }\n}\n\nmd-tabs-content-wrapper {\n  display: block;\n  position: absolute;\n  top: 48px;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  overflow: hidden;\n}\n\nmd-tab-content {\n  display: flex;\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  transition: transform 0.5s cubic-bezier(0.35, 0, 0.25, 1);\n  overflow: auto;\n  transform: translate(0, 0);\n}\nmd-tab-content.md-no-scroll {\n  bottom: auto;\n  overflow: hidden;\n}\nmd-tab-content.ng-leave, md-tab-content.md-no-transition {\n  transition: none;\n}\nmd-tab-content.md-left:not(.md-active) {\n  transform: translateX(-100%);\n  -webkit-animation: 1s md-tab-content-hide;\n          animation: 1s md-tab-content-hide;\n  visibility: hidden;\n}\n[dir=rtl] md-tab-content.md-left:not(.md-active) {\n  transform: translateX(100%);\n}\nmd-tab-content.md-left:not(.md-active) * {\n  transition: visibility 0s linear;\n  transition-delay: 0.5s;\n  visibility: hidden;\n}\nmd-tab-content.md-right:not(.md-active) {\n  transform: translateX(100%);\n  -webkit-animation: 1s md-tab-content-hide;\n          animation: 1s md-tab-content-hide;\n  visibility: hidden;\n}\n[dir=rtl] md-tab-content.md-right:not(.md-active) {\n  transform: translateX(-100%);\n}\nmd-tab-content.md-right:not(.md-active) * {\n  transition: visibility 0s linear;\n  transition-delay: 0.5s;\n  visibility: hidden;\n}\nmd-tab-content > div {\n  flex: 1 0 100%;\n  min-width: 0;\n}\nmd-tab-content > div.ng-leave {\n  -webkit-animation: 1s md-tab-content-hide;\n          animation: 1s md-tab-content-hide;\n}\n\nmd-ink-bar {\n  position: absolute;\n  left: auto;\n  right: auto;\n  bottom: 0;\n  height: 2px;\n}\nmd-ink-bar.md-left {\n  transition: left 0.125s cubic-bezier(0.35, 0, 0.25, 1), right 0.25s cubic-bezier(0.35, 0, 0.25, 1);\n}\nmd-ink-bar.md-right {\n  transition: left 0.25s cubic-bezier(0.35, 0, 0.25, 1), right 0.125s cubic-bezier(0.35, 0, 0.25, 1);\n}\n\nmd-tab {\n  position: absolute;\n  z-index: -1;\n  left: -9999px;\n}\n\n.md-tab {\n  font-size: 14px;\n  text-align: center;\n  line-height: 24px;\n  padding: 12px;\n  transition: background-color 0.35s cubic-bezier(0.35, 0, 0.25, 1);\n  cursor: pointer;\n  white-space: nowrap;\n  position: relative;\n  text-transform: uppercase;\n  float: left;\n  font-weight: 500;\n  box-sizing: border-box;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n[dir=rtl] .md-tab {\n  float: right;\n}\n.md-tab.md-focused, .md-tab:focus {\n  box-shadow: none;\n  outline: none;\n}\n.md-tab.md-active {\n  cursor: default;\n}\n.md-tab.md-disabled {\n  pointer-events: none;\n  touch-action: pan-y;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-user-drag: none;\n  opacity: 0.5;\n  cursor: default;\n}\n.md-tab.ng-leave {\n  transition: none;\n}\n\nmd-toolbar + md-tabs, md-toolbar + md-dialog-content md-tabs {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n\n.md-toast-text {\n  padding: 0 8px;\n}\n\nmd-toast {\n  position: absolute;\n  z-index: 105;\n  box-sizing: border-box;\n  cursor: default;\n  overflow: hidden;\n  padding: 8px;\n  opacity: 1;\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  /* Transition differently when swiping */\n  /*\n   * When the toast doesn't take up the whole screen,\n   * make it rotate when the user swipes it away\n   */\n}\nmd-toast .md-toast-content {\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  max-height: 168px;\n  max-width: 100%;\n  min-height: 48px;\n  padding: 0 16px;\n  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);\n  border-radius: 2px;\n  font-size: 14px;\n  overflow: hidden;\n  transform: translate3d(0, 0, 0) rotateZ(0deg);\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  justify-content: flex-start;\n}\nmd-toast .md-toast-content::before {\n  content: "";\n  min-height: 48px;\n  visibility: hidden;\n  display: inline-block;\n}\n[dir=rtl] md-toast .md-toast-content {\n  justify-content: flex-end;\n}\nmd-toast .md-toast-content span {\n  flex: 1 1 0%;\n  box-sizing: border-box;\n  min-width: 0;\n}\nmd-toast.md-capsule {\n  border-radius: 24px;\n}\nmd-toast.md-capsule .md-toast-content {\n  border-radius: 24px;\n}\nmd-toast.ng-leave-active .md-toast-content {\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n}\nmd-toast.md-swipeleft .md-toast-content, md-toast.md-swiperight .md-toast-content, md-toast.md-swipeup .md-toast-content, md-toast.md-swipedown .md-toast-content {\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n}\nmd-toast.ng-enter {\n  opacity: 0;\n}\nmd-toast.ng-enter .md-toast-content {\n  transform: translate3d(0, 100%, 0);\n}\nmd-toast.ng-enter.md-top .md-toast-content {\n  transform: translate3d(0, -100%, 0);\n}\nmd-toast.ng-enter.ng-enter-active {\n  opacity: 1;\n}\nmd-toast.ng-enter.ng-enter-active .md-toast-content {\n  transform: translate3d(0, 0, 0);\n}\nmd-toast.ng-leave.ng-leave-active .md-toast-content {\n  opacity: 0;\n  transform: translate3d(0, 100%, 0);\n}\nmd-toast.ng-leave.ng-leave-active.md-swipeup .md-toast-content {\n  transform: translate3d(0, -50%, 0);\n}\nmd-toast.ng-leave.ng-leave-active.md-swipedown .md-toast-content {\n  transform: translate3d(0, 50%, 0);\n}\nmd-toast.ng-leave.ng-leave-active.md-top .md-toast-content {\n  transform: translate3d(0, -100%, 0);\n}\nmd-toast .md-action {\n  line-height: 19px;\n  margin-left: 24px;\n  margin-right: 0;\n  cursor: pointer;\n  text-transform: uppercase;\n  float: right;\n}\nmd-toast .md-button {\n  min-width: 0;\n  margin-right: 0;\n  margin-left: 8px;\n}\n[dir=rtl] md-toast .md-button {\n  margin-right: 8px;\n}\n[dir=rtl] md-toast .md-button {\n  margin-left: 0;\n}\n\n@media (max-width: 959px) {\n  md-toast {\n    left: 0;\n    right: 0;\n    width: 100%;\n    max-width: 100%;\n    min-width: 0;\n    border-radius: 0;\n    bottom: 0;\n    padding: 0;\n  }\n  md-toast.ng-leave.ng-leave-active.md-swipeup .md-toast-content {\n    transform: translate3d(0, -50%, 0);\n  }\n  md-toast.ng-leave.ng-leave-active.md-swipedown .md-toast-content {\n    transform: translate3d(0, 50%, 0);\n  }\n}\n@media (min-width: 960px) {\n  md-toast {\n    min-width: 304px;\n    /*\n    * When the toast doesn't take up the whole screen,\n    * make it rotate when the user swipes it away\n    */\n  }\n  md-toast.md-bottom {\n    bottom: 0;\n  }\n  md-toast.md-left {\n    left: 0;\n  }\n  md-toast.md-right {\n    right: 0;\n  }\n  md-toast.md-top {\n    top: 0;\n  }\n  md-toast._md-start {\n    left: 0;\n  }\n  [dir=rtl] md-toast._md-start {\n    left: auto;\n    right: 0;\n  }\n  md-toast._md-end {\n    right: 0;\n  }\n  [dir=rtl] md-toast._md-end {\n    right: auto;\n    left: 0;\n  }\n  md-toast.ng-leave.ng-leave-active.md-swipeleft .md-toast-content {\n    transform: translate3d(-50%, 0, 0);\n  }\n  md-toast.ng-leave.ng-leave-active.md-swiperight .md-toast-content {\n    transform: translate3d(50%, 0, 0);\n  }\n}\n@media (min-width: 1920px) {\n  md-toast .md-toast-content {\n    max-width: 568px;\n  }\n}\n@media screen and (-ms-high-contrast: active) {\n  md-toast {\n    border: 1px solid #fff;\n  }\n}\n.md-toast-animating {\n  overflow: hidden !important;\n}\n\nmd-toolbar {\n  box-sizing: border-box;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  z-index: 2;\n  font-size: 20px;\n  min-height: 64px;\n  width: 100%;\n}\nmd-toolbar._md-toolbar-transitions {\n  transition-duration: 0.5s;\n  transition-timing-function: cubic-bezier(0.35, 0, 0.25, 1);\n  transition-property: background-color, fill, color;\n}\nmd-toolbar.md-whiteframe-z1-add, md-toolbar.md-whiteframe-z1-remove {\n  transition: box-shadow 0.5s linear;\n}\nmd-toolbar md-toolbar-filler {\n  width: 72px;\n}\nmd-toolbar *,\nmd-toolbar *:before,\nmd-toolbar *:after {\n  box-sizing: border-box;\n}\nmd-toolbar.ng-animate {\n  transition: none;\n}\nmd-toolbar.md-tall {\n  height: 128px;\n  min-height: 128px;\n  max-height: 128px;\n}\nmd-toolbar.md-medium-tall {\n  height: 88px;\n  min-height: 88px;\n  max-height: 88px;\n}\nmd-toolbar.md-medium-tall .md-toolbar-tools {\n  height: 48px;\n  min-height: 48px;\n  max-height: 48px;\n}\nmd-toolbar > .md-indent {\n  margin-left: 64px;\n}\n[dir=rtl] md-toolbar > .md-indent {\n  margin-left: auto;\n  margin-right: 64px;\n}\nmd-toolbar ~ md-content > md-list {\n  padding: 0;\n}\nmd-toolbar ~ md-content > md-list md-list-item:last-child md-divider {\n  display: none;\n}\n\n.md-toolbar-tools {\n  font-size: 20px;\n  letter-spacing: 0.005em;\n  box-sizing: border-box;\n  font-weight: 400;\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n  width: 100%;\n  height: 64px;\n  max-height: 64px;\n  padding: 0 16px;\n  margin: 0;\n}\n.md-toolbar-tools h1, .md-toolbar-tools h2, .md-toolbar-tools h3 {\n  font-size: inherit;\n  font-weight: inherit;\n  margin: inherit;\n}\n.md-toolbar-tools a {\n  color: inherit;\n  text-decoration: none;\n}\n.md-toolbar-tools .fill-height {\n  display: flex;\n  align-items: center;\n}\n.md-toolbar-tools md-checkbox {\n  margin: inherit;\n}\n.md-toolbar-tools .md-button {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.md-toolbar-tools .md-button, .md-toolbar-tools .md-button.md-icon-button md-icon {\n  transition-duration: 0.5s;\n  transition-timing-function: cubic-bezier(0.35, 0, 0.25, 1);\n  transition-property: background-color, fill, color;\n}\n.md-toolbar-tools .md-button.ng-animate, .md-toolbar-tools .md-button.md-icon-button md-icon.ng-animate {\n  transition: none;\n}\n.md-toolbar-tools > .md-button:first-child {\n  margin-left: -8px;\n}\n[dir=rtl] .md-toolbar-tools > .md-button:first-child {\n  margin-left: auto;\n  margin-right: -8px;\n}\n.md-toolbar-tools > .md-button:last-child {\n  margin-right: -8px;\n}\n[dir=rtl] .md-toolbar-tools > .md-button:last-child {\n  margin-right: auto;\n  margin-left: -8px;\n}\n.md-toolbar-tools > md-menu:last-child {\n  margin-right: -8px;\n}\n[dir=rtl] .md-toolbar-tools > md-menu:last-child {\n  margin-right: auto;\n  margin-left: -8px;\n}\n.md-toolbar-tools > md-menu:last-child > .md-button {\n  margin-right: 0;\n}\n[dir=rtl] .md-toolbar-tools > md-menu:last-child > .md-button {\n  margin-right: auto;\n  margin-left: 0;\n}\n@media screen and (-ms-high-contrast: active) {\n  .md-toolbar-tools {\n    border-bottom: 1px solid #fff;\n  }\n}\n\n@media (min-width: 0) and (max-width: 959px) and (orientation: portrait) {\n  md-toolbar {\n    min-height: 56px;\n  }\n\n  .md-toolbar-tools {\n    height: 56px;\n    max-height: 56px;\n  }\n}\n@media (min-width: 0) and (max-width: 959px) and (orientation: landscape) {\n  md-toolbar {\n    min-height: 48px;\n  }\n\n  .md-toolbar-tools {\n    height: 48px;\n    max-height: 48px;\n  }\n}\n.md-tooltip {\n  display: inline-block;\n  pointer-events: none;\n  border-radius: 4px;\n  overflow: hidden;\n  opacity: 0;\n  font-weight: 500;\n  font-size: 14px;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  height: 32px;\n  line-height: 32px;\n  padding-right: 16px;\n  padding-left: 16px;\n}\n.md-tooltip.md-origin-top {\n  transform-origin: center bottom;\n  margin-top: -24px;\n}\n.md-tooltip.md-origin-right {\n  transform-origin: left center;\n  margin-left: 24px;\n}\n.md-tooltip.md-origin-bottom {\n  transform-origin: center top;\n  margin-top: 24px;\n}\n.md-tooltip.md-origin-left {\n  transform-origin: right center;\n  margin-left: -24px;\n}\n@media (min-width: 960px) {\n  .md-tooltip {\n    font-size: 10px;\n    height: 22px;\n    line-height: 22px;\n    padding-right: 8px;\n    padding-left: 8px;\n  }\n  .md-tooltip.md-origin-top {\n    margin-top: -14px;\n  }\n  .md-tooltip.md-origin-right {\n    margin-left: 14px;\n  }\n  .md-tooltip.md-origin-bottom {\n    margin-top: 14px;\n  }\n  .md-tooltip.md-origin-left {\n    margin-left: -14px;\n  }\n}\n.md-tooltip.md-show-add {\n  transform: scale(0);\n}\n.md-tooltip.md-show {\n  transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);\n  transition-duration: 150ms;\n  transform: scale(1);\n  opacity: 0.9;\n}\n.md-tooltip.md-hide {\n  transition: all 0.3s cubic-bezier(0.55, 0, 0.55, 0.2);\n  transition-duration: 150ms;\n  transform: scale(0);\n  opacity: 0;\n}\n\n.md-truncate {\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.md-truncate.md-clip {\n  text-overflow: clip;\n}\n.md-truncate.flex {\n  width: 0;\n}\n\n.md-virtual-repeat-container {\n  box-sizing: border-box;\n  display: block;\n  margin: 0;\n  overflow: hidden;\n  padding: 0;\n  position: relative;\n}\n.md-virtual-repeat-container .md-virtual-repeat-scroller {\n  bottom: 0;\n  box-sizing: border-box;\n  left: 0;\n  margin: 0;\n  overflow-x: hidden;\n  padding: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  -webkit-overflow-scrolling: touch;\n}\n.md-virtual-repeat-container .md-virtual-repeat-sizer {\n  box-sizing: border-box;\n  height: 1px;\n  display: block;\n  margin: 0;\n  padding: 0;\n  width: 1px;\n}\n.md-virtual-repeat-container .md-virtual-repeat-offsetter {\n  box-sizing: border-box;\n  left: 0;\n  margin: 0;\n  padding: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n\n.md-virtual-repeat-container.md-orient-horizontal .md-virtual-repeat-scroller {\n  overflow-x: auto;\n  overflow-y: hidden;\n}\n.md-virtual-repeat-container.md-orient-horizontal .md-virtual-repeat-offsetter {\n  bottom: 16px;\n  right: auto;\n  white-space: nowrap;\n}\n[dir=rtl] .md-virtual-repeat-container.md-orient-horizontal .md-virtual-repeat-offsetter {\n  right: auto;\n  left: auto;\n}\n\n.md-whiteframe-1dp, .md-whiteframe-z1 {\n  box-shadow: 0px 1px 3px 0px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 2px 1px -1px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-2dp {\n  box-shadow: 0px 1px 5px 0px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 3px 1px -2px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-3dp {\n  box-shadow: 0px 1px 8px 0px rgba(0, 0, 0, 0.2), 0px 3px 4px 0px rgba(0, 0, 0, 0.14), 0px 3px 3px -2px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-4dp, .md-whiteframe-z2 {\n  box-shadow: 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-5dp {\n  box-shadow: 0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 5px 8px 0px rgba(0, 0, 0, 0.14), 0px 1px 14px 0px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-6dp {\n  box-shadow: 0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-7dp, .md-whiteframe-z3 {\n  box-shadow: 0px 4px 5px -2px rgba(0, 0, 0, 0.2), 0px 7px 10px 1px rgba(0, 0, 0, 0.14), 0px 2px 16px 1px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-8dp {\n  box-shadow: 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-9dp {\n  box-shadow: 0px 5px 6px -3px rgba(0, 0, 0, 0.2), 0px 9px 12px 1px rgba(0, 0, 0, 0.14), 0px 3px 16px 2px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-10dp, .md-whiteframe-z4 {\n  box-shadow: 0px 6px 6px -3px rgba(0, 0, 0, 0.2), 0px 10px 14px 1px rgba(0, 0, 0, 0.14), 0px 4px 18px 3px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-11dp {\n  box-shadow: 0px 6px 7px -4px rgba(0, 0, 0, 0.2), 0px 11px 15px 1px rgba(0, 0, 0, 0.14), 0px 4px 20px 3px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-12dp {\n  box-shadow: 0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-13dp, .md-whiteframe-z5 {\n  box-shadow: 0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 13px 19px 2px rgba(0, 0, 0, 0.14), 0px 5px 24px 4px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-14dp {\n  box-shadow: 0px 7px 9px -4px rgba(0, 0, 0, 0.2), 0px 14px 21px 2px rgba(0, 0, 0, 0.14), 0px 5px 26px 4px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-15dp {\n  box-shadow: 0px 8px 9px -5px rgba(0, 0, 0, 0.2), 0px 15px 22px 2px rgba(0, 0, 0, 0.14), 0px 6px 28px 5px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-16dp {\n  box-shadow: 0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-17dp {\n  box-shadow: 0px 8px 11px -5px rgba(0, 0, 0, 0.2), 0px 17px 26px 2px rgba(0, 0, 0, 0.14), 0px 6px 32px 5px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-18dp {\n  box-shadow: 0px 9px 11px -5px rgba(0, 0, 0, 0.2), 0px 18px 28px 2px rgba(0, 0, 0, 0.14), 0px 7px 34px 6px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-19dp {\n  box-shadow: 0px 9px 12px -6px rgba(0, 0, 0, 0.2), 0px 19px 29px 2px rgba(0, 0, 0, 0.14), 0px 7px 36px 6px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-20dp {\n  box-shadow: 0px 10px 13px -6px rgba(0, 0, 0, 0.2), 0px 20px 31px 3px rgba(0, 0, 0, 0.14), 0px 8px 38px 7px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-21dp {\n  box-shadow: 0px 10px 13px -6px rgba(0, 0, 0, 0.2), 0px 21px 33px 3px rgba(0, 0, 0, 0.14), 0px 8px 40px 7px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-22dp {\n  box-shadow: 0px 10px 14px -6px rgba(0, 0, 0, 0.2), 0px 22px 35px 3px rgba(0, 0, 0, 0.14), 0px 8px 42px 7px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-23dp {\n  box-shadow: 0px 11px 14px -7px rgba(0, 0, 0, 0.2), 0px 23px 36px 3px rgba(0, 0, 0, 0.14), 0px 9px 44px 8px rgba(0, 0, 0, 0.12);\n}\n\n.md-whiteframe-24dp {\n  box-shadow: 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);\n}\n\n@media screen and (-ms-high-contrast: active) {\n  md-whiteframe {\n    border: 1px solid #fff;\n  }\n}\n@media print {\n  md-whiteframe, [md-whiteframe] {\n    background-color: #ffffff;\n  }\n}\n/*\n* Since Layout API uses ng-cloak to hide the dom elements while layouts are adjusted\n*/\n[ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {\n  display: none !important;\n}\n\n/*\n*  Responsive attributes\n*\n*  References:\n*  1) https://scotch.io/tutorials/a-visual-guide-to-css3-flexbox-properties#flex\n*  2) https://css-tricks.com/almanac/properties/f/flex/\n*  3) https://css-tricks.com/snippets/css/a-guide-to-flexbox/\n*  4) https://github.com/philipwalton/flexbugs#3-min-height-on-a-flex-container-wont-apply-to-its-flex-items\n*  5) http://godban.com.ua/projects/flexgrid\n*/\n@-moz-document url-prefix() {\n  .layout-fill {\n    margin: 0;\n    width: 100%;\n    min-height: 100%;\n    height: 100%;\n  }\n}\n/*\n *  Apply Mixins to create Layout/Flexbox styles\n */\n.flex-order {\n  order: 0;\n}\n\n.flex-order--20 {\n  order: -20;\n}\n\n.flex-order--19 {\n  order: -19;\n}\n\n.flex-order--18 {\n  order: -18;\n}\n\n.flex-order--17 {\n  order: -17;\n}\n\n.flex-order--16 {\n  order: -16;\n}\n\n.flex-order--15 {\n  order: -15;\n}\n\n.flex-order--14 {\n  order: -14;\n}\n\n.flex-order--13 {\n  order: -13;\n}\n\n.flex-order--12 {\n  order: -12;\n}\n\n.flex-order--11 {\n  order: -11;\n}\n\n.flex-order--10 {\n  order: -10;\n}\n\n.flex-order--9 {\n  order: -9;\n}\n\n.flex-order--8 {\n  order: -8;\n}\n\n.flex-order--7 {\n  order: -7;\n}\n\n.flex-order--6 {\n  order: -6;\n}\n\n.flex-order--5 {\n  order: -5;\n}\n\n.flex-order--4 {\n  order: -4;\n}\n\n.flex-order--3 {\n  order: -3;\n}\n\n.flex-order--2 {\n  order: -2;\n}\n\n.flex-order--1 {\n  order: -1;\n}\n\n.flex-order-0 {\n  order: 0;\n}\n\n.flex-order-1 {\n  order: 1;\n}\n\n.flex-order-2 {\n  order: 2;\n}\n\n.flex-order-3 {\n  order: 3;\n}\n\n.flex-order-4 {\n  order: 4;\n}\n\n.flex-order-5 {\n  order: 5;\n}\n\n.flex-order-6 {\n  order: 6;\n}\n\n.flex-order-7 {\n  order: 7;\n}\n\n.flex-order-8 {\n  order: 8;\n}\n\n.flex-order-9 {\n  order: 9;\n}\n\n.flex-order-10 {\n  order: 10;\n}\n\n.flex-order-11 {\n  order: 11;\n}\n\n.flex-order-12 {\n  order: 12;\n}\n\n.flex-order-13 {\n  order: 13;\n}\n\n.flex-order-14 {\n  order: 14;\n}\n\n.flex-order-15 {\n  order: 15;\n}\n\n.flex-order-16 {\n  order: 16;\n}\n\n.flex-order-17 {\n  order: 17;\n}\n\n.flex-order-18 {\n  order: 18;\n}\n\n.flex-order-19 {\n  order: 19;\n}\n\n.flex-order-20 {\n  order: 20;\n}\n\n.offset-0, .flex-offset-0, .layout-margin .flex-offset-0, .layout-margin .offset-0 {\n  margin-left: 0;\n}\n[dir=rtl] .offset-0, [dir=rtl] .flex-offset-0, [dir=rtl] .layout-margin .flex-offset-0, [dir=rtl] .layout-margin .offset-0 {\n  margin-left: auto;\n  margin-right: 0;\n}\n\n.offset-5, .flex-offset-5, .layout-margin .flex-offset-5, .layout-margin .offset-5 {\n  margin-left: 5%;\n}\n[dir=rtl] .offset-5, [dir=rtl] .flex-offset-5, [dir=rtl] .layout-margin .flex-offset-5, [dir=rtl] .layout-margin .offset-5 {\n  margin-left: auto;\n  margin-right: 5%;\n}\n\n.offset-10, .flex-offset-10, .layout-margin .flex-offset-10, .layout-margin .offset-10 {\n  margin-left: 10%;\n}\n[dir=rtl] .offset-10, [dir=rtl] .flex-offset-10, [dir=rtl] .layout-margin .flex-offset-10, [dir=rtl] .layout-margin .offset-10 {\n  margin-left: auto;\n  margin-right: 10%;\n}\n\n.offset-15, .flex-offset-15, .layout-margin .flex-offset-15, .layout-margin .offset-15 {\n  margin-left: 15%;\n}\n[dir=rtl] .offset-15, [dir=rtl] .flex-offset-15, [dir=rtl] .layout-margin .flex-offset-15, [dir=rtl] .layout-margin .offset-15 {\n  margin-left: auto;\n  margin-right: 15%;\n}\n\n.offset-20, .flex-offset-20, .layout-margin .flex-offset-20, .layout-margin .offset-20 {\n  margin-left: 20%;\n}\n[dir=rtl] .offset-20, [dir=rtl] .flex-offset-20, [dir=rtl] .layout-margin .flex-offset-20, [dir=rtl] .layout-margin .offset-20 {\n  margin-left: auto;\n  margin-right: 20%;\n}\n\n.offset-25, .flex-offset-25, .layout-margin .flex-offset-25, .layout-margin .offset-25 {\n  margin-left: 25%;\n}\n[dir=rtl] .offset-25, [dir=rtl] .flex-offset-25, [dir=rtl] .layout-margin .flex-offset-25, [dir=rtl] .layout-margin .offset-25 {\n  margin-left: auto;\n  margin-right: 25%;\n}\n\n.offset-30, .flex-offset-30, .layout-margin .flex-offset-30, .layout-margin .offset-30 {\n  margin-left: 30%;\n}\n[dir=rtl] .offset-30, [dir=rtl] .flex-offset-30, [dir=rtl] .layout-margin .flex-offset-30, [dir=rtl] .layout-margin .offset-30 {\n  margin-left: auto;\n  margin-right: 30%;\n}\n\n.offset-35, .flex-offset-35, .layout-margin .flex-offset-35, .layout-margin .offset-35 {\n  margin-left: 35%;\n}\n[dir=rtl] .offset-35, [dir=rtl] .flex-offset-35, [dir=rtl] .layout-margin .flex-offset-35, [dir=rtl] .layout-margin .offset-35 {\n  margin-left: auto;\n  margin-right: 35%;\n}\n\n.offset-40, .flex-offset-40, .layout-margin .flex-offset-40, .layout-margin .offset-40 {\n  margin-left: 40%;\n}\n[dir=rtl] .offset-40, [dir=rtl] .flex-offset-40, [dir=rtl] .layout-margin .flex-offset-40, [dir=rtl] .layout-margin .offset-40 {\n  margin-left: auto;\n  margin-right: 40%;\n}\n\n.offset-45, .flex-offset-45, .layout-margin .flex-offset-45, .layout-margin .offset-45 {\n  margin-left: 45%;\n}\n[dir=rtl] .offset-45, [dir=rtl] .flex-offset-45, [dir=rtl] .layout-margin .flex-offset-45, [dir=rtl] .layout-margin .offset-45 {\n  margin-left: auto;\n  margin-right: 45%;\n}\n\n.offset-50, .flex-offset-50, .layout-margin .flex-offset-50, .layout-margin .offset-50 {\n  margin-left: 50%;\n}\n[dir=rtl] .offset-50, [dir=rtl] .flex-offset-50, [dir=rtl] .layout-margin .flex-offset-50, [dir=rtl] .layout-margin .offset-50 {\n  margin-left: auto;\n  margin-right: 50%;\n}\n\n.offset-55, .flex-offset-55, .layout-margin .flex-offset-55, .layout-margin .offset-55 {\n  margin-left: 55%;\n}\n[dir=rtl] .offset-55, [dir=rtl] .flex-offset-55, [dir=rtl] .layout-margin .flex-offset-55, [dir=rtl] .layout-margin .offset-55 {\n  margin-left: auto;\n  margin-right: 55%;\n}\n\n.offset-60, .flex-offset-60, .layout-margin .flex-offset-60, .layout-margin .offset-60 {\n  margin-left: 60%;\n}\n[dir=rtl] .offset-60, [dir=rtl] .flex-offset-60, [dir=rtl] .layout-margin .flex-offset-60, [dir=rtl] .layout-margin .offset-60 {\n  margin-left: auto;\n  margin-right: 60%;\n}\n\n.offset-65, .flex-offset-65, .layout-margin .flex-offset-65, .layout-margin .offset-65 {\n  margin-left: 65%;\n}\n[dir=rtl] .offset-65, [dir=rtl] .flex-offset-65, [dir=rtl] .layout-margin .flex-offset-65, [dir=rtl] .layout-margin .offset-65 {\n  margin-left: auto;\n  margin-right: 65%;\n}\n\n.offset-70, .flex-offset-70, .layout-margin .flex-offset-70, .layout-margin .offset-70 {\n  margin-left: 70%;\n}\n[dir=rtl] .offset-70, [dir=rtl] .flex-offset-70, [dir=rtl] .layout-margin .flex-offset-70, [dir=rtl] .layout-margin .offset-70 {\n  margin-left: auto;\n  margin-right: 70%;\n}\n\n.offset-75, .flex-offset-75, .layout-margin .flex-offset-75, .layout-margin .offset-75 {\n  margin-left: 75%;\n}\n[dir=rtl] .offset-75, [dir=rtl] .flex-offset-75, [dir=rtl] .layout-margin .flex-offset-75, [dir=rtl] .layout-margin .offset-75 {\n  margin-left: auto;\n  margin-right: 75%;\n}\n\n.offset-80, .flex-offset-80, .layout-margin .flex-offset-80, .layout-margin .offset-80 {\n  margin-left: 80%;\n}\n[dir=rtl] .offset-80, [dir=rtl] .flex-offset-80, [dir=rtl] .layout-margin .flex-offset-80, [dir=rtl] .layout-margin .offset-80 {\n  margin-left: auto;\n  margin-right: 80%;\n}\n\n.offset-85, .flex-offset-85, .layout-margin .flex-offset-85, .layout-margin .offset-85 {\n  margin-left: 85%;\n}\n[dir=rtl] .offset-85, [dir=rtl] .flex-offset-85, [dir=rtl] .layout-margin .flex-offset-85, [dir=rtl] .layout-margin .offset-85 {\n  margin-left: auto;\n  margin-right: 85%;\n}\n\n.offset-90, .flex-offset-90, .layout-margin .flex-offset-90, .layout-margin .offset-90 {\n  margin-left: 90%;\n}\n[dir=rtl] .offset-90, [dir=rtl] .flex-offset-90, [dir=rtl] .layout-margin .flex-offset-90, [dir=rtl] .layout-margin .offset-90 {\n  margin-left: auto;\n  margin-right: 90%;\n}\n\n.offset-95, .flex-offset-95, .layout-margin .flex-offset-95, .layout-margin .offset-95 {\n  margin-left: 95%;\n}\n[dir=rtl] .offset-95, [dir=rtl] .flex-offset-95, [dir=rtl] .layout-margin .flex-offset-95, [dir=rtl] .layout-margin .offset-95 {\n  margin-left: auto;\n  margin-right: 95%;\n}\n\n.offset-33, .flex-offset-33, .layout-margin .flex-offset-33, .layout-margin .offset-33 {\n  margin-left: 33.3333333333%;\n}\n\n.offset-66, .flex-offset-66, .layout-margin .flex-offset-66, .layout-margin .offset-66 {\n  margin-left: 66.6666666667%;\n}\n[dir=rtl] .offset-66, [dir=rtl] .flex-offset-66, [dir=rtl] .layout-margin .flex-offset-66, [dir=rtl] .layout-margin .offset-66 {\n  margin-left: auto;\n  margin-right: 66.6666666667%;\n}\n\n.layout-align,\n.layout-align-start-stretch {\n  justify-content: flex-start;\n  align-content: stretch;\n  align-items: stretch;\n}\n\n.layout-align-start,\n.layout-align-start-start,\n.layout-align-start-center,\n.layout-align-start-end,\n.layout-align-start-stretch {\n  justify-content: flex-start;\n}\n\n.layout-align-center,\n.layout-align-center-start,\n.layout-align-center-center,\n.layout-align-center-end,\n.layout-align-center-stretch {\n  justify-content: center;\n}\n\n.layout-align-end,\n.layout-align-end-start,\n.layout-align-end-center,\n.layout-align-end-end,\n.layout-align-end-stretch {\n  justify-content: flex-end;\n}\n\n.layout-align-space-around,\n.layout-align-space-around-center,\n.layout-align-space-around-start,\n.layout-align-space-around-end,\n.layout-align-space-around-stretch {\n  justify-content: space-around;\n}\n\n.layout-align-space-between,\n.layout-align-space-between-center,\n.layout-align-space-between-start,\n.layout-align-space-between-end,\n.layout-align-space-between-stretch {\n  justify-content: space-between;\n}\n\n.layout-align-start-start,\n.layout-align-center-start,\n.layout-align-end-start,\n.layout-align-space-between-start,\n.layout-align-space-around-start {\n  align-items: flex-start;\n  align-content: flex-start;\n}\n\n.layout-align-start-center,\n.layout-align-center-center,\n.layout-align-end-center,\n.layout-align-space-between-center,\n.layout-align-space-around-center {\n  align-items: center;\n  align-content: center;\n  max-width: 100%;\n}\n\n.layout-align-start-center > *,\n.layout-align-center-center > *,\n.layout-align-end-center > *,\n.layout-align-space-between-center > *,\n.layout-align-space-around-center > * {\n  max-width: 100%;\n  box-sizing: border-box;\n}\n\n.layout-align-start-end,\n.layout-align-center-end,\n.layout-align-end-end,\n.layout-align-space-between-end,\n.layout-align-space-around-end {\n  align-items: flex-end;\n  align-content: flex-end;\n}\n\n.layout-align-start-stretch,\n.layout-align-center-stretch,\n.layout-align-end-stretch,\n.layout-align-space-between-stretch,\n.layout-align-space-around-stretch {\n  align-items: stretch;\n  align-content: stretch;\n}\n\n.flex {\n  flex: 1;\n  box-sizing: border-box;\n}\n\n.flex-grow {\n  flex: 1 1 100%;\n  box-sizing: border-box;\n}\n\n.flex-initial {\n  flex: 0 1 auto;\n  box-sizing: border-box;\n}\n\n.flex-auto {\n  flex: 1 1 auto;\n  box-sizing: border-box;\n}\n\n.flex-none {\n  flex: 0 0 auto;\n  box-sizing: border-box;\n}\n\n.flex-noshrink {\n  flex: 1 0 auto;\n  box-sizing: border-box;\n}\n\n.flex-nogrow {\n  flex: 0 1 auto;\n  box-sizing: border-box;\n}\n\n.flex-0 {\n  flex: 1 1 100%;\n  max-width: 0%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-0 {\n  flex: 1 1 100%;\n  max-width: 0%;\n  max-height: 100%;\n  box-sizing: border-box;\n  min-width: 0;\n}\n\n.layout-column > .flex-0 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 0%;\n  box-sizing: border-box;\n}\n\n.flex-5 {\n  flex: 1 1 100%;\n  max-width: 5%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-5 {\n  flex: 1 1 100%;\n  max-width: 5%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-5 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 5%;\n  box-sizing: border-box;\n}\n\n.flex-10 {\n  flex: 1 1 100%;\n  max-width: 10%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-10 {\n  flex: 1 1 100%;\n  max-width: 10%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-10 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 10%;\n  box-sizing: border-box;\n}\n\n.flex-15 {\n  flex: 1 1 100%;\n  max-width: 15%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-15 {\n  flex: 1 1 100%;\n  max-width: 15%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-15 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 15%;\n  box-sizing: border-box;\n}\n\n.flex-20 {\n  flex: 1 1 100%;\n  max-width: 20%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-20 {\n  flex: 1 1 100%;\n  max-width: 20%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-20 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 20%;\n  box-sizing: border-box;\n}\n\n.flex-25 {\n  flex: 1 1 100%;\n  max-width: 25%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-25 {\n  flex: 1 1 100%;\n  max-width: 25%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-25 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 25%;\n  box-sizing: border-box;\n}\n\n.flex-30 {\n  flex: 1 1 100%;\n  max-width: 30%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-30 {\n  flex: 1 1 100%;\n  max-width: 30%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-30 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 30%;\n  box-sizing: border-box;\n}\n\n.flex-35 {\n  flex: 1 1 100%;\n  max-width: 35%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-35 {\n  flex: 1 1 100%;\n  max-width: 35%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-35 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 35%;\n  box-sizing: border-box;\n}\n\n.flex-40 {\n  flex: 1 1 100%;\n  max-width: 40%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-40 {\n  flex: 1 1 100%;\n  max-width: 40%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-40 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 40%;\n  box-sizing: border-box;\n}\n\n.flex-45 {\n  flex: 1 1 100%;\n  max-width: 45%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-45 {\n  flex: 1 1 100%;\n  max-width: 45%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-45 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 45%;\n  box-sizing: border-box;\n}\n\n.flex-50 {\n  flex: 1 1 100%;\n  max-width: 50%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-50 {\n  flex: 1 1 100%;\n  max-width: 50%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-50 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 50%;\n  box-sizing: border-box;\n}\n\n.flex-55 {\n  flex: 1 1 100%;\n  max-width: 55%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-55 {\n  flex: 1 1 100%;\n  max-width: 55%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-55 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 55%;\n  box-sizing: border-box;\n}\n\n.flex-60 {\n  flex: 1 1 100%;\n  max-width: 60%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-60 {\n  flex: 1 1 100%;\n  max-width: 60%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-60 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 60%;\n  box-sizing: border-box;\n}\n\n.flex-65 {\n  flex: 1 1 100%;\n  max-width: 65%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-65 {\n  flex: 1 1 100%;\n  max-width: 65%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-65 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 65%;\n  box-sizing: border-box;\n}\n\n.flex-70 {\n  flex: 1 1 100%;\n  max-width: 70%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-70 {\n  flex: 1 1 100%;\n  max-width: 70%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-70 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 70%;\n  box-sizing: border-box;\n}\n\n.flex-75 {\n  flex: 1 1 100%;\n  max-width: 75%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-75 {\n  flex: 1 1 100%;\n  max-width: 75%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-75 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 75%;\n  box-sizing: border-box;\n}\n\n.flex-80 {\n  flex: 1 1 100%;\n  max-width: 80%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-80 {\n  flex: 1 1 100%;\n  max-width: 80%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-80 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 80%;\n  box-sizing: border-box;\n}\n\n.flex-85 {\n  flex: 1 1 100%;\n  max-width: 85%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-85 {\n  flex: 1 1 100%;\n  max-width: 85%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-85 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 85%;\n  box-sizing: border-box;\n}\n\n.flex-90 {\n  flex: 1 1 100%;\n  max-width: 90%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-90 {\n  flex: 1 1 100%;\n  max-width: 90%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-90 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 90%;\n  box-sizing: border-box;\n}\n\n.flex-95 {\n  flex: 1 1 100%;\n  max-width: 95%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-95 {\n  flex: 1 1 100%;\n  max-width: 95%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-95 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 95%;\n  box-sizing: border-box;\n}\n\n.flex-100 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-100 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-100 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.flex-33 {\n  flex: 1 1 100%;\n  max-width: 33.33%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.flex-66 {\n  flex: 1 1 100%;\n  max-width: 66.66%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-33 {\n  flex: 1 1 33.33%;\n  max-width: 33.33%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n.layout-row > .flex-66 {\n  flex: 1 1 66.66%;\n  max-width: 66.66%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n\n.layout-column > .flex-33 {\n  flex: 1 1 33.33%;\n  max-width: 100%;\n  max-height: 33.33%;\n  box-sizing: border-box;\n}\n.layout-column > .flex-66 {\n  flex: 1 1 66.66%;\n  max-width: 100%;\n  max-height: 66.66%;\n  box-sizing: border-box;\n}\n\n.layout-row > .flex-33 {\n  flex: 1 1 100%;\n  max-width: 33.33%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n.layout-row > .flex-66 {\n  flex: 1 1 100%;\n  max-width: 66.66%;\n  max-height: 100%;\n  box-sizing: border-box;\n}\n.layout-row > .flex {\n  min-width: 0;\n}\n\n.layout-column > .flex-33 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 33.33%;\n  box-sizing: border-box;\n}\n.layout-column > .flex-66 {\n  flex: 1 1 100%;\n  max-width: 100%;\n  max-height: 66.66%;\n  box-sizing: border-box;\n}\n.layout-column > .flex {\n  min-height: 0;\n}\n\n.layout, .layout-column, .layout-row {\n  box-sizing: border-box;\n  display: flex;\n}\n\n.layout-column {\n  flex-direction: column;\n}\n\n.layout-row {\n  flex-direction: row;\n}\n\n.layout-padding-sm > *,\n.layout-padding > .flex-sm {\n  padding: 4px;\n}\n\n.layout-padding,\n.layout-padding-gt-sm,\n.layout-padding-md,\n.layout-padding > *,\n.layout-padding-gt-sm > *,\n.layout-padding-md > *,\n.layout-padding > .flex,\n.layout-padding > .flex-gt-sm,\n.layout-padding > .flex-md {\n  padding: 8px;\n}\n\n.layout-padding-gt-md > *,\n.layout-padding-lg > *,\n.layout-padding-gt-lg > *,\n.layout-padding > .flex-gt-md,\n.layout-padding > .flex-lg,\n.layout-padding > .flex-lg,\n.layout-padding > .flex-gt-lg {\n  padding: 16px;\n}\n\n.layout-margin-sm > *,\n.layout-margin > .flex-sm {\n  margin: 4px;\n}\n\n.layout-margin,\n.layout-margin-gt-sm,\n.layout-margin-md,\n.layout-margin > *,\n.layout-margin-gt-sm > *,\n.layout-margin-md > *,\n.layout-margin > .flex,\n.layout-margin > .flex-gt-sm,\n.layout-margin > .flex-md {\n  margin: 8px;\n}\n\n.layout-margin-gt-md > *,\n.layout-margin-lg > *,\n.layout-margin-gt-lg > *,\n.layout-margin > .flex-gt-md,\n.layout-margin > .flex-lg,\n.layout-margin > .flex-gt-lg {\n  margin: 16px;\n}\n\n.layout-wrap {\n  flex-wrap: wrap;\n}\n\n.layout-nowrap {\n  flex-wrap: nowrap;\n}\n\n.layout-fill {\n  margin: 0;\n  width: 100%;\n  min-height: 100%;\n  height: 100%;\n}\n\n/**\n * \`hide-gt-sm show-gt-lg\` should hide from 600px to 1200px\n * \`show-md hide-gt-sm\` should show from 0px to 960px and hide at >960px\n * \`hide-gt-md show-gt-sm\` should show everywhere (show overrides hide)\`\n *\n *  hide means hide everywhere\n *  Sizes:\n *         $layout-breakpoint-xs:     600px !default;\n *         $layout-breakpoint-sm:     960px !default;\n *         $layout-breakpoint-md:     1280px !default;\n *         $layout-breakpoint-lg:     1920px !default;\n */\n@media (max-width: 599px) {\n  .hide-xs:not(.show-xs):not(.show), .hide:not(.show-xs):not(.show) {\n    display: none;\n  }\n\n  .flex-order-xs--20 {\n    order: -20;\n  }\n\n  .flex-order-xs--19 {\n    order: -19;\n  }\n\n  .flex-order-xs--18 {\n    order: -18;\n  }\n\n  .flex-order-xs--17 {\n    order: -17;\n  }\n\n  .flex-order-xs--16 {\n    order: -16;\n  }\n\n  .flex-order-xs--15 {\n    order: -15;\n  }\n\n  .flex-order-xs--14 {\n    order: -14;\n  }\n\n  .flex-order-xs--13 {\n    order: -13;\n  }\n\n  .flex-order-xs--12 {\n    order: -12;\n  }\n\n  .flex-order-xs--11 {\n    order: -11;\n  }\n\n  .flex-order-xs--10 {\n    order: -10;\n  }\n\n  .flex-order-xs--9 {\n    order: -9;\n  }\n\n  .flex-order-xs--8 {\n    order: -8;\n  }\n\n  .flex-order-xs--7 {\n    order: -7;\n  }\n\n  .flex-order-xs--6 {\n    order: -6;\n  }\n\n  .flex-order-xs--5 {\n    order: -5;\n  }\n\n  .flex-order-xs--4 {\n    order: -4;\n  }\n\n  .flex-order-xs--3 {\n    order: -3;\n  }\n\n  .flex-order-xs--2 {\n    order: -2;\n  }\n\n  .flex-order-xs--1 {\n    order: -1;\n  }\n\n  .flex-order-xs-0 {\n    order: 0;\n  }\n\n  .flex-order-xs-1 {\n    order: 1;\n  }\n\n  .flex-order-xs-2 {\n    order: 2;\n  }\n\n  .flex-order-xs-3 {\n    order: 3;\n  }\n\n  .flex-order-xs-4 {\n    order: 4;\n  }\n\n  .flex-order-xs-5 {\n    order: 5;\n  }\n\n  .flex-order-xs-6 {\n    order: 6;\n  }\n\n  .flex-order-xs-7 {\n    order: 7;\n  }\n\n  .flex-order-xs-8 {\n    order: 8;\n  }\n\n  .flex-order-xs-9 {\n    order: 9;\n  }\n\n  .flex-order-xs-10 {\n    order: 10;\n  }\n\n  .flex-order-xs-11 {\n    order: 11;\n  }\n\n  .flex-order-xs-12 {\n    order: 12;\n  }\n\n  .flex-order-xs-13 {\n    order: 13;\n  }\n\n  .flex-order-xs-14 {\n    order: 14;\n  }\n\n  .flex-order-xs-15 {\n    order: 15;\n  }\n\n  .flex-order-xs-16 {\n    order: 16;\n  }\n\n  .flex-order-xs-17 {\n    order: 17;\n  }\n\n  .flex-order-xs-18 {\n    order: 18;\n  }\n\n  .flex-order-xs-19 {\n    order: 19;\n  }\n\n  .flex-order-xs-20 {\n    order: 20;\n  }\n\n  .offset-xs-0, .flex-offset-xs-0, .layout-margin .flex-offset-xs-0, .layout-margin .offset-xs-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-xs-0, [dir=rtl] .flex-offset-xs-0, [dir=rtl] .layout-margin .flex-offset-xs-0, [dir=rtl] .layout-margin .offset-xs-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-xs-5, .flex-offset-xs-5, .layout-margin .flex-offset-xs-5, .layout-margin .offset-xs-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-xs-5, [dir=rtl] .flex-offset-xs-5, [dir=rtl] .layout-margin .flex-offset-xs-5, [dir=rtl] .layout-margin .offset-xs-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-xs-10, .flex-offset-xs-10, .layout-margin .flex-offset-xs-10, .layout-margin .offset-xs-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-xs-10, [dir=rtl] .flex-offset-xs-10, [dir=rtl] .layout-margin .flex-offset-xs-10, [dir=rtl] .layout-margin .offset-xs-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-xs-15, .flex-offset-xs-15, .layout-margin .flex-offset-xs-15, .layout-margin .offset-xs-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-xs-15, [dir=rtl] .flex-offset-xs-15, [dir=rtl] .layout-margin .flex-offset-xs-15, [dir=rtl] .layout-margin .offset-xs-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-xs-20, .flex-offset-xs-20, .layout-margin .flex-offset-xs-20, .layout-margin .offset-xs-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-xs-20, [dir=rtl] .flex-offset-xs-20, [dir=rtl] .layout-margin .flex-offset-xs-20, [dir=rtl] .layout-margin .offset-xs-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-xs-25, .flex-offset-xs-25, .layout-margin .flex-offset-xs-25, .layout-margin .offset-xs-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-xs-25, [dir=rtl] .flex-offset-xs-25, [dir=rtl] .layout-margin .flex-offset-xs-25, [dir=rtl] .layout-margin .offset-xs-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-xs-30, .flex-offset-xs-30, .layout-margin .flex-offset-xs-30, .layout-margin .offset-xs-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-xs-30, [dir=rtl] .flex-offset-xs-30, [dir=rtl] .layout-margin .flex-offset-xs-30, [dir=rtl] .layout-margin .offset-xs-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-xs-35, .flex-offset-xs-35, .layout-margin .flex-offset-xs-35, .layout-margin .offset-xs-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-xs-35, [dir=rtl] .flex-offset-xs-35, [dir=rtl] .layout-margin .flex-offset-xs-35, [dir=rtl] .layout-margin .offset-xs-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-xs-40, .flex-offset-xs-40, .layout-margin .flex-offset-xs-40, .layout-margin .offset-xs-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-xs-40, [dir=rtl] .flex-offset-xs-40, [dir=rtl] .layout-margin .flex-offset-xs-40, [dir=rtl] .layout-margin .offset-xs-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-xs-45, .flex-offset-xs-45, .layout-margin .flex-offset-xs-45, .layout-margin .offset-xs-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-xs-45, [dir=rtl] .flex-offset-xs-45, [dir=rtl] .layout-margin .flex-offset-xs-45, [dir=rtl] .layout-margin .offset-xs-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-xs-50, .flex-offset-xs-50, .layout-margin .flex-offset-xs-50, .layout-margin .offset-xs-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-xs-50, [dir=rtl] .flex-offset-xs-50, [dir=rtl] .layout-margin .flex-offset-xs-50, [dir=rtl] .layout-margin .offset-xs-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-xs-55, .flex-offset-xs-55, .layout-margin .flex-offset-xs-55, .layout-margin .offset-xs-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-xs-55, [dir=rtl] .flex-offset-xs-55, [dir=rtl] .layout-margin .flex-offset-xs-55, [dir=rtl] .layout-margin .offset-xs-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-xs-60, .flex-offset-xs-60, .layout-margin .flex-offset-xs-60, .layout-margin .offset-xs-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-xs-60, [dir=rtl] .flex-offset-xs-60, [dir=rtl] .layout-margin .flex-offset-xs-60, [dir=rtl] .layout-margin .offset-xs-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-xs-65, .flex-offset-xs-65, .layout-margin .flex-offset-xs-65, .layout-margin .offset-xs-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-xs-65, [dir=rtl] .flex-offset-xs-65, [dir=rtl] .layout-margin .flex-offset-xs-65, [dir=rtl] .layout-margin .offset-xs-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-xs-70, .flex-offset-xs-70, .layout-margin .flex-offset-xs-70, .layout-margin .offset-xs-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-xs-70, [dir=rtl] .flex-offset-xs-70, [dir=rtl] .layout-margin .flex-offset-xs-70, [dir=rtl] .layout-margin .offset-xs-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-xs-75, .flex-offset-xs-75, .layout-margin .flex-offset-xs-75, .layout-margin .offset-xs-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-xs-75, [dir=rtl] .flex-offset-xs-75, [dir=rtl] .layout-margin .flex-offset-xs-75, [dir=rtl] .layout-margin .offset-xs-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-xs-80, .flex-offset-xs-80, .layout-margin .flex-offset-xs-80, .layout-margin .offset-xs-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-xs-80, [dir=rtl] .flex-offset-xs-80, [dir=rtl] .layout-margin .flex-offset-xs-80, [dir=rtl] .layout-margin .offset-xs-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-xs-85, .flex-offset-xs-85, .layout-margin .flex-offset-xs-85, .layout-margin .offset-xs-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-xs-85, [dir=rtl] .flex-offset-xs-85, [dir=rtl] .layout-margin .flex-offset-xs-85, [dir=rtl] .layout-margin .offset-xs-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-xs-90, .flex-offset-xs-90, .layout-margin .flex-offset-xs-90, .layout-margin .offset-xs-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-xs-90, [dir=rtl] .flex-offset-xs-90, [dir=rtl] .layout-margin .flex-offset-xs-90, [dir=rtl] .layout-margin .offset-xs-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-xs-95, .flex-offset-xs-95, .layout-margin .flex-offset-xs-95, .layout-margin .offset-xs-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-xs-95, [dir=rtl] .flex-offset-xs-95, [dir=rtl] .layout-margin .flex-offset-xs-95, [dir=rtl] .layout-margin .offset-xs-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-xs-33, .flex-offset-xs-33, .layout-margin .flex-offset-xs-33, .layout-margin .offset-xs-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-xs-66, .flex-offset-xs-66, .layout-margin .flex-offset-xs-66, .layout-margin .offset-xs-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-xs-66, [dir=rtl] .flex-offset-xs-66, [dir=rtl] .layout-margin .flex-offset-xs-66, [dir=rtl] .layout-margin .offset-xs-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-xs,\n.layout-align-xs-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-xs-start,\n.layout-align-xs-start-start,\n.layout-align-xs-start-center,\n.layout-align-xs-start-end,\n.layout-align-xs-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-xs-center,\n.layout-align-xs-center-start,\n.layout-align-xs-center-center,\n.layout-align-xs-center-end,\n.layout-align-xs-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-xs-end,\n.layout-align-xs-end-start,\n.layout-align-xs-end-center,\n.layout-align-xs-end-end,\n.layout-align-xs-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-xs-space-around,\n.layout-align-xs-space-around-center,\n.layout-align-xs-space-around-start,\n.layout-align-xs-space-around-end,\n.layout-align-xs-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-xs-space-between,\n.layout-align-xs-space-between-center,\n.layout-align-xs-space-between-start,\n.layout-align-xs-space-between-end,\n.layout-align-xs-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-xs-start-start,\n.layout-align-xs-center-start,\n.layout-align-xs-end-start,\n.layout-align-xs-space-between-start,\n.layout-align-xs-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-xs-start-center,\n.layout-align-xs-center-center,\n.layout-align-xs-end-center,\n.layout-align-xs-space-between-center,\n.layout-align-xs-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-xs-start-center > *,\n.layout-align-xs-center-center > *,\n.layout-align-xs-end-center > *,\n.layout-align-xs-space-between-center > *,\n.layout-align-xs-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-xs-start-end,\n.layout-align-xs-center-end,\n.layout-align-xs-end-end,\n.layout-align-xs-space-between-end,\n.layout-align-xs-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-xs-start-stretch,\n.layout-align-xs-center-stretch,\n.layout-align-xs-end-stretch,\n.layout-align-xs-space-between-stretch,\n.layout-align-xs-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-xs {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-xs-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-xs-column > .flex-xs-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-xs-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-column > .flex-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xs-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-xs-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xs-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-xs-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-xs-row > .flex-xs-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-xs-row > .flex-xs-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-xs-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-xs-column > .flex-xs-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-xs-column > .flex-xs-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-xs-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-xs, .layout-xs-column, .layout-xs-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-xs-column {\n    flex-direction: column;\n  }\n\n  .layout-xs-row {\n    flex-direction: row;\n  }\n}\n@media (min-width: 600px) {\n  .flex-order-gt-xs--20 {\n    order: -20;\n  }\n\n  .flex-order-gt-xs--19 {\n    order: -19;\n  }\n\n  .flex-order-gt-xs--18 {\n    order: -18;\n  }\n\n  .flex-order-gt-xs--17 {\n    order: -17;\n  }\n\n  .flex-order-gt-xs--16 {\n    order: -16;\n  }\n\n  .flex-order-gt-xs--15 {\n    order: -15;\n  }\n\n  .flex-order-gt-xs--14 {\n    order: -14;\n  }\n\n  .flex-order-gt-xs--13 {\n    order: -13;\n  }\n\n  .flex-order-gt-xs--12 {\n    order: -12;\n  }\n\n  .flex-order-gt-xs--11 {\n    order: -11;\n  }\n\n  .flex-order-gt-xs--10 {\n    order: -10;\n  }\n\n  .flex-order-gt-xs--9 {\n    order: -9;\n  }\n\n  .flex-order-gt-xs--8 {\n    order: -8;\n  }\n\n  .flex-order-gt-xs--7 {\n    order: -7;\n  }\n\n  .flex-order-gt-xs--6 {\n    order: -6;\n  }\n\n  .flex-order-gt-xs--5 {\n    order: -5;\n  }\n\n  .flex-order-gt-xs--4 {\n    order: -4;\n  }\n\n  .flex-order-gt-xs--3 {\n    order: -3;\n  }\n\n  .flex-order-gt-xs--2 {\n    order: -2;\n  }\n\n  .flex-order-gt-xs--1 {\n    order: -1;\n  }\n\n  .flex-order-gt-xs-0 {\n    order: 0;\n  }\n\n  .flex-order-gt-xs-1 {\n    order: 1;\n  }\n\n  .flex-order-gt-xs-2 {\n    order: 2;\n  }\n\n  .flex-order-gt-xs-3 {\n    order: 3;\n  }\n\n  .flex-order-gt-xs-4 {\n    order: 4;\n  }\n\n  .flex-order-gt-xs-5 {\n    order: 5;\n  }\n\n  .flex-order-gt-xs-6 {\n    order: 6;\n  }\n\n  .flex-order-gt-xs-7 {\n    order: 7;\n  }\n\n  .flex-order-gt-xs-8 {\n    order: 8;\n  }\n\n  .flex-order-gt-xs-9 {\n    order: 9;\n  }\n\n  .flex-order-gt-xs-10 {\n    order: 10;\n  }\n\n  .flex-order-gt-xs-11 {\n    order: 11;\n  }\n\n  .flex-order-gt-xs-12 {\n    order: 12;\n  }\n\n  .flex-order-gt-xs-13 {\n    order: 13;\n  }\n\n  .flex-order-gt-xs-14 {\n    order: 14;\n  }\n\n  .flex-order-gt-xs-15 {\n    order: 15;\n  }\n\n  .flex-order-gt-xs-16 {\n    order: 16;\n  }\n\n  .flex-order-gt-xs-17 {\n    order: 17;\n  }\n\n  .flex-order-gt-xs-18 {\n    order: 18;\n  }\n\n  .flex-order-gt-xs-19 {\n    order: 19;\n  }\n\n  .flex-order-gt-xs-20 {\n    order: 20;\n  }\n\n  .offset-gt-xs-0, .flex-offset-gt-xs-0, .layout-margin .flex-offset-gt-xs-0, .layout-margin .offset-gt-xs-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-gt-xs-0, [dir=rtl] .flex-offset-gt-xs-0, [dir=rtl] .layout-margin .flex-offset-gt-xs-0, [dir=rtl] .layout-margin .offset-gt-xs-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-gt-xs-5, .flex-offset-gt-xs-5, .layout-margin .flex-offset-gt-xs-5, .layout-margin .offset-gt-xs-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-gt-xs-5, [dir=rtl] .flex-offset-gt-xs-5, [dir=rtl] .layout-margin .flex-offset-gt-xs-5, [dir=rtl] .layout-margin .offset-gt-xs-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-gt-xs-10, .flex-offset-gt-xs-10, .layout-margin .flex-offset-gt-xs-10, .layout-margin .offset-gt-xs-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-gt-xs-10, [dir=rtl] .flex-offset-gt-xs-10, [dir=rtl] .layout-margin .flex-offset-gt-xs-10, [dir=rtl] .layout-margin .offset-gt-xs-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-gt-xs-15, .flex-offset-gt-xs-15, .layout-margin .flex-offset-gt-xs-15, .layout-margin .offset-gt-xs-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-gt-xs-15, [dir=rtl] .flex-offset-gt-xs-15, [dir=rtl] .layout-margin .flex-offset-gt-xs-15, [dir=rtl] .layout-margin .offset-gt-xs-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-gt-xs-20, .flex-offset-gt-xs-20, .layout-margin .flex-offset-gt-xs-20, .layout-margin .offset-gt-xs-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-gt-xs-20, [dir=rtl] .flex-offset-gt-xs-20, [dir=rtl] .layout-margin .flex-offset-gt-xs-20, [dir=rtl] .layout-margin .offset-gt-xs-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-gt-xs-25, .flex-offset-gt-xs-25, .layout-margin .flex-offset-gt-xs-25, .layout-margin .offset-gt-xs-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-gt-xs-25, [dir=rtl] .flex-offset-gt-xs-25, [dir=rtl] .layout-margin .flex-offset-gt-xs-25, [dir=rtl] .layout-margin .offset-gt-xs-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-gt-xs-30, .flex-offset-gt-xs-30, .layout-margin .flex-offset-gt-xs-30, .layout-margin .offset-gt-xs-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-gt-xs-30, [dir=rtl] .flex-offset-gt-xs-30, [dir=rtl] .layout-margin .flex-offset-gt-xs-30, [dir=rtl] .layout-margin .offset-gt-xs-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-gt-xs-35, .flex-offset-gt-xs-35, .layout-margin .flex-offset-gt-xs-35, .layout-margin .offset-gt-xs-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-gt-xs-35, [dir=rtl] .flex-offset-gt-xs-35, [dir=rtl] .layout-margin .flex-offset-gt-xs-35, [dir=rtl] .layout-margin .offset-gt-xs-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-gt-xs-40, .flex-offset-gt-xs-40, .layout-margin .flex-offset-gt-xs-40, .layout-margin .offset-gt-xs-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-gt-xs-40, [dir=rtl] .flex-offset-gt-xs-40, [dir=rtl] .layout-margin .flex-offset-gt-xs-40, [dir=rtl] .layout-margin .offset-gt-xs-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-gt-xs-45, .flex-offset-gt-xs-45, .layout-margin .flex-offset-gt-xs-45, .layout-margin .offset-gt-xs-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-gt-xs-45, [dir=rtl] .flex-offset-gt-xs-45, [dir=rtl] .layout-margin .flex-offset-gt-xs-45, [dir=rtl] .layout-margin .offset-gt-xs-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-gt-xs-50, .flex-offset-gt-xs-50, .layout-margin .flex-offset-gt-xs-50, .layout-margin .offset-gt-xs-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-gt-xs-50, [dir=rtl] .flex-offset-gt-xs-50, [dir=rtl] .layout-margin .flex-offset-gt-xs-50, [dir=rtl] .layout-margin .offset-gt-xs-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-gt-xs-55, .flex-offset-gt-xs-55, .layout-margin .flex-offset-gt-xs-55, .layout-margin .offset-gt-xs-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-gt-xs-55, [dir=rtl] .flex-offset-gt-xs-55, [dir=rtl] .layout-margin .flex-offset-gt-xs-55, [dir=rtl] .layout-margin .offset-gt-xs-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-gt-xs-60, .flex-offset-gt-xs-60, .layout-margin .flex-offset-gt-xs-60, .layout-margin .offset-gt-xs-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-gt-xs-60, [dir=rtl] .flex-offset-gt-xs-60, [dir=rtl] .layout-margin .flex-offset-gt-xs-60, [dir=rtl] .layout-margin .offset-gt-xs-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-gt-xs-65, .flex-offset-gt-xs-65, .layout-margin .flex-offset-gt-xs-65, .layout-margin .offset-gt-xs-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-gt-xs-65, [dir=rtl] .flex-offset-gt-xs-65, [dir=rtl] .layout-margin .flex-offset-gt-xs-65, [dir=rtl] .layout-margin .offset-gt-xs-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-gt-xs-70, .flex-offset-gt-xs-70, .layout-margin .flex-offset-gt-xs-70, .layout-margin .offset-gt-xs-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-gt-xs-70, [dir=rtl] .flex-offset-gt-xs-70, [dir=rtl] .layout-margin .flex-offset-gt-xs-70, [dir=rtl] .layout-margin .offset-gt-xs-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-gt-xs-75, .flex-offset-gt-xs-75, .layout-margin .flex-offset-gt-xs-75, .layout-margin .offset-gt-xs-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-gt-xs-75, [dir=rtl] .flex-offset-gt-xs-75, [dir=rtl] .layout-margin .flex-offset-gt-xs-75, [dir=rtl] .layout-margin .offset-gt-xs-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-gt-xs-80, .flex-offset-gt-xs-80, .layout-margin .flex-offset-gt-xs-80, .layout-margin .offset-gt-xs-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-gt-xs-80, [dir=rtl] .flex-offset-gt-xs-80, [dir=rtl] .layout-margin .flex-offset-gt-xs-80, [dir=rtl] .layout-margin .offset-gt-xs-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-gt-xs-85, .flex-offset-gt-xs-85, .layout-margin .flex-offset-gt-xs-85, .layout-margin .offset-gt-xs-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-gt-xs-85, [dir=rtl] .flex-offset-gt-xs-85, [dir=rtl] .layout-margin .flex-offset-gt-xs-85, [dir=rtl] .layout-margin .offset-gt-xs-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-gt-xs-90, .flex-offset-gt-xs-90, .layout-margin .flex-offset-gt-xs-90, .layout-margin .offset-gt-xs-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-gt-xs-90, [dir=rtl] .flex-offset-gt-xs-90, [dir=rtl] .layout-margin .flex-offset-gt-xs-90, [dir=rtl] .layout-margin .offset-gt-xs-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-gt-xs-95, .flex-offset-gt-xs-95, .layout-margin .flex-offset-gt-xs-95, .layout-margin .offset-gt-xs-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-gt-xs-95, [dir=rtl] .flex-offset-gt-xs-95, [dir=rtl] .layout-margin .flex-offset-gt-xs-95, [dir=rtl] .layout-margin .offset-gt-xs-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-gt-xs-33, .flex-offset-gt-xs-33, .layout-margin .flex-offset-gt-xs-33, .layout-margin .offset-gt-xs-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-gt-xs-66, .flex-offset-gt-xs-66, .layout-margin .flex-offset-gt-xs-66, .layout-margin .offset-gt-xs-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-gt-xs-66, [dir=rtl] .flex-offset-gt-xs-66, [dir=rtl] .layout-margin .flex-offset-gt-xs-66, [dir=rtl] .layout-margin .offset-gt-xs-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-gt-xs,\n.layout-align-gt-xs-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-gt-xs-start,\n.layout-align-gt-xs-start-start,\n.layout-align-gt-xs-start-center,\n.layout-align-gt-xs-start-end,\n.layout-align-gt-xs-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-gt-xs-center,\n.layout-align-gt-xs-center-start,\n.layout-align-gt-xs-center-center,\n.layout-align-gt-xs-center-end,\n.layout-align-gt-xs-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-gt-xs-end,\n.layout-align-gt-xs-end-start,\n.layout-align-gt-xs-end-center,\n.layout-align-gt-xs-end-end,\n.layout-align-gt-xs-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-gt-xs-space-around,\n.layout-align-gt-xs-space-around-center,\n.layout-align-gt-xs-space-around-start,\n.layout-align-gt-xs-space-around-end,\n.layout-align-gt-xs-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-gt-xs-space-between,\n.layout-align-gt-xs-space-between-center,\n.layout-align-gt-xs-space-between-start,\n.layout-align-gt-xs-space-between-end,\n.layout-align-gt-xs-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-gt-xs-start-start,\n.layout-align-gt-xs-center-start,\n.layout-align-gt-xs-end-start,\n.layout-align-gt-xs-space-between-start,\n.layout-align-gt-xs-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-gt-xs-start-center,\n.layout-align-gt-xs-center-center,\n.layout-align-gt-xs-end-center,\n.layout-align-gt-xs-space-between-center,\n.layout-align-gt-xs-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-gt-xs-start-center > *,\n.layout-align-gt-xs-center-center > *,\n.layout-align-gt-xs-end-center > *,\n.layout-align-gt-xs-space-between-center > *,\n.layout-align-gt-xs-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-gt-xs-start-end,\n.layout-align-gt-xs-center-end,\n.layout-align-gt-xs-end-end,\n.layout-align-gt-xs-space-between-end,\n.layout-align-gt-xs-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-gt-xs-start-stretch,\n.layout-align-gt-xs-center-stretch,\n.layout-align-gt-xs-end-stretch,\n.layout-align-gt-xs-space-between-stretch,\n.layout-align-gt-xs-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-gt-xs {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-gt-xs-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-gt-xs-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-xs-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-gt-xs-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-xs-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-gt-xs-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-xs-row > .flex-gt-xs-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-xs-row > .flex-gt-xs-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-xs-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-gt-xs-column > .flex-gt-xs-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-gt-xs-column > .flex-gt-xs-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-gt-xs-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-gt-xs, .layout-gt-xs-column, .layout-gt-xs-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-gt-xs-column {\n    flex-direction: column;\n  }\n\n  .layout-gt-xs-row {\n    flex-direction: row;\n  }\n}\n@media (min-width: 600px) and (max-width: 959px) {\n  .hide:not(.show-gt-xs):not(.show-sm):not(.show), .hide-gt-xs:not(.show-gt-xs):not(.show-sm):not(.show) {\n    display: none;\n  }\n\n  .hide-sm:not(.show-gt-xs):not(.show-sm):not(.show) {\n    display: none;\n  }\n\n  .flex-order-sm--20 {\n    order: -20;\n  }\n\n  .flex-order-sm--19 {\n    order: -19;\n  }\n\n  .flex-order-sm--18 {\n    order: -18;\n  }\n\n  .flex-order-sm--17 {\n    order: -17;\n  }\n\n  .flex-order-sm--16 {\n    order: -16;\n  }\n\n  .flex-order-sm--15 {\n    order: -15;\n  }\n\n  .flex-order-sm--14 {\n    order: -14;\n  }\n\n  .flex-order-sm--13 {\n    order: -13;\n  }\n\n  .flex-order-sm--12 {\n    order: -12;\n  }\n\n  .flex-order-sm--11 {\n    order: -11;\n  }\n\n  .flex-order-sm--10 {\n    order: -10;\n  }\n\n  .flex-order-sm--9 {\n    order: -9;\n  }\n\n  .flex-order-sm--8 {\n    order: -8;\n  }\n\n  .flex-order-sm--7 {\n    order: -7;\n  }\n\n  .flex-order-sm--6 {\n    order: -6;\n  }\n\n  .flex-order-sm--5 {\n    order: -5;\n  }\n\n  .flex-order-sm--4 {\n    order: -4;\n  }\n\n  .flex-order-sm--3 {\n    order: -3;\n  }\n\n  .flex-order-sm--2 {\n    order: -2;\n  }\n\n  .flex-order-sm--1 {\n    order: -1;\n  }\n\n  .flex-order-sm-0 {\n    order: 0;\n  }\n\n  .flex-order-sm-1 {\n    order: 1;\n  }\n\n  .flex-order-sm-2 {\n    order: 2;\n  }\n\n  .flex-order-sm-3 {\n    order: 3;\n  }\n\n  .flex-order-sm-4 {\n    order: 4;\n  }\n\n  .flex-order-sm-5 {\n    order: 5;\n  }\n\n  .flex-order-sm-6 {\n    order: 6;\n  }\n\n  .flex-order-sm-7 {\n    order: 7;\n  }\n\n  .flex-order-sm-8 {\n    order: 8;\n  }\n\n  .flex-order-sm-9 {\n    order: 9;\n  }\n\n  .flex-order-sm-10 {\n    order: 10;\n  }\n\n  .flex-order-sm-11 {\n    order: 11;\n  }\n\n  .flex-order-sm-12 {\n    order: 12;\n  }\n\n  .flex-order-sm-13 {\n    order: 13;\n  }\n\n  .flex-order-sm-14 {\n    order: 14;\n  }\n\n  .flex-order-sm-15 {\n    order: 15;\n  }\n\n  .flex-order-sm-16 {\n    order: 16;\n  }\n\n  .flex-order-sm-17 {\n    order: 17;\n  }\n\n  .flex-order-sm-18 {\n    order: 18;\n  }\n\n  .flex-order-sm-19 {\n    order: 19;\n  }\n\n  .flex-order-sm-20 {\n    order: 20;\n  }\n\n  .offset-sm-0, .flex-offset-sm-0, .layout-margin .flex-offset-sm-0, .layout-margin .offset-sm-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-sm-0, [dir=rtl] .flex-offset-sm-0, [dir=rtl] .layout-margin .flex-offset-sm-0, [dir=rtl] .layout-margin .offset-sm-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-sm-5, .flex-offset-sm-5, .layout-margin .flex-offset-sm-5, .layout-margin .offset-sm-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-sm-5, [dir=rtl] .flex-offset-sm-5, [dir=rtl] .layout-margin .flex-offset-sm-5, [dir=rtl] .layout-margin .offset-sm-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-sm-10, .flex-offset-sm-10, .layout-margin .flex-offset-sm-10, .layout-margin .offset-sm-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-sm-10, [dir=rtl] .flex-offset-sm-10, [dir=rtl] .layout-margin .flex-offset-sm-10, [dir=rtl] .layout-margin .offset-sm-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-sm-15, .flex-offset-sm-15, .layout-margin .flex-offset-sm-15, .layout-margin .offset-sm-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-sm-15, [dir=rtl] .flex-offset-sm-15, [dir=rtl] .layout-margin .flex-offset-sm-15, [dir=rtl] .layout-margin .offset-sm-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-sm-20, .flex-offset-sm-20, .layout-margin .flex-offset-sm-20, .layout-margin .offset-sm-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-sm-20, [dir=rtl] .flex-offset-sm-20, [dir=rtl] .layout-margin .flex-offset-sm-20, [dir=rtl] .layout-margin .offset-sm-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-sm-25, .flex-offset-sm-25, .layout-margin .flex-offset-sm-25, .layout-margin .offset-sm-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-sm-25, [dir=rtl] .flex-offset-sm-25, [dir=rtl] .layout-margin .flex-offset-sm-25, [dir=rtl] .layout-margin .offset-sm-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-sm-30, .flex-offset-sm-30, .layout-margin .flex-offset-sm-30, .layout-margin .offset-sm-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-sm-30, [dir=rtl] .flex-offset-sm-30, [dir=rtl] .layout-margin .flex-offset-sm-30, [dir=rtl] .layout-margin .offset-sm-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-sm-35, .flex-offset-sm-35, .layout-margin .flex-offset-sm-35, .layout-margin .offset-sm-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-sm-35, [dir=rtl] .flex-offset-sm-35, [dir=rtl] .layout-margin .flex-offset-sm-35, [dir=rtl] .layout-margin .offset-sm-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-sm-40, .flex-offset-sm-40, .layout-margin .flex-offset-sm-40, .layout-margin .offset-sm-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-sm-40, [dir=rtl] .flex-offset-sm-40, [dir=rtl] .layout-margin .flex-offset-sm-40, [dir=rtl] .layout-margin .offset-sm-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-sm-45, .flex-offset-sm-45, .layout-margin .flex-offset-sm-45, .layout-margin .offset-sm-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-sm-45, [dir=rtl] .flex-offset-sm-45, [dir=rtl] .layout-margin .flex-offset-sm-45, [dir=rtl] .layout-margin .offset-sm-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-sm-50, .flex-offset-sm-50, .layout-margin .flex-offset-sm-50, .layout-margin .offset-sm-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-sm-50, [dir=rtl] .flex-offset-sm-50, [dir=rtl] .layout-margin .flex-offset-sm-50, [dir=rtl] .layout-margin .offset-sm-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-sm-55, .flex-offset-sm-55, .layout-margin .flex-offset-sm-55, .layout-margin .offset-sm-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-sm-55, [dir=rtl] .flex-offset-sm-55, [dir=rtl] .layout-margin .flex-offset-sm-55, [dir=rtl] .layout-margin .offset-sm-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-sm-60, .flex-offset-sm-60, .layout-margin .flex-offset-sm-60, .layout-margin .offset-sm-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-sm-60, [dir=rtl] .flex-offset-sm-60, [dir=rtl] .layout-margin .flex-offset-sm-60, [dir=rtl] .layout-margin .offset-sm-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-sm-65, .flex-offset-sm-65, .layout-margin .flex-offset-sm-65, .layout-margin .offset-sm-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-sm-65, [dir=rtl] .flex-offset-sm-65, [dir=rtl] .layout-margin .flex-offset-sm-65, [dir=rtl] .layout-margin .offset-sm-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-sm-70, .flex-offset-sm-70, .layout-margin .flex-offset-sm-70, .layout-margin .offset-sm-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-sm-70, [dir=rtl] .flex-offset-sm-70, [dir=rtl] .layout-margin .flex-offset-sm-70, [dir=rtl] .layout-margin .offset-sm-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-sm-75, .flex-offset-sm-75, .layout-margin .flex-offset-sm-75, .layout-margin .offset-sm-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-sm-75, [dir=rtl] .flex-offset-sm-75, [dir=rtl] .layout-margin .flex-offset-sm-75, [dir=rtl] .layout-margin .offset-sm-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-sm-80, .flex-offset-sm-80, .layout-margin .flex-offset-sm-80, .layout-margin .offset-sm-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-sm-80, [dir=rtl] .flex-offset-sm-80, [dir=rtl] .layout-margin .flex-offset-sm-80, [dir=rtl] .layout-margin .offset-sm-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-sm-85, .flex-offset-sm-85, .layout-margin .flex-offset-sm-85, .layout-margin .offset-sm-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-sm-85, [dir=rtl] .flex-offset-sm-85, [dir=rtl] .layout-margin .flex-offset-sm-85, [dir=rtl] .layout-margin .offset-sm-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-sm-90, .flex-offset-sm-90, .layout-margin .flex-offset-sm-90, .layout-margin .offset-sm-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-sm-90, [dir=rtl] .flex-offset-sm-90, [dir=rtl] .layout-margin .flex-offset-sm-90, [dir=rtl] .layout-margin .offset-sm-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-sm-95, .flex-offset-sm-95, .layout-margin .flex-offset-sm-95, .layout-margin .offset-sm-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-sm-95, [dir=rtl] .flex-offset-sm-95, [dir=rtl] .layout-margin .flex-offset-sm-95, [dir=rtl] .layout-margin .offset-sm-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-sm-33, .flex-offset-sm-33, .layout-margin .flex-offset-sm-33, .layout-margin .offset-sm-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-sm-66, .flex-offset-sm-66, .layout-margin .flex-offset-sm-66, .layout-margin .offset-sm-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-sm-66, [dir=rtl] .flex-offset-sm-66, [dir=rtl] .layout-margin .flex-offset-sm-66, [dir=rtl] .layout-margin .offset-sm-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-sm,\n.layout-align-sm-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-sm-start,\n.layout-align-sm-start-start,\n.layout-align-sm-start-center,\n.layout-align-sm-start-end,\n.layout-align-sm-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-sm-center,\n.layout-align-sm-center-start,\n.layout-align-sm-center-center,\n.layout-align-sm-center-end,\n.layout-align-sm-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-sm-end,\n.layout-align-sm-end-start,\n.layout-align-sm-end-center,\n.layout-align-sm-end-end,\n.layout-align-sm-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-sm-space-around,\n.layout-align-sm-space-around-center,\n.layout-align-sm-space-around-start,\n.layout-align-sm-space-around-end,\n.layout-align-sm-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-sm-space-between,\n.layout-align-sm-space-between-center,\n.layout-align-sm-space-between-start,\n.layout-align-sm-space-between-end,\n.layout-align-sm-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-sm-start-start,\n.layout-align-sm-center-start,\n.layout-align-sm-end-start,\n.layout-align-sm-space-between-start,\n.layout-align-sm-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-sm-start-center,\n.layout-align-sm-center-center,\n.layout-align-sm-end-center,\n.layout-align-sm-space-between-center,\n.layout-align-sm-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-sm-start-center > *,\n.layout-align-sm-center-center > *,\n.layout-align-sm-end-center > *,\n.layout-align-sm-space-between-center > *,\n.layout-align-sm-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-sm-start-end,\n.layout-align-sm-center-end,\n.layout-align-sm-end-end,\n.layout-align-sm-space-between-end,\n.layout-align-sm-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-sm-start-stretch,\n.layout-align-sm-center-stretch,\n.layout-align-sm-end-stretch,\n.layout-align-sm-space-between-stretch,\n.layout-align-sm-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-sm {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-sm-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-sm-column > .flex-sm-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-sm-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-column > .flex-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-sm-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-sm-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-sm-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-sm-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-sm-row > .flex-sm-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-sm-row > .flex-sm-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-sm-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-sm-column > .flex-sm-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-sm-column > .flex-sm-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-sm-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-sm, .layout-sm-column, .layout-sm-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-sm-column {\n    flex-direction: column;\n  }\n\n  .layout-sm-row {\n    flex-direction: row;\n  }\n}\n@media (min-width: 960px) {\n  .flex-order-gt-sm--20 {\n    order: -20;\n  }\n\n  .flex-order-gt-sm--19 {\n    order: -19;\n  }\n\n  .flex-order-gt-sm--18 {\n    order: -18;\n  }\n\n  .flex-order-gt-sm--17 {\n    order: -17;\n  }\n\n  .flex-order-gt-sm--16 {\n    order: -16;\n  }\n\n  .flex-order-gt-sm--15 {\n    order: -15;\n  }\n\n  .flex-order-gt-sm--14 {\n    order: -14;\n  }\n\n  .flex-order-gt-sm--13 {\n    order: -13;\n  }\n\n  .flex-order-gt-sm--12 {\n    order: -12;\n  }\n\n  .flex-order-gt-sm--11 {\n    order: -11;\n  }\n\n  .flex-order-gt-sm--10 {\n    order: -10;\n  }\n\n  .flex-order-gt-sm--9 {\n    order: -9;\n  }\n\n  .flex-order-gt-sm--8 {\n    order: -8;\n  }\n\n  .flex-order-gt-sm--7 {\n    order: -7;\n  }\n\n  .flex-order-gt-sm--6 {\n    order: -6;\n  }\n\n  .flex-order-gt-sm--5 {\n    order: -5;\n  }\n\n  .flex-order-gt-sm--4 {\n    order: -4;\n  }\n\n  .flex-order-gt-sm--3 {\n    order: -3;\n  }\n\n  .flex-order-gt-sm--2 {\n    order: -2;\n  }\n\n  .flex-order-gt-sm--1 {\n    order: -1;\n  }\n\n  .flex-order-gt-sm-0 {\n    order: 0;\n  }\n\n  .flex-order-gt-sm-1 {\n    order: 1;\n  }\n\n  .flex-order-gt-sm-2 {\n    order: 2;\n  }\n\n  .flex-order-gt-sm-3 {\n    order: 3;\n  }\n\n  .flex-order-gt-sm-4 {\n    order: 4;\n  }\n\n  .flex-order-gt-sm-5 {\n    order: 5;\n  }\n\n  .flex-order-gt-sm-6 {\n    order: 6;\n  }\n\n  .flex-order-gt-sm-7 {\n    order: 7;\n  }\n\n  .flex-order-gt-sm-8 {\n    order: 8;\n  }\n\n  .flex-order-gt-sm-9 {\n    order: 9;\n  }\n\n  .flex-order-gt-sm-10 {\n    order: 10;\n  }\n\n  .flex-order-gt-sm-11 {\n    order: 11;\n  }\n\n  .flex-order-gt-sm-12 {\n    order: 12;\n  }\n\n  .flex-order-gt-sm-13 {\n    order: 13;\n  }\n\n  .flex-order-gt-sm-14 {\n    order: 14;\n  }\n\n  .flex-order-gt-sm-15 {\n    order: 15;\n  }\n\n  .flex-order-gt-sm-16 {\n    order: 16;\n  }\n\n  .flex-order-gt-sm-17 {\n    order: 17;\n  }\n\n  .flex-order-gt-sm-18 {\n    order: 18;\n  }\n\n  .flex-order-gt-sm-19 {\n    order: 19;\n  }\n\n  .flex-order-gt-sm-20 {\n    order: 20;\n  }\n\n  .offset-gt-sm-0, .flex-offset-gt-sm-0, .layout-margin .flex-offset-gt-sm-0, .layout-margin .offset-gt-sm-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-gt-sm-0, [dir=rtl] .flex-offset-gt-sm-0, [dir=rtl] .layout-margin .flex-offset-gt-sm-0, [dir=rtl] .layout-margin .offset-gt-sm-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-gt-sm-5, .flex-offset-gt-sm-5, .layout-margin .flex-offset-gt-sm-5, .layout-margin .offset-gt-sm-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-gt-sm-5, [dir=rtl] .flex-offset-gt-sm-5, [dir=rtl] .layout-margin .flex-offset-gt-sm-5, [dir=rtl] .layout-margin .offset-gt-sm-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-gt-sm-10, .flex-offset-gt-sm-10, .layout-margin .flex-offset-gt-sm-10, .layout-margin .offset-gt-sm-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-gt-sm-10, [dir=rtl] .flex-offset-gt-sm-10, [dir=rtl] .layout-margin .flex-offset-gt-sm-10, [dir=rtl] .layout-margin .offset-gt-sm-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-gt-sm-15, .flex-offset-gt-sm-15, .layout-margin .flex-offset-gt-sm-15, .layout-margin .offset-gt-sm-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-gt-sm-15, [dir=rtl] .flex-offset-gt-sm-15, [dir=rtl] .layout-margin .flex-offset-gt-sm-15, [dir=rtl] .layout-margin .offset-gt-sm-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-gt-sm-20, .flex-offset-gt-sm-20, .layout-margin .flex-offset-gt-sm-20, .layout-margin .offset-gt-sm-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-gt-sm-20, [dir=rtl] .flex-offset-gt-sm-20, [dir=rtl] .layout-margin .flex-offset-gt-sm-20, [dir=rtl] .layout-margin .offset-gt-sm-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-gt-sm-25, .flex-offset-gt-sm-25, .layout-margin .flex-offset-gt-sm-25, .layout-margin .offset-gt-sm-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-gt-sm-25, [dir=rtl] .flex-offset-gt-sm-25, [dir=rtl] .layout-margin .flex-offset-gt-sm-25, [dir=rtl] .layout-margin .offset-gt-sm-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-gt-sm-30, .flex-offset-gt-sm-30, .layout-margin .flex-offset-gt-sm-30, .layout-margin .offset-gt-sm-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-gt-sm-30, [dir=rtl] .flex-offset-gt-sm-30, [dir=rtl] .layout-margin .flex-offset-gt-sm-30, [dir=rtl] .layout-margin .offset-gt-sm-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-gt-sm-35, .flex-offset-gt-sm-35, .layout-margin .flex-offset-gt-sm-35, .layout-margin .offset-gt-sm-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-gt-sm-35, [dir=rtl] .flex-offset-gt-sm-35, [dir=rtl] .layout-margin .flex-offset-gt-sm-35, [dir=rtl] .layout-margin .offset-gt-sm-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-gt-sm-40, .flex-offset-gt-sm-40, .layout-margin .flex-offset-gt-sm-40, .layout-margin .offset-gt-sm-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-gt-sm-40, [dir=rtl] .flex-offset-gt-sm-40, [dir=rtl] .layout-margin .flex-offset-gt-sm-40, [dir=rtl] .layout-margin .offset-gt-sm-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-gt-sm-45, .flex-offset-gt-sm-45, .layout-margin .flex-offset-gt-sm-45, .layout-margin .offset-gt-sm-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-gt-sm-45, [dir=rtl] .flex-offset-gt-sm-45, [dir=rtl] .layout-margin .flex-offset-gt-sm-45, [dir=rtl] .layout-margin .offset-gt-sm-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-gt-sm-50, .flex-offset-gt-sm-50, .layout-margin .flex-offset-gt-sm-50, .layout-margin .offset-gt-sm-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-gt-sm-50, [dir=rtl] .flex-offset-gt-sm-50, [dir=rtl] .layout-margin .flex-offset-gt-sm-50, [dir=rtl] .layout-margin .offset-gt-sm-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-gt-sm-55, .flex-offset-gt-sm-55, .layout-margin .flex-offset-gt-sm-55, .layout-margin .offset-gt-sm-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-gt-sm-55, [dir=rtl] .flex-offset-gt-sm-55, [dir=rtl] .layout-margin .flex-offset-gt-sm-55, [dir=rtl] .layout-margin .offset-gt-sm-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-gt-sm-60, .flex-offset-gt-sm-60, .layout-margin .flex-offset-gt-sm-60, .layout-margin .offset-gt-sm-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-gt-sm-60, [dir=rtl] .flex-offset-gt-sm-60, [dir=rtl] .layout-margin .flex-offset-gt-sm-60, [dir=rtl] .layout-margin .offset-gt-sm-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-gt-sm-65, .flex-offset-gt-sm-65, .layout-margin .flex-offset-gt-sm-65, .layout-margin .offset-gt-sm-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-gt-sm-65, [dir=rtl] .flex-offset-gt-sm-65, [dir=rtl] .layout-margin .flex-offset-gt-sm-65, [dir=rtl] .layout-margin .offset-gt-sm-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-gt-sm-70, .flex-offset-gt-sm-70, .layout-margin .flex-offset-gt-sm-70, .layout-margin .offset-gt-sm-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-gt-sm-70, [dir=rtl] .flex-offset-gt-sm-70, [dir=rtl] .layout-margin .flex-offset-gt-sm-70, [dir=rtl] .layout-margin .offset-gt-sm-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-gt-sm-75, .flex-offset-gt-sm-75, .layout-margin .flex-offset-gt-sm-75, .layout-margin .offset-gt-sm-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-gt-sm-75, [dir=rtl] .flex-offset-gt-sm-75, [dir=rtl] .layout-margin .flex-offset-gt-sm-75, [dir=rtl] .layout-margin .offset-gt-sm-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-gt-sm-80, .flex-offset-gt-sm-80, .layout-margin .flex-offset-gt-sm-80, .layout-margin .offset-gt-sm-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-gt-sm-80, [dir=rtl] .flex-offset-gt-sm-80, [dir=rtl] .layout-margin .flex-offset-gt-sm-80, [dir=rtl] .layout-margin .offset-gt-sm-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-gt-sm-85, .flex-offset-gt-sm-85, .layout-margin .flex-offset-gt-sm-85, .layout-margin .offset-gt-sm-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-gt-sm-85, [dir=rtl] .flex-offset-gt-sm-85, [dir=rtl] .layout-margin .flex-offset-gt-sm-85, [dir=rtl] .layout-margin .offset-gt-sm-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-gt-sm-90, .flex-offset-gt-sm-90, .layout-margin .flex-offset-gt-sm-90, .layout-margin .offset-gt-sm-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-gt-sm-90, [dir=rtl] .flex-offset-gt-sm-90, [dir=rtl] .layout-margin .flex-offset-gt-sm-90, [dir=rtl] .layout-margin .offset-gt-sm-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-gt-sm-95, .flex-offset-gt-sm-95, .layout-margin .flex-offset-gt-sm-95, .layout-margin .offset-gt-sm-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-gt-sm-95, [dir=rtl] .flex-offset-gt-sm-95, [dir=rtl] .layout-margin .flex-offset-gt-sm-95, [dir=rtl] .layout-margin .offset-gt-sm-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-gt-sm-33, .flex-offset-gt-sm-33, .layout-margin .flex-offset-gt-sm-33, .layout-margin .offset-gt-sm-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-gt-sm-66, .flex-offset-gt-sm-66, .layout-margin .flex-offset-gt-sm-66, .layout-margin .offset-gt-sm-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-gt-sm-66, [dir=rtl] .flex-offset-gt-sm-66, [dir=rtl] .layout-margin .flex-offset-gt-sm-66, [dir=rtl] .layout-margin .offset-gt-sm-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-gt-sm,\n.layout-align-gt-sm-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-gt-sm-start,\n.layout-align-gt-sm-start-start,\n.layout-align-gt-sm-start-center,\n.layout-align-gt-sm-start-end,\n.layout-align-gt-sm-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-gt-sm-center,\n.layout-align-gt-sm-center-start,\n.layout-align-gt-sm-center-center,\n.layout-align-gt-sm-center-end,\n.layout-align-gt-sm-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-gt-sm-end,\n.layout-align-gt-sm-end-start,\n.layout-align-gt-sm-end-center,\n.layout-align-gt-sm-end-end,\n.layout-align-gt-sm-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-gt-sm-space-around,\n.layout-align-gt-sm-space-around-center,\n.layout-align-gt-sm-space-around-start,\n.layout-align-gt-sm-space-around-end,\n.layout-align-gt-sm-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-gt-sm-space-between,\n.layout-align-gt-sm-space-between-center,\n.layout-align-gt-sm-space-between-start,\n.layout-align-gt-sm-space-between-end,\n.layout-align-gt-sm-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-gt-sm-start-start,\n.layout-align-gt-sm-center-start,\n.layout-align-gt-sm-end-start,\n.layout-align-gt-sm-space-between-start,\n.layout-align-gt-sm-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-gt-sm-start-center,\n.layout-align-gt-sm-center-center,\n.layout-align-gt-sm-end-center,\n.layout-align-gt-sm-space-between-center,\n.layout-align-gt-sm-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-gt-sm-start-center > *,\n.layout-align-gt-sm-center-center > *,\n.layout-align-gt-sm-end-center > *,\n.layout-align-gt-sm-space-between-center > *,\n.layout-align-gt-sm-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-gt-sm-start-end,\n.layout-align-gt-sm-center-end,\n.layout-align-gt-sm-end-end,\n.layout-align-gt-sm-space-between-end,\n.layout-align-gt-sm-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-gt-sm-start-stretch,\n.layout-align-gt-sm-center-stretch,\n.layout-align-gt-sm-end-stretch,\n.layout-align-gt-sm-space-between-stretch,\n.layout-align-gt-sm-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-gt-sm {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-gt-sm-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-gt-sm-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-sm-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-gt-sm-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-sm-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-gt-sm-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-sm-row > .flex-gt-sm-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-sm-row > .flex-gt-sm-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-sm-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-gt-sm-column > .flex-gt-sm-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-gt-sm-column > .flex-gt-sm-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-gt-sm-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-gt-sm, .layout-gt-sm-column, .layout-gt-sm-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-gt-sm-column {\n    flex-direction: column;\n  }\n\n  .layout-gt-sm-row {\n    flex-direction: row;\n  }\n}\n@media (min-width: 960px) and (max-width: 1279px) {\n  .hide:not(.show-gt-xs):not(.show-gt-sm):not(.show-md):not(.show), .hide-gt-xs:not(.show-gt-xs):not(.show-gt-sm):not(.show-md):not(.show), .hide-gt-sm:not(.show-gt-xs):not(.show-gt-sm):not(.show-md):not(.show) {\n    display: none;\n  }\n\n  .hide-md:not(.show-md):not(.show-gt-sm):not(.show-gt-xs):not(.show) {\n    display: none;\n  }\n\n  .flex-order-md--20 {\n    order: -20;\n  }\n\n  .flex-order-md--19 {\n    order: -19;\n  }\n\n  .flex-order-md--18 {\n    order: -18;\n  }\n\n  .flex-order-md--17 {\n    order: -17;\n  }\n\n  .flex-order-md--16 {\n    order: -16;\n  }\n\n  .flex-order-md--15 {\n    order: -15;\n  }\n\n  .flex-order-md--14 {\n    order: -14;\n  }\n\n  .flex-order-md--13 {\n    order: -13;\n  }\n\n  .flex-order-md--12 {\n    order: -12;\n  }\n\n  .flex-order-md--11 {\n    order: -11;\n  }\n\n  .flex-order-md--10 {\n    order: -10;\n  }\n\n  .flex-order-md--9 {\n    order: -9;\n  }\n\n  .flex-order-md--8 {\n    order: -8;\n  }\n\n  .flex-order-md--7 {\n    order: -7;\n  }\n\n  .flex-order-md--6 {\n    order: -6;\n  }\n\n  .flex-order-md--5 {\n    order: -5;\n  }\n\n  .flex-order-md--4 {\n    order: -4;\n  }\n\n  .flex-order-md--3 {\n    order: -3;\n  }\n\n  .flex-order-md--2 {\n    order: -2;\n  }\n\n  .flex-order-md--1 {\n    order: -1;\n  }\n\n  .flex-order-md-0 {\n    order: 0;\n  }\n\n  .flex-order-md-1 {\n    order: 1;\n  }\n\n  .flex-order-md-2 {\n    order: 2;\n  }\n\n  .flex-order-md-3 {\n    order: 3;\n  }\n\n  .flex-order-md-4 {\n    order: 4;\n  }\n\n  .flex-order-md-5 {\n    order: 5;\n  }\n\n  .flex-order-md-6 {\n    order: 6;\n  }\n\n  .flex-order-md-7 {\n    order: 7;\n  }\n\n  .flex-order-md-8 {\n    order: 8;\n  }\n\n  .flex-order-md-9 {\n    order: 9;\n  }\n\n  .flex-order-md-10 {\n    order: 10;\n  }\n\n  .flex-order-md-11 {\n    order: 11;\n  }\n\n  .flex-order-md-12 {\n    order: 12;\n  }\n\n  .flex-order-md-13 {\n    order: 13;\n  }\n\n  .flex-order-md-14 {\n    order: 14;\n  }\n\n  .flex-order-md-15 {\n    order: 15;\n  }\n\n  .flex-order-md-16 {\n    order: 16;\n  }\n\n  .flex-order-md-17 {\n    order: 17;\n  }\n\n  .flex-order-md-18 {\n    order: 18;\n  }\n\n  .flex-order-md-19 {\n    order: 19;\n  }\n\n  .flex-order-md-20 {\n    order: 20;\n  }\n\n  .offset-md-0, .flex-offset-md-0, .layout-margin .flex-offset-md-0, .layout-margin .offset-md-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-md-0, [dir=rtl] .flex-offset-md-0, [dir=rtl] .layout-margin .flex-offset-md-0, [dir=rtl] .layout-margin .offset-md-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-md-5, .flex-offset-md-5, .layout-margin .flex-offset-md-5, .layout-margin .offset-md-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-md-5, [dir=rtl] .flex-offset-md-5, [dir=rtl] .layout-margin .flex-offset-md-5, [dir=rtl] .layout-margin .offset-md-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-md-10, .flex-offset-md-10, .layout-margin .flex-offset-md-10, .layout-margin .offset-md-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-md-10, [dir=rtl] .flex-offset-md-10, [dir=rtl] .layout-margin .flex-offset-md-10, [dir=rtl] .layout-margin .offset-md-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-md-15, .flex-offset-md-15, .layout-margin .flex-offset-md-15, .layout-margin .offset-md-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-md-15, [dir=rtl] .flex-offset-md-15, [dir=rtl] .layout-margin .flex-offset-md-15, [dir=rtl] .layout-margin .offset-md-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-md-20, .flex-offset-md-20, .layout-margin .flex-offset-md-20, .layout-margin .offset-md-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-md-20, [dir=rtl] .flex-offset-md-20, [dir=rtl] .layout-margin .flex-offset-md-20, [dir=rtl] .layout-margin .offset-md-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-md-25, .flex-offset-md-25, .layout-margin .flex-offset-md-25, .layout-margin .offset-md-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-md-25, [dir=rtl] .flex-offset-md-25, [dir=rtl] .layout-margin .flex-offset-md-25, [dir=rtl] .layout-margin .offset-md-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-md-30, .flex-offset-md-30, .layout-margin .flex-offset-md-30, .layout-margin .offset-md-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-md-30, [dir=rtl] .flex-offset-md-30, [dir=rtl] .layout-margin .flex-offset-md-30, [dir=rtl] .layout-margin .offset-md-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-md-35, .flex-offset-md-35, .layout-margin .flex-offset-md-35, .layout-margin .offset-md-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-md-35, [dir=rtl] .flex-offset-md-35, [dir=rtl] .layout-margin .flex-offset-md-35, [dir=rtl] .layout-margin .offset-md-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-md-40, .flex-offset-md-40, .layout-margin .flex-offset-md-40, .layout-margin .offset-md-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-md-40, [dir=rtl] .flex-offset-md-40, [dir=rtl] .layout-margin .flex-offset-md-40, [dir=rtl] .layout-margin .offset-md-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-md-45, .flex-offset-md-45, .layout-margin .flex-offset-md-45, .layout-margin .offset-md-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-md-45, [dir=rtl] .flex-offset-md-45, [dir=rtl] .layout-margin .flex-offset-md-45, [dir=rtl] .layout-margin .offset-md-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-md-50, .flex-offset-md-50, .layout-margin .flex-offset-md-50, .layout-margin .offset-md-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-md-50, [dir=rtl] .flex-offset-md-50, [dir=rtl] .layout-margin .flex-offset-md-50, [dir=rtl] .layout-margin .offset-md-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-md-55, .flex-offset-md-55, .layout-margin .flex-offset-md-55, .layout-margin .offset-md-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-md-55, [dir=rtl] .flex-offset-md-55, [dir=rtl] .layout-margin .flex-offset-md-55, [dir=rtl] .layout-margin .offset-md-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-md-60, .flex-offset-md-60, .layout-margin .flex-offset-md-60, .layout-margin .offset-md-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-md-60, [dir=rtl] .flex-offset-md-60, [dir=rtl] .layout-margin .flex-offset-md-60, [dir=rtl] .layout-margin .offset-md-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-md-65, .flex-offset-md-65, .layout-margin .flex-offset-md-65, .layout-margin .offset-md-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-md-65, [dir=rtl] .flex-offset-md-65, [dir=rtl] .layout-margin .flex-offset-md-65, [dir=rtl] .layout-margin .offset-md-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-md-70, .flex-offset-md-70, .layout-margin .flex-offset-md-70, .layout-margin .offset-md-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-md-70, [dir=rtl] .flex-offset-md-70, [dir=rtl] .layout-margin .flex-offset-md-70, [dir=rtl] .layout-margin .offset-md-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-md-75, .flex-offset-md-75, .layout-margin .flex-offset-md-75, .layout-margin .offset-md-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-md-75, [dir=rtl] .flex-offset-md-75, [dir=rtl] .layout-margin .flex-offset-md-75, [dir=rtl] .layout-margin .offset-md-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-md-80, .flex-offset-md-80, .layout-margin .flex-offset-md-80, .layout-margin .offset-md-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-md-80, [dir=rtl] .flex-offset-md-80, [dir=rtl] .layout-margin .flex-offset-md-80, [dir=rtl] .layout-margin .offset-md-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-md-85, .flex-offset-md-85, .layout-margin .flex-offset-md-85, .layout-margin .offset-md-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-md-85, [dir=rtl] .flex-offset-md-85, [dir=rtl] .layout-margin .flex-offset-md-85, [dir=rtl] .layout-margin .offset-md-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-md-90, .flex-offset-md-90, .layout-margin .flex-offset-md-90, .layout-margin .offset-md-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-md-90, [dir=rtl] .flex-offset-md-90, [dir=rtl] .layout-margin .flex-offset-md-90, [dir=rtl] .layout-margin .offset-md-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-md-95, .flex-offset-md-95, .layout-margin .flex-offset-md-95, .layout-margin .offset-md-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-md-95, [dir=rtl] .flex-offset-md-95, [dir=rtl] .layout-margin .flex-offset-md-95, [dir=rtl] .layout-margin .offset-md-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-md-33, .flex-offset-md-33, .layout-margin .flex-offset-md-33, .layout-margin .offset-md-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-md-66, .flex-offset-md-66, .layout-margin .flex-offset-md-66, .layout-margin .offset-md-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-md-66, [dir=rtl] .flex-offset-md-66, [dir=rtl] .layout-margin .flex-offset-md-66, [dir=rtl] .layout-margin .offset-md-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-md,\n.layout-align-md-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-md-start,\n.layout-align-md-start-start,\n.layout-align-md-start-center,\n.layout-align-md-start-end,\n.layout-align-md-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-md-center,\n.layout-align-md-center-start,\n.layout-align-md-center-center,\n.layout-align-md-center-end,\n.layout-align-md-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-md-end,\n.layout-align-md-end-start,\n.layout-align-md-end-center,\n.layout-align-md-end-end,\n.layout-align-md-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-md-space-around,\n.layout-align-md-space-around-center,\n.layout-align-md-space-around-start,\n.layout-align-md-space-around-end,\n.layout-align-md-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-md-space-between,\n.layout-align-md-space-between-center,\n.layout-align-md-space-between-start,\n.layout-align-md-space-between-end,\n.layout-align-md-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-md-start-start,\n.layout-align-md-center-start,\n.layout-align-md-end-start,\n.layout-align-md-space-between-start,\n.layout-align-md-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-md-start-center,\n.layout-align-md-center-center,\n.layout-align-md-end-center,\n.layout-align-md-space-between-center,\n.layout-align-md-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-md-start-center > *,\n.layout-align-md-center-center > *,\n.layout-align-md-end-center > *,\n.layout-align-md-space-between-center > *,\n.layout-align-md-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-md-start-end,\n.layout-align-md-center-end,\n.layout-align-md-end-end,\n.layout-align-md-space-between-end,\n.layout-align-md-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-md-start-stretch,\n.layout-align-md-center-stretch,\n.layout-align-md-end-stretch,\n.layout-align-md-space-between-stretch,\n.layout-align-md-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-md {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-md-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-md-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-md-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-md-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-md-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-md-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-md-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-md-column > .flex-md-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-md-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-column > .flex-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-md-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-md-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-md-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-md-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-md-row > .flex-md-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-md-row > .flex-md-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-md-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-md-column > .flex-md-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-md-column > .flex-md-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-md-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-md, .layout-md-column, .layout-md-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-md-column {\n    flex-direction: column;\n  }\n\n  .layout-md-row {\n    flex-direction: row;\n  }\n}\n@media (min-width: 1280px) {\n  .flex-order-gt-md--20 {\n    order: -20;\n  }\n\n  .flex-order-gt-md--19 {\n    order: -19;\n  }\n\n  .flex-order-gt-md--18 {\n    order: -18;\n  }\n\n  .flex-order-gt-md--17 {\n    order: -17;\n  }\n\n  .flex-order-gt-md--16 {\n    order: -16;\n  }\n\n  .flex-order-gt-md--15 {\n    order: -15;\n  }\n\n  .flex-order-gt-md--14 {\n    order: -14;\n  }\n\n  .flex-order-gt-md--13 {\n    order: -13;\n  }\n\n  .flex-order-gt-md--12 {\n    order: -12;\n  }\n\n  .flex-order-gt-md--11 {\n    order: -11;\n  }\n\n  .flex-order-gt-md--10 {\n    order: -10;\n  }\n\n  .flex-order-gt-md--9 {\n    order: -9;\n  }\n\n  .flex-order-gt-md--8 {\n    order: -8;\n  }\n\n  .flex-order-gt-md--7 {\n    order: -7;\n  }\n\n  .flex-order-gt-md--6 {\n    order: -6;\n  }\n\n  .flex-order-gt-md--5 {\n    order: -5;\n  }\n\n  .flex-order-gt-md--4 {\n    order: -4;\n  }\n\n  .flex-order-gt-md--3 {\n    order: -3;\n  }\n\n  .flex-order-gt-md--2 {\n    order: -2;\n  }\n\n  .flex-order-gt-md--1 {\n    order: -1;\n  }\n\n  .flex-order-gt-md-0 {\n    order: 0;\n  }\n\n  .flex-order-gt-md-1 {\n    order: 1;\n  }\n\n  .flex-order-gt-md-2 {\n    order: 2;\n  }\n\n  .flex-order-gt-md-3 {\n    order: 3;\n  }\n\n  .flex-order-gt-md-4 {\n    order: 4;\n  }\n\n  .flex-order-gt-md-5 {\n    order: 5;\n  }\n\n  .flex-order-gt-md-6 {\n    order: 6;\n  }\n\n  .flex-order-gt-md-7 {\n    order: 7;\n  }\n\n  .flex-order-gt-md-8 {\n    order: 8;\n  }\n\n  .flex-order-gt-md-9 {\n    order: 9;\n  }\n\n  .flex-order-gt-md-10 {\n    order: 10;\n  }\n\n  .flex-order-gt-md-11 {\n    order: 11;\n  }\n\n  .flex-order-gt-md-12 {\n    order: 12;\n  }\n\n  .flex-order-gt-md-13 {\n    order: 13;\n  }\n\n  .flex-order-gt-md-14 {\n    order: 14;\n  }\n\n  .flex-order-gt-md-15 {\n    order: 15;\n  }\n\n  .flex-order-gt-md-16 {\n    order: 16;\n  }\n\n  .flex-order-gt-md-17 {\n    order: 17;\n  }\n\n  .flex-order-gt-md-18 {\n    order: 18;\n  }\n\n  .flex-order-gt-md-19 {\n    order: 19;\n  }\n\n  .flex-order-gt-md-20 {\n    order: 20;\n  }\n\n  .offset-gt-md-0, .flex-offset-gt-md-0, .layout-margin .flex-offset-gt-md-0, .layout-margin .offset-gt-md-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-gt-md-0, [dir=rtl] .flex-offset-gt-md-0, [dir=rtl] .layout-margin .flex-offset-gt-md-0, [dir=rtl] .layout-margin .offset-gt-md-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-gt-md-5, .flex-offset-gt-md-5, .layout-margin .flex-offset-gt-md-5, .layout-margin .offset-gt-md-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-gt-md-5, [dir=rtl] .flex-offset-gt-md-5, [dir=rtl] .layout-margin .flex-offset-gt-md-5, [dir=rtl] .layout-margin .offset-gt-md-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-gt-md-10, .flex-offset-gt-md-10, .layout-margin .flex-offset-gt-md-10, .layout-margin .offset-gt-md-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-gt-md-10, [dir=rtl] .flex-offset-gt-md-10, [dir=rtl] .layout-margin .flex-offset-gt-md-10, [dir=rtl] .layout-margin .offset-gt-md-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-gt-md-15, .flex-offset-gt-md-15, .layout-margin .flex-offset-gt-md-15, .layout-margin .offset-gt-md-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-gt-md-15, [dir=rtl] .flex-offset-gt-md-15, [dir=rtl] .layout-margin .flex-offset-gt-md-15, [dir=rtl] .layout-margin .offset-gt-md-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-gt-md-20, .flex-offset-gt-md-20, .layout-margin .flex-offset-gt-md-20, .layout-margin .offset-gt-md-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-gt-md-20, [dir=rtl] .flex-offset-gt-md-20, [dir=rtl] .layout-margin .flex-offset-gt-md-20, [dir=rtl] .layout-margin .offset-gt-md-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-gt-md-25, .flex-offset-gt-md-25, .layout-margin .flex-offset-gt-md-25, .layout-margin .offset-gt-md-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-gt-md-25, [dir=rtl] .flex-offset-gt-md-25, [dir=rtl] .layout-margin .flex-offset-gt-md-25, [dir=rtl] .layout-margin .offset-gt-md-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-gt-md-30, .flex-offset-gt-md-30, .layout-margin .flex-offset-gt-md-30, .layout-margin .offset-gt-md-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-gt-md-30, [dir=rtl] .flex-offset-gt-md-30, [dir=rtl] .layout-margin .flex-offset-gt-md-30, [dir=rtl] .layout-margin .offset-gt-md-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-gt-md-35, .flex-offset-gt-md-35, .layout-margin .flex-offset-gt-md-35, .layout-margin .offset-gt-md-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-gt-md-35, [dir=rtl] .flex-offset-gt-md-35, [dir=rtl] .layout-margin .flex-offset-gt-md-35, [dir=rtl] .layout-margin .offset-gt-md-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-gt-md-40, .flex-offset-gt-md-40, .layout-margin .flex-offset-gt-md-40, .layout-margin .offset-gt-md-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-gt-md-40, [dir=rtl] .flex-offset-gt-md-40, [dir=rtl] .layout-margin .flex-offset-gt-md-40, [dir=rtl] .layout-margin .offset-gt-md-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-gt-md-45, .flex-offset-gt-md-45, .layout-margin .flex-offset-gt-md-45, .layout-margin .offset-gt-md-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-gt-md-45, [dir=rtl] .flex-offset-gt-md-45, [dir=rtl] .layout-margin .flex-offset-gt-md-45, [dir=rtl] .layout-margin .offset-gt-md-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-gt-md-50, .flex-offset-gt-md-50, .layout-margin .flex-offset-gt-md-50, .layout-margin .offset-gt-md-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-gt-md-50, [dir=rtl] .flex-offset-gt-md-50, [dir=rtl] .layout-margin .flex-offset-gt-md-50, [dir=rtl] .layout-margin .offset-gt-md-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-gt-md-55, .flex-offset-gt-md-55, .layout-margin .flex-offset-gt-md-55, .layout-margin .offset-gt-md-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-gt-md-55, [dir=rtl] .flex-offset-gt-md-55, [dir=rtl] .layout-margin .flex-offset-gt-md-55, [dir=rtl] .layout-margin .offset-gt-md-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-gt-md-60, .flex-offset-gt-md-60, .layout-margin .flex-offset-gt-md-60, .layout-margin .offset-gt-md-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-gt-md-60, [dir=rtl] .flex-offset-gt-md-60, [dir=rtl] .layout-margin .flex-offset-gt-md-60, [dir=rtl] .layout-margin .offset-gt-md-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-gt-md-65, .flex-offset-gt-md-65, .layout-margin .flex-offset-gt-md-65, .layout-margin .offset-gt-md-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-gt-md-65, [dir=rtl] .flex-offset-gt-md-65, [dir=rtl] .layout-margin .flex-offset-gt-md-65, [dir=rtl] .layout-margin .offset-gt-md-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-gt-md-70, .flex-offset-gt-md-70, .layout-margin .flex-offset-gt-md-70, .layout-margin .offset-gt-md-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-gt-md-70, [dir=rtl] .flex-offset-gt-md-70, [dir=rtl] .layout-margin .flex-offset-gt-md-70, [dir=rtl] .layout-margin .offset-gt-md-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-gt-md-75, .flex-offset-gt-md-75, .layout-margin .flex-offset-gt-md-75, .layout-margin .offset-gt-md-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-gt-md-75, [dir=rtl] .flex-offset-gt-md-75, [dir=rtl] .layout-margin .flex-offset-gt-md-75, [dir=rtl] .layout-margin .offset-gt-md-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-gt-md-80, .flex-offset-gt-md-80, .layout-margin .flex-offset-gt-md-80, .layout-margin .offset-gt-md-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-gt-md-80, [dir=rtl] .flex-offset-gt-md-80, [dir=rtl] .layout-margin .flex-offset-gt-md-80, [dir=rtl] .layout-margin .offset-gt-md-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-gt-md-85, .flex-offset-gt-md-85, .layout-margin .flex-offset-gt-md-85, .layout-margin .offset-gt-md-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-gt-md-85, [dir=rtl] .flex-offset-gt-md-85, [dir=rtl] .layout-margin .flex-offset-gt-md-85, [dir=rtl] .layout-margin .offset-gt-md-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-gt-md-90, .flex-offset-gt-md-90, .layout-margin .flex-offset-gt-md-90, .layout-margin .offset-gt-md-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-gt-md-90, [dir=rtl] .flex-offset-gt-md-90, [dir=rtl] .layout-margin .flex-offset-gt-md-90, [dir=rtl] .layout-margin .offset-gt-md-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-gt-md-95, .flex-offset-gt-md-95, .layout-margin .flex-offset-gt-md-95, .layout-margin .offset-gt-md-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-gt-md-95, [dir=rtl] .flex-offset-gt-md-95, [dir=rtl] .layout-margin .flex-offset-gt-md-95, [dir=rtl] .layout-margin .offset-gt-md-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-gt-md-33, .flex-offset-gt-md-33, .layout-margin .flex-offset-gt-md-33, .layout-margin .offset-gt-md-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-gt-md-66, .flex-offset-gt-md-66, .layout-margin .flex-offset-gt-md-66, .layout-margin .offset-gt-md-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-gt-md-66, [dir=rtl] .flex-offset-gt-md-66, [dir=rtl] .layout-margin .flex-offset-gt-md-66, [dir=rtl] .layout-margin .offset-gt-md-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-gt-md,\n.layout-align-gt-md-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-gt-md-start,\n.layout-align-gt-md-start-start,\n.layout-align-gt-md-start-center,\n.layout-align-gt-md-start-end,\n.layout-align-gt-md-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-gt-md-center,\n.layout-align-gt-md-center-start,\n.layout-align-gt-md-center-center,\n.layout-align-gt-md-center-end,\n.layout-align-gt-md-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-gt-md-end,\n.layout-align-gt-md-end-start,\n.layout-align-gt-md-end-center,\n.layout-align-gt-md-end-end,\n.layout-align-gt-md-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-gt-md-space-around,\n.layout-align-gt-md-space-around-center,\n.layout-align-gt-md-space-around-start,\n.layout-align-gt-md-space-around-end,\n.layout-align-gt-md-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-gt-md-space-between,\n.layout-align-gt-md-space-between-center,\n.layout-align-gt-md-space-between-start,\n.layout-align-gt-md-space-between-end,\n.layout-align-gt-md-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-gt-md-start-start,\n.layout-align-gt-md-center-start,\n.layout-align-gt-md-end-start,\n.layout-align-gt-md-space-between-start,\n.layout-align-gt-md-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-gt-md-start-center,\n.layout-align-gt-md-center-center,\n.layout-align-gt-md-end-center,\n.layout-align-gt-md-space-between-center,\n.layout-align-gt-md-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-gt-md-start-center > *,\n.layout-align-gt-md-center-center > *,\n.layout-align-gt-md-end-center > *,\n.layout-align-gt-md-space-between-center > *,\n.layout-align-gt-md-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-gt-md-start-end,\n.layout-align-gt-md-center-end,\n.layout-align-gt-md-end-end,\n.layout-align-gt-md-space-between-end,\n.layout-align-gt-md-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-gt-md-start-stretch,\n.layout-align-gt-md-center-stretch,\n.layout-align-gt-md-end-stretch,\n.layout-align-gt-md-space-between-stretch,\n.layout-align-gt-md-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-gt-md {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-gt-md-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-gt-md-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-md-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-gt-md-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-md-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-gt-md-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-md-row > .flex-gt-md-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-md-row > .flex-gt-md-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-md-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-gt-md-column > .flex-gt-md-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-gt-md-column > .flex-gt-md-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-gt-md-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-gt-md, .layout-gt-md-column, .layout-gt-md-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-gt-md-column {\n    flex-direction: column;\n  }\n\n  .layout-gt-md-row {\n    flex-direction: row;\n  }\n}\n@media (min-width: 1280px) and (max-width: 1919px) {\n  .hide:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show), .hide-gt-xs:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show), .hide-gt-sm:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show), .hide-gt-md:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-lg):not(.show) {\n    display: none;\n  }\n\n  .hide-lg:not(.show-lg):not(.show-gt-md):not(.show-gt-sm):not(.show-gt-xs):not(.show) {\n    display: none;\n  }\n\n  .flex-order-lg--20 {\n    order: -20;\n  }\n\n  .flex-order-lg--19 {\n    order: -19;\n  }\n\n  .flex-order-lg--18 {\n    order: -18;\n  }\n\n  .flex-order-lg--17 {\n    order: -17;\n  }\n\n  .flex-order-lg--16 {\n    order: -16;\n  }\n\n  .flex-order-lg--15 {\n    order: -15;\n  }\n\n  .flex-order-lg--14 {\n    order: -14;\n  }\n\n  .flex-order-lg--13 {\n    order: -13;\n  }\n\n  .flex-order-lg--12 {\n    order: -12;\n  }\n\n  .flex-order-lg--11 {\n    order: -11;\n  }\n\n  .flex-order-lg--10 {\n    order: -10;\n  }\n\n  .flex-order-lg--9 {\n    order: -9;\n  }\n\n  .flex-order-lg--8 {\n    order: -8;\n  }\n\n  .flex-order-lg--7 {\n    order: -7;\n  }\n\n  .flex-order-lg--6 {\n    order: -6;\n  }\n\n  .flex-order-lg--5 {\n    order: -5;\n  }\n\n  .flex-order-lg--4 {\n    order: -4;\n  }\n\n  .flex-order-lg--3 {\n    order: -3;\n  }\n\n  .flex-order-lg--2 {\n    order: -2;\n  }\n\n  .flex-order-lg--1 {\n    order: -1;\n  }\n\n  .flex-order-lg-0 {\n    order: 0;\n  }\n\n  .flex-order-lg-1 {\n    order: 1;\n  }\n\n  .flex-order-lg-2 {\n    order: 2;\n  }\n\n  .flex-order-lg-3 {\n    order: 3;\n  }\n\n  .flex-order-lg-4 {\n    order: 4;\n  }\n\n  .flex-order-lg-5 {\n    order: 5;\n  }\n\n  .flex-order-lg-6 {\n    order: 6;\n  }\n\n  .flex-order-lg-7 {\n    order: 7;\n  }\n\n  .flex-order-lg-8 {\n    order: 8;\n  }\n\n  .flex-order-lg-9 {\n    order: 9;\n  }\n\n  .flex-order-lg-10 {\n    order: 10;\n  }\n\n  .flex-order-lg-11 {\n    order: 11;\n  }\n\n  .flex-order-lg-12 {\n    order: 12;\n  }\n\n  .flex-order-lg-13 {\n    order: 13;\n  }\n\n  .flex-order-lg-14 {\n    order: 14;\n  }\n\n  .flex-order-lg-15 {\n    order: 15;\n  }\n\n  .flex-order-lg-16 {\n    order: 16;\n  }\n\n  .flex-order-lg-17 {\n    order: 17;\n  }\n\n  .flex-order-lg-18 {\n    order: 18;\n  }\n\n  .flex-order-lg-19 {\n    order: 19;\n  }\n\n  .flex-order-lg-20 {\n    order: 20;\n  }\n\n  .offset-lg-0, .flex-offset-lg-0, .layout-margin .flex-offset-lg-0, .layout-margin .offset-lg-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-lg-0, [dir=rtl] .flex-offset-lg-0, [dir=rtl] .layout-margin .flex-offset-lg-0, [dir=rtl] .layout-margin .offset-lg-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-lg-5, .flex-offset-lg-5, .layout-margin .flex-offset-lg-5, .layout-margin .offset-lg-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-lg-5, [dir=rtl] .flex-offset-lg-5, [dir=rtl] .layout-margin .flex-offset-lg-5, [dir=rtl] .layout-margin .offset-lg-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-lg-10, .flex-offset-lg-10, .layout-margin .flex-offset-lg-10, .layout-margin .offset-lg-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-lg-10, [dir=rtl] .flex-offset-lg-10, [dir=rtl] .layout-margin .flex-offset-lg-10, [dir=rtl] .layout-margin .offset-lg-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-lg-15, .flex-offset-lg-15, .layout-margin .flex-offset-lg-15, .layout-margin .offset-lg-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-lg-15, [dir=rtl] .flex-offset-lg-15, [dir=rtl] .layout-margin .flex-offset-lg-15, [dir=rtl] .layout-margin .offset-lg-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-lg-20, .flex-offset-lg-20, .layout-margin .flex-offset-lg-20, .layout-margin .offset-lg-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-lg-20, [dir=rtl] .flex-offset-lg-20, [dir=rtl] .layout-margin .flex-offset-lg-20, [dir=rtl] .layout-margin .offset-lg-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-lg-25, .flex-offset-lg-25, .layout-margin .flex-offset-lg-25, .layout-margin .offset-lg-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-lg-25, [dir=rtl] .flex-offset-lg-25, [dir=rtl] .layout-margin .flex-offset-lg-25, [dir=rtl] .layout-margin .offset-lg-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-lg-30, .flex-offset-lg-30, .layout-margin .flex-offset-lg-30, .layout-margin .offset-lg-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-lg-30, [dir=rtl] .flex-offset-lg-30, [dir=rtl] .layout-margin .flex-offset-lg-30, [dir=rtl] .layout-margin .offset-lg-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-lg-35, .flex-offset-lg-35, .layout-margin .flex-offset-lg-35, .layout-margin .offset-lg-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-lg-35, [dir=rtl] .flex-offset-lg-35, [dir=rtl] .layout-margin .flex-offset-lg-35, [dir=rtl] .layout-margin .offset-lg-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-lg-40, .flex-offset-lg-40, .layout-margin .flex-offset-lg-40, .layout-margin .offset-lg-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-lg-40, [dir=rtl] .flex-offset-lg-40, [dir=rtl] .layout-margin .flex-offset-lg-40, [dir=rtl] .layout-margin .offset-lg-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-lg-45, .flex-offset-lg-45, .layout-margin .flex-offset-lg-45, .layout-margin .offset-lg-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-lg-45, [dir=rtl] .flex-offset-lg-45, [dir=rtl] .layout-margin .flex-offset-lg-45, [dir=rtl] .layout-margin .offset-lg-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-lg-50, .flex-offset-lg-50, .layout-margin .flex-offset-lg-50, .layout-margin .offset-lg-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-lg-50, [dir=rtl] .flex-offset-lg-50, [dir=rtl] .layout-margin .flex-offset-lg-50, [dir=rtl] .layout-margin .offset-lg-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-lg-55, .flex-offset-lg-55, .layout-margin .flex-offset-lg-55, .layout-margin .offset-lg-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-lg-55, [dir=rtl] .flex-offset-lg-55, [dir=rtl] .layout-margin .flex-offset-lg-55, [dir=rtl] .layout-margin .offset-lg-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-lg-60, .flex-offset-lg-60, .layout-margin .flex-offset-lg-60, .layout-margin .offset-lg-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-lg-60, [dir=rtl] .flex-offset-lg-60, [dir=rtl] .layout-margin .flex-offset-lg-60, [dir=rtl] .layout-margin .offset-lg-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-lg-65, .flex-offset-lg-65, .layout-margin .flex-offset-lg-65, .layout-margin .offset-lg-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-lg-65, [dir=rtl] .flex-offset-lg-65, [dir=rtl] .layout-margin .flex-offset-lg-65, [dir=rtl] .layout-margin .offset-lg-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-lg-70, .flex-offset-lg-70, .layout-margin .flex-offset-lg-70, .layout-margin .offset-lg-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-lg-70, [dir=rtl] .flex-offset-lg-70, [dir=rtl] .layout-margin .flex-offset-lg-70, [dir=rtl] .layout-margin .offset-lg-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-lg-75, .flex-offset-lg-75, .layout-margin .flex-offset-lg-75, .layout-margin .offset-lg-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-lg-75, [dir=rtl] .flex-offset-lg-75, [dir=rtl] .layout-margin .flex-offset-lg-75, [dir=rtl] .layout-margin .offset-lg-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-lg-80, .flex-offset-lg-80, .layout-margin .flex-offset-lg-80, .layout-margin .offset-lg-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-lg-80, [dir=rtl] .flex-offset-lg-80, [dir=rtl] .layout-margin .flex-offset-lg-80, [dir=rtl] .layout-margin .offset-lg-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-lg-85, .flex-offset-lg-85, .layout-margin .flex-offset-lg-85, .layout-margin .offset-lg-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-lg-85, [dir=rtl] .flex-offset-lg-85, [dir=rtl] .layout-margin .flex-offset-lg-85, [dir=rtl] .layout-margin .offset-lg-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-lg-90, .flex-offset-lg-90, .layout-margin .flex-offset-lg-90, .layout-margin .offset-lg-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-lg-90, [dir=rtl] .flex-offset-lg-90, [dir=rtl] .layout-margin .flex-offset-lg-90, [dir=rtl] .layout-margin .offset-lg-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-lg-95, .flex-offset-lg-95, .layout-margin .flex-offset-lg-95, .layout-margin .offset-lg-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-lg-95, [dir=rtl] .flex-offset-lg-95, [dir=rtl] .layout-margin .flex-offset-lg-95, [dir=rtl] .layout-margin .offset-lg-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-lg-33, .flex-offset-lg-33, .layout-margin .flex-offset-lg-33, .layout-margin .offset-lg-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-lg-66, .flex-offset-lg-66, .layout-margin .flex-offset-lg-66, .layout-margin .offset-lg-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-lg-66, [dir=rtl] .flex-offset-lg-66, [dir=rtl] .layout-margin .flex-offset-lg-66, [dir=rtl] .layout-margin .offset-lg-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-lg,\n.layout-align-lg-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-lg-start,\n.layout-align-lg-start-start,\n.layout-align-lg-start-center,\n.layout-align-lg-start-end,\n.layout-align-lg-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-lg-center,\n.layout-align-lg-center-start,\n.layout-align-lg-center-center,\n.layout-align-lg-center-end,\n.layout-align-lg-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-lg-end,\n.layout-align-lg-end-start,\n.layout-align-lg-end-center,\n.layout-align-lg-end-end,\n.layout-align-lg-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-lg-space-around,\n.layout-align-lg-space-around-center,\n.layout-align-lg-space-around-start,\n.layout-align-lg-space-around-end,\n.layout-align-lg-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-lg-space-between,\n.layout-align-lg-space-between-center,\n.layout-align-lg-space-between-start,\n.layout-align-lg-space-between-end,\n.layout-align-lg-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-lg-start-start,\n.layout-align-lg-center-start,\n.layout-align-lg-end-start,\n.layout-align-lg-space-between-start,\n.layout-align-lg-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-lg-start-center,\n.layout-align-lg-center-center,\n.layout-align-lg-end-center,\n.layout-align-lg-space-between-center,\n.layout-align-lg-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-lg-start-center > *,\n.layout-align-lg-center-center > *,\n.layout-align-lg-end-center > *,\n.layout-align-lg-space-between-center > *,\n.layout-align-lg-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-lg-start-end,\n.layout-align-lg-center-end,\n.layout-align-lg-end-end,\n.layout-align-lg-space-between-end,\n.layout-align-lg-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-lg-start-stretch,\n.layout-align-lg-center-stretch,\n.layout-align-lg-end-stretch,\n.layout-align-lg-space-between-stretch,\n.layout-align-lg-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-lg {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-lg-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-lg-column > .flex-lg-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-lg-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-column > .flex-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-lg-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-lg-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-lg-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-lg-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-lg-row > .flex-lg-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-lg-row > .flex-lg-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-lg-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-lg-column > .flex-lg-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-lg-column > .flex-lg-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-lg-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-lg, .layout-lg-column, .layout-lg-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-lg-column {\n    flex-direction: column;\n  }\n\n  .layout-lg-row {\n    flex-direction: row;\n  }\n}\n@media (min-width: 1920px) {\n  .flex-order-gt-lg--20 {\n    order: -20;\n  }\n\n  .flex-order-gt-lg--19 {\n    order: -19;\n  }\n\n  .flex-order-gt-lg--18 {\n    order: -18;\n  }\n\n  .flex-order-gt-lg--17 {\n    order: -17;\n  }\n\n  .flex-order-gt-lg--16 {\n    order: -16;\n  }\n\n  .flex-order-gt-lg--15 {\n    order: -15;\n  }\n\n  .flex-order-gt-lg--14 {\n    order: -14;\n  }\n\n  .flex-order-gt-lg--13 {\n    order: -13;\n  }\n\n  .flex-order-gt-lg--12 {\n    order: -12;\n  }\n\n  .flex-order-gt-lg--11 {\n    order: -11;\n  }\n\n  .flex-order-gt-lg--10 {\n    order: -10;\n  }\n\n  .flex-order-gt-lg--9 {\n    order: -9;\n  }\n\n  .flex-order-gt-lg--8 {\n    order: -8;\n  }\n\n  .flex-order-gt-lg--7 {\n    order: -7;\n  }\n\n  .flex-order-gt-lg--6 {\n    order: -6;\n  }\n\n  .flex-order-gt-lg--5 {\n    order: -5;\n  }\n\n  .flex-order-gt-lg--4 {\n    order: -4;\n  }\n\n  .flex-order-gt-lg--3 {\n    order: -3;\n  }\n\n  .flex-order-gt-lg--2 {\n    order: -2;\n  }\n\n  .flex-order-gt-lg--1 {\n    order: -1;\n  }\n\n  .flex-order-gt-lg-0 {\n    order: 0;\n  }\n\n  .flex-order-gt-lg-1 {\n    order: 1;\n  }\n\n  .flex-order-gt-lg-2 {\n    order: 2;\n  }\n\n  .flex-order-gt-lg-3 {\n    order: 3;\n  }\n\n  .flex-order-gt-lg-4 {\n    order: 4;\n  }\n\n  .flex-order-gt-lg-5 {\n    order: 5;\n  }\n\n  .flex-order-gt-lg-6 {\n    order: 6;\n  }\n\n  .flex-order-gt-lg-7 {\n    order: 7;\n  }\n\n  .flex-order-gt-lg-8 {\n    order: 8;\n  }\n\n  .flex-order-gt-lg-9 {\n    order: 9;\n  }\n\n  .flex-order-gt-lg-10 {\n    order: 10;\n  }\n\n  .flex-order-gt-lg-11 {\n    order: 11;\n  }\n\n  .flex-order-gt-lg-12 {\n    order: 12;\n  }\n\n  .flex-order-gt-lg-13 {\n    order: 13;\n  }\n\n  .flex-order-gt-lg-14 {\n    order: 14;\n  }\n\n  .flex-order-gt-lg-15 {\n    order: 15;\n  }\n\n  .flex-order-gt-lg-16 {\n    order: 16;\n  }\n\n  .flex-order-gt-lg-17 {\n    order: 17;\n  }\n\n  .flex-order-gt-lg-18 {\n    order: 18;\n  }\n\n  .flex-order-gt-lg-19 {\n    order: 19;\n  }\n\n  .flex-order-gt-lg-20 {\n    order: 20;\n  }\n\n  .offset-gt-lg-0, .flex-offset-gt-lg-0, .layout-margin .flex-offset-gt-lg-0, .layout-margin .offset-gt-lg-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-gt-lg-0, [dir=rtl] .flex-offset-gt-lg-0, [dir=rtl] .layout-margin .flex-offset-gt-lg-0, [dir=rtl] .layout-margin .offset-gt-lg-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-gt-lg-5, .flex-offset-gt-lg-5, .layout-margin .flex-offset-gt-lg-5, .layout-margin .offset-gt-lg-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-gt-lg-5, [dir=rtl] .flex-offset-gt-lg-5, [dir=rtl] .layout-margin .flex-offset-gt-lg-5, [dir=rtl] .layout-margin .offset-gt-lg-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-gt-lg-10, .flex-offset-gt-lg-10, .layout-margin .flex-offset-gt-lg-10, .layout-margin .offset-gt-lg-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-gt-lg-10, [dir=rtl] .flex-offset-gt-lg-10, [dir=rtl] .layout-margin .flex-offset-gt-lg-10, [dir=rtl] .layout-margin .offset-gt-lg-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-gt-lg-15, .flex-offset-gt-lg-15, .layout-margin .flex-offset-gt-lg-15, .layout-margin .offset-gt-lg-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-gt-lg-15, [dir=rtl] .flex-offset-gt-lg-15, [dir=rtl] .layout-margin .flex-offset-gt-lg-15, [dir=rtl] .layout-margin .offset-gt-lg-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-gt-lg-20, .flex-offset-gt-lg-20, .layout-margin .flex-offset-gt-lg-20, .layout-margin .offset-gt-lg-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-gt-lg-20, [dir=rtl] .flex-offset-gt-lg-20, [dir=rtl] .layout-margin .flex-offset-gt-lg-20, [dir=rtl] .layout-margin .offset-gt-lg-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-gt-lg-25, .flex-offset-gt-lg-25, .layout-margin .flex-offset-gt-lg-25, .layout-margin .offset-gt-lg-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-gt-lg-25, [dir=rtl] .flex-offset-gt-lg-25, [dir=rtl] .layout-margin .flex-offset-gt-lg-25, [dir=rtl] .layout-margin .offset-gt-lg-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-gt-lg-30, .flex-offset-gt-lg-30, .layout-margin .flex-offset-gt-lg-30, .layout-margin .offset-gt-lg-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-gt-lg-30, [dir=rtl] .flex-offset-gt-lg-30, [dir=rtl] .layout-margin .flex-offset-gt-lg-30, [dir=rtl] .layout-margin .offset-gt-lg-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-gt-lg-35, .flex-offset-gt-lg-35, .layout-margin .flex-offset-gt-lg-35, .layout-margin .offset-gt-lg-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-gt-lg-35, [dir=rtl] .flex-offset-gt-lg-35, [dir=rtl] .layout-margin .flex-offset-gt-lg-35, [dir=rtl] .layout-margin .offset-gt-lg-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-gt-lg-40, .flex-offset-gt-lg-40, .layout-margin .flex-offset-gt-lg-40, .layout-margin .offset-gt-lg-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-gt-lg-40, [dir=rtl] .flex-offset-gt-lg-40, [dir=rtl] .layout-margin .flex-offset-gt-lg-40, [dir=rtl] .layout-margin .offset-gt-lg-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-gt-lg-45, .flex-offset-gt-lg-45, .layout-margin .flex-offset-gt-lg-45, .layout-margin .offset-gt-lg-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-gt-lg-45, [dir=rtl] .flex-offset-gt-lg-45, [dir=rtl] .layout-margin .flex-offset-gt-lg-45, [dir=rtl] .layout-margin .offset-gt-lg-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-gt-lg-50, .flex-offset-gt-lg-50, .layout-margin .flex-offset-gt-lg-50, .layout-margin .offset-gt-lg-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-gt-lg-50, [dir=rtl] .flex-offset-gt-lg-50, [dir=rtl] .layout-margin .flex-offset-gt-lg-50, [dir=rtl] .layout-margin .offset-gt-lg-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-gt-lg-55, .flex-offset-gt-lg-55, .layout-margin .flex-offset-gt-lg-55, .layout-margin .offset-gt-lg-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-gt-lg-55, [dir=rtl] .flex-offset-gt-lg-55, [dir=rtl] .layout-margin .flex-offset-gt-lg-55, [dir=rtl] .layout-margin .offset-gt-lg-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-gt-lg-60, .flex-offset-gt-lg-60, .layout-margin .flex-offset-gt-lg-60, .layout-margin .offset-gt-lg-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-gt-lg-60, [dir=rtl] .flex-offset-gt-lg-60, [dir=rtl] .layout-margin .flex-offset-gt-lg-60, [dir=rtl] .layout-margin .offset-gt-lg-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-gt-lg-65, .flex-offset-gt-lg-65, .layout-margin .flex-offset-gt-lg-65, .layout-margin .offset-gt-lg-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-gt-lg-65, [dir=rtl] .flex-offset-gt-lg-65, [dir=rtl] .layout-margin .flex-offset-gt-lg-65, [dir=rtl] .layout-margin .offset-gt-lg-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-gt-lg-70, .flex-offset-gt-lg-70, .layout-margin .flex-offset-gt-lg-70, .layout-margin .offset-gt-lg-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-gt-lg-70, [dir=rtl] .flex-offset-gt-lg-70, [dir=rtl] .layout-margin .flex-offset-gt-lg-70, [dir=rtl] .layout-margin .offset-gt-lg-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-gt-lg-75, .flex-offset-gt-lg-75, .layout-margin .flex-offset-gt-lg-75, .layout-margin .offset-gt-lg-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-gt-lg-75, [dir=rtl] .flex-offset-gt-lg-75, [dir=rtl] .layout-margin .flex-offset-gt-lg-75, [dir=rtl] .layout-margin .offset-gt-lg-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-gt-lg-80, .flex-offset-gt-lg-80, .layout-margin .flex-offset-gt-lg-80, .layout-margin .offset-gt-lg-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-gt-lg-80, [dir=rtl] .flex-offset-gt-lg-80, [dir=rtl] .layout-margin .flex-offset-gt-lg-80, [dir=rtl] .layout-margin .offset-gt-lg-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-gt-lg-85, .flex-offset-gt-lg-85, .layout-margin .flex-offset-gt-lg-85, .layout-margin .offset-gt-lg-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-gt-lg-85, [dir=rtl] .flex-offset-gt-lg-85, [dir=rtl] .layout-margin .flex-offset-gt-lg-85, [dir=rtl] .layout-margin .offset-gt-lg-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-gt-lg-90, .flex-offset-gt-lg-90, .layout-margin .flex-offset-gt-lg-90, .layout-margin .offset-gt-lg-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-gt-lg-90, [dir=rtl] .flex-offset-gt-lg-90, [dir=rtl] .layout-margin .flex-offset-gt-lg-90, [dir=rtl] .layout-margin .offset-gt-lg-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-gt-lg-95, .flex-offset-gt-lg-95, .layout-margin .flex-offset-gt-lg-95, .layout-margin .offset-gt-lg-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-gt-lg-95, [dir=rtl] .flex-offset-gt-lg-95, [dir=rtl] .layout-margin .flex-offset-gt-lg-95, [dir=rtl] .layout-margin .offset-gt-lg-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-gt-lg-33, .flex-offset-gt-lg-33, .layout-margin .flex-offset-gt-lg-33, .layout-margin .offset-gt-lg-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-gt-lg-66, .flex-offset-gt-lg-66, .layout-margin .flex-offset-gt-lg-66, .layout-margin .offset-gt-lg-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-gt-lg-66, [dir=rtl] .flex-offset-gt-lg-66, [dir=rtl] .layout-margin .flex-offset-gt-lg-66, [dir=rtl] .layout-margin .offset-gt-lg-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-gt-lg,\n.layout-align-gt-lg-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-gt-lg-start,\n.layout-align-gt-lg-start-start,\n.layout-align-gt-lg-start-center,\n.layout-align-gt-lg-start-end,\n.layout-align-gt-lg-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-gt-lg-center,\n.layout-align-gt-lg-center-start,\n.layout-align-gt-lg-center-center,\n.layout-align-gt-lg-center-end,\n.layout-align-gt-lg-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-gt-lg-end,\n.layout-align-gt-lg-end-start,\n.layout-align-gt-lg-end-center,\n.layout-align-gt-lg-end-end,\n.layout-align-gt-lg-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-gt-lg-space-around,\n.layout-align-gt-lg-space-around-center,\n.layout-align-gt-lg-space-around-start,\n.layout-align-gt-lg-space-around-end,\n.layout-align-gt-lg-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-gt-lg-space-between,\n.layout-align-gt-lg-space-between-center,\n.layout-align-gt-lg-space-between-start,\n.layout-align-gt-lg-space-between-end,\n.layout-align-gt-lg-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-gt-lg-start-start,\n.layout-align-gt-lg-center-start,\n.layout-align-gt-lg-end-start,\n.layout-align-gt-lg-space-between-start,\n.layout-align-gt-lg-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-gt-lg-start-center,\n.layout-align-gt-lg-center-center,\n.layout-align-gt-lg-end-center,\n.layout-align-gt-lg-space-between-center,\n.layout-align-gt-lg-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-gt-lg-start-center > *,\n.layout-align-gt-lg-center-center > *,\n.layout-align-gt-lg-end-center > *,\n.layout-align-gt-lg-space-between-center > *,\n.layout-align-gt-lg-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-gt-lg-start-end,\n.layout-align-gt-lg-center-end,\n.layout-align-gt-lg-end-end,\n.layout-align-gt-lg-space-between-end,\n.layout-align-gt-lg-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-gt-lg-start-stretch,\n.layout-align-gt-lg-center-stretch,\n.layout-align-gt-lg-end-stretch,\n.layout-align-gt-lg-space-between-stretch,\n.layout-align-gt-lg-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-gt-lg {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-gt-lg-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-gt-lg-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-gt-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-gt-lg-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-gt-lg-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-gt-lg-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-gt-lg-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-gt-lg-row > .flex-gt-lg-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-lg-row > .flex-gt-lg-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-gt-lg-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-gt-lg-column > .flex-gt-lg-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-gt-lg-column > .flex-gt-lg-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-gt-lg-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-gt-lg, .layout-gt-lg-column, .layout-gt-lg-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-gt-lg-column {\n    flex-direction: column;\n  }\n\n  .layout-gt-lg-row {\n    flex-direction: row;\n  }\n\n  .flex-order-xl--20 {\n    order: -20;\n  }\n\n  .flex-order-xl--19 {\n    order: -19;\n  }\n\n  .flex-order-xl--18 {\n    order: -18;\n  }\n\n  .flex-order-xl--17 {\n    order: -17;\n  }\n\n  .flex-order-xl--16 {\n    order: -16;\n  }\n\n  .flex-order-xl--15 {\n    order: -15;\n  }\n\n  .flex-order-xl--14 {\n    order: -14;\n  }\n\n  .flex-order-xl--13 {\n    order: -13;\n  }\n\n  .flex-order-xl--12 {\n    order: -12;\n  }\n\n  .flex-order-xl--11 {\n    order: -11;\n  }\n\n  .flex-order-xl--10 {\n    order: -10;\n  }\n\n  .flex-order-xl--9 {\n    order: -9;\n  }\n\n  .flex-order-xl--8 {\n    order: -8;\n  }\n\n  .flex-order-xl--7 {\n    order: -7;\n  }\n\n  .flex-order-xl--6 {\n    order: -6;\n  }\n\n  .flex-order-xl--5 {\n    order: -5;\n  }\n\n  .flex-order-xl--4 {\n    order: -4;\n  }\n\n  .flex-order-xl--3 {\n    order: -3;\n  }\n\n  .flex-order-xl--2 {\n    order: -2;\n  }\n\n  .flex-order-xl--1 {\n    order: -1;\n  }\n\n  .flex-order-xl-0 {\n    order: 0;\n  }\n\n  .flex-order-xl-1 {\n    order: 1;\n  }\n\n  .flex-order-xl-2 {\n    order: 2;\n  }\n\n  .flex-order-xl-3 {\n    order: 3;\n  }\n\n  .flex-order-xl-4 {\n    order: 4;\n  }\n\n  .flex-order-xl-5 {\n    order: 5;\n  }\n\n  .flex-order-xl-6 {\n    order: 6;\n  }\n\n  .flex-order-xl-7 {\n    order: 7;\n  }\n\n  .flex-order-xl-8 {\n    order: 8;\n  }\n\n  .flex-order-xl-9 {\n    order: 9;\n  }\n\n  .flex-order-xl-10 {\n    order: 10;\n  }\n\n  .flex-order-xl-11 {\n    order: 11;\n  }\n\n  .flex-order-xl-12 {\n    order: 12;\n  }\n\n  .flex-order-xl-13 {\n    order: 13;\n  }\n\n  .flex-order-xl-14 {\n    order: 14;\n  }\n\n  .flex-order-xl-15 {\n    order: 15;\n  }\n\n  .flex-order-xl-16 {\n    order: 16;\n  }\n\n  .flex-order-xl-17 {\n    order: 17;\n  }\n\n  .flex-order-xl-18 {\n    order: 18;\n  }\n\n  .flex-order-xl-19 {\n    order: 19;\n  }\n\n  .flex-order-xl-20 {\n    order: 20;\n  }\n\n  .offset-xl-0, .flex-offset-xl-0, .layout-margin .flex-offset-xl-0, .layout-margin .offset-xl-0 {\n    margin-left: 0;\n  }\n  [dir=rtl] .offset-xl-0, [dir=rtl] .flex-offset-xl-0, [dir=rtl] .layout-margin .flex-offset-xl-0, [dir=rtl] .layout-margin .offset-xl-0 {\n    margin-left: auto;\n    margin-right: 0;\n  }\n\n  .offset-xl-5, .flex-offset-xl-5, .layout-margin .flex-offset-xl-5, .layout-margin .offset-xl-5 {\n    margin-left: 5%;\n  }\n  [dir=rtl] .offset-xl-5, [dir=rtl] .flex-offset-xl-5, [dir=rtl] .layout-margin .flex-offset-xl-5, [dir=rtl] .layout-margin .offset-xl-5 {\n    margin-left: auto;\n    margin-right: 5%;\n  }\n\n  .offset-xl-10, .flex-offset-xl-10, .layout-margin .flex-offset-xl-10, .layout-margin .offset-xl-10 {\n    margin-left: 10%;\n  }\n  [dir=rtl] .offset-xl-10, [dir=rtl] .flex-offset-xl-10, [dir=rtl] .layout-margin .flex-offset-xl-10, [dir=rtl] .layout-margin .offset-xl-10 {\n    margin-left: auto;\n    margin-right: 10%;\n  }\n\n  .offset-xl-15, .flex-offset-xl-15, .layout-margin .flex-offset-xl-15, .layout-margin .offset-xl-15 {\n    margin-left: 15%;\n  }\n  [dir=rtl] .offset-xl-15, [dir=rtl] .flex-offset-xl-15, [dir=rtl] .layout-margin .flex-offset-xl-15, [dir=rtl] .layout-margin .offset-xl-15 {\n    margin-left: auto;\n    margin-right: 15%;\n  }\n\n  .offset-xl-20, .flex-offset-xl-20, .layout-margin .flex-offset-xl-20, .layout-margin .offset-xl-20 {\n    margin-left: 20%;\n  }\n  [dir=rtl] .offset-xl-20, [dir=rtl] .flex-offset-xl-20, [dir=rtl] .layout-margin .flex-offset-xl-20, [dir=rtl] .layout-margin .offset-xl-20 {\n    margin-left: auto;\n    margin-right: 20%;\n  }\n\n  .offset-xl-25, .flex-offset-xl-25, .layout-margin .flex-offset-xl-25, .layout-margin .offset-xl-25 {\n    margin-left: 25%;\n  }\n  [dir=rtl] .offset-xl-25, [dir=rtl] .flex-offset-xl-25, [dir=rtl] .layout-margin .flex-offset-xl-25, [dir=rtl] .layout-margin .offset-xl-25 {\n    margin-left: auto;\n    margin-right: 25%;\n  }\n\n  .offset-xl-30, .flex-offset-xl-30, .layout-margin .flex-offset-xl-30, .layout-margin .offset-xl-30 {\n    margin-left: 30%;\n  }\n  [dir=rtl] .offset-xl-30, [dir=rtl] .flex-offset-xl-30, [dir=rtl] .layout-margin .flex-offset-xl-30, [dir=rtl] .layout-margin .offset-xl-30 {\n    margin-left: auto;\n    margin-right: 30%;\n  }\n\n  .offset-xl-35, .flex-offset-xl-35, .layout-margin .flex-offset-xl-35, .layout-margin .offset-xl-35 {\n    margin-left: 35%;\n  }\n  [dir=rtl] .offset-xl-35, [dir=rtl] .flex-offset-xl-35, [dir=rtl] .layout-margin .flex-offset-xl-35, [dir=rtl] .layout-margin .offset-xl-35 {\n    margin-left: auto;\n    margin-right: 35%;\n  }\n\n  .offset-xl-40, .flex-offset-xl-40, .layout-margin .flex-offset-xl-40, .layout-margin .offset-xl-40 {\n    margin-left: 40%;\n  }\n  [dir=rtl] .offset-xl-40, [dir=rtl] .flex-offset-xl-40, [dir=rtl] .layout-margin .flex-offset-xl-40, [dir=rtl] .layout-margin .offset-xl-40 {\n    margin-left: auto;\n    margin-right: 40%;\n  }\n\n  .offset-xl-45, .flex-offset-xl-45, .layout-margin .flex-offset-xl-45, .layout-margin .offset-xl-45 {\n    margin-left: 45%;\n  }\n  [dir=rtl] .offset-xl-45, [dir=rtl] .flex-offset-xl-45, [dir=rtl] .layout-margin .flex-offset-xl-45, [dir=rtl] .layout-margin .offset-xl-45 {\n    margin-left: auto;\n    margin-right: 45%;\n  }\n\n  .offset-xl-50, .flex-offset-xl-50, .layout-margin .flex-offset-xl-50, .layout-margin .offset-xl-50 {\n    margin-left: 50%;\n  }\n  [dir=rtl] .offset-xl-50, [dir=rtl] .flex-offset-xl-50, [dir=rtl] .layout-margin .flex-offset-xl-50, [dir=rtl] .layout-margin .offset-xl-50 {\n    margin-left: auto;\n    margin-right: 50%;\n  }\n\n  .offset-xl-55, .flex-offset-xl-55, .layout-margin .flex-offset-xl-55, .layout-margin .offset-xl-55 {\n    margin-left: 55%;\n  }\n  [dir=rtl] .offset-xl-55, [dir=rtl] .flex-offset-xl-55, [dir=rtl] .layout-margin .flex-offset-xl-55, [dir=rtl] .layout-margin .offset-xl-55 {\n    margin-left: auto;\n    margin-right: 55%;\n  }\n\n  .offset-xl-60, .flex-offset-xl-60, .layout-margin .flex-offset-xl-60, .layout-margin .offset-xl-60 {\n    margin-left: 60%;\n  }\n  [dir=rtl] .offset-xl-60, [dir=rtl] .flex-offset-xl-60, [dir=rtl] .layout-margin .flex-offset-xl-60, [dir=rtl] .layout-margin .offset-xl-60 {\n    margin-left: auto;\n    margin-right: 60%;\n  }\n\n  .offset-xl-65, .flex-offset-xl-65, .layout-margin .flex-offset-xl-65, .layout-margin .offset-xl-65 {\n    margin-left: 65%;\n  }\n  [dir=rtl] .offset-xl-65, [dir=rtl] .flex-offset-xl-65, [dir=rtl] .layout-margin .flex-offset-xl-65, [dir=rtl] .layout-margin .offset-xl-65 {\n    margin-left: auto;\n    margin-right: 65%;\n  }\n\n  .offset-xl-70, .flex-offset-xl-70, .layout-margin .flex-offset-xl-70, .layout-margin .offset-xl-70 {\n    margin-left: 70%;\n  }\n  [dir=rtl] .offset-xl-70, [dir=rtl] .flex-offset-xl-70, [dir=rtl] .layout-margin .flex-offset-xl-70, [dir=rtl] .layout-margin .offset-xl-70 {\n    margin-left: auto;\n    margin-right: 70%;\n  }\n\n  .offset-xl-75, .flex-offset-xl-75, .layout-margin .flex-offset-xl-75, .layout-margin .offset-xl-75 {\n    margin-left: 75%;\n  }\n  [dir=rtl] .offset-xl-75, [dir=rtl] .flex-offset-xl-75, [dir=rtl] .layout-margin .flex-offset-xl-75, [dir=rtl] .layout-margin .offset-xl-75 {\n    margin-left: auto;\n    margin-right: 75%;\n  }\n\n  .offset-xl-80, .flex-offset-xl-80, .layout-margin .flex-offset-xl-80, .layout-margin .offset-xl-80 {\n    margin-left: 80%;\n  }\n  [dir=rtl] .offset-xl-80, [dir=rtl] .flex-offset-xl-80, [dir=rtl] .layout-margin .flex-offset-xl-80, [dir=rtl] .layout-margin .offset-xl-80 {\n    margin-left: auto;\n    margin-right: 80%;\n  }\n\n  .offset-xl-85, .flex-offset-xl-85, .layout-margin .flex-offset-xl-85, .layout-margin .offset-xl-85 {\n    margin-left: 85%;\n  }\n  [dir=rtl] .offset-xl-85, [dir=rtl] .flex-offset-xl-85, [dir=rtl] .layout-margin .flex-offset-xl-85, [dir=rtl] .layout-margin .offset-xl-85 {\n    margin-left: auto;\n    margin-right: 85%;\n  }\n\n  .offset-xl-90, .flex-offset-xl-90, .layout-margin .flex-offset-xl-90, .layout-margin .offset-xl-90 {\n    margin-left: 90%;\n  }\n  [dir=rtl] .offset-xl-90, [dir=rtl] .flex-offset-xl-90, [dir=rtl] .layout-margin .flex-offset-xl-90, [dir=rtl] .layout-margin .offset-xl-90 {\n    margin-left: auto;\n    margin-right: 90%;\n  }\n\n  .offset-xl-95, .flex-offset-xl-95, .layout-margin .flex-offset-xl-95, .layout-margin .offset-xl-95 {\n    margin-left: 95%;\n  }\n  [dir=rtl] .offset-xl-95, [dir=rtl] .flex-offset-xl-95, [dir=rtl] .layout-margin .flex-offset-xl-95, [dir=rtl] .layout-margin .offset-xl-95 {\n    margin-left: auto;\n    margin-right: 95%;\n  }\n\n  .offset-xl-33, .flex-offset-xl-33, .layout-margin .flex-offset-xl-33, .layout-margin .offset-xl-33 {\n    margin-left: 33.3333333333%;\n  }\n\n  .offset-xl-66, .flex-offset-xl-66, .layout-margin .flex-offset-xl-66, .layout-margin .offset-xl-66 {\n    margin-left: 66.6666666667%;\n  }\n  [dir=rtl] .offset-xl-66, [dir=rtl] .flex-offset-xl-66, [dir=rtl] .layout-margin .flex-offset-xl-66, [dir=rtl] .layout-margin .offset-xl-66 {\n    margin-left: auto;\n    margin-right: 66.6666666667%;\n  }\n\n  .layout-align-xl,\n.layout-align-xl-start-stretch {\n    justify-content: flex-start;\n    align-content: stretch;\n    align-items: stretch;\n  }\n\n  .layout-align-xl-start,\n.layout-align-xl-start-start,\n.layout-align-xl-start-center,\n.layout-align-xl-start-end,\n.layout-align-xl-start-stretch {\n    justify-content: flex-start;\n  }\n\n  .layout-align-xl-center,\n.layout-align-xl-center-start,\n.layout-align-xl-center-center,\n.layout-align-xl-center-end,\n.layout-align-xl-center-stretch {\n    justify-content: center;\n  }\n\n  .layout-align-xl-end,\n.layout-align-xl-end-start,\n.layout-align-xl-end-center,\n.layout-align-xl-end-end,\n.layout-align-xl-end-stretch {\n    justify-content: flex-end;\n  }\n\n  .layout-align-xl-space-around,\n.layout-align-xl-space-around-center,\n.layout-align-xl-space-around-start,\n.layout-align-xl-space-around-end,\n.layout-align-xl-space-around-stretch {\n    justify-content: space-around;\n  }\n\n  .layout-align-xl-space-between,\n.layout-align-xl-space-between-center,\n.layout-align-xl-space-between-start,\n.layout-align-xl-space-between-end,\n.layout-align-xl-space-between-stretch {\n    justify-content: space-between;\n  }\n\n  .layout-align-xl-start-start,\n.layout-align-xl-center-start,\n.layout-align-xl-end-start,\n.layout-align-xl-space-between-start,\n.layout-align-xl-space-around-start {\n    align-items: flex-start;\n    align-content: flex-start;\n  }\n\n  .layout-align-xl-start-center,\n.layout-align-xl-center-center,\n.layout-align-xl-end-center,\n.layout-align-xl-space-between-center,\n.layout-align-xl-space-around-center {\n    align-items: center;\n    align-content: center;\n    max-width: 100%;\n  }\n\n  .layout-align-xl-start-center > *,\n.layout-align-xl-center-center > *,\n.layout-align-xl-end-center > *,\n.layout-align-xl-space-between-center > *,\n.layout-align-xl-space-around-center > * {\n    max-width: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-align-xl-start-end,\n.layout-align-xl-center-end,\n.layout-align-xl-end-end,\n.layout-align-xl-space-between-end,\n.layout-align-xl-space-around-end {\n    align-items: flex-end;\n    align-content: flex-end;\n  }\n\n  .layout-align-xl-start-stretch,\n.layout-align-xl-center-stretch,\n.layout-align-xl-end-stretch,\n.layout-align-xl-space-between-stretch,\n.layout-align-xl-space-around-stretch {\n    align-items: stretch;\n    align-content: stretch;\n  }\n\n  .flex-xl {\n    flex: 1;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-grow {\n    flex: 1 1 100%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-initial {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-auto {\n    flex: 1 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-none {\n    flex: 0 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-noshrink {\n    flex: 1 0 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-nogrow {\n    flex: 0 1 auto;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-column > .flex-xl-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-0 {\n    flex: 1 1 100%;\n    max-width: 0%;\n    max-height: 100%;\n    box-sizing: border-box;\n    min-width: 0;\n  }\n\n  .layout-xl-column > .flex-xl-0 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 0%;\n    box-sizing: border-box;\n    min-height: 0;\n  }\n\n  .flex-xl-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-5 {\n    flex: 1 1 100%;\n    max-width: 5%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-5 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 5%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-10 {\n    flex: 1 1 100%;\n    max-width: 10%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-10 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 10%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-15 {\n    flex: 1 1 100%;\n    max-width: 15%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-15 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 15%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-20 {\n    flex: 1 1 100%;\n    max-width: 20%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-20 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 20%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-25 {\n    flex: 1 1 100%;\n    max-width: 25%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-25 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 25%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-30 {\n    flex: 1 1 100%;\n    max-width: 30%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-30 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 30%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-35 {\n    flex: 1 1 100%;\n    max-width: 35%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-35 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 35%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-40 {\n    flex: 1 1 100%;\n    max-width: 40%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-40 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 40%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-45 {\n    flex: 1 1 100%;\n    max-width: 45%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-45 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 45%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-50 {\n    flex: 1 1 100%;\n    max-width: 50%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-50 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 50%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-55 {\n    flex: 1 1 100%;\n    max-width: 55%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-55 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 55%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-60 {\n    flex: 1 1 100%;\n    max-width: 60%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-60 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 60%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-65 {\n    flex: 1 1 100%;\n    max-width: 65%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-65 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 65%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-70 {\n    flex: 1 1 100%;\n    max-width: 70%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-70 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 70%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-75 {\n    flex: 1 1 100%;\n    max-width: 75%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-75 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 75%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-80 {\n    flex: 1 1 100%;\n    max-width: 80%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-80 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 80%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-85 {\n    flex: 1 1 100%;\n    max-width: 85%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-85 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 85%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-90 {\n    flex: 1 1 100%;\n    max-width: 90%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-90 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 90%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-95 {\n    flex: 1 1 100%;\n    max-width: 95%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-95 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 95%;\n    box-sizing: border-box;\n  }\n\n  .flex-xl-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-column > .flex-xl-100 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-row > .flex-xl-33 {\n    flex: 1 1 33.33%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-row > .flex-xl-66 {\n    flex: 1 1 66.66%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n\n  .layout-column > .flex-xl-33 {\n    flex: 1 1 33.33%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-column > .flex-xl-66 {\n    flex: 1 1 66.66%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n\n  .layout-xl-row > .flex-xl-33 {\n    flex: 1 1 100%;\n    max-width: 33.33%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-xl-row > .flex-xl-66 {\n    flex: 1 1 100%;\n    max-width: 66.66%;\n    max-height: 100%;\n    box-sizing: border-box;\n  }\n  .layout-xl-row > .flex {\n    min-width: 0;\n  }\n\n  .layout-xl-column > .flex-xl-33 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 33.33%;\n    box-sizing: border-box;\n  }\n  .layout-xl-column > .flex-xl-66 {\n    flex: 1 1 100%;\n    max-width: 100%;\n    max-height: 66.66%;\n    box-sizing: border-box;\n  }\n  .layout-xl-column > .flex {\n    min-height: 0;\n  }\n\n  .layout-xl, .layout-xl-column, .layout-xl-row {\n    box-sizing: border-box;\n    display: flex;\n  }\n\n  .layout-xl-column {\n    flex-direction: column;\n  }\n\n  .layout-xl-row {\n    flex-direction: row;\n  }\n\n  .hide:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show), .hide-gt-xs:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show), .hide-gt-sm:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show), .hide-gt-md:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show), .hide-gt-lg:not(.show-gt-xs):not(.show-gt-sm):not(.show-gt-md):not(.show-gt-lg):not(.show-xl):not(.show) {\n    display: none;\n  }\n\n  .hide-xl:not(.show-xl):not(.show-gt-lg):not(.show-gt-md):not(.show-gt-sm):not(.show-gt-xs):not(.show) {\n    display: none;\n  }\n}\n@media print {\n  .hide-print:not(.show-print):not(.show) {\n    display: none !important;\n  }\n}`, "" ]);
        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
    },
    703: (module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: () => __WEBPACK_DEFAULT_EXPORT__
        });
        var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(645), _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__), _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278), ___CSS_LOADER_EXPORT___ = __webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__)()(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
        ___CSS_LOADER_EXPORT___.push([ module.id, '.marker-cluster-small {\n\tbackground-color: rgba(181, 226, 140, 0.6);\n\t}\n.marker-cluster-small div {\n\tbackground-color: rgba(110, 204, 57, 0.6);\n\t}\n\n.marker-cluster-medium {\n\tbackground-color: rgba(241, 211, 87, 0.6);\n\t}\n.marker-cluster-medium div {\n\tbackground-color: rgba(240, 194, 12, 0.6);\n\t}\n\n.marker-cluster-large {\n\tbackground-color: rgba(253, 156, 115, 0.6);\n\t}\n.marker-cluster-large div {\n\tbackground-color: rgba(241, 128, 23, 0.6);\n\t}\n\n\t/* IE 6-8 fallback colors */\n.leaflet-oldie .marker-cluster-small {\n\tbackground-color: rgb(181, 226, 140);\n\t}\n.leaflet-oldie .marker-cluster-small div {\n\tbackground-color: rgb(110, 204, 57);\n\t}\n\n.leaflet-oldie .marker-cluster-medium {\n\tbackground-color: rgb(241, 211, 87);\n\t}\n.leaflet-oldie .marker-cluster-medium div {\n\tbackground-color: rgb(240, 194, 12);\n\t}\n\n.leaflet-oldie .marker-cluster-large {\n\tbackground-color: rgb(253, 156, 115);\n\t}\n.leaflet-oldie .marker-cluster-large div {\n\tbackground-color: rgb(241, 128, 23);\n}\n\n.marker-cluster {\n\tbackground-clip: padding-box;\n\tborder-radius: 20px;\n\t}\n.marker-cluster div {\n\twidth: 30px;\n\theight: 30px;\n\tmargin-left: 5px;\n\tmargin-top: 5px;\n\n\ttext-align: center;\n\tborder-radius: 15px;\n\tfont: 12px "Helvetica Neue", Arial, Helvetica, sans-serif;\n\t}\n.marker-cluster span {\n\tline-height: 30px;\n\t}', "" ]);
        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
    },
    914: (module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: () => __WEBPACK_DEFAULT_EXPORT__
        });
        var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(645), _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__), _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278), ___CSS_LOADER_EXPORT___ = __webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__)()(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default());
        ___CSS_LOADER_EXPORT___.push([ module.id, ".leaflet-cluster-anim .leaflet-marker-icon, .leaflet-cluster-anim .leaflet-marker-shadow {\n\t-webkit-transition: -webkit-transform 0.3s ease-out, opacity 0.3s ease-in;\n\t-moz-transition: -moz-transform 0.3s ease-out, opacity 0.3s ease-in;\n\t-o-transition: -o-transform 0.3s ease-out, opacity 0.3s ease-in;\n\ttransition: transform 0.3s ease-out, opacity 0.3s ease-in;\n}\n\n.leaflet-cluster-spider-leg {\n\t/* stroke-dashoffset (duration and function) should match with leaflet-marker-icon transform in order to track it exactly */\n\t-webkit-transition: -webkit-stroke-dashoffset 0.3s ease-out, -webkit-stroke-opacity 0.3s ease-in;\n\t-moz-transition: -moz-stroke-dashoffset 0.3s ease-out, -moz-stroke-opacity 0.3s ease-in;\n\t-o-transition: -o-stroke-dashoffset 0.3s ease-out, -o-stroke-opacity 0.3s ease-in;\n\ttransition: stroke-dashoffset 0.3s ease-out, stroke-opacity 0.3s ease-in;\n}\n", "" ]);
        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
    },
    139: (module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: () => __WEBPACK_DEFAULT_EXPORT__
        });
        var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(645), _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__), _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(278), _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__), _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21), _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__), ___CSS_LOADER_URL_IMPORT_0___ = new URL(__webpack_require__(835), __webpack_require__.b), ___CSS_LOADER_URL_IMPORT_1___ = new URL(__webpack_require__(524), __webpack_require__.b), ___CSS_LOADER_URL_IMPORT_2___ = new URL(__webpack_require__(845), __webpack_require__.b), ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()), ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___), ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___), ___CSS_LOADER_URL_REPLACEMENT_2___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_2___);
        ___CSS_LOADER_EXPORT___.push([ module.id, `/* required styles */\n\n.leaflet-pane,\n.leaflet-tile,\n.leaflet-marker-icon,\n.leaflet-marker-shadow,\n.leaflet-tile-container,\n.leaflet-pane > svg,\n.leaflet-pane > canvas,\n.leaflet-zoom-box,\n.leaflet-image-layer,\n.leaflet-layer {\n\tposition: absolute;\n\tleft: 0;\n\ttop: 0;\n\t}\n.leaflet-container {\n\toverflow: hidden;\n\t}\n.leaflet-tile,\n.leaflet-marker-icon,\n.leaflet-marker-shadow {\n\t-webkit-user-select: none;\n\t   -moz-user-select: none;\n\t        user-select: none;\n\t  -webkit-user-drag: none;\n\t}\n/* Prevents IE11 from highlighting tiles in blue */\n.leaflet-tile::selection {\n\tbackground: transparent;\n}\n/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\n.leaflet-safari .leaflet-tile {\n\timage-rendering: -webkit-optimize-contrast;\n\t}\n/* hack that prevents hw layers "stretching" when loading new tiles */\n.leaflet-safari .leaflet-tile-container {\n\twidth: 1600px;\n\theight: 1600px;\n\t-webkit-transform-origin: 0 0;\n\t}\n.leaflet-marker-icon,\n.leaflet-marker-shadow {\n\tdisplay: block;\n\t}\n/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\n/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\n.leaflet-container .leaflet-overlay-pane svg {\n\tmax-width: none !important;\n\tmax-height: none !important;\n\t}\n.leaflet-container .leaflet-marker-pane img,\n.leaflet-container .leaflet-shadow-pane img,\n.leaflet-container .leaflet-tile-pane img,\n.leaflet-container img.leaflet-image-layer,\n.leaflet-container .leaflet-tile {\n\tmax-width: none !important;\n\tmax-height: none !important;\n\twidth: auto;\n\tpadding: 0;\n\t}\n\n.leaflet-container img.leaflet-tile {\n\t/* See: https://bugs.chromium.org/p/chromium/issues/detail?id=600120 */\n\tmix-blend-mode: plus-lighter;\n}\n\n.leaflet-container.leaflet-touch-zoom {\n\t-ms-touch-action: pan-x pan-y;\n\ttouch-action: pan-x pan-y;\n\t}\n.leaflet-container.leaflet-touch-drag {\n\t-ms-touch-action: pinch-zoom;\n\t/* Fallback for FF which doesn't support pinch-zoom */\n\ttouch-action: none;\n\ttouch-action: pinch-zoom;\n}\n.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\n\t-ms-touch-action: none;\n\ttouch-action: none;\n}\n.leaflet-container {\n\t-webkit-tap-highlight-color: transparent;\n}\n.leaflet-container a {\n\t-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\n}\n.leaflet-tile {\n\tfilter: inherit;\n\tvisibility: hidden;\n\t}\n.leaflet-tile-loaded {\n\tvisibility: inherit;\n\t}\n.leaflet-zoom-box {\n\twidth: 0;\n\theight: 0;\n\t-moz-box-sizing: border-box;\n\t     box-sizing: border-box;\n\tz-index: 800;\n\t}\n/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\n.leaflet-overlay-pane svg {\n\t-moz-user-select: none;\n\t}\n\n.leaflet-pane         { z-index: 400; }\n\n.leaflet-tile-pane    { z-index: 200; }\n.leaflet-overlay-pane { z-index: 400; }\n.leaflet-shadow-pane  { z-index: 500; }\n.leaflet-marker-pane  { z-index: 600; }\n.leaflet-tooltip-pane   { z-index: 650; }\n.leaflet-popup-pane   { z-index: 700; }\n\n.leaflet-map-pane canvas { z-index: 100; }\n.leaflet-map-pane svg    { z-index: 200; }\n\n.leaflet-vml-shape {\n\twidth: 1px;\n\theight: 1px;\n\t}\n.lvml {\n\tbehavior: url(#default#VML);\n\tdisplay: inline-block;\n\tposition: absolute;\n\t}\n\n\n/* control positioning */\n\n.leaflet-control {\n\tposition: relative;\n\tz-index: 800;\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\n\tpointer-events: auto;\n\t}\n.leaflet-top,\n.leaflet-bottom {\n\tposition: absolute;\n\tz-index: 1000;\n\tpointer-events: none;\n\t}\n.leaflet-top {\n\ttop: 0;\n\t}\n.leaflet-right {\n\tright: 0;\n\t}\n.leaflet-bottom {\n\tbottom: 0;\n\t}\n.leaflet-left {\n\tleft: 0;\n\t}\n.leaflet-control {\n\tfloat: left;\n\tclear: both;\n\t}\n.leaflet-right .leaflet-control {\n\tfloat: right;\n\t}\n.leaflet-top .leaflet-control {\n\tmargin-top: 10px;\n\t}\n.leaflet-bottom .leaflet-control {\n\tmargin-bottom: 10px;\n\t}\n.leaflet-left .leaflet-control {\n\tmargin-left: 10px;\n\t}\n.leaflet-right .leaflet-control {\n\tmargin-right: 10px;\n\t}\n\n\n/* zoom and fade animations */\n\n.leaflet-fade-anim .leaflet-popup {\n\topacity: 0;\n\t-webkit-transition: opacity 0.2s linear;\n\t   -moz-transition: opacity 0.2s linear;\n\t        transition: opacity 0.2s linear;\n\t}\n.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\n\topacity: 1;\n\t}\n.leaflet-zoom-animated {\n\t-webkit-transform-origin: 0 0;\n\t    -ms-transform-origin: 0 0;\n\t        transform-origin: 0 0;\n\t}\nsvg.leaflet-zoom-animated {\n\twill-change: transform;\n}\n\n.leaflet-zoom-anim .leaflet-zoom-animated {\n\t-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\n\t   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\n\t        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\n\t}\n.leaflet-zoom-anim .leaflet-tile,\n.leaflet-pan-anim .leaflet-tile {\n\t-webkit-transition: none;\n\t   -moz-transition: none;\n\t        transition: none;\n\t}\n\n.leaflet-zoom-anim .leaflet-zoom-hide {\n\tvisibility: hidden;\n\t}\n\n\n/* cursors */\n\n.leaflet-interactive {\n\tcursor: pointer;\n\t}\n.leaflet-grab {\n\tcursor: -webkit-grab;\n\tcursor:    -moz-grab;\n\tcursor:         grab;\n\t}\n.leaflet-crosshair,\n.leaflet-crosshair .leaflet-interactive {\n\tcursor: crosshair;\n\t}\n.leaflet-popup-pane,\n.leaflet-control {\n\tcursor: auto;\n\t}\n.leaflet-dragging .leaflet-grab,\n.leaflet-dragging .leaflet-grab .leaflet-interactive,\n.leaflet-dragging .leaflet-marker-draggable {\n\tcursor: move;\n\tcursor: -webkit-grabbing;\n\tcursor:    -moz-grabbing;\n\tcursor:         grabbing;\n\t}\n\n/* marker & overlays interactivity */\n.leaflet-marker-icon,\n.leaflet-marker-shadow,\n.leaflet-image-layer,\n.leaflet-pane > svg path,\n.leaflet-tile-container {\n\tpointer-events: none;\n\t}\n\n.leaflet-marker-icon.leaflet-interactive,\n.leaflet-image-layer.leaflet-interactive,\n.leaflet-pane > svg path.leaflet-interactive,\nsvg.leaflet-image-layer.leaflet-interactive path {\n\tpointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\n\tpointer-events: auto;\n\t}\n\n/* visual tweaks */\n\n.leaflet-container {\n\tbackground: #ddd;\n\toutline-offset: 1px;\n\t}\n.leaflet-container a {\n\tcolor: #0078A8;\n\t}\n.leaflet-zoom-box {\n\tborder: 2px dotted #38f;\n\tbackground: rgba(255,255,255,0.5);\n\t}\n\n\n/* general typography */\n.leaflet-container {\n\tfont-family: "Helvetica Neue", Arial, Helvetica, sans-serif;\n\tfont-size: 12px;\n\tfont-size: 0.75rem;\n\tline-height: 1.5;\n\t}\n\n\n/* general toolbar styles */\n\n.leaflet-bar {\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.65);\n\tborder-radius: 4px;\n\t}\n.leaflet-bar a {\n\tbackground-color: #fff;\n\tborder-bottom: 1px solid #ccc;\n\twidth: 26px;\n\theight: 26px;\n\tline-height: 26px;\n\tdisplay: block;\n\ttext-align: center;\n\ttext-decoration: none;\n\tcolor: black;\n\t}\n.leaflet-bar a,\n.leaflet-control-layers-toggle {\n\tbackground-position: 50% 50%;\n\tbackground-repeat: no-repeat;\n\tdisplay: block;\n\t}\n.leaflet-bar a:hover,\n.leaflet-bar a:focus {\n\tbackground-color: #f4f4f4;\n\t}\n.leaflet-bar a:first-child {\n\tborder-top-left-radius: 4px;\n\tborder-top-right-radius: 4px;\n\t}\n.leaflet-bar a:last-child {\n\tborder-bottom-left-radius: 4px;\n\tborder-bottom-right-radius: 4px;\n\tborder-bottom: none;\n\t}\n.leaflet-bar a.leaflet-disabled {\n\tcursor: default;\n\tbackground-color: #f4f4f4;\n\tcolor: #bbb;\n\t}\n\n.leaflet-touch .leaflet-bar a {\n\twidth: 30px;\n\theight: 30px;\n\tline-height: 30px;\n\t}\n.leaflet-touch .leaflet-bar a:first-child {\n\tborder-top-left-radius: 2px;\n\tborder-top-right-radius: 2px;\n\t}\n.leaflet-touch .leaflet-bar a:last-child {\n\tborder-bottom-left-radius: 2px;\n\tborder-bottom-right-radius: 2px;\n\t}\n\n/* zoom control */\n\n.leaflet-control-zoom-in,\n.leaflet-control-zoom-out {\n\tfont: bold 18px 'Lucida Console', Monaco, monospace;\n\ttext-indent: 1px;\n\t}\n\n.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\n\tfont-size: 22px;\n\t}\n\n\n/* layers control */\n\n.leaflet-control-layers {\n\tbox-shadow: 0 1px 5px rgba(0,0,0,0.4);\n\tbackground: #fff;\n\tborder-radius: 5px;\n\t}\n.leaflet-control-layers-toggle {\n\tbackground-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});\n\twidth: 36px;\n\theight: 36px;\n\t}\n.leaflet-retina .leaflet-control-layers-toggle {\n\tbackground-image: url(${___CSS_LOADER_URL_REPLACEMENT_1___});\n\tbackground-size: 26px 26px;\n\t}\n.leaflet-touch .leaflet-control-layers-toggle {\n\twidth: 44px;\n\theight: 44px;\n\t}\n.leaflet-control-layers .leaflet-control-layers-list,\n.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\n\tdisplay: none;\n\t}\n.leaflet-control-layers-expanded .leaflet-control-layers-list {\n\tdisplay: block;\n\tposition: relative;\n\t}\n.leaflet-control-layers-expanded {\n\tpadding: 6px 10px 6px 6px;\n\tcolor: #333;\n\tbackground: #fff;\n\t}\n.leaflet-control-layers-scrollbar {\n\toverflow-y: scroll;\n\toverflow-x: hidden;\n\tpadding-right: 5px;\n\t}\n.leaflet-control-layers-selector {\n\tmargin-top: 2px;\n\tposition: relative;\n\ttop: 1px;\n\t}\n.leaflet-control-layers label {\n\tdisplay: block;\n\tfont-size: 13px;\n\tfont-size: 1.08333em;\n\t}\n.leaflet-control-layers-separator {\n\theight: 0;\n\tborder-top: 1px solid #ddd;\n\tmargin: 5px -10px 5px -6px;\n\t}\n\n/* Default icon URLs */\n.leaflet-default-icon-path { /* used only in path-guessing heuristic, see L.Icon.Default */\n\tbackground-image: url(${___CSS_LOADER_URL_REPLACEMENT_2___});\n\t}\n\n\n/* attribution and scale controls */\n\n.leaflet-container .leaflet-control-attribution {\n\tbackground: #fff;\n\tbackground: rgba(255, 255, 255, 0.8);\n\tmargin: 0;\n\t}\n.leaflet-control-attribution,\n.leaflet-control-scale-line {\n\tpadding: 0 5px;\n\tcolor: #333;\n\tline-height: 1.4;\n\t}\n.leaflet-control-attribution a {\n\ttext-decoration: none;\n\t}\n.leaflet-control-attribution a:hover,\n.leaflet-control-attribution a:focus {\n\ttext-decoration: underline;\n\t}\n.leaflet-attribution-flag {\n\tdisplay: inline !important;\n\tvertical-align: baseline !important;\n\twidth: 1em;\n\theight: 0.6669em;\n\t}\n.leaflet-left .leaflet-control-scale {\n\tmargin-left: 5px;\n\t}\n.leaflet-bottom .leaflet-control-scale {\n\tmargin-bottom: 5px;\n\t}\n.leaflet-control-scale-line {\n\tborder: 2px solid #777;\n\tborder-top: none;\n\tline-height: 1.1;\n\tpadding: 2px 5px 1px;\n\twhite-space: nowrap;\n\t-moz-box-sizing: border-box;\n\t     box-sizing: border-box;\n\tbackground: rgba(255, 255, 255, 0.8);\n\ttext-shadow: 1px 1px #fff;\n\t}\n.leaflet-control-scale-line:not(:first-child) {\n\tborder-top: 2px solid #777;\n\tborder-bottom: none;\n\tmargin-top: -2px;\n\t}\n.leaflet-control-scale-line:not(:first-child):not(:last-child) {\n\tborder-bottom: 2px solid #777;\n\t}\n\n.leaflet-touch .leaflet-control-attribution,\n.leaflet-touch .leaflet-control-layers,\n.leaflet-touch .leaflet-bar {\n\tbox-shadow: none;\n\t}\n.leaflet-touch .leaflet-control-layers,\n.leaflet-touch .leaflet-bar {\n\tborder: 2px solid rgba(0,0,0,0.2);\n\tbackground-clip: padding-box;\n\t}\n\n\n/* popup */\n\n.leaflet-popup {\n\tposition: absolute;\n\ttext-align: center;\n\tmargin-bottom: 20px;\n\t}\n.leaflet-popup-content-wrapper {\n\tpadding: 1px;\n\ttext-align: left;\n\tborder-radius: 12px;\n\t}\n.leaflet-popup-content {\n\tmargin: 13px 24px 13px 20px;\n\tline-height: 1.3;\n\tfont-size: 13px;\n\tfont-size: 1.08333em;\n\tmin-height: 1px;\n\t}\n.leaflet-popup-content p {\n\tmargin: 17px 0;\n\tmargin: 1.3em 0;\n\t}\n.leaflet-popup-tip-container {\n\twidth: 40px;\n\theight: 20px;\n\tposition: absolute;\n\tleft: 50%;\n\tmargin-top: -1px;\n\tmargin-left: -20px;\n\toverflow: hidden;\n\tpointer-events: none;\n\t}\n.leaflet-popup-tip {\n\twidth: 17px;\n\theight: 17px;\n\tpadding: 1px;\n\n\tmargin: -10px auto 0;\n\tpointer-events: auto;\n\n\t-webkit-transform: rotate(45deg);\n\t   -moz-transform: rotate(45deg);\n\t    -ms-transform: rotate(45deg);\n\t        transform: rotate(45deg);\n\t}\n.leaflet-popup-content-wrapper,\n.leaflet-popup-tip {\n\tbackground: white;\n\tcolor: #333;\n\tbox-shadow: 0 3px 14px rgba(0,0,0,0.4);\n\t}\n.leaflet-container a.leaflet-popup-close-button {\n\tposition: absolute;\n\ttop: 0;\n\tright: 0;\n\tborder: none;\n\ttext-align: center;\n\twidth: 24px;\n\theight: 24px;\n\tfont: 16px/24px Tahoma, Verdana, sans-serif;\n\tcolor: #757575;\n\ttext-decoration: none;\n\tbackground: transparent;\n\t}\n.leaflet-container a.leaflet-popup-close-button:hover,\n.leaflet-container a.leaflet-popup-close-button:focus {\n\tcolor: #585858;\n\t}\n.leaflet-popup-scrolled {\n\toverflow: auto;\n\t}\n\n.leaflet-oldie .leaflet-popup-content-wrapper {\n\t-ms-zoom: 1;\n\t}\n.leaflet-oldie .leaflet-popup-tip {\n\twidth: 24px;\n\tmargin: 0 auto;\n\n\t-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";\n\tfilter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\n\t}\n\n.leaflet-oldie .leaflet-control-zoom,\n.leaflet-oldie .leaflet-control-layers,\n.leaflet-oldie .leaflet-popup-content-wrapper,\n.leaflet-oldie .leaflet-popup-tip {\n\tborder: 1px solid #999;\n\t}\n\n\n/* div icon */\n\n.leaflet-div-icon {\n\tbackground: #fff;\n\tborder: 1px solid #666;\n\t}\n\n\n/* Tooltip */\n/* Base styles for the element that has a tooltip */\n.leaflet-tooltip {\n\tposition: absolute;\n\tpadding: 6px;\n\tbackground-color: #fff;\n\tborder: 1px solid #fff;\n\tborder-radius: 3px;\n\tcolor: #222;\n\twhite-space: nowrap;\n\t-webkit-user-select: none;\n\t-moz-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none;\n\tpointer-events: none;\n\tbox-shadow: 0 1px 3px rgba(0,0,0,0.4);\n\t}\n.leaflet-tooltip.leaflet-interactive {\n\tcursor: pointer;\n\tpointer-events: auto;\n\t}\n.leaflet-tooltip-top:before,\n.leaflet-tooltip-bottom:before,\n.leaflet-tooltip-left:before,\n.leaflet-tooltip-right:before {\n\tposition: absolute;\n\tpointer-events: none;\n\tborder: 6px solid transparent;\n\tbackground: transparent;\n\tcontent: "";\n\t}\n\n/* Directions */\n\n.leaflet-tooltip-bottom {\n\tmargin-top: 6px;\n}\n.leaflet-tooltip-top {\n\tmargin-top: -6px;\n}\n.leaflet-tooltip-bottom:before,\n.leaflet-tooltip-top:before {\n\tleft: 50%;\n\tmargin-left: -6px;\n\t}\n.leaflet-tooltip-top:before {\n\tbottom: 0;\n\tmargin-bottom: -12px;\n\tborder-top-color: #fff;\n\t}\n.leaflet-tooltip-bottom:before {\n\ttop: 0;\n\tmargin-top: -12px;\n\tmargin-left: -6px;\n\tborder-bottom-color: #fff;\n\t}\n.leaflet-tooltip-left {\n\tmargin-left: -6px;\n}\n.leaflet-tooltip-right {\n\tmargin-left: 6px;\n}\n.leaflet-tooltip-left:before,\n.leaflet-tooltip-right:before {\n\ttop: 50%;\n\tmargin-top: -6px;\n\t}\n.leaflet-tooltip-left:before {\n\tright: 0;\n\tmargin-right: -12px;\n\tborder-left-color: #fff;\n\t}\n.leaflet-tooltip-right:before {\n\tleft: 0;\n\tmargin-left: -12px;\n\tborder-right-color: #fff;\n\t}\n\n/* Printing */\n\n@media print {\n\t/* Prevent printers from removing background-images of controls. */\n\t.leaflet-control {\n\t\t-webkit-print-color-adjust: exact;\n\t\tprint-color-adjust: exact;\n\t\t}\n\t}\n`, "" ]);
        const __WEBPACK_DEFAULT_EXPORT__ = ___CSS_LOADER_EXPORT___;
    },
    278: module => {
        "use strict";
        module.exports = function(cssWithMappingToString) {
            var list = [];
            return list.toString = function() {
                return this.map((function(item) {
                    var content = "", needLayer = void 0 !== item[5];
                    return item[4] && (content += "@supports (".concat(item[4], ") {")), item[2] && (content += "@media ".concat(item[2], " {")), 
                    needLayer && (content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {")), 
                    content += cssWithMappingToString(item), needLayer && (content += "}"), item[2] && (content += "}"), 
                    item[4] && (content += "}"), content;
                })).join("");
            }, list.i = function(modules, media, dedupe, supports, layer) {
                "string" == typeof modules && (modules = [ [ null, modules, void 0 ] ]);
                var alreadyImportedModules = {};
                if (dedupe) for (var k = 0; k < this.length; k++) {
                    var id = this[k][0];
                    null != id && (alreadyImportedModules[id] = !0);
                }
                for (var _k = 0; _k < modules.length; _k++) {
                    var item = [].concat(modules[_k]);
                    dedupe && alreadyImportedModules[item[0]] || (void 0 !== layer && (void 0 === item[5] || (item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}")), 
                    item[5] = layer), media && (item[2] ? (item[1] = "@media ".concat(item[2], " {").concat(item[1], "}"), 
                    item[2] = media) : item[2] = media), supports && (item[4] ? (item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}"), 
                    item[4] = supports) : item[4] = "".concat(supports)), list.push(item));
                }
            }, list;
        };
    },
    21: module => {
        "use strict";
        module.exports = function(url, options) {
            return options || (options = {}), url ? (url = String(url.__esModule ? url.default : url), 
            /^['"].*['"]$/.test(url) && (url = url.slice(1, -1)), options.hash && (url += options.hash), 
            /["'() \t\n]|(%20)/.test(url) || options.needQuotes ? '"'.concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), '"') : url) : url;
        };
    },
    645: module => {
        "use strict";
        module.exports = function(i) {
            return i[1];
        };
    },
    625: function(__unused_webpack_module, exports) {
        !function(exports) {
            "use strict";
            var MarkerClusterGroup = L.MarkerClusterGroup = L.FeatureGroup.extend({
                options: {
                    maxClusterRadius: 80,
                    iconCreateFunction: null,
                    clusterPane: L.Marker.prototype.options.pane,
                    spiderfyOnEveryZoom: !1,
                    spiderfyOnMaxZoom: !0,
                    showCoverageOnHover: !0,
                    zoomToBoundsOnClick: !0,
                    singleMarkerMode: !1,
                    disableClusteringAtZoom: null,
                    removeOutsideVisibleBounds: !0,
                    animate: !0,
                    animateAddingMarkers: !1,
                    spiderfyShapePositions: null,
                    spiderfyDistanceMultiplier: 1,
                    spiderLegPolylineOptions: {
                        weight: 1.5,
                        color: "#222",
                        opacity: .5
                    },
                    chunkedLoading: !1,
                    chunkInterval: 200,
                    chunkDelay: 50,
                    chunkProgress: null,
                    polygonOptions: {}
                },
                initialize: function(options) {
                    L.Util.setOptions(this, options), this.options.iconCreateFunction || (this.options.iconCreateFunction = this._defaultIconCreateFunction), 
                    this._featureGroup = L.featureGroup(), this._featureGroup.addEventParent(this), 
                    this._nonPointGroup = L.featureGroup(), this._nonPointGroup.addEventParent(this), 
                    this._inZoomAnimation = 0, this._needsClustering = [], this._needsRemoving = [], 
                    this._currentShownBounds = null, this._queue = [], this._childMarkerEventHandlers = {
                        dragstart: this._childMarkerDragStart,
                        move: this._childMarkerMoved,
                        dragend: this._childMarkerDragEnd
                    };
                    var animate = L.DomUtil.TRANSITION && this.options.animate;
                    L.extend(this, animate ? this._withAnimation : this._noAnimation), this._markerCluster = animate ? L.MarkerCluster : L.MarkerClusterNonAnimated;
                },
                addLayer: function(layer) {
                    if (layer instanceof L.LayerGroup) return this.addLayers([ layer ]);
                    if (!layer.getLatLng) return this._nonPointGroup.addLayer(layer), this.fire("layeradd", {
                        layer
                    }), this;
                    if (!this._map) return this._needsClustering.push(layer), this.fire("layeradd", {
                        layer
                    }), this;
                    if (this.hasLayer(layer)) return this;
                    this._unspiderfy && this._unspiderfy(), this._addLayer(layer, this._maxZoom), this.fire("layeradd", {
                        layer
                    }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons();
                    var visibleLayer = layer, currentZoom = this._zoom;
                    if (layer.__parent) for (;visibleLayer.__parent._zoom >= currentZoom; ) visibleLayer = visibleLayer.__parent;
                    return this._currentShownBounds.contains(visibleLayer.getLatLng()) && (this.options.animateAddingMarkers ? this._animationAddLayer(layer, visibleLayer) : this._animationAddLayerNonAnimated(layer, visibleLayer)), 
                    this;
                },
                removeLayer: function(layer) {
                    return layer instanceof L.LayerGroup ? this.removeLayers([ layer ]) : layer.getLatLng ? this._map ? layer.__parent ? (this._unspiderfy && (this._unspiderfy(), 
                    this._unspiderfyLayer(layer)), this._removeLayer(layer, !0), this.fire("layerremove", {
                        layer
                    }), this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), layer.off(this._childMarkerEventHandlers, this), 
                    this._featureGroup.hasLayer(layer) && (this._featureGroup.removeLayer(layer), layer.clusterShow && layer.clusterShow()), 
                    this) : this : (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer) && this._needsRemoving.push({
                        layer,
                        latlng: layer._latlng
                    }), this.fire("layerremove", {
                        layer
                    }), this) : (this._nonPointGroup.removeLayer(layer), this.fire("layerremove", {
                        layer
                    }), this);
                },
                addLayers: function(layersArray, skipLayerAddEvent) {
                    if (!L.Util.isArray(layersArray)) return this.addLayer(layersArray);
                    var m, fg = this._featureGroup, npg = this._nonPointGroup, chunked = this.options.chunkedLoading, chunkInterval = this.options.chunkInterval, chunkProgress = this.options.chunkProgress, l = layersArray.length, offset = 0, originalArray = !0;
                    if (this._map) {
                        var started = (new Date).getTime(), process = L.bind((function() {
                            var start = (new Date).getTime();
                            for (this._map && this._unspiderfy && this._unspiderfy(); offset < l && !(chunked && offset % 200 == 0 && (new Date).getTime() - start > chunkInterval); offset++) if ((m = layersArray[offset]) instanceof L.LayerGroup) originalArray && (layersArray = layersArray.slice(), 
                            originalArray = !1), this._extractNonGroupLayers(m, layersArray), l = layersArray.length; else if (m.getLatLng) {
                                if (!this.hasLayer(m) && (this._addLayer(m, this._maxZoom), skipLayerAddEvent || this.fire("layeradd", {
                                    layer: m
                                }), m.__parent && 2 === m.__parent.getChildCount())) {
                                    var markers = m.__parent.getAllChildMarkers(), otherMarker = markers[0] === m ? markers[1] : markers[0];
                                    fg.removeLayer(otherMarker);
                                }
                            } else npg.addLayer(m), skipLayerAddEvent || this.fire("layeradd", {
                                layer: m
                            });
                            chunkProgress && chunkProgress(offset, l, (new Date).getTime() - started), offset === l ? (this._topClusterLevel._recalculateBounds(), 
                            this._refreshClustersIcons(), this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds)) : setTimeout(process, this.options.chunkDelay);
                        }), this);
                        process();
                    } else for (var needsClustering = this._needsClustering; offset < l; offset++) (m = layersArray[offset]) instanceof L.LayerGroup ? (originalArray && (layersArray = layersArray.slice(), 
                    originalArray = !1), this._extractNonGroupLayers(m, layersArray), l = layersArray.length) : m.getLatLng ? this.hasLayer(m) || needsClustering.push(m) : npg.addLayer(m);
                    return this;
                },
                removeLayers: function(layersArray) {
                    var i, m, l = layersArray.length, fg = this._featureGroup, npg = this._nonPointGroup, originalArray = !0;
                    if (!this._map) {
                        for (i = 0; i < l; i++) (m = layersArray[i]) instanceof L.LayerGroup ? (originalArray && (layersArray = layersArray.slice(), 
                        originalArray = !1), this._extractNonGroupLayers(m, layersArray), l = layersArray.length) : (this._arraySplice(this._needsClustering, m), 
                        npg.removeLayer(m), this.hasLayer(m) && this._needsRemoving.push({
                            layer: m,
                            latlng: m._latlng
                        }), this.fire("layerremove", {
                            layer: m
                        }));
                        return this;
                    }
                    if (this._unspiderfy) {
                        this._unspiderfy();
                        var layersArray2 = layersArray.slice(), l2 = l;
                        for (i = 0; i < l2; i++) (m = layersArray2[i]) instanceof L.LayerGroup ? (this._extractNonGroupLayers(m, layersArray2), 
                        l2 = layersArray2.length) : this._unspiderfyLayer(m);
                    }
                    for (i = 0; i < l; i++) (m = layersArray[i]) instanceof L.LayerGroup ? (originalArray && (layersArray = layersArray.slice(), 
                    originalArray = !1), this._extractNonGroupLayers(m, layersArray), l = layersArray.length) : m.__parent ? (this._removeLayer(m, !0, !0), 
                    this.fire("layerremove", {
                        layer: m
                    }), fg.hasLayer(m) && (fg.removeLayer(m), m.clusterShow && m.clusterShow())) : (npg.removeLayer(m), 
                    this.fire("layerremove", {
                        layer: m
                    }));
                    return this._topClusterLevel._recalculateBounds(), this._refreshClustersIcons(), 
                    this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds), 
                    this;
                },
                clearLayers: function() {
                    return this._map || (this._needsClustering = [], this._needsRemoving = [], delete this._gridClusters, 
                    delete this._gridUnclustered), this._noanimationUnspiderfy && this._noanimationUnspiderfy(), 
                    this._featureGroup.clearLayers(), this._nonPointGroup.clearLayers(), this.eachLayer((function(marker) {
                        marker.off(this._childMarkerEventHandlers, this), delete marker.__parent;
                    }), this), this._map && this._generateInitialClusters(), this;
                },
                getBounds: function() {
                    var bounds = new L.LatLngBounds;
                    this._topClusterLevel && bounds.extend(this._topClusterLevel._bounds);
                    for (var i = this._needsClustering.length - 1; i >= 0; i--) bounds.extend(this._needsClustering[i].getLatLng());
                    return bounds.extend(this._nonPointGroup.getBounds()), bounds;
                },
                eachLayer: function(method, context) {
                    var thisNeedsRemoving, i, j, markers = this._needsClustering.slice(), needsRemoving = this._needsRemoving;
                    for (this._topClusterLevel && this._topClusterLevel.getAllChildMarkers(markers), 
                    i = markers.length - 1; i >= 0; i--) {
                        for (thisNeedsRemoving = !0, j = needsRemoving.length - 1; j >= 0; j--) if (needsRemoving[j].layer === markers[i]) {
                            thisNeedsRemoving = !1;
                            break;
                        }
                        thisNeedsRemoving && method.call(context, markers[i]);
                    }
                    this._nonPointGroup.eachLayer(method, context);
                },
                getLayers: function() {
                    var layers = [];
                    return this.eachLayer((function(l) {
                        layers.push(l);
                    })), layers;
                },
                getLayer: function(id) {
                    var result = null;
                    return id = parseInt(id, 10), this.eachLayer((function(l) {
                        L.stamp(l) === id && (result = l);
                    })), result;
                },
                hasLayer: function(layer) {
                    if (!layer) return !1;
                    var i, anArray = this._needsClustering;
                    for (i = anArray.length - 1; i >= 0; i--) if (anArray[i] === layer) return !0;
                    for (i = (anArray = this._needsRemoving).length - 1; i >= 0; i--) if (anArray[i].layer === layer) return !1;
                    return !(!layer.__parent || layer.__parent._group !== this) || this._nonPointGroup.hasLayer(layer);
                },
                zoomToShowLayer: function(layer, callback) {
                    var map = this._map;
                    "function" != typeof callback && (callback = function() {});
                    var showMarker = function() {
                        !map.hasLayer(layer) && !map.hasLayer(layer.__parent) || this._inZoomAnimation || (this._map.off("moveend", showMarker, this), 
                        this.off("animationend", showMarker, this), map.hasLayer(layer) ? callback() : layer.__parent._icon && (this.once("spiderfied", callback, this), 
                        layer.__parent.spiderfy()));
                    };
                    layer._icon && this._map.getBounds().contains(layer.getLatLng()) ? callback() : layer.__parent._zoom < Math.round(this._map._zoom) ? (this._map.on("moveend", showMarker, this), 
                    this._map.panTo(layer.getLatLng())) : (this._map.on("moveend", showMarker, this), 
                    this.on("animationend", showMarker, this), layer.__parent.zoomToBounds());
                },
                onAdd: function(map) {
                    var i, l, layer;
                    if (this._map = map, !isFinite(this._map.getMaxZoom())) throw "Map has no maxZoom specified";
                    for (this._featureGroup.addTo(map), this._nonPointGroup.addTo(map), this._gridClusters || this._generateInitialClusters(), 
                    this._maxLat = map.options.crs.projection.MAX_LATITUDE, i = 0, l = this._needsRemoving.length; i < l; i++) (layer = this._needsRemoving[i]).newlatlng = layer.layer._latlng, 
                    layer.layer._latlng = layer.latlng;
                    for (i = 0, l = this._needsRemoving.length; i < l; i++) layer = this._needsRemoving[i], 
                    this._removeLayer(layer.layer, !0), layer.layer._latlng = layer.newlatlng;
                    this._needsRemoving = [], this._zoom = Math.round(this._map._zoom), this._currentShownBounds = this._getExpandedVisibleBounds(), 
                    this._map.on("zoomend", this._zoomEnd, this), this._map.on("moveend", this._moveEnd, this), 
                    this._spiderfierOnAdd && this._spiderfierOnAdd(), this._bindEvents(), l = this._needsClustering, 
                    this._needsClustering = [], this.addLayers(l, !0);
                },
                onRemove: function(map) {
                    map.off("zoomend", this._zoomEnd, this), map.off("moveend", this._moveEnd, this), 
                    this._unbindEvents(), this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", ""), 
                    this._spiderfierOnRemove && this._spiderfierOnRemove(), delete this._maxLat, this._hideCoverage(), 
                    this._featureGroup.remove(), this._nonPointGroup.remove(), this._featureGroup.clearLayers(), 
                    this._map = null;
                },
                getVisibleParent: function(marker) {
                    for (var vMarker = marker; vMarker && !vMarker._icon; ) vMarker = vMarker.__parent;
                    return vMarker || null;
                },
                _arraySplice: function(anArray, obj) {
                    for (var i = anArray.length - 1; i >= 0; i--) if (anArray[i] === obj) return anArray.splice(i, 1), 
                    !0;
                },
                _removeFromGridUnclustered: function(marker, z) {
                    for (var map = this._map, gridUnclustered = this._gridUnclustered, minZoom = Math.floor(this._map.getMinZoom()); z >= minZoom && gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z)); z--) ;
                },
                _childMarkerDragStart: function(e) {
                    e.target.__dragStart = e.target._latlng;
                },
                _childMarkerMoved: function(e) {
                    if (!this._ignoreMove && !e.target.__dragStart) {
                        var isPopupOpen = e.target._popup && e.target._popup.isOpen();
                        this._moveChild(e.target, e.oldLatLng, e.latlng), isPopupOpen && e.target.openPopup();
                    }
                },
                _moveChild: function(layer, from, to) {
                    layer._latlng = from, this.removeLayer(layer), layer._latlng = to, this.addLayer(layer);
                },
                _childMarkerDragEnd: function(e) {
                    var dragStart = e.target.__dragStart;
                    delete e.target.__dragStart, dragStart && this._moveChild(e.target, dragStart, e.target._latlng);
                },
                _removeLayer: function(marker, removeFromDistanceGrid, dontUpdateMap) {
                    var gridClusters = this._gridClusters, gridUnclustered = this._gridUnclustered, fg = this._featureGroup, map = this._map, minZoom = Math.floor(this._map.getMinZoom());
                    removeFromDistanceGrid && this._removeFromGridUnclustered(marker, this._maxZoom);
                    var otherMarker, cluster = marker.__parent, markers = cluster._markers;
                    for (this._arraySplice(markers, marker); cluster && (cluster._childCount--, cluster._boundsNeedUpdate = !0, 
                    !(cluster._zoom < minZoom)); ) removeFromDistanceGrid && cluster._childCount <= 1 ? (otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0], 
                    gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom)), 
                    gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom)), 
                    this._arraySplice(cluster.__parent._childClusters, cluster), cluster.__parent._markers.push(otherMarker), 
                    otherMarker.__parent = cluster.__parent, cluster._icon && (fg.removeLayer(cluster), 
                    dontUpdateMap || fg.addLayer(otherMarker))) : cluster._iconNeedsUpdate = !0, cluster = cluster.__parent;
                    delete marker.__parent;
                },
                _isOrIsParent: function(el, oel) {
                    for (;oel; ) {
                        if (el === oel) return !0;
                        oel = oel.parentNode;
                    }
                    return !1;
                },
                fire: function(type, data, propagate) {
                    if (data && data.layer instanceof L.MarkerCluster) {
                        if (data.originalEvent && this._isOrIsParent(data.layer._icon, data.originalEvent.relatedTarget)) return;
                        type = "cluster" + type;
                    }
                    L.FeatureGroup.prototype.fire.call(this, type, data, propagate);
                },
                listens: function(type, propagate) {
                    return L.FeatureGroup.prototype.listens.call(this, type, propagate) || L.FeatureGroup.prototype.listens.call(this, "cluster" + type, propagate);
                },
                _defaultIconCreateFunction: function(cluster) {
                    var childCount = cluster.getChildCount(), c = " marker-cluster-";
                    return c += childCount < 10 ? "small" : childCount < 100 ? "medium" : "large", new L.DivIcon({
                        html: "<div><span>" + childCount + "</span></div>",
                        className: "marker-cluster" + c,
                        iconSize: new L.Point(40, 40)
                    });
                },
                _bindEvents: function() {
                    var map = this._map, spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick, spiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom;
                    (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) && this.on("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), 
                    showCoverageOnHover && (this.on("clustermouseover", this._showCoverage, this), this.on("clustermouseout", this._hideCoverage, this), 
                    map.on("zoomend", this._hideCoverage, this));
                },
                _zoomOrSpiderfy: function(e) {
                    var cluster = e.layer, bottomCluster = cluster;
                    if ("clusterkeypress" !== e.type || !e.originalEvent || 13 === e.originalEvent.keyCode) {
                        for (;1 === bottomCluster._childClusters.length; ) bottomCluster = bottomCluster._childClusters[0];
                        bottomCluster._zoom === this._maxZoom && bottomCluster._childCount === cluster._childCount && this.options.spiderfyOnMaxZoom ? cluster.spiderfy() : this.options.zoomToBoundsOnClick && cluster.zoomToBounds(), 
                        this.options.spiderfyOnEveryZoom && cluster.spiderfy(), e.originalEvent && 13 === e.originalEvent.keyCode && this._map._container.focus();
                    }
                },
                _showCoverage: function(e) {
                    var map = this._map;
                    this._inZoomAnimation || (this._shownPolygon && map.removeLayer(this._shownPolygon), 
                    e.layer.getChildCount() > 2 && e.layer !== this._spiderfied && (this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions), 
                    map.addLayer(this._shownPolygon)));
                },
                _hideCoverage: function() {
                    this._shownPolygon && (this._map.removeLayer(this._shownPolygon), this._shownPolygon = null);
                },
                _unbindEvents: function() {
                    var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom, showCoverageOnHover = this.options.showCoverageOnHover, zoomToBoundsOnClick = this.options.zoomToBoundsOnClick, spiderfyOnEveryZoom = this.options.spiderfyOnEveryZoom, map = this._map;
                    (spiderfyOnMaxZoom || zoomToBoundsOnClick || spiderfyOnEveryZoom) && this.off("clusterclick clusterkeypress", this._zoomOrSpiderfy, this), 
                    showCoverageOnHover && (this.off("clustermouseover", this._showCoverage, this), 
                    this.off("clustermouseout", this._hideCoverage, this), map.off("zoomend", this._hideCoverage, this));
                },
                _zoomEnd: function() {
                    this._map && (this._mergeSplitClusters(), this._zoom = Math.round(this._map._zoom), 
                    this._currentShownBounds = this._getExpandedVisibleBounds());
                },
                _moveEnd: function() {
                    if (!this._inZoomAnimation) {
                        var newBounds = this._getExpandedVisibleBounds();
                        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, newBounds), 
                        this._topClusterLevel._recursivelyAddChildrenToMap(null, Math.round(this._map._zoom), newBounds), 
                        this._currentShownBounds = newBounds;
                    }
                },
                _generateInitialClusters: function() {
                    var maxZoom = Math.ceil(this._map.getMaxZoom()), minZoom = Math.floor(this._map.getMinZoom()), radius = this.options.maxClusterRadius, radiusFn = radius;
                    "function" != typeof radius && (radiusFn = function() {
                        return radius;
                    }), null !== this.options.disableClusteringAtZoom && (maxZoom = this.options.disableClusteringAtZoom - 1), 
                    this._maxZoom = maxZoom, this._gridClusters = {}, this._gridUnclustered = {};
                    for (var zoom = maxZoom; zoom >= minZoom; zoom--) this._gridClusters[zoom] = new L.DistanceGrid(radiusFn(zoom)), 
                    this._gridUnclustered[zoom] = new L.DistanceGrid(radiusFn(zoom));
                    this._topClusterLevel = new this._markerCluster(this, minZoom - 1);
                },
                _addLayer: function(layer, zoom) {
                    var markerPoint, z, gridClusters = this._gridClusters, gridUnclustered = this._gridUnclustered, minZoom = Math.floor(this._map.getMinZoom());
                    for (this.options.singleMarkerMode && this._overrideMarkerIcon(layer), layer.on(this._childMarkerEventHandlers, this); zoom >= minZoom; zoom--) {
                        markerPoint = this._map.project(layer.getLatLng(), zoom);
                        var closest = gridClusters[zoom].getNearObject(markerPoint);
                        if (closest) return closest._addChild(layer), void (layer.__parent = closest);
                        if (closest = gridUnclustered[zoom].getNearObject(markerPoint)) {
                            var parent = closest.__parent;
                            parent && this._removeLayer(closest, !1);
                            var newCluster = new this._markerCluster(this, zoom, closest, layer);
                            gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom)), 
                            closest.__parent = newCluster, layer.__parent = newCluster;
                            var lastParent = newCluster;
                            for (z = zoom - 1; z > parent._zoom; z--) lastParent = new this._markerCluster(this, z, lastParent), 
                            gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
                            return parent._addChild(lastParent), void this._removeFromGridUnclustered(closest, zoom);
                        }
                        gridUnclustered[zoom].addObject(layer, markerPoint);
                    }
                    this._topClusterLevel._addChild(layer), layer.__parent = this._topClusterLevel;
                },
                _refreshClustersIcons: function() {
                    this._featureGroup.eachLayer((function(c) {
                        c instanceof L.MarkerCluster && c._iconNeedsUpdate && c._updateIcon();
                    }));
                },
                _enqueue: function(fn) {
                    this._queue.push(fn), this._queueTimeout || (this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300));
                },
                _processQueue: function() {
                    for (var i = 0; i < this._queue.length; i++) this._queue[i].call(this);
                    this._queue.length = 0, clearTimeout(this._queueTimeout), this._queueTimeout = null;
                },
                _mergeSplitClusters: function() {
                    var mapZoom = Math.round(this._map._zoom);
                    this._processQueue(), this._zoom < mapZoom && this._currentShownBounds.intersects(this._getExpandedVisibleBounds()) ? (this._animationStart(), 
                    this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), this._zoom, this._getExpandedVisibleBounds()), 
                    this._animationZoomIn(this._zoom, mapZoom)) : this._zoom > mapZoom ? (this._animationStart(), 
                    this._animationZoomOut(this._zoom, mapZoom)) : this._moveEnd();
                },
                _getExpandedVisibleBounds: function() {
                    return this.options.removeOutsideVisibleBounds ? L.Browser.mobile ? this._checkBoundsMaxLat(this._map.getBounds()) : this._checkBoundsMaxLat(this._map.getBounds().pad(1)) : this._mapBoundsInfinite;
                },
                _checkBoundsMaxLat: function(bounds) {
                    var maxLat = this._maxLat;
                    return void 0 !== maxLat && (bounds.getNorth() >= maxLat && (bounds._northEast.lat = 1 / 0), 
                    bounds.getSouth() <= -maxLat && (bounds._southWest.lat = -1 / 0)), bounds;
                },
                _animationAddLayerNonAnimated: function(layer, newCluster) {
                    if (newCluster === layer) this._featureGroup.addLayer(layer); else if (2 === newCluster._childCount) {
                        newCluster._addToMap();
                        var markers = newCluster.getAllChildMarkers();
                        this._featureGroup.removeLayer(markers[0]), this._featureGroup.removeLayer(markers[1]);
                    } else newCluster._updateIcon();
                },
                _extractNonGroupLayers: function(group, output) {
                    var layer, layers = group.getLayers(), i = 0;
                    for (output = output || []; i < layers.length; i++) (layer = layers[i]) instanceof L.LayerGroup ? this._extractNonGroupLayers(layer, output) : output.push(layer);
                    return output;
                },
                _overrideMarkerIcon: function(layer) {
                    return layer.options.icon = this.options.iconCreateFunction({
                        getChildCount: function() {
                            return 1;
                        },
                        getAllChildMarkers: function() {
                            return [ layer ];
                        }
                    });
                }
            });
            L.MarkerClusterGroup.include({
                _mapBoundsInfinite: new L.LatLngBounds(new L.LatLng(-1 / 0, -1 / 0), new L.LatLng(1 / 0, 1 / 0))
            }), L.MarkerClusterGroup.include({
                _noAnimation: {
                    _animationStart: function() {},
                    _animationZoomIn: function(previousZoomLevel, newZoomLevel) {
                        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel), 
                        this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds()), 
                        this.fire("animationend");
                    },
                    _animationZoomOut: function(previousZoomLevel, newZoomLevel) {
                        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel), 
                        this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds()), 
                        this.fire("animationend");
                    },
                    _animationAddLayer: function(layer, newCluster) {
                        this._animationAddLayerNonAnimated(layer, newCluster);
                    }
                },
                _withAnimation: {
                    _animationStart: function() {
                        this._map._mapPane.className += " leaflet-cluster-anim", this._inZoomAnimation++;
                    },
                    _animationZoomIn: function(previousZoomLevel, newZoomLevel) {
                        var i, bounds = this._getExpandedVisibleBounds(), fg = this._featureGroup, minZoom = Math.floor(this._map.getMinZoom());
                        this._ignoreMove = !0, this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, (function(c) {
                            var m, startPos = c._latlng, markers = c._markers;
                            for (bounds.contains(startPos) || (startPos = null), c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel ? (fg.removeLayer(c), 
                            c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds)) : (c.clusterHide(), 
                            c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds)), i = markers.length - 1; i >= 0; i--) m = markers[i], 
                            bounds.contains(m._latlng) || fg.removeLayer(m);
                        })), this._forceLayout(), this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel), 
                        fg.eachLayer((function(n) {
                            n instanceof L.MarkerCluster || !n._icon || n.clusterShow();
                        })), this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, (function(c) {
                            c._recursivelyRestoreChildPositions(newZoomLevel);
                        })), this._ignoreMove = !1, this._enqueue((function() {
                            this._topClusterLevel._recursively(bounds, previousZoomLevel, minZoom, (function(c) {
                                fg.removeLayer(c), c.clusterShow();
                            })), this._animationEnd();
                        }));
                    },
                    _animationZoomOut: function(previousZoomLevel, newZoomLevel) {
                        this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel), 
                        this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds()), 
                        this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, Math.floor(this._map.getMinZoom()), previousZoomLevel, this._getExpandedVisibleBounds());
                    },
                    _animationAddLayer: function(layer, newCluster) {
                        var me = this, fg = this._featureGroup;
                        fg.addLayer(layer), newCluster !== layer && (newCluster._childCount > 2 ? (newCluster._updateIcon(), 
                        this._forceLayout(), this._animationStart(), layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng())), 
                        layer.clusterHide(), this._enqueue((function() {
                            fg.removeLayer(layer), layer.clusterShow(), me._animationEnd();
                        }))) : (this._forceLayout(), me._animationStart(), me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._zoom)));
                    }
                },
                _animationZoomOutSingle: function(cluster, previousZoomLevel, newZoomLevel) {
                    var bounds = this._getExpandedVisibleBounds(), minZoom = Math.floor(this._map.getMinZoom());
                    cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, minZoom, previousZoomLevel + 1, newZoomLevel);
                    var me = this;
                    this._forceLayout(), cluster._recursivelyBecomeVisible(bounds, newZoomLevel), this._enqueue((function() {
                        if (1 === cluster._childCount) {
                            var m = cluster._markers[0];
                            this._ignoreMove = !0, m.setLatLng(m.getLatLng()), this._ignoreMove = !1, m.clusterShow && m.clusterShow();
                        } else cluster._recursively(bounds, newZoomLevel, minZoom, (function(c) {
                            c._recursivelyRemoveChildrenFromMap(bounds, minZoom, previousZoomLevel + 1);
                        }));
                        me._animationEnd();
                    }));
                },
                _animationEnd: function() {
                    this._map && (this._map._mapPane.className = this._map._mapPane.className.replace(" leaflet-cluster-anim", "")), 
                    this._inZoomAnimation--, this.fire("animationend");
                },
                _forceLayout: function() {
                    L.Util.falseFn(document.body.offsetWidth);
                }
            }), L.markerClusterGroup = function(options) {
                return new L.MarkerClusterGroup(options);
            };
            var MarkerCluster = L.MarkerCluster = L.Marker.extend({
                options: L.Icon.prototype.options,
                initialize: function(group, zoom, a, b) {
                    L.Marker.prototype.initialize.call(this, a ? a._cLatLng || a.getLatLng() : new L.LatLng(0, 0), {
                        icon: this,
                        pane: group.options.clusterPane
                    }), this._group = group, this._zoom = zoom, this._markers = [], this._childClusters = [], 
                    this._childCount = 0, this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._bounds = new L.LatLngBounds, 
                    a && this._addChild(a), b && this._addChild(b);
                },
                getAllChildMarkers: function(storageArray, ignoreDraggedMarker) {
                    storageArray = storageArray || [];
                    for (var i = this._childClusters.length - 1; i >= 0; i--) this._childClusters[i].getAllChildMarkers(storageArray, ignoreDraggedMarker);
                    for (var j = this._markers.length - 1; j >= 0; j--) ignoreDraggedMarker && this._markers[j].__dragStart || storageArray.push(this._markers[j]);
                    return storageArray;
                },
                getChildCount: function() {
                    return this._childCount;
                },
                zoomToBounds: function(fitBoundsOptions) {
                    for (var i, childClusters = this._childClusters.slice(), map = this._group._map, boundsZoom = map.getBoundsZoom(this._bounds), zoom = this._zoom + 1, mapZoom = map.getZoom(); childClusters.length > 0 && boundsZoom > zoom; ) {
                        zoom++;
                        var newClusters = [];
                        for (i = 0; i < childClusters.length; i++) newClusters = newClusters.concat(childClusters[i]._childClusters);
                        childClusters = newClusters;
                    }
                    boundsZoom > zoom ? this._group._map.setView(this._latlng, zoom) : boundsZoom <= mapZoom ? this._group._map.setView(this._latlng, mapZoom + 1) : this._group._map.fitBounds(this._bounds, fitBoundsOptions);
                },
                getBounds: function() {
                    var bounds = new L.LatLngBounds;
                    return bounds.extend(this._bounds), bounds;
                },
                _updateIcon: function() {
                    this._iconNeedsUpdate = !0, this._icon && this.setIcon(this);
                },
                createIcon: function() {
                    return this._iconNeedsUpdate && (this._iconObj = this._group.options.iconCreateFunction(this), 
                    this._iconNeedsUpdate = !1), this._iconObj.createIcon();
                },
                createShadow: function() {
                    return this._iconObj.createShadow();
                },
                _addChild: function(new1, isNotificationFromChild) {
                    this._iconNeedsUpdate = !0, this._boundsNeedUpdate = !0, this._setClusterCenter(new1), 
                    new1 instanceof L.MarkerCluster ? (isNotificationFromChild || (this._childClusters.push(new1), 
                    new1.__parent = this), this._childCount += new1._childCount) : (isNotificationFromChild || this._markers.push(new1), 
                    this._childCount++), this.__parent && this.__parent._addChild(new1, !0);
                },
                _setClusterCenter: function(child) {
                    this._cLatLng || (this._cLatLng = child._cLatLng || child._latlng);
                },
                _resetBounds: function() {
                    var bounds = this._bounds;
                    bounds._southWest && (bounds._southWest.lat = 1 / 0, bounds._southWest.lng = 1 / 0), 
                    bounds._northEast && (bounds._northEast.lat = -1 / 0, bounds._northEast.lng = -1 / 0);
                },
                _recalculateBounds: function() {
                    var i, child, childLatLng, childCount, markers = this._markers, childClusters = this._childClusters, latSum = 0, lngSum = 0, totalCount = this._childCount;
                    if (0 !== totalCount) {
                        for (this._resetBounds(), i = 0; i < markers.length; i++) childLatLng = markers[i]._latlng, 
                        this._bounds.extend(childLatLng), latSum += childLatLng.lat, lngSum += childLatLng.lng;
                        for (i = 0; i < childClusters.length; i++) (child = childClusters[i])._boundsNeedUpdate && child._recalculateBounds(), 
                        this._bounds.extend(child._bounds), childLatLng = child._wLatLng, childCount = child._childCount, 
                        latSum += childLatLng.lat * childCount, lngSum += childLatLng.lng * childCount;
                        this._latlng = this._wLatLng = new L.LatLng(latSum / totalCount, lngSum / totalCount), 
                        this._boundsNeedUpdate = !1;
                    }
                },
                _addToMap: function(startPos) {
                    startPos && (this._backupLatlng = this._latlng, this.setLatLng(startPos)), this._group._featureGroup.addLayer(this);
                },
                _recursivelyAnimateChildrenIn: function(bounds, center, maxZoom) {
                    this._recursively(bounds, this._group._map.getMinZoom(), maxZoom - 1, (function(c) {
                        var i, m, markers = c._markers;
                        for (i = markers.length - 1; i >= 0; i--) (m = markers[i])._icon && (m._setPos(center), 
                        m.clusterHide());
                    }), (function(c) {
                        var j, cm, childClusters = c._childClusters;
                        for (j = childClusters.length - 1; j >= 0; j--) (cm = childClusters[j])._icon && (cm._setPos(center), 
                        cm.clusterHide());
                    }));
                },
                _recursivelyAnimateChildrenInAndAddSelfToMap: function(bounds, mapMinZoom, previousZoomLevel, newZoomLevel) {
                    this._recursively(bounds, newZoomLevel, mapMinZoom, (function(c) {
                        c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel), 
                        c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel ? (c.clusterShow(), 
                        c._recursivelyRemoveChildrenFromMap(bounds, mapMinZoom, previousZoomLevel)) : c.clusterHide(), 
                        c._addToMap();
                    }));
                },
                _recursivelyBecomeVisible: function(bounds, zoomLevel) {
                    this._recursively(bounds, this._group._map.getMinZoom(), zoomLevel, null, (function(c) {
                        c.clusterShow();
                    }));
                },
                _recursivelyAddChildrenToMap: function(startPos, zoomLevel, bounds) {
                    this._recursively(bounds, this._group._map.getMinZoom() - 1, zoomLevel, (function(c) {
                        if (zoomLevel !== c._zoom) for (var i = c._markers.length - 1; i >= 0; i--) {
                            var nm = c._markers[i];
                            bounds.contains(nm._latlng) && (startPos && (nm._backupLatlng = nm.getLatLng(), 
                            nm.setLatLng(startPos), nm.clusterHide && nm.clusterHide()), c._group._featureGroup.addLayer(nm));
                        }
                    }), (function(c) {
                        c._addToMap(startPos);
                    }));
                },
                _recursivelyRestoreChildPositions: function(zoomLevel) {
                    for (var i = this._markers.length - 1; i >= 0; i--) {
                        var nm = this._markers[i];
                        nm._backupLatlng && (nm.setLatLng(nm._backupLatlng), delete nm._backupLatlng);
                    }
                    if (zoomLevel - 1 === this._zoom) for (var j = this._childClusters.length - 1; j >= 0; j--) this._childClusters[j]._restorePosition(); else for (var k = this._childClusters.length - 1; k >= 0; k--) this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
                },
                _restorePosition: function() {
                    this._backupLatlng && (this.setLatLng(this._backupLatlng), delete this._backupLatlng);
                },
                _recursivelyRemoveChildrenFromMap: function(previousBounds, mapMinZoom, zoomLevel, exceptBounds) {
                    var m, i;
                    this._recursively(previousBounds, mapMinZoom - 1, zoomLevel - 1, (function(c) {
                        for (i = c._markers.length - 1; i >= 0; i--) m = c._markers[i], exceptBounds && exceptBounds.contains(m._latlng) || (c._group._featureGroup.removeLayer(m), 
                        m.clusterShow && m.clusterShow());
                    }), (function(c) {
                        for (i = c._childClusters.length - 1; i >= 0; i--) m = c._childClusters[i], exceptBounds && exceptBounds.contains(m._latlng) || (c._group._featureGroup.removeLayer(m), 
                        m.clusterShow && m.clusterShow());
                    }));
                },
                _recursively: function(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
                    var i, c, childClusters = this._childClusters, zoom = this._zoom;
                    if (zoomLevelToStart <= zoom && (runAtEveryLevel && runAtEveryLevel(this), runAtBottomLevel && zoom === zoomLevelToStop && runAtBottomLevel(this)), 
                    zoom < zoomLevelToStart || zoom < zoomLevelToStop) for (i = childClusters.length - 1; i >= 0; i--) (c = childClusters[i])._boundsNeedUpdate && c._recalculateBounds(), 
                    boundsToApplyTo.intersects(c._bounds) && c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
                },
                _isSingleParent: function() {
                    return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
                }
            });
            L.Marker.include({
                clusterHide: function() {
                    var backup = this.options.opacity;
                    return this.setOpacity(0), this.options.opacity = backup, this;
                },
                clusterShow: function() {
                    return this.setOpacity(this.options.opacity);
                }
            }), L.DistanceGrid = function(cellSize) {
                this._cellSize = cellSize, this._sqCellSize = cellSize * cellSize, this._grid = {}, 
                this._objectPoint = {};
            }, L.DistanceGrid.prototype = {
                addObject: function(obj, point) {
                    var x = this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {}, cell = row[x] = row[x] || [], stamp = L.Util.stamp(obj);
                    this._objectPoint[stamp] = point, cell.push(obj);
                },
                updateObject: function(obj, point) {
                    this.removeObject(obj), this.addObject(obj, point);
                },
                removeObject: function(obj, point) {
                    var i, len, x = this._getCoord(point.x), y = this._getCoord(point.y), grid = this._grid, row = grid[y] = grid[y] || {}, cell = row[x] = row[x] || [];
                    for (delete this._objectPoint[L.Util.stamp(obj)], i = 0, len = cell.length; i < len; i++) if (cell[i] === obj) return cell.splice(i, 1), 
                    1 === len && delete row[x], !0;
                },
                eachObject: function(fn, context) {
                    var i, j, k, len, row, cell, grid = this._grid;
                    for (i in grid) for (j in row = grid[i]) for (k = 0, len = (cell = row[j]).length; k < len; k++) fn.call(context, cell[k]) && (k--, 
                    len--);
                },
                getNearObject: function(point) {
                    var i, j, k, row, cell, len, obj, dist, x = this._getCoord(point.x), y = this._getCoord(point.y), objectPoint = this._objectPoint, closestDistSq = this._sqCellSize, closest = null;
                    for (i = y - 1; i <= y + 1; i++) if (row = this._grid[i]) for (j = x - 1; j <= x + 1; j++) if (cell = row[j]) for (k = 0, 
                    len = cell.length; k < len; k++) obj = cell[k], ((dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point)) < closestDistSq || dist <= closestDistSq && null === closest) && (closestDistSq = dist, 
                    closest = obj);
                    return closest;
                },
                _getCoord: function(x) {
                    var coord = Math.floor(x / this._cellSize);
                    return isFinite(coord) ? coord : x;
                },
                _sqDist: function(p, p2) {
                    var dx = p2.x - p.x, dy = p2.y - p.y;
                    return dx * dx + dy * dy;
                }
            }, L.QuickHull = {
                getDistant: function(cpt, bl) {
                    var vY = bl[1].lat - bl[0].lat;
                    return (bl[0].lng - bl[1].lng) * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng);
                },
                findMostDistantPointFromBaseLine: function(baseLine, latLngs) {
                    var i, pt, d, maxD = 0, maxPt = null, newPoints = [];
                    for (i = latLngs.length - 1; i >= 0; i--) pt = latLngs[i], (d = this.getDistant(pt, baseLine)) > 0 && (newPoints.push(pt), 
                    d > maxD && (maxD = d, maxPt = pt));
                    return {
                        maxPoint: maxPt,
                        newPoints
                    };
                },
                buildConvexHull: function(baseLine, latLngs) {
                    var convexHullBaseLines = [], t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);
                    return t.maxPoint ? convexHullBaseLines = (convexHullBaseLines = convexHullBaseLines.concat(this.buildConvexHull([ baseLine[0], t.maxPoint ], t.newPoints))).concat(this.buildConvexHull([ t.maxPoint, baseLine[1] ], t.newPoints)) : [ baseLine[0] ];
                },
                getConvexHull: function(latLngs) {
                    var i, maxLat = !1, minLat = !1, maxLng = !1, minLng = !1, maxLatPt = null, minLatPt = null, maxLngPt = null, minLngPt = null, maxPt = null, minPt = null;
                    for (i = latLngs.length - 1; i >= 0; i--) {
                        var pt = latLngs[i];
                        (!1 === maxLat || pt.lat > maxLat) && (maxLatPt = pt, maxLat = pt.lat), (!1 === minLat || pt.lat < minLat) && (minLatPt = pt, 
                        minLat = pt.lat), (!1 === maxLng || pt.lng > maxLng) && (maxLngPt = pt, maxLng = pt.lng), 
                        (!1 === minLng || pt.lng < minLng) && (minLngPt = pt, minLng = pt.lng);
                    }
                    return minLat !== maxLat ? (minPt = minLatPt, maxPt = maxLatPt) : (minPt = minLngPt, 
                    maxPt = maxLngPt), [].concat(this.buildConvexHull([ minPt, maxPt ], latLngs), this.buildConvexHull([ maxPt, minPt ], latLngs));
                }
            }, L.MarkerCluster.include({
                getConvexHull: function() {
                    var p, i, childMarkers = this.getAllChildMarkers(), points = [];
                    for (i = childMarkers.length - 1; i >= 0; i--) p = childMarkers[i].getLatLng(), 
                    points.push(p);
                    return L.QuickHull.getConvexHull(points);
                }
            }), L.MarkerCluster.include({
                _2PI: 2 * Math.PI,
                _circleFootSeparation: 25,
                _circleStartAngle: 0,
                _spiralFootSeparation: 28,
                _spiralLengthStart: 11,
                _spiralLengthFactor: 5,
                _circleSpiralSwitchover: 9,
                spiderfy: function() {
                    if (this._group._spiderfied !== this && !this._group._inZoomAnimation) {
                        var positions, childMarkers = this.getAllChildMarkers(null, !0), center = this._group._map.latLngToLayerPoint(this._latlng);
                        this._group._unspiderfy(), this._group._spiderfied = this, this._group.options.spiderfyShapePositions ? positions = this._group.options.spiderfyShapePositions(childMarkers.length, center) : childMarkers.length >= this._circleSpiralSwitchover ? positions = this._generatePointsSpiral(childMarkers.length, center) : (center.y += 10, 
                        positions = this._generatePointsCircle(childMarkers.length, center)), this._animationSpiderfy(childMarkers, positions);
                    }
                },
                unspiderfy: function(zoomDetails) {
                    this._group._inZoomAnimation || (this._animationUnspiderfy(zoomDetails), this._group._spiderfied = null);
                },
                _generatePointsCircle: function(count, centerPt) {
                    var i, angle, legLength = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count) / this._2PI, angleStep = this._2PI / count, res = [];
                    for (legLength = Math.max(legLength, 35), res.length = count, i = 0; i < count; i++) angle = this._circleStartAngle + i * angleStep, 
                    res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
                    return res;
                },
                _generatePointsSpiral: function(count, centerPt) {
                    var i, spiderfyDistanceMultiplier = this._group.options.spiderfyDistanceMultiplier, legLength = spiderfyDistanceMultiplier * this._spiralLengthStart, separation = spiderfyDistanceMultiplier * this._spiralFootSeparation, lengthFactor = spiderfyDistanceMultiplier * this._spiralLengthFactor * this._2PI, angle = 0, res = [];
                    for (res.length = count, i = count; i >= 0; i--) i < count && (res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round()), 
                    legLength += lengthFactor / (angle += separation / legLength + 5e-4 * i);
                    return res;
                },
                _noanimationUnspiderfy: function() {
                    var m, i, group = this._group, map = group._map, fg = group._featureGroup, childMarkers = this.getAllChildMarkers(null, !0);
                    for (group._ignoreMove = !0, this.setOpacity(1), i = childMarkers.length - 1; i >= 0; i--) m = childMarkers[i], 
                    fg.removeLayer(m), m._preSpiderfyLatlng && (m.setLatLng(m._preSpiderfyLatlng), delete m._preSpiderfyLatlng), 
                    m.setZIndexOffset && m.setZIndexOffset(0), m._spiderLeg && (map.removeLayer(m._spiderLeg), 
                    delete m._spiderLeg);
                    group.fire("unspiderfied", {
                        cluster: this,
                        markers: childMarkers
                    }), group._ignoreMove = !1, group._spiderfied = null;
                }
            }), L.MarkerClusterNonAnimated = L.MarkerCluster.extend({
                _animationSpiderfy: function(childMarkers, positions) {
                    var i, m, leg, newPos, group = this._group, map = group._map, fg = group._featureGroup, legOptions = this._group.options.spiderLegPolylineOptions;
                    for (group._ignoreMove = !0, i = 0; i < childMarkers.length; i++) newPos = map.layerPointToLatLng(positions[i]), 
                    m = childMarkers[i], leg = new L.Polyline([ this._latlng, newPos ], legOptions), 
                    map.addLayer(leg), m._spiderLeg = leg, m._preSpiderfyLatlng = m._latlng, m.setLatLng(newPos), 
                    m.setZIndexOffset && m.setZIndexOffset(1e6), fg.addLayer(m);
                    this.setOpacity(.3), group._ignoreMove = !1, group.fire("spiderfied", {
                        cluster: this,
                        markers: childMarkers
                    });
                },
                _animationUnspiderfy: function() {
                    this._noanimationUnspiderfy();
                }
            }), L.MarkerCluster.include({
                _animationSpiderfy: function(childMarkers, positions) {
                    var i, m, leg, legPath, legLength, newPos, me = this, group = this._group, map = group._map, fg = group._featureGroup, thisLayerLatLng = this._latlng, thisLayerPos = map.latLngToLayerPoint(thisLayerLatLng), svg = L.Path.SVG, legOptions = L.extend({}, this._group.options.spiderLegPolylineOptions), finalLegOpacity = legOptions.opacity;
                    for (void 0 === finalLegOpacity && (finalLegOpacity = L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity), 
                    svg ? (legOptions.opacity = 0, legOptions.className = (legOptions.className || "") + " leaflet-cluster-spider-leg") : legOptions.opacity = finalLegOpacity, 
                    group._ignoreMove = !0, i = 0; i < childMarkers.length; i++) m = childMarkers[i], 
                    newPos = map.layerPointToLatLng(positions[i]), leg = new L.Polyline([ thisLayerLatLng, newPos ], legOptions), 
                    map.addLayer(leg), m._spiderLeg = leg, svg && (legLength = (legPath = leg._path).getTotalLength() + .1, 
                    legPath.style.strokeDasharray = legLength, legPath.style.strokeDashoffset = legLength), 
                    m.setZIndexOffset && m.setZIndexOffset(1e6), m.clusterHide && m.clusterHide(), fg.addLayer(m), 
                    m._setPos && m._setPos(thisLayerPos);
                    for (group._forceLayout(), group._animationStart(), i = childMarkers.length - 1; i >= 0; i--) newPos = map.layerPointToLatLng(positions[i]), 
                    (m = childMarkers[i])._preSpiderfyLatlng = m._latlng, m.setLatLng(newPos), m.clusterShow && m.clusterShow(), 
                    svg && ((legPath = (leg = m._spiderLeg)._path).style.strokeDashoffset = 0, leg.setStyle({
                        opacity: finalLegOpacity
                    }));
                    this.setOpacity(.3), group._ignoreMove = !1, setTimeout((function() {
                        group._animationEnd(), group.fire("spiderfied", {
                            cluster: me,
                            markers: childMarkers
                        });
                    }), 200);
                },
                _animationUnspiderfy: function(zoomDetails) {
                    var m, i, leg, legPath, legLength, nonAnimatable, me = this, group = this._group, map = group._map, fg = group._featureGroup, thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng), childMarkers = this.getAllChildMarkers(null, !0), svg = L.Path.SVG;
                    for (group._ignoreMove = !0, group._animationStart(), this.setOpacity(1), i = childMarkers.length - 1; i >= 0; i--) (m = childMarkers[i])._preSpiderfyLatlng && (m.closePopup(), 
                    m.setLatLng(m._preSpiderfyLatlng), delete m._preSpiderfyLatlng, nonAnimatable = !0, 
                    m._setPos && (m._setPos(thisLayerPos), nonAnimatable = !1), m.clusterHide && (m.clusterHide(), 
                    nonAnimatable = !1), nonAnimatable && fg.removeLayer(m), svg && (legLength = (legPath = (leg = m._spiderLeg)._path).getTotalLength() + .1, 
                    legPath.style.strokeDashoffset = legLength, leg.setStyle({
                        opacity: 0
                    })));
                    group._ignoreMove = !1, setTimeout((function() {
                        var stillThereChildCount = 0;
                        for (i = childMarkers.length - 1; i >= 0; i--) (m = childMarkers[i])._spiderLeg && stillThereChildCount++;
                        for (i = childMarkers.length - 1; i >= 0; i--) (m = childMarkers[i])._spiderLeg && (m.clusterShow && m.clusterShow(), 
                        m.setZIndexOffset && m.setZIndexOffset(0), stillThereChildCount > 1 && fg.removeLayer(m), 
                        map.removeLayer(m._spiderLeg), delete m._spiderLeg);
                        group._animationEnd(), group.fire("unspiderfied", {
                            cluster: me,
                            markers: childMarkers
                        });
                    }), 200);
                }
            }), L.MarkerClusterGroup.include({
                _spiderfied: null,
                unspiderfy: function() {
                    this._unspiderfy.apply(this, arguments);
                },
                _spiderfierOnAdd: function() {
                    this._map.on("click", this._unspiderfyWrapper, this), this._map.options.zoomAnimation && this._map.on("zoomstart", this._unspiderfyZoomStart, this), 
                    this._map.on("zoomend", this._noanimationUnspiderfy, this), L.Browser.touch || this._map.getRenderer(this);
                },
                _spiderfierOnRemove: function() {
                    this._map.off("click", this._unspiderfyWrapper, this), this._map.off("zoomstart", this._unspiderfyZoomStart, this), 
                    this._map.off("zoomanim", this._unspiderfyZoomAnim, this), this._map.off("zoomend", this._noanimationUnspiderfy, this), 
                    this._noanimationUnspiderfy();
                },
                _unspiderfyZoomStart: function() {
                    this._map && this._map.on("zoomanim", this._unspiderfyZoomAnim, this);
                },
                _unspiderfyZoomAnim: function(zoomDetails) {
                    L.DomUtil.hasClass(this._map._mapPane, "leaflet-touching") || (this._map.off("zoomanim", this._unspiderfyZoomAnim, this), 
                    this._unspiderfy(zoomDetails));
                },
                _unspiderfyWrapper: function() {
                    this._unspiderfy();
                },
                _unspiderfy: function(zoomDetails) {
                    this._spiderfied && this._spiderfied.unspiderfy(zoomDetails);
                },
                _noanimationUnspiderfy: function() {
                    this._spiderfied && this._spiderfied._noanimationUnspiderfy();
                },
                _unspiderfyLayer: function(layer) {
                    layer._spiderLeg && (this._featureGroup.removeLayer(layer), layer.clusterShow && layer.clusterShow(), 
                    layer.setZIndexOffset && layer.setZIndexOffset(0), this._map.removeLayer(layer._spiderLeg), 
                    delete layer._spiderLeg);
                }
            }), L.MarkerClusterGroup.include({
                refreshClusters: function(layers) {
                    return layers ? layers instanceof L.MarkerClusterGroup ? layers = layers._topClusterLevel.getAllChildMarkers() : layers instanceof L.LayerGroup ? layers = layers._layers : layers instanceof L.MarkerCluster ? layers = layers.getAllChildMarkers() : layers instanceof L.Marker && (layers = [ layers ]) : layers = this._topClusterLevel.getAllChildMarkers(), 
                    this._flagParentsIconsNeedUpdate(layers), this._refreshClustersIcons(), this.options.singleMarkerMode && this._refreshSingleMarkerModeMarkers(layers), 
                    this;
                },
                _flagParentsIconsNeedUpdate: function(layers) {
                    var id, parent;
                    for (id in layers) for (parent = layers[id].__parent; parent; ) parent._iconNeedsUpdate = !0, 
                    parent = parent.__parent;
                },
                _refreshSingleMarkerModeMarkers: function(layers) {
                    var id, layer;
                    for (id in layers) layer = layers[id], this.hasLayer(layer) && layer.setIcon(this._overrideMarkerIcon(layer));
                }
            }), L.Marker.include({
                refreshIconOptions: function(options, directlyRefreshClusters) {
                    var icon = this.options.icon;
                    return L.setOptions(icon, options), this.setIcon(icon), directlyRefreshClusters && this.__parent && this.__parent._group.refreshClusters(this), 
                    this;
                }
            }), exports.MarkerClusterGroup = MarkerClusterGroup, exports.MarkerCluster = MarkerCluster, 
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
        }(exports);
    },
    541: function(__unused_webpack_module, exports) {
        !function(exports) {
            "use strict";
            var version = "1.9.4";
            function extend(dest) {
                var i, j, len, src;
                for (j = 1, len = arguments.length; j < len; j++) for (i in src = arguments[j]) dest[i] = src[i];
                return dest;
            }
            var create$2 = Object.create || function() {
                function F() {}
                return function(proto) {
                    return F.prototype = proto, new F;
                };
            }();
            function bind(fn, obj) {
                var slice = Array.prototype.slice;
                if (fn.bind) return fn.bind.apply(fn, slice.call(arguments, 1));
                var args = slice.call(arguments, 2);
                return function() {
                    return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
                };
            }
            var lastId = 0;
            function stamp(obj) {
                return "_leaflet_id" in obj || (obj._leaflet_id = ++lastId), obj._leaflet_id;
            }
            function throttle(fn, time, context) {
                var lock, args, wrapperFn, later;
                return later = function() {
                    lock = !1, args && (wrapperFn.apply(context, args), args = !1);
                }, wrapperFn = function() {
                    lock ? args = arguments : (fn.apply(context, arguments), setTimeout(later, time), 
                    lock = !0);
                }, wrapperFn;
            }
            function wrapNum(x, range, includeMax) {
                var max = range[1], min = range[0], d = max - min;
                return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
            }
            function falseFn() {
                return !1;
            }
            function formatNum(num, precision) {
                if (!1 === precision) return num;
                var pow = Math.pow(10, void 0 === precision ? 6 : precision);
                return Math.round(num * pow) / pow;
            }
            function trim(str) {
                return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
            }
            function splitWords(str) {
                return trim(str).split(/\s+/);
            }
            function setOptions(obj, options) {
                for (var i in Object.prototype.hasOwnProperty.call(obj, "options") || (obj.options = obj.options ? create$2(obj.options) : {}), 
                options) obj.options[i] = options[i];
                return obj.options;
            }
            function getParamString(obj, existingUrl, uppercase) {
                var params = [];
                for (var i in obj) params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + "=" + encodeURIComponent(obj[i]));
                return (existingUrl && -1 !== existingUrl.indexOf("?") ? "&" : "?") + params.join("&");
            }
            var templateRe = /\{ *([\w_ -]+) *\}/g;
            function template(str, data) {
                return str.replace(templateRe, (function(str, key) {
                    var value = data[key];
                    if (void 0 === value) throw new Error("No value provided for variable " + str);
                    return "function" == typeof value && (value = value(data)), value;
                }));
            }
            var isArray = Array.isArray || function(obj) {
                return "[object Array]" === Object.prototype.toString.call(obj);
            };
            function indexOf(array, el) {
                for (var i = 0; i < array.length; i++) if (array[i] === el) return i;
                return -1;
            }
            var emptyImageUrl = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
            function getPrefixed(name) {
                return window["webkit" + name] || window["moz" + name] || window["ms" + name];
            }
            var lastTime = 0;
            function timeoutDefer(fn) {
                var time = +new Date, timeToCall = Math.max(0, 16 - (time - lastTime));
                return lastTime = time + timeToCall, window.setTimeout(fn, timeToCall);
            }
            var requestFn = window.requestAnimationFrame || getPrefixed("RequestAnimationFrame") || timeoutDefer, cancelFn = window.cancelAnimationFrame || getPrefixed("CancelAnimationFrame") || getPrefixed("CancelRequestAnimationFrame") || function(id) {
                window.clearTimeout(id);
            };
            function requestAnimFrame(fn, context, immediate) {
                if (!immediate || requestFn !== timeoutDefer) return requestFn.call(window, bind(fn, context));
                fn.call(context);
            }
            function cancelAnimFrame(id) {
                id && cancelFn.call(window, id);
            }
            var Util = {
                __proto__: null,
                extend,
                create: create$2,
                bind,
                get lastId() {
                    return lastId;
                },
                stamp,
                throttle,
                wrapNum,
                falseFn,
                formatNum,
                trim,
                splitWords,
                setOptions,
                getParamString,
                template,
                isArray,
                indexOf,
                emptyImageUrl,
                requestFn,
                cancelFn,
                requestAnimFrame,
                cancelAnimFrame
            };
            function Class() {}
            function checkDeprecatedMixinEvents(includes) {
                if ("undefined" != typeof L && L && L.Mixin) {
                    includes = isArray(includes) ? includes : [ includes ];
                    for (var i = 0; i < includes.length; i++) includes[i] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack);
                }
            }
            Class.extend = function(props) {
                var NewClass = function() {
                    setOptions(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();
                }, parentProto = NewClass.__super__ = this.prototype, proto = create$2(parentProto);
                for (var i in proto.constructor = NewClass, NewClass.prototype = proto, this) Object.prototype.hasOwnProperty.call(this, i) && "prototype" !== i && "__super__" !== i && (NewClass[i] = this[i]);
                return props.statics && extend(NewClass, props.statics), props.includes && (checkDeprecatedMixinEvents(props.includes), 
                extend.apply(null, [ proto ].concat(props.includes))), extend(proto, props), delete proto.statics, 
                delete proto.includes, proto.options && (proto.options = parentProto.options ? create$2(parentProto.options) : {}, 
                extend(proto.options, props.options)), proto._initHooks = [], proto.callInitHooks = function() {
                    if (!this._initHooksCalled) {
                        parentProto.callInitHooks && parentProto.callInitHooks.call(this), this._initHooksCalled = !0;
                        for (var i = 0, len = proto._initHooks.length; i < len; i++) proto._initHooks[i].call(this);
                    }
                }, NewClass;
            }, Class.include = function(props) {
                var parentOptions = this.prototype.options;
                return extend(this.prototype, props), props.options && (this.prototype.options = parentOptions, 
                this.mergeOptions(props.options)), this;
            }, Class.mergeOptions = function(options) {
                return extend(this.prototype.options, options), this;
            }, Class.addInitHook = function(fn) {
                var args = Array.prototype.slice.call(arguments, 1), init = "function" == typeof fn ? fn : function() {
                    this[fn].apply(this, args);
                };
                return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(init), 
                this;
            };
            var Events = {
                on: function(types, fn, context) {
                    if ("object" == typeof types) for (var type in types) this._on(type, types[type], fn); else for (var i = 0, len = (types = splitWords(types)).length; i < len; i++) this._on(types[i], fn, context);
                    return this;
                },
                off: function(types, fn, context) {
                    if (arguments.length) if ("object" == typeof types) for (var type in types) this._off(type, types[type], fn); else {
                        types = splitWords(types);
                        for (var removeAll = 1 === arguments.length, i = 0, len = types.length; i < len; i++) removeAll ? this._off(types[i]) : this._off(types[i], fn, context);
                    } else delete this._events;
                    return this;
                },
                _on: function(type, fn, context, _once) {
                    if ("function" == typeof fn) {
                        if (!1 === this._listens(type, fn, context)) {
                            context === this && (context = void 0);
                            var newListener = {
                                fn,
                                ctx: context
                            };
                            _once && (newListener.once = !0), this._events = this._events || {}, this._events[type] = this._events[type] || [], 
                            this._events[type].push(newListener);
                        }
                    } else console.warn("wrong listener type: " + typeof fn);
                },
                _off: function(type, fn, context) {
                    var listeners, i, len;
                    if (this._events && (listeners = this._events[type])) if (1 !== arguments.length) if ("function" == typeof fn) {
                        var index = this._listens(type, fn, context);
                        if (!1 !== index) {
                            var listener = listeners[index];
                            this._firingCount && (listener.fn = falseFn, this._events[type] = listeners = listeners.slice()), 
                            listeners.splice(index, 1);
                        }
                    } else console.warn("wrong listener type: " + typeof fn); else {
                        if (this._firingCount) for (i = 0, len = listeners.length; i < len; i++) listeners[i].fn = falseFn;
                        delete this._events[type];
                    }
                },
                fire: function(type, data, propagate) {
                    if (!this.listens(type, propagate)) return this;
                    var event = extend({}, data, {
                        type,
                        target: this,
                        sourceTarget: data && data.sourceTarget || this
                    });
                    if (this._events) {
                        var listeners = this._events[type];
                        if (listeners) {
                            this._firingCount = this._firingCount + 1 || 1;
                            for (var i = 0, len = listeners.length; i < len; i++) {
                                var l = listeners[i], fn = l.fn;
                                l.once && this.off(type, fn, l.ctx), fn.call(l.ctx || this, event);
                            }
                            this._firingCount--;
                        }
                    }
                    return propagate && this._propagateEvent(event), this;
                },
                listens: function(type, fn, context, propagate) {
                    "string" != typeof type && console.warn('"string" type argument expected');
                    var _fn = fn;
                    "function" != typeof fn && (propagate = !!fn, _fn = void 0, context = void 0);
                    var listeners = this._events && this._events[type];
                    if (listeners && listeners.length && !1 !== this._listens(type, _fn, context)) return !0;
                    if (propagate) for (var id in this._eventParents) if (this._eventParents[id].listens(type, fn, context, propagate)) return !0;
                    return !1;
                },
                _listens: function(type, fn, context) {
                    if (!this._events) return !1;
                    var listeners = this._events[type] || [];
                    if (!fn) return !!listeners.length;
                    context === this && (context = void 0);
                    for (var i = 0, len = listeners.length; i < len; i++) if (listeners[i].fn === fn && listeners[i].ctx === context) return i;
                    return !1;
                },
                once: function(types, fn, context) {
                    if ("object" == typeof types) for (var type in types) this._on(type, types[type], fn, !0); else for (var i = 0, len = (types = splitWords(types)).length; i < len; i++) this._on(types[i], fn, context, !0);
                    return this;
                },
                addEventParent: function(obj) {
                    return this._eventParents = this._eventParents || {}, this._eventParents[stamp(obj)] = obj, 
                    this;
                },
                removeEventParent: function(obj) {
                    return this._eventParents && delete this._eventParents[stamp(obj)], this;
                },
                _propagateEvent: function(e) {
                    for (var id in this._eventParents) this._eventParents[id].fire(e.type, extend({
                        layer: e.target,
                        propagatedFrom: e.target
                    }, e), !0);
                }
            };
            Events.addEventListener = Events.on, Events.removeEventListener = Events.clearAllEventListeners = Events.off, 
            Events.addOneTimeEventListener = Events.once, Events.fireEvent = Events.fire, Events.hasEventListeners = Events.listens;
            var Evented = Class.extend(Events);
            function Point(x, y, round) {
                this.x = round ? Math.round(x) : x, this.y = round ? Math.round(y) : y;
            }
            var trunc = Math.trunc || function(v) {
                return v > 0 ? Math.floor(v) : Math.ceil(v);
            };
            function toPoint(x, y, round) {
                return x instanceof Point ? x : isArray(x) ? new Point(x[0], x[1]) : null == x ? x : "object" == typeof x && "x" in x && "y" in x ? new Point(x.x, x.y) : new Point(x, y, round);
            }
            function Bounds(a, b) {
                if (a) for (var points = b ? [ a, b ] : a, i = 0, len = points.length; i < len; i++) this.extend(points[i]);
            }
            function toBounds(a, b) {
                return !a || a instanceof Bounds ? a : new Bounds(a, b);
            }
            function LatLngBounds(corner1, corner2) {
                if (corner1) for (var latlngs = corner2 ? [ corner1, corner2 ] : corner1, i = 0, len = latlngs.length; i < len; i++) this.extend(latlngs[i]);
            }
            function toLatLngBounds(a, b) {
                return a instanceof LatLngBounds ? a : new LatLngBounds(a, b);
            }
            function LatLng(lat, lng, alt) {
                if (isNaN(lat) || isNaN(lng)) throw new Error("Invalid LatLng object: (" + lat + ", " + lng + ")");
                this.lat = +lat, this.lng = +lng, void 0 !== alt && (this.alt = +alt);
            }
            function toLatLng(a, b, c) {
                return a instanceof LatLng ? a : isArray(a) && "object" != typeof a[0] ? 3 === a.length ? new LatLng(a[0], a[1], a[2]) : 2 === a.length ? new LatLng(a[0], a[1]) : null : null == a ? a : "object" == typeof a && "lat" in a ? new LatLng(a.lat, "lng" in a ? a.lng : a.lon, a.alt) : void 0 === b ? null : new LatLng(a, b, c);
            }
            Point.prototype = {
                clone: function() {
                    return new Point(this.x, this.y);
                },
                add: function(point) {
                    return this.clone()._add(toPoint(point));
                },
                _add: function(point) {
                    return this.x += point.x, this.y += point.y, this;
                },
                subtract: function(point) {
                    return this.clone()._subtract(toPoint(point));
                },
                _subtract: function(point) {
                    return this.x -= point.x, this.y -= point.y, this;
                },
                divideBy: function(num) {
                    return this.clone()._divideBy(num);
                },
                _divideBy: function(num) {
                    return this.x /= num, this.y /= num, this;
                },
                multiplyBy: function(num) {
                    return this.clone()._multiplyBy(num);
                },
                _multiplyBy: function(num) {
                    return this.x *= num, this.y *= num, this;
                },
                scaleBy: function(point) {
                    return new Point(this.x * point.x, this.y * point.y);
                },
                unscaleBy: function(point) {
                    return new Point(this.x / point.x, this.y / point.y);
                },
                round: function() {
                    return this.clone()._round();
                },
                _round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
                },
                floor: function() {
                    return this.clone()._floor();
                },
                _floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
                },
                ceil: function() {
                    return this.clone()._ceil();
                },
                _ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
                },
                trunc: function() {
                    return this.clone()._trunc();
                },
                _trunc: function() {
                    return this.x = trunc(this.x), this.y = trunc(this.y), this;
                },
                distanceTo: function(point) {
                    var x = (point = toPoint(point)).x - this.x, y = point.y - this.y;
                    return Math.sqrt(x * x + y * y);
                },
                equals: function(point) {
                    return (point = toPoint(point)).x === this.x && point.y === this.y;
                },
                contains: function(point) {
                    return point = toPoint(point), Math.abs(point.x) <= Math.abs(this.x) && Math.abs(point.y) <= Math.abs(this.y);
                },
                toString: function() {
                    return "Point(" + formatNum(this.x) + ", " + formatNum(this.y) + ")";
                }
            }, Bounds.prototype = {
                extend: function(obj) {
                    var min2, max2;
                    if (!obj) return this;
                    if (obj instanceof Point || "number" == typeof obj[0] || "x" in obj) min2 = max2 = toPoint(obj); else if (min2 = (obj = toBounds(obj)).min, 
                    max2 = obj.max, !min2 || !max2) return this;
                    return this.min || this.max ? (this.min.x = Math.min(min2.x, this.min.x), this.max.x = Math.max(max2.x, this.max.x), 
                    this.min.y = Math.min(min2.y, this.min.y), this.max.y = Math.max(max2.y, this.max.y)) : (this.min = min2.clone(), 
                    this.max = max2.clone()), this;
                },
                getCenter: function(round) {
                    return toPoint((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);
                },
                getBottomLeft: function() {
                    return toPoint(this.min.x, this.max.y);
                },
                getTopRight: function() {
                    return toPoint(this.max.x, this.min.y);
                },
                getTopLeft: function() {
                    return this.min;
                },
                getBottomRight: function() {
                    return this.max;
                },
                getSize: function() {
                    return this.max.subtract(this.min);
                },
                contains: function(obj) {
                    var min, max;
                    return (obj = "number" == typeof obj[0] || obj instanceof Point ? toPoint(obj) : toBounds(obj)) instanceof Bounds ? (min = obj.min, 
                    max = obj.max) : min = max = obj, min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;
                },
                intersects: function(bounds) {
                    bounds = toBounds(bounds);
                    var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xIntersects = max2.x >= min.x && min2.x <= max.x, yIntersects = max2.y >= min.y && min2.y <= max.y;
                    return xIntersects && yIntersects;
                },
                overlaps: function(bounds) {
                    bounds = toBounds(bounds);
                    var min = this.min, max = this.max, min2 = bounds.min, max2 = bounds.max, xOverlaps = max2.x > min.x && min2.x < max.x, yOverlaps = max2.y > min.y && min2.y < max.y;
                    return xOverlaps && yOverlaps;
                },
                isValid: function() {
                    return !(!this.min || !this.max);
                },
                pad: function(bufferRatio) {
                    var min = this.min, max = this.max, heightBuffer = Math.abs(min.x - max.x) * bufferRatio, widthBuffer = Math.abs(min.y - max.y) * bufferRatio;
                    return toBounds(toPoint(min.x - heightBuffer, min.y - widthBuffer), toPoint(max.x + heightBuffer, max.y + widthBuffer));
                },
                equals: function(bounds) {
                    return !!bounds && (bounds = toBounds(bounds), this.min.equals(bounds.getTopLeft()) && this.max.equals(bounds.getBottomRight()));
                }
            }, LatLngBounds.prototype = {
                extend: function(obj) {
                    var sw2, ne2, sw = this._southWest, ne = this._northEast;
                    if (obj instanceof LatLng) sw2 = obj, ne2 = obj; else {
                        if (!(obj instanceof LatLngBounds)) return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
                        if (sw2 = obj._southWest, ne2 = obj._northEast, !sw2 || !ne2) return this;
                    }
                    return sw || ne ? (sw.lat = Math.min(sw2.lat, sw.lat), sw.lng = Math.min(sw2.lng, sw.lng), 
                    ne.lat = Math.max(ne2.lat, ne.lat), ne.lng = Math.max(ne2.lng, ne.lng)) : (this._southWest = new LatLng(sw2.lat, sw2.lng), 
                    this._northEast = new LatLng(ne2.lat, ne2.lng)), this;
                },
                pad: function(bufferRatio) {
                    var sw = this._southWest, ne = this._northEast, heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio, widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;
                    return new LatLngBounds(new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer), new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
                },
                getCenter: function() {
                    return new LatLng((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);
                },
                getSouthWest: function() {
                    return this._southWest;
                },
                getNorthEast: function() {
                    return this._northEast;
                },
                getNorthWest: function() {
                    return new LatLng(this.getNorth(), this.getWest());
                },
                getSouthEast: function() {
                    return new LatLng(this.getSouth(), this.getEast());
                },
                getWest: function() {
                    return this._southWest.lng;
                },
                getSouth: function() {
                    return this._southWest.lat;
                },
                getEast: function() {
                    return this._northEast.lng;
                },
                getNorth: function() {
                    return this._northEast.lat;
                },
                contains: function(obj) {
                    obj = "number" == typeof obj[0] || obj instanceof LatLng || "lat" in obj ? toLatLng(obj) : toLatLngBounds(obj);
                    var sw2, ne2, sw = this._southWest, ne = this._northEast;
                    return obj instanceof LatLngBounds ? (sw2 = obj.getSouthWest(), ne2 = obj.getNorthEast()) : sw2 = ne2 = obj, 
                    sw2.lat >= sw.lat && ne2.lat <= ne.lat && sw2.lng >= sw.lng && ne2.lng <= ne.lng;
                },
                intersects: function(bounds) {
                    bounds = toLatLngBounds(bounds);
                    var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latIntersects = ne2.lat >= sw.lat && sw2.lat <= ne.lat, lngIntersects = ne2.lng >= sw.lng && sw2.lng <= ne.lng;
                    return latIntersects && lngIntersects;
                },
                overlaps: function(bounds) {
                    bounds = toLatLngBounds(bounds);
                    var sw = this._southWest, ne = this._northEast, sw2 = bounds.getSouthWest(), ne2 = bounds.getNorthEast(), latOverlaps = ne2.lat > sw.lat && sw2.lat < ne.lat, lngOverlaps = ne2.lng > sw.lng && sw2.lng < ne.lng;
                    return latOverlaps && lngOverlaps;
                },
                toBBoxString: function() {
                    return [ this.getWest(), this.getSouth(), this.getEast(), this.getNorth() ].join(",");
                },
                equals: function(bounds, maxMargin) {
                    return !!bounds && (bounds = toLatLngBounds(bounds), this._southWest.equals(bounds.getSouthWest(), maxMargin) && this._northEast.equals(bounds.getNorthEast(), maxMargin));
                },
                isValid: function() {
                    return !(!this._southWest || !this._northEast);
                }
            }, LatLng.prototype = {
                equals: function(obj, maxMargin) {
                    return !!obj && (obj = toLatLng(obj), Math.max(Math.abs(this.lat - obj.lat), Math.abs(this.lng - obj.lng)) <= (void 0 === maxMargin ? 1e-9 : maxMargin));
                },
                toString: function(precision) {
                    return "LatLng(" + formatNum(this.lat, precision) + ", " + formatNum(this.lng, precision) + ")";
                },
                distanceTo: function(other) {
                    return Earth.distance(this, toLatLng(other));
                },
                wrap: function() {
                    return Earth.wrapLatLng(this);
                },
                toBounds: function(sizeInMeters) {
                    var latAccuracy = 180 * sizeInMeters / 40075017, lngAccuracy = latAccuracy / Math.cos(Math.PI / 180 * this.lat);
                    return toLatLngBounds([ this.lat - latAccuracy, this.lng - lngAccuracy ], [ this.lat + latAccuracy, this.lng + lngAccuracy ]);
                },
                clone: function() {
                    return new LatLng(this.lat, this.lng, this.alt);
                }
            };
            var d, CRS = {
                latLngToPoint: function(latlng, zoom) {
                    var projectedPoint = this.projection.project(latlng), scale = this.scale(zoom);
                    return this.transformation._transform(projectedPoint, scale);
                },
                pointToLatLng: function(point, zoom) {
                    var scale = this.scale(zoom), untransformedPoint = this.transformation.untransform(point, scale);
                    return this.projection.unproject(untransformedPoint);
                },
                project: function(latlng) {
                    return this.projection.project(latlng);
                },
                unproject: function(point) {
                    return this.projection.unproject(point);
                },
                scale: function(zoom) {
                    return 256 * Math.pow(2, zoom);
                },
                zoom: function(scale) {
                    return Math.log(scale / 256) / Math.LN2;
                },
                getProjectedBounds: function(zoom) {
                    if (this.infinite) return null;
                    var b = this.projection.bounds, s = this.scale(zoom);
                    return new Bounds(this.transformation.transform(b.min, s), this.transformation.transform(b.max, s));
                },
                infinite: !1,
                wrapLatLng: function(latlng) {
                    var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, !0) : latlng.lng;
                    return new LatLng(this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, !0) : latlng.lat, lng, latlng.alt);
                },
                wrapLatLngBounds: function(bounds) {
                    var center = bounds.getCenter(), newCenter = this.wrapLatLng(center), latShift = center.lat - newCenter.lat, lngShift = center.lng - newCenter.lng;
                    if (0 === latShift && 0 === lngShift) return bounds;
                    var sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
                    return new LatLngBounds(new LatLng(sw.lat - latShift, sw.lng - lngShift), new LatLng(ne.lat - latShift, ne.lng - lngShift));
                }
            }, Earth = extend({}, CRS, {
                wrapLng: [ -180, 180 ],
                R: 6371e3,
                distance: function(latlng1, latlng2) {
                    var rad = Math.PI / 180, lat1 = latlng1.lat * rad, lat2 = latlng2.lat * rad, sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2), sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2), a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon, c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                    return this.R * c;
                }
            }), earthRadius = 6378137, SphericalMercator = {
                R: earthRadius,
                MAX_LATITUDE: 85.0511287798,
                project: function(latlng) {
                    var d = Math.PI / 180, max = this.MAX_LATITUDE, lat = Math.max(Math.min(max, latlng.lat), -max), sin = Math.sin(lat * d);
                    return new Point(this.R * latlng.lng * d, this.R * Math.log((1 + sin) / (1 - sin)) / 2);
                },
                unproject: function(point) {
                    var d = 180 / Math.PI;
                    return new LatLng((2 * Math.atan(Math.exp(point.y / this.R)) - Math.PI / 2) * d, point.x * d / this.R);
                },
                bounds: (d = earthRadius * Math.PI, new Bounds([ -d, -d ], [ d, d ]))
            };
            function Transformation(a, b, c, d) {
                if (isArray(a)) return this._a = a[0], this._b = a[1], this._c = a[2], void (this._d = a[3]);
                this._a = a, this._b = b, this._c = c, this._d = d;
            }
            function toTransformation(a, b, c, d) {
                return new Transformation(a, b, c, d);
            }
            Transformation.prototype = {
                transform: function(point, scale) {
                    return this._transform(point.clone(), scale);
                },
                _transform: function(point, scale) {
                    return scale = scale || 1, point.x = scale * (this._a * point.x + this._b), point.y = scale * (this._c * point.y + this._d), 
                    point;
                },
                untransform: function(point, scale) {
                    return scale = scale || 1, new Point((point.x / scale - this._b) / this._a, (point.y / scale - this._d) / this._c);
                }
            };
            var EPSG3857 = extend({}, Earth, {
                code: "EPSG:3857",
                projection: SphericalMercator,
                transformation: function() {
                    var scale = .5 / (Math.PI * SphericalMercator.R);
                    return toTransformation(scale, .5, -scale, .5);
                }()
            }), EPSG900913 = extend({}, EPSG3857, {
                code: "EPSG:900913"
            });
            function svgCreate(name) {
                return document.createElementNS("http://www.w3.org/2000/svg", name);
            }
            function pointsToPath(rings, closed) {
                var i, j, len, len2, points, p, str = "";
                for (i = 0, len = rings.length; i < len; i++) {
                    for (j = 0, len2 = (points = rings[i]).length; j < len2; j++) str += (j ? "L" : "M") + (p = points[j]).x + " " + p.y;
                    str += closed ? Browser.svg ? "z" : "x" : "";
                }
                return str || "M0 0";
            }
            var div, style = document.documentElement.style, ie = "ActiveXObject" in window, ielt9 = ie && !document.addEventListener, edge = "msLaunchUri" in navigator && !("documentMode" in document), webkit = userAgentContains("webkit"), android = userAgentContains("android"), android23 = userAgentContains("android 2") || userAgentContains("android 3"), webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), androidStock = android && userAgentContains("Google") && webkitVer < 537 && !("AudioNode" in window), opera = !!window.opera, chrome = !edge && userAgentContains("chrome"), gecko = userAgentContains("gecko") && !webkit && !opera && !ie, safari = !chrome && userAgentContains("safari"), phantom = userAgentContains("phantom"), opera12 = "OTransition" in style, win = 0 === navigator.platform.indexOf("Win"), ie3d = ie && "transition" in style, webkit3d = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !android23, gecko3d = "MozPerspective" in style, any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom, mobile = "undefined" != typeof orientation || userAgentContains("mobile"), mobileWebkit = mobile && webkit, mobileWebkit3d = mobile && webkit3d, msPointer = !window.PointerEvent && window.MSPointerEvent, pointer = !(!window.PointerEvent && !msPointer), touchNative = "ontouchstart" in window || !!window.TouchEvent, touch = !window.L_NO_TOUCH && (touchNative || pointer), mobileOpera = mobile && opera, mobileGecko = mobile && gecko, retina = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1, passiveEvents = function() {
                var supportsPassiveOption = !1;
                try {
                    var opts = Object.defineProperty({}, "passive", {
                        get: function() {
                            supportsPassiveOption = !0;
                        }
                    });
                    window.addEventListener("testPassiveEventSupport", falseFn, opts), window.removeEventListener("testPassiveEventSupport", falseFn, opts);
                } catch (e) {}
                return supportsPassiveOption;
            }(), canvas$1 = !!document.createElement("canvas").getContext, svg$1 = !(!document.createElementNS || !svgCreate("svg").createSVGRect), inlineSvg = !!svg$1 && ((div = document.createElement("div")).innerHTML = "<svg/>", 
            "http://www.w3.org/2000/svg" === (div.firstChild && div.firstChild.namespaceURI)), vml = !svg$1 && function() {
                try {
                    var div = document.createElement("div");
                    div.innerHTML = '<v:shape adj="1"/>';
                    var shape = div.firstChild;
                    return shape.style.behavior = "url(#default#VML)", shape && "object" == typeof shape.adj;
                } catch (e) {
                    return !1;
                }
            }(), mac = 0 === navigator.platform.indexOf("Mac"), linux = 0 === navigator.platform.indexOf("Linux");
            function userAgentContains(str) {
                return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
            }
            var Browser = {
                ie,
                ielt9,
                edge,
                webkit,
                android,
                android23,
                androidStock,
                opera,
                chrome,
                gecko,
                safari,
                phantom,
                opera12,
                win,
                ie3d,
                webkit3d,
                gecko3d,
                any3d,
                mobile,
                mobileWebkit,
                mobileWebkit3d,
                msPointer,
                pointer,
                touch,
                touchNative,
                mobileOpera,
                mobileGecko,
                retina,
                passiveEvents,
                canvas: canvas$1,
                svg: svg$1,
                vml,
                inlineSvg,
                mac,
                linux
            }, POINTER_DOWN = Browser.msPointer ? "MSPointerDown" : "pointerdown", POINTER_MOVE = Browser.msPointer ? "MSPointerMove" : "pointermove", POINTER_UP = Browser.msPointer ? "MSPointerUp" : "pointerup", POINTER_CANCEL = Browser.msPointer ? "MSPointerCancel" : "pointercancel", pEvent = {
                touchstart: POINTER_DOWN,
                touchmove: POINTER_MOVE,
                touchend: POINTER_UP,
                touchcancel: POINTER_CANCEL
            }, handle = {
                touchstart: _onPointerStart,
                touchmove: _handlePointer,
                touchend: _handlePointer,
                touchcancel: _handlePointer
            }, _pointers = {}, _pointerDocListener = !1;
            function addPointerListener(obj, type, handler) {
                return "touchstart" === type && _addPointerDocListener(), handle[type] ? (handler = handle[type].bind(this, handler), 
                obj.addEventListener(pEvent[type], handler, !1), handler) : (console.warn("wrong event specified:", type), 
                falseFn);
            }
            function removePointerListener(obj, type, handler) {
                pEvent[type] ? obj.removeEventListener(pEvent[type], handler, !1) : console.warn("wrong event specified:", type);
            }
            function _globalPointerDown(e) {
                _pointers[e.pointerId] = e;
            }
            function _globalPointerMove(e) {
                _pointers[e.pointerId] && (_pointers[e.pointerId] = e);
            }
            function _globalPointerUp(e) {
                delete _pointers[e.pointerId];
            }
            function _addPointerDocListener() {
                _pointerDocListener || (document.addEventListener(POINTER_DOWN, _globalPointerDown, !0), 
                document.addEventListener(POINTER_MOVE, _globalPointerMove, !0), document.addEventListener(POINTER_UP, _globalPointerUp, !0), 
                document.addEventListener(POINTER_CANCEL, _globalPointerUp, !0), _pointerDocListener = !0);
            }
            function _handlePointer(handler, e) {
                if (e.pointerType !== (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
                    for (var i in e.touches = [], _pointers) e.touches.push(_pointers[i]);
                    e.changedTouches = [ e ], handler(e);
                }
            }
            function _onPointerStart(handler, e) {
                e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH && preventDefault(e), 
                _handlePointer(handler, e);
            }
            function makeDblclick(event) {
                var prop, i, newEvent = {};
                for (i in event) prop = event[i], newEvent[i] = prop && prop.bind ? prop.bind(event) : prop;
                return event = newEvent, newEvent.type = "dblclick", newEvent.detail = 2, newEvent.isTrusted = !1, 
                newEvent._simulated = !0, newEvent;
            }
            var delay = 200;
            function addDoubleTapListener(obj, handler) {
                obj.addEventListener("dblclick", handler);
                var detail, last = 0;
                function simDblclick(e) {
                    if (1 === e.detail) {
                        if ("mouse" !== e.pointerType && (!e.sourceCapabilities || e.sourceCapabilities.firesTouchEvents)) {
                            var path = getPropagationPath(e);
                            if (!path.some((function(el) {
                                return el instanceof HTMLLabelElement && el.attributes.for;
                            })) || path.some((function(el) {
                                return el instanceof HTMLInputElement || el instanceof HTMLSelectElement;
                            }))) {
                                var now = Date.now();
                                now - last <= delay ? 2 == ++detail && handler(makeDblclick(e)) : detail = 1, last = now;
                            }
                        }
                    } else detail = e.detail;
                }
                return obj.addEventListener("click", simDblclick), {
                    dblclick: handler,
                    simDblclick
                };
            }
            function removeDoubleTapListener(obj, handlers) {
                obj.removeEventListener("dblclick", handlers.dblclick), obj.removeEventListener("click", handlers.simDblclick);
            }
            var disableTextSelection, enableTextSelection, _userSelect, _outlineElement, _outlineStyle, TRANSFORM = testProp([ "transform", "webkitTransform", "OTransform", "MozTransform", "msTransform" ]), TRANSITION = testProp([ "webkitTransition", "transition", "OTransition", "MozTransition", "msTransition" ]), TRANSITION_END = "webkitTransition" === TRANSITION || "OTransition" === TRANSITION ? TRANSITION + "End" : "transitionend";
            function get(id) {
                return "string" == typeof id ? document.getElementById(id) : id;
            }
            function getStyle(el, style) {
                var value = el.style[style] || el.currentStyle && el.currentStyle[style];
                if ((!value || "auto" === value) && document.defaultView) {
                    var css = document.defaultView.getComputedStyle(el, null);
                    value = css ? css[style] : null;
                }
                return "auto" === value ? null : value;
            }
            function create$1(tagName, className, container) {
                var el = document.createElement(tagName);
                return el.className = className || "", container && container.appendChild(el), el;
            }
            function remove(el) {
                var parent = el.parentNode;
                parent && parent.removeChild(el);
            }
            function empty(el) {
                for (;el.firstChild; ) el.removeChild(el.firstChild);
            }
            function toFront(el) {
                var parent = el.parentNode;
                parent && parent.lastChild !== el && parent.appendChild(el);
            }
            function toBack(el) {
                var parent = el.parentNode;
                parent && parent.firstChild !== el && parent.insertBefore(el, parent.firstChild);
            }
            function hasClass(el, name) {
                if (void 0 !== el.classList) return el.classList.contains(name);
                var className = getClass(el);
                return className.length > 0 && new RegExp("(^|\\s)" + name + "(\\s|$)").test(className);
            }
            function addClass(el, name) {
                if (void 0 !== el.classList) for (var classes = splitWords(name), i = 0, len = classes.length; i < len; i++) el.classList.add(classes[i]); else if (!hasClass(el, name)) {
                    var className = getClass(el);
                    setClass(el, (className ? className + " " : "") + name);
                }
            }
            function removeClass(el, name) {
                void 0 !== el.classList ? el.classList.remove(name) : setClass(el, trim((" " + getClass(el) + " ").replace(" " + name + " ", " ")));
            }
            function setClass(el, name) {
                void 0 === el.className.baseVal ? el.className = name : el.className.baseVal = name;
            }
            function getClass(el) {
                return el.correspondingElement && (el = el.correspondingElement), void 0 === el.className.baseVal ? el.className : el.className.baseVal;
            }
            function setOpacity(el, value) {
                "opacity" in el.style ? el.style.opacity = value : "filter" in el.style && _setOpacityIE(el, value);
            }
            function _setOpacityIE(el, value) {
                var filter = !1, filterName = "DXImageTransform.Microsoft.Alpha";
                try {
                    filter = el.filters.item(filterName);
                } catch (e) {
                    if (1 === value) return;
                }
                value = Math.round(100 * value), filter ? (filter.Enabled = 100 !== value, filter.Opacity = value) : el.style.filter += " progid:" + filterName + "(opacity=" + value + ")";
            }
            function testProp(props) {
                for (var style = document.documentElement.style, i = 0; i < props.length; i++) if (props[i] in style) return props[i];
                return !1;
            }
            function setTransform(el, offset, scale) {
                var pos = offset || new Point(0, 0);
                el.style[TRANSFORM] = (Browser.ie3d ? "translate(" + pos.x + "px," + pos.y + "px)" : "translate3d(" + pos.x + "px," + pos.y + "px,0)") + (scale ? " scale(" + scale + ")" : "");
            }
            function setPosition(el, point) {
                el._leaflet_pos = point, Browser.any3d ? setTransform(el, point) : (el.style.left = point.x + "px", 
                el.style.top = point.y + "px");
            }
            function getPosition(el) {
                return el._leaflet_pos || new Point(0, 0);
            }
            if ("onselectstart" in document) disableTextSelection = function() {
                on(window, "selectstart", preventDefault);
            }, enableTextSelection = function() {
                off(window, "selectstart", preventDefault);
            }; else {
                var userSelectProperty = testProp([ "userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect" ]);
                disableTextSelection = function() {
                    if (userSelectProperty) {
                        var style = document.documentElement.style;
                        _userSelect = style[userSelectProperty], style[userSelectProperty] = "none";
                    }
                }, enableTextSelection = function() {
                    userSelectProperty && (document.documentElement.style[userSelectProperty] = _userSelect, 
                    _userSelect = void 0);
                };
            }
            function disableImageDrag() {
                on(window, "dragstart", preventDefault);
            }
            function enableImageDrag() {
                off(window, "dragstart", preventDefault);
            }
            function preventOutline(element) {
                for (;-1 === element.tabIndex; ) element = element.parentNode;
                element.style && (restoreOutline(), _outlineElement = element, _outlineStyle = element.style.outlineStyle, 
                element.style.outlineStyle = "none", on(window, "keydown", restoreOutline));
            }
            function restoreOutline() {
                _outlineElement && (_outlineElement.style.outlineStyle = _outlineStyle, _outlineElement = void 0, 
                _outlineStyle = void 0, off(window, "keydown", restoreOutline));
            }
            function getSizedParentNode(element) {
                do {
                    element = element.parentNode;
                } while (!(element.offsetWidth && element.offsetHeight || element === document.body));
                return element;
            }
            function getScale(element) {
                var rect = element.getBoundingClientRect();
                return {
                    x: rect.width / element.offsetWidth || 1,
                    y: rect.height / element.offsetHeight || 1,
                    boundingClientRect: rect
                };
            }
            var DomUtil = {
                __proto__: null,
                TRANSFORM,
                TRANSITION,
                TRANSITION_END,
                get,
                getStyle,
                create: create$1,
                remove,
                empty,
                toFront,
                toBack,
                hasClass,
                addClass,
                removeClass,
                setClass,
                getClass,
                setOpacity,
                testProp,
                setTransform,
                setPosition,
                getPosition,
                get disableTextSelection() {
                    return disableTextSelection;
                },
                get enableTextSelection() {
                    return enableTextSelection;
                },
                disableImageDrag,
                enableImageDrag,
                preventOutline,
                restoreOutline,
                getSizedParentNode,
                getScale
            };
            function on(obj, types, fn, context) {
                if (types && "object" == typeof types) for (var type in types) addOne(obj, type, types[type], fn); else for (var i = 0, len = (types = splitWords(types)).length; i < len; i++) addOne(obj, types[i], fn, context);
                return this;
            }
            var eventsKey = "_leaflet_events";
            function off(obj, types, fn, context) {
                if (1 === arguments.length) batchRemove(obj), delete obj[eventsKey]; else if (types && "object" == typeof types) for (var type in types) removeOne(obj, type, types[type], fn); else if (types = splitWords(types), 
                2 === arguments.length) batchRemove(obj, (function(type) {
                    return -1 !== indexOf(types, type);
                })); else for (var i = 0, len = types.length; i < len; i++) removeOne(obj, types[i], fn, context);
                return this;
            }
            function batchRemove(obj, filterFn) {
                for (var id in obj[eventsKey]) {
                    var type = id.split(/\d/)[0];
                    filterFn && !filterFn(type) || removeOne(obj, type, null, null, id);
                }
            }
            var mouseSubst = {
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                wheel: !("onwheel" in window) && "mousewheel"
            };
            function addOne(obj, type, fn, context) {
                var id = type + stamp(fn) + (context ? "_" + stamp(context) : "");
                if (obj[eventsKey] && obj[eventsKey][id]) return this;
                var handler = function(e) {
                    return fn.call(context || obj, e || window.event);
                }, originalHandler = handler;
                !Browser.touchNative && Browser.pointer && 0 === type.indexOf("touch") ? handler = addPointerListener(obj, type, handler) : Browser.touch && "dblclick" === type ? handler = addDoubleTapListener(obj, handler) : "addEventListener" in obj ? "touchstart" === type || "touchmove" === type || "wheel" === type || "mousewheel" === type ? obj.addEventListener(mouseSubst[type] || type, handler, !!Browser.passiveEvents && {
                    passive: !1
                }) : "mouseenter" === type || "mouseleave" === type ? (handler = function(e) {
                    e = e || window.event, isExternalTarget(obj, e) && originalHandler(e);
                }, obj.addEventListener(mouseSubst[type], handler, !1)) : obj.addEventListener(type, originalHandler, !1) : obj.attachEvent("on" + type, handler), 
                obj[eventsKey] = obj[eventsKey] || {}, obj[eventsKey][id] = handler;
            }
            function removeOne(obj, type, fn, context, id) {
                id = id || type + stamp(fn) + (context ? "_" + stamp(context) : "");
                var handler = obj[eventsKey] && obj[eventsKey][id];
                if (!handler) return this;
                !Browser.touchNative && Browser.pointer && 0 === type.indexOf("touch") ? removePointerListener(obj, type, handler) : Browser.touch && "dblclick" === type ? removeDoubleTapListener(obj, handler) : "removeEventListener" in obj ? obj.removeEventListener(mouseSubst[type] || type, handler, !1) : obj.detachEvent("on" + type, handler), 
                obj[eventsKey][id] = null;
            }
            function stopPropagation(e) {
                return e.stopPropagation ? e.stopPropagation() : e.originalEvent ? e.originalEvent._stopped = !0 : e.cancelBubble = !0, 
                this;
            }
            function disableScrollPropagation(el) {
                return addOne(el, "wheel", stopPropagation), this;
            }
            function disableClickPropagation(el) {
                return on(el, "mousedown touchstart dblclick contextmenu", stopPropagation), el._leaflet_disable_click = !0, 
                this;
            }
            function preventDefault(e) {
                return e.preventDefault ? e.preventDefault() : e.returnValue = !1, this;
            }
            function stop(e) {
                return preventDefault(e), stopPropagation(e), this;
            }
            function getPropagationPath(ev) {
                if (ev.composedPath) return ev.composedPath();
                for (var path = [], el = ev.target; el; ) path.push(el), el = el.parentNode;
                return path;
            }
            function getMousePosition(e, container) {
                if (!container) return new Point(e.clientX, e.clientY);
                var scale = getScale(container), offset = scale.boundingClientRect;
                return new Point((e.clientX - offset.left) / scale.x - container.clientLeft, (e.clientY - offset.top) / scale.y - container.clientTop);
            }
            var wheelPxFactor = Browser.linux && Browser.chrome ? window.devicePixelRatio : Browser.mac ? 3 * window.devicePixelRatio : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
            function getWheelDelta(e) {
                return Browser.edge ? e.wheelDeltaY / 2 : e.deltaY && 0 === e.deltaMode ? -e.deltaY / wheelPxFactor : e.deltaY && 1 === e.deltaMode ? 20 * -e.deltaY : e.deltaY && 2 === e.deltaMode ? 60 * -e.deltaY : e.deltaX || e.deltaZ ? 0 : e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : e.detail && Math.abs(e.detail) < 32765 ? 20 * -e.detail : e.detail ? e.detail / -32765 * 60 : 0;
            }
            function isExternalTarget(el, e) {
                var related = e.relatedTarget;
                if (!related) return !0;
                try {
                    for (;related && related !== el; ) related = related.parentNode;
                } catch (err) {
                    return !1;
                }
                return related !== el;
            }
            var DomEvent = {
                __proto__: null,
                on,
                off,
                stopPropagation,
                disableScrollPropagation,
                disableClickPropagation,
                preventDefault,
                stop,
                getPropagationPath,
                getMousePosition,
                getWheelDelta,
                isExternalTarget,
                addListener: on,
                removeListener: off
            }, PosAnimation = Evented.extend({
                run: function(el, newPos, duration, easeLinearity) {
                    this.stop(), this._el = el, this._inProgress = !0, this._duration = duration || .25, 
                    this._easeOutPower = 1 / Math.max(easeLinearity || .5, .2), this._startPos = getPosition(el), 
                    this._offset = newPos.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), 
                    this._animate();
                },
                stop: function() {
                    this._inProgress && (this._step(!0), this._complete());
                },
                _animate: function() {
                    this._animId = requestAnimFrame(this._animate, this), this._step();
                },
                _step: function(round) {
                    var elapsed = +new Date - this._startTime, duration = 1e3 * this._duration;
                    elapsed < duration ? this._runFrame(this._easeOut(elapsed / duration), round) : (this._runFrame(1), 
                    this._complete());
                },
                _runFrame: function(progress, round) {
                    var pos = this._startPos.add(this._offset.multiplyBy(progress));
                    round && pos._round(), setPosition(this._el, pos), this.fire("step");
                },
                _complete: function() {
                    cancelAnimFrame(this._animId), this._inProgress = !1, this.fire("end");
                },
                _easeOut: function(t) {
                    return 1 - Math.pow(1 - t, this._easeOutPower);
                }
            }), Map = Evented.extend({
                options: {
                    crs: EPSG3857,
                    center: void 0,
                    zoom: void 0,
                    minZoom: void 0,
                    maxZoom: void 0,
                    layers: [],
                    maxBounds: void 0,
                    renderer: void 0,
                    zoomAnimation: !0,
                    zoomAnimationThreshold: 4,
                    fadeAnimation: !0,
                    markerZoomAnimation: !0,
                    transform3DLimit: 8388608,
                    zoomSnap: 1,
                    zoomDelta: 1,
                    trackResize: !0
                },
                initialize: function(id, options) {
                    options = setOptions(this, options), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, 
                    this._sizeChanged = !0, this._initContainer(id), this._initLayout(), this._onResize = bind(this._onResize, this), 
                    this._initEvents(), options.maxBounds && this.setMaxBounds(options.maxBounds), void 0 !== options.zoom && (this._zoom = this._limitZoom(options.zoom)), 
                    options.center && void 0 !== options.zoom && this.setView(toLatLng(options.center), options.zoom, {
                        reset: !0
                    }), this.callInitHooks(), this._zoomAnimated = TRANSITION && Browser.any3d && !Browser.mobileOpera && this.options.zoomAnimation, 
                    this._zoomAnimated && (this._createAnimProxy(), on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this)), 
                    this._addLayers(this.options.layers);
                },
                setView: function(center, zoom, options) {
                    return zoom = void 0 === zoom ? this._zoom : this._limitZoom(zoom), center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds), 
                    options = options || {}, this._stop(), this._loaded && !options.reset && !0 !== options && (void 0 !== options.animate && (options.zoom = extend({
                        animate: options.animate
                    }, options.zoom), options.pan = extend({
                        animate: options.animate,
                        duration: options.duration
                    }, options.pan)), this._zoom !== zoom ? this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) : this._tryAnimatedPan(center, options.pan)) ? (clearTimeout(this._sizeTimer), 
                    this) : (this._resetView(center, zoom, options.pan && options.pan.noMoveStart), 
                    this);
                },
                setZoom: function(zoom, options) {
                    return this._loaded ? this.setView(this.getCenter(), zoom, {
                        zoom: options
                    }) : (this._zoom = zoom, this);
                },
                zoomIn: function(delta, options) {
                    return delta = delta || (Browser.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + delta, options);
                },
                zoomOut: function(delta, options) {
                    return delta = delta || (Browser.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - delta, options);
                },
                setZoomAround: function(latlng, zoom, options) {
                    var scale = this.getZoomScale(zoom), viewHalf = this.getSize().divideBy(2), centerOffset = (latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng)).subtract(viewHalf).multiplyBy(1 - 1 / scale), newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));
                    return this.setView(newCenter, zoom, {
                        zoom: options
                    });
                },
                _getBoundsCenterZoom: function(bounds, options) {
                    options = options || {}, bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);
                    var paddingTL = toPoint(options.paddingTopLeft || options.padding || [ 0, 0 ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [ 0, 0 ]), zoom = this.getBoundsZoom(bounds, !1, paddingTL.add(paddingBR));
                    if ((zoom = "number" == typeof options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom) === 1 / 0) return {
                        center: bounds.getCenter(),
                        zoom
                    };
                    var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2), swPoint = this.project(bounds.getSouthWest(), zoom), nePoint = this.project(bounds.getNorthEast(), zoom);
                    return {
                        center: this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom),
                        zoom
                    };
                },
                fitBounds: function(bounds, options) {
                    if (!(bounds = toLatLngBounds(bounds)).isValid()) throw new Error("Bounds are not valid.");
                    var target = this._getBoundsCenterZoom(bounds, options);
                    return this.setView(target.center, target.zoom, options);
                },
                fitWorld: function(options) {
                    return this.fitBounds([ [ -90, -180 ], [ 90, 180 ] ], options);
                },
                panTo: function(center, options) {
                    return this.setView(center, this._zoom, {
                        pan: options
                    });
                },
                panBy: function(offset, options) {
                    if (options = options || {}, !(offset = toPoint(offset).round()).x && !offset.y) return this.fire("moveend");
                    if (!0 !== options.animate && !this.getSize().contains(offset)) return this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom()), 
                    this;
                    if (this._panAnim || (this._panAnim = new PosAnimation, this._panAnim.on({
                        step: this._onPanTransitionStep,
                        end: this._onPanTransitionEnd
                    }, this)), options.noMoveStart || this.fire("movestart"), !1 !== options.animate) {
                        addClass(this._mapPane, "leaflet-pan-anim");
                        var newPos = this._getMapPanePos().subtract(offset).round();
                        this._panAnim.run(this._mapPane, newPos, options.duration || .25, options.easeLinearity);
                    } else this._rawPanBy(offset), this.fire("move").fire("moveend");
                    return this;
                },
                flyTo: function(targetCenter, targetZoom, options) {
                    if (!1 === (options = options || {}).animate || !Browser.any3d) return this.setView(targetCenter, targetZoom, options);
                    this._stop();
                    var from = this.project(this.getCenter()), to = this.project(targetCenter), size = this.getSize(), startZoom = this._zoom;
                    targetCenter = toLatLng(targetCenter), targetZoom = void 0 === targetZoom ? startZoom : targetZoom;
                    var w0 = Math.max(size.x, size.y), w1 = w0 * this.getZoomScale(startZoom, targetZoom), u1 = to.distanceTo(from) || 1, rho = 1.42, rho2 = rho * rho;
                    function r(i) {
                        var b = (w1 * w1 - w0 * w0 + (i ? -1 : 1) * rho2 * rho2 * u1 * u1) / (2 * (i ? w1 : w0) * rho2 * u1), sq = Math.sqrt(b * b + 1) - b;
                        return sq < 1e-9 ? -18 : Math.log(sq);
                    }
                    function sinh(n) {
                        return (Math.exp(n) - Math.exp(-n)) / 2;
                    }
                    function cosh(n) {
                        return (Math.exp(n) + Math.exp(-n)) / 2;
                    }
                    function tanh(n) {
                        return sinh(n) / cosh(n);
                    }
                    var r0 = r(0);
                    function w(s) {
                        return w0 * (cosh(r0) / cosh(r0 + rho * s));
                    }
                    function u(s) {
                        return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2;
                    }
                    function easeOut(t) {
                        return 1 - Math.pow(1 - t, 1.5);
                    }
                    var start = Date.now(), S = (r(1) - r0) / rho, duration = options.duration ? 1e3 * options.duration : 1e3 * S * .8;
                    function frame() {
                        var t = (Date.now() - start) / duration, s = easeOut(t) * S;
                        t <= 1 ? (this._flyToFrame = requestAnimFrame(frame, this), this._move(this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom), this.getScaleZoom(w0 / w(s), startZoom), {
                            flyTo: !0
                        })) : this._move(targetCenter, targetZoom)._moveEnd(!0);
                    }
                    return this._moveStart(!0, options.noMoveStart), frame.call(this), this;
                },
                flyToBounds: function(bounds, options) {
                    var target = this._getBoundsCenterZoom(bounds, options);
                    return this.flyTo(target.center, target.zoom, options);
                },
                setMaxBounds: function(bounds) {
                    return bounds = toLatLngBounds(bounds), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), 
                    bounds.isValid() ? (this.options.maxBounds = bounds, this._loaded && this._panInsideMaxBounds(), 
                    this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, 
                    this);
                },
                setMinZoom: function(zoom) {
                    var oldZoom = this.options.minZoom;
                    return this.options.minZoom = zoom, this._loaded && oldZoom !== zoom && (this.fire("zoomlevelschange"), 
                    this.getZoom() < this.options.minZoom) ? this.setZoom(zoom) : this;
                },
                setMaxZoom: function(zoom) {
                    var oldZoom = this.options.maxZoom;
                    return this.options.maxZoom = zoom, this._loaded && oldZoom !== zoom && (this.fire("zoomlevelschange"), 
                    this.getZoom() > this.options.maxZoom) ? this.setZoom(zoom) : this;
                },
                panInsideBounds: function(bounds, options) {
                    this._enforcingBounds = !0;
                    var center = this.getCenter(), newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));
                    return center.equals(newCenter) || this.panTo(newCenter, options), this._enforcingBounds = !1, 
                    this;
                },
                panInside: function(latlng, options) {
                    var paddingTL = toPoint((options = options || {}).paddingTopLeft || options.padding || [ 0, 0 ]), paddingBR = toPoint(options.paddingBottomRight || options.padding || [ 0, 0 ]), pixelCenter = this.project(this.getCenter()), pixelPoint = this.project(latlng), pixelBounds = this.getPixelBounds(), paddedBounds = toBounds([ pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR) ]), paddedSize = paddedBounds.getSize();
                    if (!paddedBounds.contains(pixelPoint)) {
                        this._enforcingBounds = !0;
                        var centerOffset = pixelPoint.subtract(paddedBounds.getCenter()), offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);
                        pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x, pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y, 
                        this.panTo(this.unproject(pixelCenter), options), this._enforcingBounds = !1;
                    }
                    return this;
                },
                invalidateSize: function(options) {
                    if (!this._loaded) return this;
                    options = extend({
                        animate: !1,
                        pan: !0
                    }, !0 === options ? {
                        animate: !0
                    } : options);
                    var oldSize = this.getSize();
                    this._sizeChanged = !0, this._lastCenter = null;
                    var newSize = this.getSize(), oldCenter = oldSize.divideBy(2).round(), newCenter = newSize.divideBy(2).round(), offset = oldCenter.subtract(newCenter);
                    return offset.x || offset.y ? (options.animate && options.pan ? this.panBy(offset) : (options.pan && this._rawPanBy(offset), 
                    this.fire("move"), options.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(bind(this.fire, this, "moveend"), 200)) : this.fire("moveend")), 
                    this.fire("resize", {
                        oldSize,
                        newSize
                    })) : this;
                },
                stop: function() {
                    return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), 
                    this._stop();
                },
                locate: function(options) {
                    if (options = this._locateOptions = extend({
                        timeout: 1e4,
                        watch: !1
                    }, options), !("geolocation" in navigator)) return this._handleGeolocationError({
                        code: 0,
                        message: "Geolocation not supported."
                    }), this;
                    var onResponse = bind(this._handleGeolocationResponse, this), onError = bind(this._handleGeolocationError, this);
                    return options.watch ? this._locationWatchId = navigator.geolocation.watchPosition(onResponse, onError, options) : navigator.geolocation.getCurrentPosition(onResponse, onError, options), 
                    this;
                },
                stopLocate: function() {
                    return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), 
                    this._locateOptions && (this._locateOptions.setView = !1), this;
                },
                _handleGeolocationError: function(error) {
                    if (this._container._leaflet_id) {
                        var c = error.code, message = error.message || (1 === c ? "permission denied" : 2 === c ? "position unavailable" : "timeout");
                        this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", {
                            code: c,
                            message: "Geolocation error: " + message + "."
                        });
                    }
                },
                _handleGeolocationResponse: function(pos) {
                    if (this._container._leaflet_id) {
                        var latlng = new LatLng(pos.coords.latitude, pos.coords.longitude), bounds = latlng.toBounds(2 * pos.coords.accuracy), options = this._locateOptions;
                        if (options.setView) {
                            var zoom = this.getBoundsZoom(bounds);
                            this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
                        }
                        var data = {
                            latlng,
                            bounds,
                            timestamp: pos.timestamp
                        };
                        for (var i in pos.coords) "number" == typeof pos.coords[i] && (data[i] = pos.coords[i]);
                        this.fire("locationfound", data);
                    }
                },
                addHandler: function(name, HandlerClass) {
                    if (!HandlerClass) return this;
                    var handler = this[name] = new HandlerClass(this);
                    return this._handlers.push(handler), this.options[name] && handler.enable(), this;
                },
                remove: function() {
                    if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), 
                    this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance");
                    try {
                        delete this._container._leaflet_id, delete this._containerId;
                    } catch (e) {
                        this._container._leaflet_id = void 0, this._containerId = void 0;
                    }
                    var i;
                    for (i in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), remove(this._mapPane), 
                    this._clearControlPos && this._clearControlPos(), this._resizeRequest && (cancelAnimFrame(this._resizeRequest), 
                    this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), 
                    this._layers) this._layers[i].remove();
                    for (i in this._panes) remove(this._panes[i]);
                    return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, 
                    this;
                },
                createPane: function(name, container) {
                    var pane = create$1("div", "leaflet-pane" + (name ? " leaflet-" + name.replace("Pane", "") + "-pane" : ""), container || this._mapPane);
                    return name && (this._panes[name] = pane), pane;
                },
                getCenter: function() {
                    return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint());
                },
                getZoom: function() {
                    return this._zoom;
                },
                getBounds: function() {
                    var bounds = this.getPixelBounds();
                    return new LatLngBounds(this.unproject(bounds.getBottomLeft()), this.unproject(bounds.getTopRight()));
                },
                getMinZoom: function() {
                    return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom;
                },
                getMaxZoom: function() {
                    return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;
                },
                getBoundsZoom: function(bounds, inside, padding) {
                    bounds = toLatLngBounds(bounds), padding = toPoint(padding || [ 0, 0 ]);
                    var zoom = this.getZoom() || 0, min = this.getMinZoom(), max = this.getMaxZoom(), nw = bounds.getNorthWest(), se = bounds.getSouthEast(), size = this.getSize().subtract(padding), boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(), snap = Browser.any3d ? this.options.zoomSnap : 1, scalex = size.x / boundsSize.x, scaley = size.y / boundsSize.y, scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);
                    return zoom = this.getScaleZoom(scale, zoom), snap && (zoom = Math.round(zoom / (snap / 100)) * (snap / 100), 
                    zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap), 
                    Math.max(min, Math.min(max, zoom));
                },
                getSize: function() {
                    return this._size && !this._sizeChanged || (this._size = new Point(this._container.clientWidth || 0, this._container.clientHeight || 0), 
                    this._sizeChanged = !1), this._size.clone();
                },
                getPixelBounds: function(center, zoom) {
                    var topLeftPoint = this._getTopLeftPoint(center, zoom);
                    return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
                },
                getPixelOrigin: function() {
                    return this._checkIfLoaded(), this._pixelOrigin;
                },
                getPixelWorldBounds: function(zoom) {
                    return this.options.crs.getProjectedBounds(void 0 === zoom ? this.getZoom() : zoom);
                },
                getPane: function(pane) {
                    return "string" == typeof pane ? this._panes[pane] : pane;
                },
                getPanes: function() {
                    return this._panes;
                },
                getContainer: function() {
                    return this._container;
                },
                getZoomScale: function(toZoom, fromZoom) {
                    var crs = this.options.crs;
                    return fromZoom = void 0 === fromZoom ? this._zoom : fromZoom, crs.scale(toZoom) / crs.scale(fromZoom);
                },
                getScaleZoom: function(scale, fromZoom) {
                    var crs = this.options.crs;
                    fromZoom = void 0 === fromZoom ? this._zoom : fromZoom;
                    var zoom = crs.zoom(scale * crs.scale(fromZoom));
                    return isNaN(zoom) ? 1 / 0 : zoom;
                },
                project: function(latlng, zoom) {
                    return zoom = void 0 === zoom ? this._zoom : zoom, this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
                },
                unproject: function(point, zoom) {
                    return zoom = void 0 === zoom ? this._zoom : zoom, this.options.crs.pointToLatLng(toPoint(point), zoom);
                },
                layerPointToLatLng: function(point) {
                    var projectedPoint = toPoint(point).add(this.getPixelOrigin());
                    return this.unproject(projectedPoint);
                },
                latLngToLayerPoint: function(latlng) {
                    return this.project(toLatLng(latlng))._round()._subtract(this.getPixelOrigin());
                },
                wrapLatLng: function(latlng) {
                    return this.options.crs.wrapLatLng(toLatLng(latlng));
                },
                wrapLatLngBounds: function(latlng) {
                    return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
                },
                distance: function(latlng1, latlng2) {
                    return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
                },
                containerPointToLayerPoint: function(point) {
                    return toPoint(point).subtract(this._getMapPanePos());
                },
                layerPointToContainerPoint: function(point) {
                    return toPoint(point).add(this._getMapPanePos());
                },
                containerPointToLatLng: function(point) {
                    var layerPoint = this.containerPointToLayerPoint(toPoint(point));
                    return this.layerPointToLatLng(layerPoint);
                },
                latLngToContainerPoint: function(latlng) {
                    return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
                },
                mouseEventToContainerPoint: function(e) {
                    return getMousePosition(e, this._container);
                },
                mouseEventToLayerPoint: function(e) {
                    return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
                },
                mouseEventToLatLng: function(e) {
                    return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
                },
                _initContainer: function(id) {
                    var container = this._container = get(id);
                    if (!container) throw new Error("Map container not found.");
                    if (container._leaflet_id) throw new Error("Map container is already initialized.");
                    on(container, "scroll", this._onScroll, this), this._containerId = stamp(container);
                },
                _initLayout: function() {
                    var container = this._container;
                    this._fadeAnimated = this.options.fadeAnimation && Browser.any3d, addClass(container, "leaflet-container" + (Browser.touch ? " leaflet-touch" : "") + (Browser.retina ? " leaflet-retina" : "") + (Browser.ielt9 ? " leaflet-oldie" : "") + (Browser.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
                    var position = getStyle(container, "position");
                    "absolute" !== position && "relative" !== position && "fixed" !== position && "sticky" !== position && (container.style.position = "relative"), 
                    this._initPanes(), this._initControlPos && this._initControlPos();
                },
                _initPanes: function() {
                    var panes = this._panes = {};
                    this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), 
                    setPosition(this._mapPane, new Point(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), 
                    this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), 
                    this.createPane("popupPane"), this.options.markerZoomAnimation || (addClass(panes.markerPane, "leaflet-zoom-hide"), 
                    addClass(panes.shadowPane, "leaflet-zoom-hide"));
                },
                _resetView: function(center, zoom, noMoveStart) {
                    setPosition(this._mapPane, new Point(0, 0));
                    var loading = !this._loaded;
                    this._loaded = !0, zoom = this._limitZoom(zoom), this.fire("viewprereset");
                    var zoomChanged = this._zoom !== zoom;
                    this._moveStart(zoomChanged, noMoveStart)._move(center, zoom)._moveEnd(zoomChanged), 
                    this.fire("viewreset"), loading && this.fire("load");
                },
                _moveStart: function(zoomChanged, noMoveStart) {
                    return zoomChanged && this.fire("zoomstart"), noMoveStart || this.fire("movestart"), 
                    this;
                },
                _move: function(center, zoom, data, supressEvent) {
                    void 0 === zoom && (zoom = this._zoom);
                    var zoomChanged = this._zoom !== zoom;
                    return this._zoom = zoom, this._lastCenter = center, this._pixelOrigin = this._getNewPixelOrigin(center), 
                    supressEvent ? data && data.pinch && this.fire("zoom", data) : ((zoomChanged || data && data.pinch) && this.fire("zoom", data), 
                    this.fire("move", data)), this;
                },
                _moveEnd: function(zoomChanged) {
                    return zoomChanged && this.fire("zoomend"), this.fire("moveend");
                },
                _stop: function() {
                    return cancelAnimFrame(this._flyToFrame), this._panAnim && this._panAnim.stop(), 
                    this;
                },
                _rawPanBy: function(offset) {
                    setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
                },
                _getZoomSpan: function() {
                    return this.getMaxZoom() - this.getMinZoom();
                },
                _panInsideMaxBounds: function() {
                    this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);
                },
                _checkIfLoaded: function() {
                    if (!this._loaded) throw new Error("Set map center and zoom first.");
                },
                _initEvents: function(remove) {
                    this._targets = {}, this._targets[stamp(this._container)] = this;
                    var onOff = remove ? off : on;
                    onOff(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), 
                    this.options.trackResize && onOff(window, "resize", this._onResize, this), Browser.any3d && this.options.transform3DLimit && (remove ? this.off : this.on).call(this, "moveend", this._onMoveEnd);
                },
                _onResize: function() {
                    cancelAnimFrame(this._resizeRequest), this._resizeRequest = requestAnimFrame((function() {
                        this.invalidateSize({
                            debounceMoveend: !0
                        });
                    }), this);
                },
                _onScroll: function() {
                    this._container.scrollTop = 0, this._container.scrollLeft = 0;
                },
                _onMoveEnd: function() {
                    var pos = this._getMapPanePos();
                    Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());
                },
                _findEventTargets: function(e, type) {
                    for (var target, targets = [], isHover = "mouseout" === type || "mouseover" === type, src = e.target || e.srcElement, dragging = !1; src; ) {
                        if ((target = this._targets[stamp(src)]) && ("click" === type || "preclick" === type) && this._draggableMoved(target)) {
                            dragging = !0;
                            break;
                        }
                        if (target && target.listens(type, !0)) {
                            if (isHover && !isExternalTarget(src, e)) break;
                            if (targets.push(target), isHover) break;
                        }
                        if (src === this._container) break;
                        src = src.parentNode;
                    }
                    return targets.length || dragging || isHover || !this.listens(type, !0) || (targets = [ this ]), 
                    targets;
                },
                _isClickDisabled: function(el) {
                    for (;el && el !== this._container; ) {
                        if (el._leaflet_disable_click) return !0;
                        el = el.parentNode;
                    }
                },
                _handleDOMEvent: function(e) {
                    var el = e.target || e.srcElement;
                    if (!(!this._loaded || el._leaflet_disable_events || "click" === e.type && this._isClickDisabled(el))) {
                        var type = e.type;
                        "mousedown" === type && preventOutline(el), this._fireDOMEvent(e, type);
                    }
                },
                _mouseEvents: [ "click", "dblclick", "mouseover", "mouseout", "contextmenu" ],
                _fireDOMEvent: function(e, type, canvasTargets) {
                    if ("click" === e.type) {
                        var synth = extend({}, e);
                        synth.type = "preclick", this._fireDOMEvent(synth, synth.type, canvasTargets);
                    }
                    var targets = this._findEventTargets(e, type);
                    if (canvasTargets) {
                        for (var filtered = [], i = 0; i < canvasTargets.length; i++) canvasTargets[i].listens(type, !0) && filtered.push(canvasTargets[i]);
                        targets = filtered.concat(targets);
                    }
                    if (targets.length) {
                        "contextmenu" === type && preventDefault(e);
                        var target = targets[0], data = {
                            originalEvent: e
                        };
                        if ("keypress" !== e.type && "keydown" !== e.type && "keyup" !== e.type) {
                            var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
                            data.containerPoint = isMarker ? this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e), 
                            data.layerPoint = this.containerPointToLayerPoint(data.containerPoint), data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
                        }
                        for (i = 0; i < targets.length; i++) if (targets[i].fire(type, data, !0), data.originalEvent._stopped || !1 === targets[i].options.bubblingMouseEvents && -1 !== indexOf(this._mouseEvents, type)) return;
                    }
                },
                _draggableMoved: function(obj) {
                    return (obj = obj.dragging && obj.dragging.enabled() ? obj : this).dragging && obj.dragging.moved() || this.boxZoom && this.boxZoom.moved();
                },
                _clearHandlers: function() {
                    for (var i = 0, len = this._handlers.length; i < len; i++) this._handlers[i].disable();
                },
                whenReady: function(callback, context) {
                    return this._loaded ? callback.call(context || this, {
                        target: this
                    }) : this.on("load", callback, context), this;
                },
                _getMapPanePos: function() {
                    return getPosition(this._mapPane) || new Point(0, 0);
                },
                _moved: function() {
                    var pos = this._getMapPanePos();
                    return pos && !pos.equals([ 0, 0 ]);
                },
                _getTopLeftPoint: function(center, zoom) {
                    return (center && void 0 !== zoom ? this._getNewPixelOrigin(center, zoom) : this.getPixelOrigin()).subtract(this._getMapPanePos());
                },
                _getNewPixelOrigin: function(center, zoom) {
                    var viewHalf = this.getSize()._divideBy(2);
                    return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
                },
                _latLngToNewLayerPoint: function(latlng, zoom, center) {
                    var topLeft = this._getNewPixelOrigin(center, zoom);
                    return this.project(latlng, zoom)._subtract(topLeft);
                },
                _latLngBoundsToNewLayerBounds: function(latLngBounds, zoom, center) {
                    var topLeft = this._getNewPixelOrigin(center, zoom);
                    return toBounds([ this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft), this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft), this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft) ]);
                },
                _getCenterLayerPoint: function() {
                    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
                },
                _getCenterOffset: function(latlng) {
                    return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
                },
                _limitCenter: function(center, zoom, bounds) {
                    if (!bounds) return center;
                    var centerPoint = this.project(center, zoom), viewHalf = this.getSize().divideBy(2), viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)), offset = this._getBoundsOffset(viewBounds, bounds, zoom);
                    return Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1 ? center : this.unproject(centerPoint.add(offset), zoom);
                },
                _limitOffset: function(offset, bounds) {
                    if (!bounds) return offset;
                    var viewBounds = this.getPixelBounds(), newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));
                    return offset.add(this._getBoundsOffset(newBounds, bounds));
                },
                _getBoundsOffset: function(pxBounds, maxBounds, zoom) {
                    var projectedMaxBounds = toBounds(this.project(maxBounds.getNorthEast(), zoom), this.project(maxBounds.getSouthWest(), zoom)), minOffset = projectedMaxBounds.min.subtract(pxBounds.min), maxOffset = projectedMaxBounds.max.subtract(pxBounds.max);
                    return new Point(this._rebound(minOffset.x, -maxOffset.x), this._rebound(minOffset.y, -maxOffset.y));
                },
                _rebound: function(left, right) {
                    return left + right > 0 ? Math.round(left - right) / 2 : Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
                },
                _limitZoom: function(zoom) {
                    var min = this.getMinZoom(), max = this.getMaxZoom(), snap = Browser.any3d ? this.options.zoomSnap : 1;
                    return snap && (zoom = Math.round(zoom / snap) * snap), Math.max(min, Math.min(max, zoom));
                },
                _onPanTransitionStep: function() {
                    this.fire("move");
                },
                _onPanTransitionEnd: function() {
                    removeClass(this._mapPane, "leaflet-pan-anim"), this.fire("moveend");
                },
                _tryAnimatedPan: function(center, options) {
                    var offset = this._getCenterOffset(center)._trunc();
                    return !(!0 !== (options && options.animate) && !this.getSize().contains(offset) || (this.panBy(offset, options), 
                    0));
                },
                _createAnimProxy: function() {
                    var proxy = this._proxy = create$1("div", "leaflet-proxy leaflet-zoom-animated");
                    this._panes.mapPane.appendChild(proxy), this.on("zoomanim", (function(e) {
                        var prop = TRANSFORM, transform = this._proxy.style[prop];
                        setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1)), 
                        transform === this._proxy.style[prop] && this._animatingZoom && this._onZoomTransitionEnd();
                    }), this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this);
                },
                _destroyAnimProxy: function() {
                    remove(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy;
                },
                _animMoveEnd: function() {
                    var c = this.getCenter(), z = this.getZoom();
                    setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
                },
                _catchTransitionEnd: function(e) {
                    this._animatingZoom && e.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd();
                },
                _nothingToAnimate: function() {
                    return !this._container.getElementsByClassName("leaflet-zoom-animated").length;
                },
                _tryAnimatedZoom: function(center, zoom, options) {
                    if (this._animatingZoom) return !0;
                    if (options = options || {}, !this._zoomAnimated || !1 === options.animate || this._nothingToAnimate() || Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) return !1;
                    var scale = this.getZoomScale(zoom), offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);
                    return !(!0 !== options.animate && !this.getSize().contains(offset) || (requestAnimFrame((function() {
                        this._moveStart(!0, options.noMoveStart || !1)._animateZoom(center, zoom, !0);
                    }), this), 0));
                },
                _animateZoom: function(center, zoom, startAnim, noUpdate) {
                    this._mapPane && (startAnim && (this._animatingZoom = !0, this._animateToCenter = center, 
                    this._animateToZoom = zoom, addClass(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", {
                        center,
                        zoom,
                        noUpdate
                    }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), 
                    this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(bind(this._onZoomTransitionEnd, this), 250));
                },
                _onZoomTransitionEnd: function() {
                    this._animatingZoom && (this._mapPane && removeClass(this._mapPane, "leaflet-zoom-anim"), 
                    this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), 
                    this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), 
                    this._moveEnd(!0));
                }
            });
            function createMap(id, options) {
                return new Map(id, options);
            }
            var Control = Class.extend({
                options: {
                    position: "topright"
                },
                initialize: function(options) {
                    setOptions(this, options);
                },
                getPosition: function() {
                    return this.options.position;
                },
                setPosition: function(position) {
                    var map = this._map;
                    return map && map.removeControl(this), this.options.position = position, map && map.addControl(this), 
                    this;
                },
                getContainer: function() {
                    return this._container;
                },
                addTo: function(map) {
                    this.remove(), this._map = map;
                    var container = this._container = this.onAdd(map), pos = this.getPosition(), corner = map._controlCorners[pos];
                    return addClass(container, "leaflet-control"), -1 !== pos.indexOf("bottom") ? corner.insertBefore(container, corner.firstChild) : corner.appendChild(container), 
                    this._map.on("unload", this.remove, this), this;
                },
                remove: function() {
                    return this._map ? (remove(this._container), this.onRemove && this.onRemove(this._map), 
                    this._map.off("unload", this.remove, this), this._map = null, this) : this;
                },
                _refocusOnMap: function(e) {
                    this._map && e && e.screenX > 0 && e.screenY > 0 && this._map.getContainer().focus();
                }
            }), control = function(options) {
                return new Control(options);
            };
            Map.include({
                addControl: function(control) {
                    return control.addTo(this), this;
                },
                removeControl: function(control) {
                    return control.remove(), this;
                },
                _initControlPos: function() {
                    var corners = this._controlCorners = {}, l = "leaflet-", container = this._controlContainer = create$1("div", l + "control-container", this._container);
                    function createCorner(vSide, hSide) {
                        var className = l + vSide + " " + l + hSide;
                        corners[vSide + hSide] = create$1("div", className, container);
                    }
                    createCorner("top", "left"), createCorner("top", "right"), createCorner("bottom", "left"), 
                    createCorner("bottom", "right");
                },
                _clearControlPos: function() {
                    for (var i in this._controlCorners) remove(this._controlCorners[i]);
                    remove(this._controlContainer), delete this._controlCorners, delete this._controlContainer;
                }
            });
            var Layers = Control.extend({
                options: {
                    collapsed: !0,
                    position: "topright",
                    autoZIndex: !0,
                    hideSingleBase: !1,
                    sortLayers: !1,
                    sortFunction: function(layerA, layerB, nameA, nameB) {
                        return nameA < nameB ? -1 : nameB < nameA ? 1 : 0;
                    }
                },
                initialize: function(baseLayers, overlays, options) {
                    for (var i in setOptions(this, options), this._layerControlInputs = [], this._layers = [], 
                    this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1, baseLayers) this._addLayer(baseLayers[i], i);
                    for (i in overlays) this._addLayer(overlays[i], i, !0);
                },
                onAdd: function(map) {
                    this._initLayout(), this._update(), this._map = map, map.on("zoomend", this._checkDisabledLayers, this);
                    for (var i = 0; i < this._layers.length; i++) this._layers[i].layer.on("add remove", this._onLayerChange, this);
                    return this._container;
                },
                addTo: function(map) {
                    return Control.prototype.addTo.call(this, map), this._expandIfNotCollapsed();
                },
                onRemove: function() {
                    this._map.off("zoomend", this._checkDisabledLayers, this);
                    for (var i = 0; i < this._layers.length; i++) this._layers[i].layer.off("add remove", this._onLayerChange, this);
                },
                addBaseLayer: function(layer, name) {
                    return this._addLayer(layer, name), this._map ? this._update() : this;
                },
                addOverlay: function(layer, name) {
                    return this._addLayer(layer, name, !0), this._map ? this._update() : this;
                },
                removeLayer: function(layer) {
                    layer.off("add remove", this._onLayerChange, this);
                    var obj = this._getLayer(stamp(layer));
                    return obj && this._layers.splice(this._layers.indexOf(obj), 1), this._map ? this._update() : this;
                },
                expand: function() {
                    addClass(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null;
                    var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
                    return acceptableHeight < this._section.clientHeight ? (addClass(this._section, "leaflet-control-layers-scrollbar"), 
                    this._section.style.height = acceptableHeight + "px") : removeClass(this._section, "leaflet-control-layers-scrollbar"), 
                    this._checkDisabledLayers(), this;
                },
                collapse: function() {
                    return removeClass(this._container, "leaflet-control-layers-expanded"), this;
                },
                _initLayout: function() {
                    var className = "leaflet-control-layers", container = this._container = create$1("div", className), collapsed = this.options.collapsed;
                    container.setAttribute("aria-haspopup", !0), disableClickPropagation(container), 
                    disableScrollPropagation(container);
                    var section = this._section = create$1("section", className + "-list");
                    collapsed && (this._map.on("click", this.collapse, this), on(container, {
                        mouseenter: this._expandSafely,
                        mouseleave: this.collapse
                    }, this));
                    var link = this._layersLink = create$1("a", className + "-toggle", container);
                    link.href = "#", link.title = "Layers", link.setAttribute("role", "button"), on(link, {
                        keydown: function(e) {
                            13 === e.keyCode && this._expandSafely();
                        },
                        click: function(e) {
                            preventDefault(e), this._expandSafely();
                        }
                    }, this), collapsed || this.expand(), this._baseLayersList = create$1("div", className + "-base", section), 
                    this._separator = create$1("div", className + "-separator", section), this._overlaysList = create$1("div", className + "-overlays", section), 
                    container.appendChild(section);
                },
                _getLayer: function(id) {
                    for (var i = 0; i < this._layers.length; i++) if (this._layers[i] && stamp(this._layers[i].layer) === id) return this._layers[i];
                },
                _addLayer: function(layer, name, overlay) {
                    this._map && layer.on("add remove", this._onLayerChange, this), this._layers.push({
                        layer,
                        name,
                        overlay
                    }), this.options.sortLayers && this._layers.sort(bind((function(a, b) {
                        return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
                    }), this)), this.options.autoZIndex && layer.setZIndex && (this._lastZIndex++, layer.setZIndex(this._lastZIndex)), 
                    this._expandIfNotCollapsed();
                },
                _update: function() {
                    if (!this._container) return this;
                    empty(this._baseLayersList), empty(this._overlaysList), this._layerControlInputs = [];
                    var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;
                    for (i = 0; i < this._layers.length; i++) obj = this._layers[i], this._addItem(obj), 
                    overlaysPresent = overlaysPresent || obj.overlay, baseLayersPresent = baseLayersPresent || !obj.overlay, 
                    baseLayersCount += obj.overlay ? 0 : 1;
                    return this.options.hideSingleBase && (baseLayersPresent = baseLayersPresent && baseLayersCount > 1, 
                    this._baseLayersList.style.display = baseLayersPresent ? "" : "none"), this._separator.style.display = overlaysPresent && baseLayersPresent ? "" : "none", 
                    this;
                },
                _onLayerChange: function(e) {
                    this._handlingClick || this._update();
                    var obj = this._getLayer(stamp(e.target)), type = obj.overlay ? "add" === e.type ? "overlayadd" : "overlayremove" : "add" === e.type ? "baselayerchange" : null;
                    type && this._map.fire(type, obj);
                },
                _createRadioElement: function(name, checked) {
                    var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"' + (checked ? ' checked="checked"' : "") + "/>", radioFragment = document.createElement("div");
                    return radioFragment.innerHTML = radioHtml, radioFragment.firstChild;
                },
                _addItem: function(obj) {
                    var input, label = document.createElement("label"), checked = this._map.hasLayer(obj.layer);
                    obj.overlay ? ((input = document.createElement("input")).type = "checkbox", input.className = "leaflet-control-layers-selector", 
                    input.defaultChecked = checked) : input = this._createRadioElement("leaflet-base-layers_" + stamp(this), checked), 
                    this._layerControlInputs.push(input), input.layerId = stamp(obj.layer), on(input, "click", this._onInputClick, this);
                    var name = document.createElement("span");
                    name.innerHTML = " " + obj.name;
                    var holder = document.createElement("span");
                    return label.appendChild(holder), holder.appendChild(input), holder.appendChild(name), 
                    (obj.overlay ? this._overlaysList : this._baseLayersList).appendChild(label), this._checkDisabledLayers(), 
                    label;
                },
                _onInputClick: function() {
                    if (!this._preventClick) {
                        var input, layer, inputs = this._layerControlInputs, addedLayers = [], removedLayers = [];
                        this._handlingClick = !0;
                        for (var i = inputs.length - 1; i >= 0; i--) input = inputs[i], layer = this._getLayer(input.layerId).layer, 
                        input.checked ? addedLayers.push(layer) : input.checked || removedLayers.push(layer);
                        for (i = 0; i < removedLayers.length; i++) this._map.hasLayer(removedLayers[i]) && this._map.removeLayer(removedLayers[i]);
                        for (i = 0; i < addedLayers.length; i++) this._map.hasLayer(addedLayers[i]) || this._map.addLayer(addedLayers[i]);
                        this._handlingClick = !1, this._refocusOnMap();
                    }
                },
                _checkDisabledLayers: function() {
                    for (var input, layer, inputs = this._layerControlInputs, zoom = this._map.getZoom(), i = inputs.length - 1; i >= 0; i--) input = inputs[i], 
                    layer = this._getLayer(input.layerId).layer, input.disabled = void 0 !== layer.options.minZoom && zoom < layer.options.minZoom || void 0 !== layer.options.maxZoom && zoom > layer.options.maxZoom;
                },
                _expandIfNotCollapsed: function() {
                    return this._map && !this.options.collapsed && this.expand(), this;
                },
                _expandSafely: function() {
                    var section = this._section;
                    this._preventClick = !0, on(section, "click", preventDefault), this.expand();
                    var that = this;
                    setTimeout((function() {
                        off(section, "click", preventDefault), that._preventClick = !1;
                    }));
                }
            }), layers = function(baseLayers, overlays, options) {
                return new Layers(baseLayers, overlays, options);
            }, Zoom = Control.extend({
                options: {
                    position: "topleft",
                    zoomInText: '<span aria-hidden="true">+</span>',
                    zoomInTitle: "Zoom in",
                    zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
                    zoomOutTitle: "Zoom out"
                },
                onAdd: function(map) {
                    var zoomName = "leaflet-control-zoom", container = create$1("div", zoomName + " leaflet-bar"), options = this.options;
                    return this._zoomInButton = this._createButton(options.zoomInText, options.zoomInTitle, zoomName + "-in", container, this._zoomIn), 
                    this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle, zoomName + "-out", container, this._zoomOut), 
                    this._updateDisabled(), map.on("zoomend zoomlevelschange", this._updateDisabled, this), 
                    container;
                },
                onRemove: function(map) {
                    map.off("zoomend zoomlevelschange", this._updateDisabled, this);
                },
                disable: function() {
                    return this._disabled = !0, this._updateDisabled(), this;
                },
                enable: function() {
                    return this._disabled = !1, this._updateDisabled(), this;
                },
                _zoomIn: function(e) {
                    !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
                },
                _zoomOut: function(e) {
                    !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
                },
                _createButton: function(html, title, className, container, fn) {
                    var link = create$1("a", className, container);
                    return link.innerHTML = html, link.href = "#", link.title = title, link.setAttribute("role", "button"), 
                    link.setAttribute("aria-label", title), disableClickPropagation(link), on(link, "click", stop), 
                    on(link, "click", fn, this), on(link, "click", this._refocusOnMap, this), link;
                },
                _updateDisabled: function() {
                    var map = this._map, className = "leaflet-disabled";
                    removeClass(this._zoomInButton, className), removeClass(this._zoomOutButton, className), 
                    this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), 
                    (this._disabled || map._zoom === map.getMinZoom()) && (addClass(this._zoomOutButton, className), 
                    this._zoomOutButton.setAttribute("aria-disabled", "true")), (this._disabled || map._zoom === map.getMaxZoom()) && (addClass(this._zoomInButton, className), 
                    this._zoomInButton.setAttribute("aria-disabled", "true"));
                }
            });
            Map.mergeOptions({
                zoomControl: !0
            }), Map.addInitHook((function() {
                this.options.zoomControl && (this.zoomControl = new Zoom, this.addControl(this.zoomControl));
            }));
            var zoom = function(options) {
                return new Zoom(options);
            }, Scale = Control.extend({
                options: {
                    position: "bottomleft",
                    maxWidth: 100,
                    metric: !0,
                    imperial: !0
                },
                onAdd: function(map) {
                    var className = "leaflet-control-scale", container = create$1("div", className), options = this.options;
                    return this._addScales(options, className + "-line", container), map.on(options.updateWhenIdle ? "moveend" : "move", this._update, this), 
                    map.whenReady(this._update, this), container;
                },
                onRemove: function(map) {
                    map.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this);
                },
                _addScales: function(options, className, container) {
                    options.metric && (this._mScale = create$1("div", className, container)), options.imperial && (this._iScale = create$1("div", className, container));
                },
                _update: function() {
                    var map = this._map, y = map.getSize().y / 2, maxMeters = map.distance(map.containerPointToLatLng([ 0, y ]), map.containerPointToLatLng([ this.options.maxWidth, y ]));
                    this._updateScales(maxMeters);
                },
                _updateScales: function(maxMeters) {
                    this.options.metric && maxMeters && this._updateMetric(maxMeters), this.options.imperial && maxMeters && this._updateImperial(maxMeters);
                },
                _updateMetric: function(maxMeters) {
                    var meters = this._getRoundNum(maxMeters), label = meters < 1e3 ? meters + " m" : meters / 1e3 + " km";
                    this._updateScale(this._mScale, label, meters / maxMeters);
                },
                _updateImperial: function(maxMeters) {
                    var maxMiles, miles, feet, maxFeet = 3.2808399 * maxMeters;
                    maxFeet > 5280 ? (maxMiles = maxFeet / 5280, miles = this._getRoundNum(maxMiles), 
                    this._updateScale(this._iScale, miles + " mi", miles / maxMiles)) : (feet = this._getRoundNum(maxFeet), 
                    this._updateScale(this._iScale, feet + " ft", feet / maxFeet));
                },
                _updateScale: function(scale, text, ratio) {
                    scale.style.width = Math.round(this.options.maxWidth * ratio) + "px", scale.innerHTML = text;
                },
                _getRoundNum: function(num) {
                    var pow10 = Math.pow(10, (Math.floor(num) + "").length - 1), d = num / pow10;
                    return pow10 * (d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1);
                }
            }), scale = function(options) {
                return new Scale(options);
            }, ukrainianFlag = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>', Attribution = Control.extend({
                options: {
                    position: "bottomright",
                    prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Browser.inlineSvg ? ukrainianFlag + " " : "") + "Leaflet</a>"
                },
                initialize: function(options) {
                    setOptions(this, options), this._attributions = {};
                },
                onAdd: function(map) {
                    for (var i in map.attributionControl = this, this._container = create$1("div", "leaflet-control-attribution"), 
                    disableClickPropagation(this._container), map._layers) map._layers[i].getAttribution && this.addAttribution(map._layers[i].getAttribution());
                    return this._update(), map.on("layeradd", this._addAttribution, this), this._container;
                },
                onRemove: function(map) {
                    map.off("layeradd", this._addAttribution, this);
                },
                _addAttribution: function(ev) {
                    ev.layer.getAttribution && (this.addAttribution(ev.layer.getAttribution()), ev.layer.once("remove", (function() {
                        this.removeAttribution(ev.layer.getAttribution());
                    }), this));
                },
                setPrefix: function(prefix) {
                    return this.options.prefix = prefix, this._update(), this;
                },
                addAttribution: function(text) {
                    return text ? (this._attributions[text] || (this._attributions[text] = 0), this._attributions[text]++, 
                    this._update(), this) : this;
                },
                removeAttribution: function(text) {
                    return text ? (this._attributions[text] && (this._attributions[text]--, this._update()), 
                    this) : this;
                },
                _update: function() {
                    if (this._map) {
                        var attribs = [];
                        for (var i in this._attributions) this._attributions[i] && attribs.push(i);
                        var prefixAndAttribs = [];
                        this.options.prefix && prefixAndAttribs.push(this.options.prefix), attribs.length && prefixAndAttribs.push(attribs.join(", ")), 
                        this._container.innerHTML = prefixAndAttribs.join(' <span aria-hidden="true">|</span> ');
                    }
                }
            });
            Map.mergeOptions({
                attributionControl: !0
            }), Map.addInitHook((function() {
                this.options.attributionControl && (new Attribution).addTo(this);
            }));
            var attribution = function(options) {
                return new Attribution(options);
            };
            Control.Layers = Layers, Control.Zoom = Zoom, Control.Scale = Scale, Control.Attribution = Attribution, 
            control.layers = layers, control.zoom = zoom, control.scale = scale, control.attribution = attribution;
            var Handler = Class.extend({
                initialize: function(map) {
                    this._map = map;
                },
                enable: function() {
                    return this._enabled || (this._enabled = !0, this.addHooks()), this;
                },
                disable: function() {
                    return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;
                },
                enabled: function() {
                    return !!this._enabled;
                }
            });
            Handler.addTo = function(map, name) {
                return map.addHandler(name, this), this;
            };
            var Mixin = {
                Events
            }, START = Browser.touch ? "touchstart mousedown" : "mousedown", Draggable = Evented.extend({
                options: {
                    clickTolerance: 3
                },
                initialize: function(element, dragStartTarget, preventOutline, options) {
                    setOptions(this, options), this._element = element, this._dragStartTarget = dragStartTarget || element, 
                    this._preventOutline = preventOutline;
                },
                enable: function() {
                    this._enabled || (on(this._dragStartTarget, START, this._onDown, this), this._enabled = !0);
                },
                disable: function() {
                    this._enabled && (Draggable._dragging === this && this.finishDrag(!0), off(this._dragStartTarget, START, this._onDown, this), 
                    this._enabled = !1, this._moved = !1);
                },
                _onDown: function(e) {
                    if (this._enabled && (this._moved = !1, !hasClass(this._element, "leaflet-zoom-anim"))) if (e.touches && 1 !== e.touches.length) Draggable._dragging === this && this.finishDrag(); else if (!(Draggable._dragging || e.shiftKey || 1 !== e.which && 1 !== e.button && !e.touches || (Draggable._dragging = this, 
                    this._preventOutline && preventOutline(this._element), disableImageDrag(), disableTextSelection(), 
                    this._moving))) {
                        this.fire("down");
                        var first = e.touches ? e.touches[0] : e, sizedParent = getSizedParentNode(this._element);
                        this._startPoint = new Point(first.clientX, first.clientY), this._startPos = getPosition(this._element), 
                        this._parentScale = getScale(sizedParent);
                        var mouseevent = "mousedown" === e.type;
                        on(document, mouseevent ? "mousemove" : "touchmove", this._onMove, this), on(document, mouseevent ? "mouseup" : "touchend touchcancel", this._onUp, this);
                    }
                },
                _onMove: function(e) {
                    if (this._enabled) if (e.touches && e.touches.length > 1) this._moved = !0; else {
                        var first = e.touches && 1 === e.touches.length ? e.touches[0] : e, offset = new Point(first.clientX, first.clientY)._subtract(this._startPoint);
                        (offset.x || offset.y) && (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance || (offset.x /= this._parentScale.x, 
                        offset.y /= this._parentScale.y, preventDefault(e), this._moved || (this.fire("dragstart"), 
                        this._moved = !0, addClass(document.body, "leaflet-dragging"), this._lastTarget = e.target || e.srcElement, 
                        window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), 
                        addClass(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(offset), 
                        this._moving = !0, this._lastEvent = e, this._updatePosition()));
                    }
                },
                _updatePosition: function() {
                    var e = {
                        originalEvent: this._lastEvent
                    };
                    this.fire("predrag", e), setPosition(this._element, this._newPos), this.fire("drag", e);
                },
                _onUp: function() {
                    this._enabled && this.finishDrag();
                },
                finishDrag: function(noInertia) {
                    removeClass(document.body, "leaflet-dragging"), this._lastTarget && (removeClass(this._lastTarget, "leaflet-drag-target"), 
                    this._lastTarget = null), off(document, "mousemove touchmove", this._onMove, this), 
                    off(document, "mouseup touchend touchcancel", this._onUp, this), enableImageDrag(), 
                    enableTextSelection();
                    var fireDragend = this._moved && this._moving;
                    this._moving = !1, Draggable._dragging = !1, fireDragend && this.fire("dragend", {
                        noInertia,
                        distance: this._newPos.distanceTo(this._startPos)
                    });
                }
            });
            function clipPolygon(points, bounds, round) {
                var clippedPoints, i, j, k, a, b, len, edge, p, edges = [ 1, 4, 2, 8 ];
                for (i = 0, len = points.length; i < len; i++) points[i]._code = _getBitCode(points[i], bounds);
                for (k = 0; k < 4; k++) {
                    for (edge = edges[k], clippedPoints = [], i = 0, j = (len = points.length) - 1; i < len; j = i++) a = points[i], 
                    b = points[j], a._code & edge ? b._code & edge || ((p = _getEdgeIntersection(b, a, edge, bounds, round))._code = _getBitCode(p, bounds), 
                    clippedPoints.push(p)) : (b._code & edge && ((p = _getEdgeIntersection(b, a, edge, bounds, round))._code = _getBitCode(p, bounds), 
                    clippedPoints.push(p)), clippedPoints.push(a));
                    points = clippedPoints;
                }
                return points;
            }
            function polygonCenter(latlngs, crs) {
                var i, j, p1, p2, f, area, x, y, center;
                if (!latlngs || 0 === latlngs.length) throw new Error("latlngs not passed");
                isFlat(latlngs) || (console.warn("latlngs are not flat! Only the first ring will be used"), 
                latlngs = latlngs[0]);
                var centroidLatLng = toLatLng([ 0, 0 ]), bounds = toLatLngBounds(latlngs);
                bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest()) < 1700 && (centroidLatLng = centroid(latlngs));
                var len = latlngs.length, points = [];
                for (i = 0; i < len; i++) {
                    var latlng = toLatLng(latlngs[i]);
                    points.push(crs.project(toLatLng([ latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng ])));
                }
                for (area = x = y = 0, i = 0, j = len - 1; i < len; j = i++) p1 = points[i], p2 = points[j], 
                f = p1.y * p2.x - p2.y * p1.x, x += (p1.x + p2.x) * f, y += (p1.y + p2.y) * f, area += 3 * f;
                center = 0 === area ? points[0] : [ x / area, y / area ];
                var latlngCenter = crs.unproject(toPoint(center));
                return toLatLng([ latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng ]);
            }
            function centroid(coords) {
                for (var latSum = 0, lngSum = 0, len = 0, i = 0; i < coords.length; i++) {
                    var latlng = toLatLng(coords[i]);
                    latSum += latlng.lat, lngSum += latlng.lng, len++;
                }
                return toLatLng([ latSum / len, lngSum / len ]);
            }
            var _lastCode, PolyUtil = {
                __proto__: null,
                clipPolygon,
                polygonCenter,
                centroid
            };
            function simplify(points, tolerance) {
                if (!tolerance || !points.length) return points.slice();
                var sqTolerance = tolerance * tolerance;
                return points = _simplifyDP(points = _reducePoints(points, sqTolerance), sqTolerance);
            }
            function pointToSegmentDistance(p, p1, p2) {
                return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, !0));
            }
            function closestPointOnSegment(p, p1, p2) {
                return _sqClosestPointOnSegment(p, p1, p2);
            }
            function _simplifyDP(points, sqTolerance) {
                var len = points.length, markers = new (typeof Uint8Array != void 0 + "" ? Uint8Array : Array)(len);
                markers[0] = markers[len - 1] = 1, _simplifyDPStep(points, markers, sqTolerance, 0, len - 1);
                var i, newPoints = [];
                for (i = 0; i < len; i++) markers[i] && newPoints.push(points[i]);
                return newPoints;
            }
            function _simplifyDPStep(points, markers, sqTolerance, first, last) {
                var index, i, sqDist, maxSqDist = 0;
                for (i = first + 1; i <= last - 1; i++) (sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], !0)) > maxSqDist && (index = i, 
                maxSqDist = sqDist);
                maxSqDist > sqTolerance && (markers[index] = 1, _simplifyDPStep(points, markers, sqTolerance, first, index), 
                _simplifyDPStep(points, markers, sqTolerance, index, last));
            }
            function _reducePoints(points, sqTolerance) {
                for (var reducedPoints = [ points[0] ], i = 1, prev = 0, len = points.length; i < len; i++) _sqDist(points[i], points[prev]) > sqTolerance && (reducedPoints.push(points[i]), 
                prev = i);
                return prev < len - 1 && reducedPoints.push(points[len - 1]), reducedPoints;
            }
            function clipSegment(a, b, bounds, useLastCode, round) {
                var codeOut, p, newCode, codeA = useLastCode ? _lastCode : _getBitCode(a, bounds), codeB = _getBitCode(b, bounds);
                for (_lastCode = codeB; ;) {
                    if (!(codeA | codeB)) return [ a, b ];
                    if (codeA & codeB) return !1;
                    newCode = _getBitCode(p = _getEdgeIntersection(a, b, codeOut = codeA || codeB, bounds, round), bounds), 
                    codeOut === codeA ? (a = p, codeA = newCode) : (b = p, codeB = newCode);
                }
            }
            function _getEdgeIntersection(a, b, code, bounds, round) {
                var x, y, dx = b.x - a.x, dy = b.y - a.y, min = bounds.min, max = bounds.max;
                return 8 & code ? (x = a.x + dx * (max.y - a.y) / dy, y = max.y) : 4 & code ? (x = a.x + dx * (min.y - a.y) / dy, 
                y = min.y) : 2 & code ? (x = max.x, y = a.y + dy * (max.x - a.x) / dx) : 1 & code && (x = min.x, 
                y = a.y + dy * (min.x - a.x) / dx), new Point(x, y, round);
            }
            function _getBitCode(p, bounds) {
                var code = 0;
                return p.x < bounds.min.x ? code |= 1 : p.x > bounds.max.x && (code |= 2), p.y < bounds.min.y ? code |= 4 : p.y > bounds.max.y && (code |= 8), 
                code;
            }
            function _sqDist(p1, p2) {
                var dx = p2.x - p1.x, dy = p2.y - p1.y;
                return dx * dx + dy * dy;
            }
            function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
                var t, x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y, dot = dx * dx + dy * dy;
                return dot > 0 && ((t = ((p.x - x) * dx + (p.y - y) * dy) / dot) > 1 ? (x = p2.x, 
                y = p2.y) : t > 0 && (x += dx * t, y += dy * t)), dx = p.x - x, dy = p.y - y, sqDist ? dx * dx + dy * dy : new Point(x, y);
            }
            function isFlat(latlngs) {
                return !isArray(latlngs[0]) || "object" != typeof latlngs[0][0] && void 0 !== latlngs[0][0];
            }
            function _flat(latlngs) {
                return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), 
                isFlat(latlngs);
            }
            function polylineCenter(latlngs, crs) {
                var i, halfDist, segDist, dist, p1, p2, ratio, center;
                if (!latlngs || 0 === latlngs.length) throw new Error("latlngs not passed");
                isFlat(latlngs) || (console.warn("latlngs are not flat! Only the first ring will be used"), 
                latlngs = latlngs[0]);
                var centroidLatLng = toLatLng([ 0, 0 ]), bounds = toLatLngBounds(latlngs);
                bounds.getNorthWest().distanceTo(bounds.getSouthWest()) * bounds.getNorthEast().distanceTo(bounds.getNorthWest()) < 1700 && (centroidLatLng = centroid(latlngs));
                var len = latlngs.length, points = [];
                for (i = 0; i < len; i++) {
                    var latlng = toLatLng(latlngs[i]);
                    points.push(crs.project(toLatLng([ latlng.lat - centroidLatLng.lat, latlng.lng - centroidLatLng.lng ])));
                }
                for (i = 0, halfDist = 0; i < len - 1; i++) halfDist += points[i].distanceTo(points[i + 1]) / 2;
                if (0 === halfDist) center = points[0]; else for (i = 0, dist = 0; i < len - 1; i++) if (p1 = points[i], 
                p2 = points[i + 1], (dist += segDist = p1.distanceTo(p2)) > halfDist) {
                    ratio = (dist - halfDist) / segDist, center = [ p2.x - ratio * (p2.x - p1.x), p2.y - ratio * (p2.y - p1.y) ];
                    break;
                }
                var latlngCenter = crs.unproject(toPoint(center));
                return toLatLng([ latlngCenter.lat + centroidLatLng.lat, latlngCenter.lng + centroidLatLng.lng ]);
            }
            var LineUtil = {
                __proto__: null,
                simplify,
                pointToSegmentDistance,
                closestPointOnSegment,
                clipSegment,
                _getEdgeIntersection,
                _getBitCode,
                _sqClosestPointOnSegment,
                isFlat,
                _flat,
                polylineCenter
            }, LonLat = {
                project: function(latlng) {
                    return new Point(latlng.lng, latlng.lat);
                },
                unproject: function(point) {
                    return new LatLng(point.y, point.x);
                },
                bounds: new Bounds([ -180, -90 ], [ 180, 90 ])
            }, Mercator = {
                R: 6378137,
                R_MINOR: 6356752.314245179,
                bounds: new Bounds([ -20037508.34279, -15496570.73972 ], [ 20037508.34279, 18764656.23138 ]),
                project: function(latlng) {
                    var d = Math.PI / 180, r = this.R, y = latlng.lat * d, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), con = e * Math.sin(y), ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
                    return y = -r * Math.log(Math.max(ts, 1e-10)), new Point(latlng.lng * d * r, y);
                },
                unproject: function(point) {
                    for (var con, d = 180 / Math.PI, r = this.R, tmp = this.R_MINOR / r, e = Math.sqrt(1 - tmp * tmp), ts = Math.exp(-point.y / r), phi = Math.PI / 2 - 2 * Math.atan(ts), i = 0, dphi = .1; i < 15 && Math.abs(dphi) > 1e-7; i++) con = e * Math.sin(phi), 
                    con = Math.pow((1 - con) / (1 + con), e / 2), phi += dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
                    return new LatLng(phi * d, point.x * d / r);
                }
            }, index = {
                __proto__: null,
                LonLat,
                Mercator,
                SphericalMercator
            }, EPSG3395 = extend({}, Earth, {
                code: "EPSG:3395",
                projection: Mercator,
                transformation: function() {
                    var scale = .5 / (Math.PI * Mercator.R);
                    return toTransformation(scale, .5, -scale, .5);
                }()
            }), EPSG4326 = extend({}, Earth, {
                code: "EPSG:4326",
                projection: LonLat,
                transformation: toTransformation(1 / 180, 1, -1 / 180, .5)
            }), Simple = extend({}, CRS, {
                projection: LonLat,
                transformation: toTransformation(1, 0, -1, 0),
                scale: function(zoom) {
                    return Math.pow(2, zoom);
                },
                zoom: function(scale) {
                    return Math.log(scale) / Math.LN2;
                },
                distance: function(latlng1, latlng2) {
                    var dx = latlng2.lng - latlng1.lng, dy = latlng2.lat - latlng1.lat;
                    return Math.sqrt(dx * dx + dy * dy);
                },
                infinite: !0
            });
            CRS.Earth = Earth, CRS.EPSG3395 = EPSG3395, CRS.EPSG3857 = EPSG3857, CRS.EPSG900913 = EPSG900913, 
            CRS.EPSG4326 = EPSG4326, CRS.Simple = Simple;
            var Layer = Evented.extend({
                options: {
                    pane: "overlayPane",
                    attribution: null,
                    bubblingMouseEvents: !0
                },
                addTo: function(map) {
                    return map.addLayer(this), this;
                },
                remove: function() {
                    return this.removeFrom(this._map || this._mapToAdd);
                },
                removeFrom: function(obj) {
                    return obj && obj.removeLayer(this), this;
                },
                getPane: function(name) {
                    return this._map.getPane(name ? this.options[name] || name : this.options.pane);
                },
                addInteractiveTarget: function(targetEl) {
                    return this._map._targets[stamp(targetEl)] = this, this;
                },
                removeInteractiveTarget: function(targetEl) {
                    return delete this._map._targets[stamp(targetEl)], this;
                },
                getAttribution: function() {
                    return this.options.attribution;
                },
                _layerAdd: function(e) {
                    var map = e.target;
                    if (map.hasLayer(this)) {
                        if (this._map = map, this._zoomAnimated = map._zoomAnimated, this.getEvents) {
                            var events = this.getEvents();
                            map.on(events, this), this.once("remove", (function() {
                                map.off(events, this);
                            }), this);
                        }
                        this.onAdd(map), this.fire("add"), map.fire("layeradd", {
                            layer: this
                        });
                    }
                }
            });
            Map.include({
                addLayer: function(layer) {
                    if (!layer._layerAdd) throw new Error("The provided object is not a Layer.");
                    var id = stamp(layer);
                    return this._layers[id] || (this._layers[id] = layer, layer._mapToAdd = this, layer.beforeAdd && layer.beforeAdd(this), 
                    this.whenReady(layer._layerAdd, layer)), this;
                },
                removeLayer: function(layer) {
                    var id = stamp(layer);
                    return this._layers[id] ? (this._loaded && layer.onRemove(this), delete this._layers[id], 
                    this._loaded && (this.fire("layerremove", {
                        layer
                    }), layer.fire("remove")), layer._map = layer._mapToAdd = null, this) : this;
                },
                hasLayer: function(layer) {
                    return stamp(layer) in this._layers;
                },
                eachLayer: function(method, context) {
                    for (var i in this._layers) method.call(context, this._layers[i]);
                    return this;
                },
                _addLayers: function(layers) {
                    for (var i = 0, len = (layers = layers ? isArray(layers) ? layers : [ layers ] : []).length; i < len; i++) this.addLayer(layers[i]);
                },
                _addZoomLimit: function(layer) {
                    isNaN(layer.options.maxZoom) && isNaN(layer.options.minZoom) || (this._zoomBoundLayers[stamp(layer)] = layer, 
                    this._updateZoomLevels());
                },
                _removeZoomLimit: function(layer) {
                    var id = stamp(layer);
                    this._zoomBoundLayers[id] && (delete this._zoomBoundLayers[id], this._updateZoomLevels());
                },
                _updateZoomLevels: function() {
                    var minZoom = 1 / 0, maxZoom = -1 / 0, oldZoomSpan = this._getZoomSpan();
                    for (var i in this._zoomBoundLayers) {
                        var options = this._zoomBoundLayers[i].options;
                        minZoom = void 0 === options.minZoom ? minZoom : Math.min(minZoom, options.minZoom), 
                        maxZoom = void 0 === options.maxZoom ? maxZoom : Math.max(maxZoom, options.maxZoom);
                    }
                    this._layersMaxZoom = maxZoom === -1 / 0 ? void 0 : maxZoom, this._layersMinZoom = minZoom === 1 / 0 ? void 0 : minZoom, 
                    oldZoomSpan !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), 
                    void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);
                }
            });
            var LayerGroup = Layer.extend({
                initialize: function(layers, options) {
                    var i, len;
                    if (setOptions(this, options), this._layers = {}, layers) for (i = 0, len = layers.length; i < len; i++) this.addLayer(layers[i]);
                },
                addLayer: function(layer) {
                    var id = this.getLayerId(layer);
                    return this._layers[id] = layer, this._map && this._map.addLayer(layer), this;
                },
                removeLayer: function(layer) {
                    var id = layer in this._layers ? layer : this.getLayerId(layer);
                    return this._map && this._layers[id] && this._map.removeLayer(this._layers[id]), 
                    delete this._layers[id], this;
                },
                hasLayer: function(layer) {
                    return ("number" == typeof layer ? layer : this.getLayerId(layer)) in this._layers;
                },
                clearLayers: function() {
                    return this.eachLayer(this.removeLayer, this);
                },
                invoke: function(methodName) {
                    var i, layer, args = Array.prototype.slice.call(arguments, 1);
                    for (i in this._layers) (layer = this._layers[i])[methodName] && layer[methodName].apply(layer, args);
                    return this;
                },
                onAdd: function(map) {
                    this.eachLayer(map.addLayer, map);
                },
                onRemove: function(map) {
                    this.eachLayer(map.removeLayer, map);
                },
                eachLayer: function(method, context) {
                    for (var i in this._layers) method.call(context, this._layers[i]);
                    return this;
                },
                getLayer: function(id) {
                    return this._layers[id];
                },
                getLayers: function() {
                    var layers = [];
                    return this.eachLayer(layers.push, layers), layers;
                },
                setZIndex: function(zIndex) {
                    return this.invoke("setZIndex", zIndex);
                },
                getLayerId: function(layer) {
                    return stamp(layer);
                }
            }), layerGroup = function(layers, options) {
                return new LayerGroup(layers, options);
            }, FeatureGroup = LayerGroup.extend({
                addLayer: function(layer) {
                    return this.hasLayer(layer) ? this : (layer.addEventParent(this), LayerGroup.prototype.addLayer.call(this, layer), 
                    this.fire("layeradd", {
                        layer
                    }));
                },
                removeLayer: function(layer) {
                    return this.hasLayer(layer) ? (layer in this._layers && (layer = this._layers[layer]), 
                    layer.removeEventParent(this), LayerGroup.prototype.removeLayer.call(this, layer), 
                    this.fire("layerremove", {
                        layer
                    })) : this;
                },
                setStyle: function(style) {
                    return this.invoke("setStyle", style);
                },
                bringToFront: function() {
                    return this.invoke("bringToFront");
                },
                bringToBack: function() {
                    return this.invoke("bringToBack");
                },
                getBounds: function() {
                    var bounds = new LatLngBounds;
                    for (var id in this._layers) {
                        var layer = this._layers[id];
                        bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
                    }
                    return bounds;
                }
            }), featureGroup = function(layers, options) {
                return new FeatureGroup(layers, options);
            }, Icon = Class.extend({
                options: {
                    popupAnchor: [ 0, 0 ],
                    tooltipAnchor: [ 0, 0 ],
                    crossOrigin: !1
                },
                initialize: function(options) {
                    setOptions(this, options);
                },
                createIcon: function(oldIcon) {
                    return this._createIcon("icon", oldIcon);
                },
                createShadow: function(oldIcon) {
                    return this._createIcon("shadow", oldIcon);
                },
                _createIcon: function(name, oldIcon) {
                    var src = this._getIconUrl(name);
                    if (!src) {
                        if ("icon" === name) throw new Error("iconUrl not set in Icon options (see the docs).");
                        return null;
                    }
                    var img = this._createImg(src, oldIcon && "IMG" === oldIcon.tagName ? oldIcon : null);
                    return this._setIconStyles(img, name), (this.options.crossOrigin || "" === this.options.crossOrigin) && (img.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), 
                    img;
                },
                _setIconStyles: function(img, name) {
                    var options = this.options, sizeOption = options[name + "Size"];
                    "number" == typeof sizeOption && (sizeOption = [ sizeOption, sizeOption ]);
                    var size = toPoint(sizeOption), anchor = toPoint("shadow" === name && options.shadowAnchor || options.iconAnchor || size && size.divideBy(2, !0));
                    img.className = "leaflet-marker-" + name + " " + (options.className || ""), anchor && (img.style.marginLeft = -anchor.x + "px", 
                    img.style.marginTop = -anchor.y + "px"), size && (img.style.width = size.x + "px", 
                    img.style.height = size.y + "px");
                },
                _createImg: function(src, el) {
                    return (el = el || document.createElement("img")).src = src, el;
                },
                _getIconUrl: function(name) {
                    return Browser.retina && this.options[name + "RetinaUrl"] || this.options[name + "Url"];
                }
            });
            function icon(options) {
                return new Icon(options);
            }
            var IconDefault = Icon.extend({
                options: {
                    iconUrl: "marker-icon.png",
                    iconRetinaUrl: "marker-icon-2x.png",
                    shadowUrl: "marker-shadow.png",
                    iconSize: [ 25, 41 ],
                    iconAnchor: [ 12, 41 ],
                    popupAnchor: [ 1, -34 ],
                    tooltipAnchor: [ 16, -28 ],
                    shadowSize: [ 41, 41 ]
                },
                _getIconUrl: function(name) {
                    return "string" != typeof IconDefault.imagePath && (IconDefault.imagePath = this._detectIconPath()), 
                    (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
                },
                _stripUrl: function(path) {
                    var strip = function(str, re, idx) {
                        var match = re.exec(str);
                        return match && match[idx];
                    };
                    return (path = strip(path, /^url\((['"])?(.+)\1\)$/, 2)) && strip(path, /^(.*)marker-icon\.png$/, 1);
                },
                _detectIconPath: function() {
                    var el = create$1("div", "leaflet-default-icon-path", document.body), path = getStyle(el, "background-image") || getStyle(el, "backgroundImage");
                    if (document.body.removeChild(el), path = this._stripUrl(path)) return path;
                    var link = document.querySelector('link[href$="leaflet.css"]');
                    return link ? link.href.substring(0, link.href.length - 11 - 1) : "";
                }
            }), MarkerDrag = Handler.extend({
                initialize: function(marker) {
                    this._marker = marker;
                },
                addHooks: function() {
                    var icon = this._marker._icon;
                    this._draggable || (this._draggable = new Draggable(icon, icon, !0)), this._draggable.on({
                        dragstart: this._onDragStart,
                        predrag: this._onPreDrag,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this).enable(), addClass(icon, "leaflet-marker-draggable");
                },
                removeHooks: function() {
                    this._draggable.off({
                        dragstart: this._onDragStart,
                        predrag: this._onPreDrag,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this).disable(), this._marker._icon && removeClass(this._marker._icon, "leaflet-marker-draggable");
                },
                moved: function() {
                    return this._draggable && this._draggable._moved;
                },
                _adjustPan: function(e) {
                    var marker = this._marker, map = marker._map, speed = this._marker.options.autoPanSpeed, padding = this._marker.options.autoPanPadding, iconPos = getPosition(marker._icon), bounds = map.getPixelBounds(), origin = map.getPixelOrigin(), panBounds = toBounds(bounds.min._subtract(origin).add(padding), bounds.max._subtract(origin).subtract(padding));
                    if (!panBounds.contains(iconPos)) {
                        var movement = toPoint((Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) - (Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x), (Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) - (Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)).multiplyBy(speed);
                        map.panBy(movement, {
                            animate: !1
                        }), this._draggable._newPos._add(movement), this._draggable._startPos._add(movement), 
                        setPosition(marker._icon, this._draggable._newPos), this._onDrag(e), this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
                    }
                },
                _onDragStart: function() {
                    this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), 
                    this._marker.fire("movestart").fire("dragstart");
                },
                _onPreDrag: function(e) {
                    this._marker.options.autoPan && (cancelAnimFrame(this._panRequest), this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e)));
                },
                _onDrag: function(e) {
                    var marker = this._marker, shadow = marker._shadow, iconPos = getPosition(marker._icon), latlng = marker._map.layerPointToLatLng(iconPos);
                    shadow && setPosition(shadow, iconPos), marker._latlng = latlng, e.latlng = latlng, 
                    e.oldLatLng = this._oldLatLng, marker.fire("move", e).fire("drag", e);
                },
                _onDragEnd: function(e) {
                    cancelAnimFrame(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", e);
                }
            }), Marker = Layer.extend({
                options: {
                    icon: new IconDefault,
                    interactive: !0,
                    keyboard: !0,
                    title: "",
                    alt: "Marker",
                    zIndexOffset: 0,
                    opacity: 1,
                    riseOnHover: !1,
                    riseOffset: 250,
                    pane: "markerPane",
                    shadowPane: "shadowPane",
                    bubblingMouseEvents: !1,
                    autoPanOnFocus: !0,
                    draggable: !1,
                    autoPan: !1,
                    autoPanPadding: [ 50, 50 ],
                    autoPanSpeed: 10
                },
                initialize: function(latlng, options) {
                    setOptions(this, options), this._latlng = toLatLng(latlng);
                },
                onAdd: function(map) {
                    this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation, this._zoomAnimated && map.on("zoomanim", this._animateZoom, this), 
                    this._initIcon(), this.update();
                },
                onRemove: function(map) {
                    this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), 
                    delete this.dragging, this._zoomAnimated && map.off("zoomanim", this._animateZoom, this), 
                    this._removeIcon(), this._removeShadow();
                },
                getEvents: function() {
                    return {
                        zoom: this.update,
                        viewreset: this.update
                    };
                },
                getLatLng: function() {
                    return this._latlng;
                },
                setLatLng: function(latlng) {
                    var oldLatLng = this._latlng;
                    return this._latlng = toLatLng(latlng), this.update(), this.fire("move", {
                        oldLatLng,
                        latlng: this._latlng
                    });
                },
                setZIndexOffset: function(offset) {
                    return this.options.zIndexOffset = offset, this.update();
                },
                getIcon: function() {
                    return this.options.icon;
                },
                setIcon: function(icon) {
                    return this.options.icon = icon, this._map && (this._initIcon(), this.update()), 
                    this._popup && this.bindPopup(this._popup, this._popup.options), this;
                },
                getElement: function() {
                    return this._icon;
                },
                update: function() {
                    if (this._icon && this._map) {
                        var pos = this._map.latLngToLayerPoint(this._latlng).round();
                        this._setPos(pos);
                    }
                    return this;
                },
                _initIcon: function() {
                    var options = this.options, classToAdd = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), icon = options.icon.createIcon(this._icon), addIcon = !1;
                    icon !== this._icon && (this._icon && this._removeIcon(), addIcon = !0, options.title && (icon.title = options.title), 
                    "IMG" === icon.tagName && (icon.alt = options.alt || "")), addClass(icon, classToAdd), 
                    options.keyboard && (icon.tabIndex = "0", icon.setAttribute("role", "button")), 
                    this._icon = icon, options.riseOnHover && this.on({
                        mouseover: this._bringToFront,
                        mouseout: this._resetZIndex
                    }), this.options.autoPanOnFocus && on(icon, "focus", this._panOnFocus, this);
                    var newShadow = options.icon.createShadow(this._shadow), addShadow = !1;
                    newShadow !== this._shadow && (this._removeShadow(), addShadow = !0), newShadow && (addClass(newShadow, classToAdd), 
                    newShadow.alt = ""), this._shadow = newShadow, options.opacity < 1 && this._updateOpacity(), 
                    addIcon && this.getPane().appendChild(this._icon), this._initInteraction(), newShadow && addShadow && this.getPane(options.shadowPane).appendChild(this._shadow);
                },
                _removeIcon: function() {
                    this.options.riseOnHover && this.off({
                        mouseover: this._bringToFront,
                        mouseout: this._resetZIndex
                    }), this.options.autoPanOnFocus && off(this._icon, "focus", this._panOnFocus, this), 
                    remove(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;
                },
                _removeShadow: function() {
                    this._shadow && remove(this._shadow), this._shadow = null;
                },
                _setPos: function(pos) {
                    this._icon && setPosition(this._icon, pos), this._shadow && setPosition(this._shadow, pos), 
                    this._zIndex = pos.y + this.options.zIndexOffset, this._resetZIndex();
                },
                _updateZIndex: function(offset) {
                    this._icon && (this._icon.style.zIndex = this._zIndex + offset);
                },
                _animateZoom: function(opt) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();
                    this._setPos(pos);
                },
                _initInteraction: function() {
                    if (this.options.interactive && (addClass(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), 
                    MarkerDrag)) {
                        var draggable = this.options.draggable;
                        this.dragging && (draggable = this.dragging.enabled(), this.dragging.disable()), 
                        this.dragging = new MarkerDrag(this), draggable && this.dragging.enable();
                    }
                },
                setOpacity: function(opacity) {
                    return this.options.opacity = opacity, this._map && this._updateOpacity(), this;
                },
                _updateOpacity: function() {
                    var opacity = this.options.opacity;
                    this._icon && setOpacity(this._icon, opacity), this._shadow && setOpacity(this._shadow, opacity);
                },
                _bringToFront: function() {
                    this._updateZIndex(this.options.riseOffset);
                },
                _resetZIndex: function() {
                    this._updateZIndex(0);
                },
                _panOnFocus: function() {
                    var map = this._map;
                    if (map) {
                        var iconOpts = this.options.icon.options, size = iconOpts.iconSize ? toPoint(iconOpts.iconSize) : toPoint(0, 0), anchor = iconOpts.iconAnchor ? toPoint(iconOpts.iconAnchor) : toPoint(0, 0);
                        map.panInside(this._latlng, {
                            paddingTopLeft: anchor,
                            paddingBottomRight: size.subtract(anchor)
                        });
                    }
                },
                _getPopupAnchor: function() {
                    return this.options.icon.options.popupAnchor;
                },
                _getTooltipAnchor: function() {
                    return this.options.icon.options.tooltipAnchor;
                }
            });
            function marker(latlng, options) {
                return new Marker(latlng, options);
            }
            var Path = Layer.extend({
                options: {
                    stroke: !0,
                    color: "#3388ff",
                    weight: 3,
                    opacity: 1,
                    lineCap: "round",
                    lineJoin: "round",
                    dashArray: null,
                    dashOffset: null,
                    fill: !1,
                    fillColor: null,
                    fillOpacity: .2,
                    fillRule: "evenodd",
                    interactive: !0,
                    bubblingMouseEvents: !0
                },
                beforeAdd: function(map) {
                    this._renderer = map.getRenderer(this);
                },
                onAdd: function() {
                    this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);
                },
                onRemove: function() {
                    this._renderer._removePath(this);
                },
                redraw: function() {
                    return this._map && this._renderer._updatePath(this), this;
                },
                setStyle: function(style) {
                    return setOptions(this, style), this._renderer && (this._renderer._updateStyle(this), 
                    this.options.stroke && style && Object.prototype.hasOwnProperty.call(style, "weight") && this._updateBounds()), 
                    this;
                },
                bringToFront: function() {
                    return this._renderer && this._renderer._bringToFront(this), this;
                },
                bringToBack: function() {
                    return this._renderer && this._renderer._bringToBack(this), this;
                },
                getElement: function() {
                    return this._path;
                },
                _reset: function() {
                    this._project(), this._update();
                },
                _clickTolerance: function() {
                    return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0);
                }
            }), CircleMarker = Path.extend({
                options: {
                    fill: !0,
                    radius: 10
                },
                initialize: function(latlng, options) {
                    setOptions(this, options), this._latlng = toLatLng(latlng), this._radius = this.options.radius;
                },
                setLatLng: function(latlng) {
                    var oldLatLng = this._latlng;
                    return this._latlng = toLatLng(latlng), this.redraw(), this.fire("move", {
                        oldLatLng,
                        latlng: this._latlng
                    });
                },
                getLatLng: function() {
                    return this._latlng;
                },
                setRadius: function(radius) {
                    return this.options.radius = this._radius = radius, this.redraw();
                },
                getRadius: function() {
                    return this._radius;
                },
                setStyle: function(options) {
                    var radius = options && options.radius || this._radius;
                    return Path.prototype.setStyle.call(this, options), this.setRadius(radius), this;
                },
                _project: function() {
                    this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();
                },
                _updateBounds: function() {
                    var r = this._radius, r2 = this._radiusY || r, w = this._clickTolerance(), p = [ r + w, r2 + w ];
                    this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
                },
                _update: function() {
                    this._map && this._updatePath();
                },
                _updatePath: function() {
                    this._renderer._updateCircle(this);
                },
                _empty: function() {
                    return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
                },
                _containsPoint: function(p) {
                    return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
                }
            });
            function circleMarker(latlng, options) {
                return new CircleMarker(latlng, options);
            }
            var Circle = CircleMarker.extend({
                initialize: function(latlng, options, legacyOptions) {
                    if ("number" == typeof options && (options = extend({}, legacyOptions, {
                        radius: options
                    })), setOptions(this, options), this._latlng = toLatLng(latlng), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN");
                    this._mRadius = this.options.radius;
                },
                setRadius: function(radius) {
                    return this._mRadius = radius, this.redraw();
                },
                getRadius: function() {
                    return this._mRadius;
                },
                getBounds: function() {
                    var half = [ this._radius, this._radiusY || this._radius ];
                    return new LatLngBounds(this._map.layerPointToLatLng(this._point.subtract(half)), this._map.layerPointToLatLng(this._point.add(half)));
                },
                setStyle: Path.prototype.setStyle,
                _project: function() {
                    var lng = this._latlng.lng, lat = this._latlng.lat, map = this._map, crs = map.options.crs;
                    if (crs.distance === Earth.distance) {
                        var d = Math.PI / 180, latR = this._mRadius / Earth.R / d, top = map.project([ lat + latR, lng ]), bottom = map.project([ lat - latR, lng ]), p = top.add(bottom).divideBy(2), lat2 = map.unproject(p).lat, lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) / (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;
                        (isNaN(lngR) || 0 === lngR) && (lngR = latR / Math.cos(Math.PI / 180 * lat)), this._point = p.subtract(map.getPixelOrigin()), 
                        this._radius = isNaN(lngR) ? 0 : p.x - map.project([ lat2, lng - lngR ]).x, this._radiusY = p.y - top.y;
                    } else {
                        var latlng2 = crs.unproject(crs.project(this._latlng).subtract([ this._mRadius, 0 ]));
                        this._point = map.latLngToLayerPoint(this._latlng), this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
                    }
                    this._updateBounds();
                }
            });
            function circle(latlng, options, legacyOptions) {
                return new Circle(latlng, options, legacyOptions);
            }
            var Polyline = Path.extend({
                options: {
                    smoothFactor: 1,
                    noClip: !1
                },
                initialize: function(latlngs, options) {
                    setOptions(this, options), this._setLatLngs(latlngs);
                },
                getLatLngs: function() {
                    return this._latlngs;
                },
                setLatLngs: function(latlngs) {
                    return this._setLatLngs(latlngs), this.redraw();
                },
                isEmpty: function() {
                    return !this._latlngs.length;
                },
                closestLayerPoint: function(p) {
                    for (var p1, p2, minDistance = 1 / 0, minPoint = null, closest = _sqClosestPointOnSegment, j = 0, jLen = this._parts.length; j < jLen; j++) for (var points = this._parts[j], i = 1, len = points.length; i < len; i++) {
                        var sqDist = closest(p, p1 = points[i - 1], p2 = points[i], !0);
                        sqDist < minDistance && (minDistance = sqDist, minPoint = closest(p, p1, p2));
                    }
                    return minPoint && (minPoint.distance = Math.sqrt(minDistance)), minPoint;
                },
                getCenter: function() {
                    if (!this._map) throw new Error("Must add layer to map before using getCenter()");
                    return polylineCenter(this._defaultShape(), this._map.options.crs);
                },
                getBounds: function() {
                    return this._bounds;
                },
                addLatLng: function(latlng, latlngs) {
                    return latlngs = latlngs || this._defaultShape(), latlng = toLatLng(latlng), latlngs.push(latlng), 
                    this._bounds.extend(latlng), this.redraw();
                },
                _setLatLngs: function(latlngs) {
                    this._bounds = new LatLngBounds, this._latlngs = this._convertLatLngs(latlngs);
                },
                _defaultShape: function() {
                    return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
                },
                _convertLatLngs: function(latlngs) {
                    for (var result = [], flat = isFlat(latlngs), i = 0, len = latlngs.length; i < len; i++) flat ? (result[i] = toLatLng(latlngs[i]), 
                    this._bounds.extend(result[i])) : result[i] = this._convertLatLngs(latlngs[i]);
                    return result;
                },
                _project: function() {
                    var pxBounds = new Bounds;
                    this._rings = [], this._projectLatlngs(this._latlngs, this._rings, pxBounds), this._bounds.isValid() && pxBounds.isValid() && (this._rawPxBounds = pxBounds, 
                    this._updateBounds());
                },
                _updateBounds: function() {
                    var w = this._clickTolerance(), p = new Point(w, w);
                    this._rawPxBounds && (this._pxBounds = new Bounds([ this._rawPxBounds.min.subtract(p), this._rawPxBounds.max.add(p) ]));
                },
                _projectLatlngs: function(latlngs, result, projectedBounds) {
                    var i, ring, flat = latlngs[0] instanceof LatLng, len = latlngs.length;
                    if (flat) {
                        for (ring = [], i = 0; i < len; i++) ring[i] = this._map.latLngToLayerPoint(latlngs[i]), 
                        projectedBounds.extend(ring[i]);
                        result.push(ring);
                    } else for (i = 0; i < len; i++) this._projectLatlngs(latlngs[i], result, projectedBounds);
                },
                _clipPoints: function() {
                    var bounds = this._renderer._bounds;
                    if (this._parts = [], this._pxBounds && this._pxBounds.intersects(bounds)) if (this.options.noClip) this._parts = this._rings; else {
                        var i, j, k, len, len2, segment, points, parts = this._parts;
                        for (i = 0, k = 0, len = this._rings.length; i < len; i++) for (j = 0, len2 = (points = this._rings[i]).length; j < len2 - 1; j++) (segment = clipSegment(points[j], points[j + 1], bounds, j, !0)) && (parts[k] = parts[k] || [], 
                        parts[k].push(segment[0]), segment[1] === points[j + 1] && j !== len2 - 2 || (parts[k].push(segment[1]), 
                        k++));
                    }
                },
                _simplifyPoints: function() {
                    for (var parts = this._parts, tolerance = this.options.smoothFactor, i = 0, len = parts.length; i < len; i++) parts[i] = simplify(parts[i], tolerance);
                },
                _update: function() {
                    this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());
                },
                _updatePath: function() {
                    this._renderer._updatePoly(this);
                },
                _containsPoint: function(p, closed) {
                    var i, j, k, len, len2, part, w = this._clickTolerance();
                    if (!this._pxBounds || !this._pxBounds.contains(p)) return !1;
                    for (i = 0, len = this._parts.length; i < len; i++) for (j = 0, k = (len2 = (part = this._parts[i]).length) - 1; j < len2; k = j++) if ((closed || 0 !== j) && pointToSegmentDistance(p, part[k], part[j]) <= w) return !0;
                    return !1;
                }
            });
            function polyline(latlngs, options) {
                return new Polyline(latlngs, options);
            }
            Polyline._flat = _flat;
            var Polygon = Polyline.extend({
                options: {
                    fill: !0
                },
                isEmpty: function() {
                    return !this._latlngs.length || !this._latlngs[0].length;
                },
                getCenter: function() {
                    if (!this._map) throw new Error("Must add layer to map before using getCenter()");
                    return polygonCenter(this._defaultShape(), this._map.options.crs);
                },
                _convertLatLngs: function(latlngs) {
                    var result = Polyline.prototype._convertLatLngs.call(this, latlngs), len = result.length;
                    return len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1]) && result.pop(), 
                    result;
                },
                _setLatLngs: function(latlngs) {
                    Polyline.prototype._setLatLngs.call(this, latlngs), isFlat(this._latlngs) && (this._latlngs = [ this._latlngs ]);
                },
                _defaultShape: function() {
                    return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
                },
                _clipPoints: function() {
                    var bounds = this._renderer._bounds, w = this.options.weight, p = new Point(w, w);
                    if (bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p)), this._parts = [], 
                    this._pxBounds && this._pxBounds.intersects(bounds)) if (this.options.noClip) this._parts = this._rings; else for (var clipped, i = 0, len = this._rings.length; i < len; i++) (clipped = clipPolygon(this._rings[i], bounds, !0)).length && this._parts.push(clipped);
                },
                _updatePath: function() {
                    this._renderer._updatePoly(this, !0);
                },
                _containsPoint: function(p) {
                    var part, p1, p2, i, j, k, len, len2, inside = !1;
                    if (!this._pxBounds || !this._pxBounds.contains(p)) return !1;
                    for (i = 0, len = this._parts.length; i < len; i++) for (j = 0, k = (len2 = (part = this._parts[i]).length) - 1; j < len2; k = j++) p1 = part[j], 
                    p2 = part[k], p1.y > p.y != p2.y > p.y && p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x && (inside = !inside);
                    return inside || Polyline.prototype._containsPoint.call(this, p, !0);
                }
            });
            function polygon(latlngs, options) {
                return new Polygon(latlngs, options);
            }
            var GeoJSON = FeatureGroup.extend({
                initialize: function(geojson, options) {
                    setOptions(this, options), this._layers = {}, geojson && this.addData(geojson);
                },
                addData: function(geojson) {
                    var i, len, feature, features = isArray(geojson) ? geojson : geojson.features;
                    if (features) {
                        for (i = 0, len = features.length; i < len; i++) ((feature = features[i]).geometries || feature.geometry || feature.features || feature.coordinates) && this.addData(feature);
                        return this;
                    }
                    var options = this.options;
                    if (options.filter && !options.filter(geojson)) return this;
                    var layer = geometryToLayer(geojson, options);
                    return layer ? (layer.feature = asFeature(geojson), layer.defaultOptions = layer.options, 
                    this.resetStyle(layer), options.onEachFeature && options.onEachFeature(geojson, layer), 
                    this.addLayer(layer)) : this;
                },
                resetStyle: function(layer) {
                    return void 0 === layer ? this.eachLayer(this.resetStyle, this) : (layer.options = extend({}, layer.defaultOptions), 
                    this._setLayerStyle(layer, this.options.style), this);
                },
                setStyle: function(style) {
                    return this.eachLayer((function(layer) {
                        this._setLayerStyle(layer, style);
                    }), this);
                },
                _setLayerStyle: function(layer, style) {
                    layer.setStyle && ("function" == typeof style && (style = style(layer.feature)), 
                    layer.setStyle(style));
                }
            });
            function geometryToLayer(geojson, options) {
                var latlng, latlngs, i, len, geometry = "Feature" === geojson.type ? geojson.geometry : geojson, coords = geometry ? geometry.coordinates : null, layers = [], pointToLayer = options && options.pointToLayer, _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng;
                if (!coords && !geometry) return null;
                switch (geometry.type) {
                  case "Point":
                    return _pointToLayer(pointToLayer, geojson, latlng = _coordsToLatLng(coords), options);

                  case "MultiPoint":
                    for (i = 0, len = coords.length; i < len; i++) latlng = _coordsToLatLng(coords[i]), 
                    layers.push(_pointToLayer(pointToLayer, geojson, latlng, options));
                    return new FeatureGroup(layers);

                  case "LineString":
                  case "MultiLineString":
                    return latlngs = coordsToLatLngs(coords, "LineString" === geometry.type ? 0 : 1, _coordsToLatLng), 
                    new Polyline(latlngs, options);

                  case "Polygon":
                  case "MultiPolygon":
                    return latlngs = coordsToLatLngs(coords, "Polygon" === geometry.type ? 1 : 2, _coordsToLatLng), 
                    new Polygon(latlngs, options);

                  case "GeometryCollection":
                    for (i = 0, len = geometry.geometries.length; i < len; i++) {
                        var geoLayer = geometryToLayer({
                            geometry: geometry.geometries[i],
                            type: "Feature",
                            properties: geojson.properties
                        }, options);
                        geoLayer && layers.push(geoLayer);
                    }
                    return new FeatureGroup(layers);

                  case "FeatureCollection":
                    for (i = 0, len = geometry.features.length; i < len; i++) {
                        var featureLayer = geometryToLayer(geometry.features[i], options);
                        featureLayer && layers.push(featureLayer);
                    }
                    return new FeatureGroup(layers);

                  default:
                    throw new Error("Invalid GeoJSON object.");
                }
            }
            function _pointToLayer(pointToLayerFn, geojson, latlng, options) {
                return pointToLayerFn ? pointToLayerFn(geojson, latlng) : new Marker(latlng, options && options.markersInheritOptions && options);
            }
            function coordsToLatLng(coords) {
                return new LatLng(coords[1], coords[0], coords[2]);
            }
            function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
                for (var latlng, latlngs = [], i = 0, len = coords.length; i < len; i++) latlng = levelsDeep ? coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) : (_coordsToLatLng || coordsToLatLng)(coords[i]), 
                latlngs.push(latlng);
                return latlngs;
            }
            function latLngToCoords(latlng, precision) {
                return void 0 !== (latlng = toLatLng(latlng)).alt ? [ formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision) ] : [ formatNum(latlng.lng, precision), formatNum(latlng.lat, precision) ];
            }
            function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
                for (var coords = [], i = 0, len = latlngs.length; i < len; i++) coords.push(levelsDeep ? latLngsToCoords(latlngs[i], isFlat(latlngs[i]) ? 0 : levelsDeep - 1, closed, precision) : latLngToCoords(latlngs[i], precision));
                return !levelsDeep && closed && coords.length > 0 && coords.push(coords[0].slice()), 
                coords;
            }
            function getFeature(layer, newGeometry) {
                return layer.feature ? extend({}, layer.feature, {
                    geometry: newGeometry
                }) : asFeature(newGeometry);
            }
            function asFeature(geojson) {
                return "Feature" === geojson.type || "FeatureCollection" === geojson.type ? geojson : {
                    type: "Feature",
                    properties: {},
                    geometry: geojson
                };
            }
            var PointToGeoJSON = {
                toGeoJSON: function(precision) {
                    return getFeature(this, {
                        type: "Point",
                        coordinates: latLngToCoords(this.getLatLng(), precision)
                    });
                }
            };
            function geoJSON(geojson, options) {
                return new GeoJSON(geojson, options);
            }
            Marker.include(PointToGeoJSON), Circle.include(PointToGeoJSON), CircleMarker.include(PointToGeoJSON), 
            Polyline.include({
                toGeoJSON: function(precision) {
                    var multi = !isFlat(this._latlngs);
                    return getFeature(this, {
                        type: (multi ? "Multi" : "") + "LineString",
                        coordinates: latLngsToCoords(this._latlngs, multi ? 1 : 0, !1, precision)
                    });
                }
            }), Polygon.include({
                toGeoJSON: function(precision) {
                    var holes = !isFlat(this._latlngs), multi = holes && !isFlat(this._latlngs[0]), coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, !0, precision);
                    return holes || (coords = [ coords ]), getFeature(this, {
                        type: (multi ? "Multi" : "") + "Polygon",
                        coordinates: coords
                    });
                }
            }), LayerGroup.include({
                toMultiPoint: function(precision) {
                    var coords = [];
                    return this.eachLayer((function(layer) {
                        coords.push(layer.toGeoJSON(precision).geometry.coordinates);
                    })), getFeature(this, {
                        type: "MultiPoint",
                        coordinates: coords
                    });
                },
                toGeoJSON: function(precision) {
                    var type = this.feature && this.feature.geometry && this.feature.geometry.type;
                    if ("MultiPoint" === type) return this.toMultiPoint(precision);
                    var isGeometryCollection = "GeometryCollection" === type, jsons = [];
                    return this.eachLayer((function(layer) {
                        if (layer.toGeoJSON) {
                            var json = layer.toGeoJSON(precision);
                            if (isGeometryCollection) jsons.push(json.geometry); else {
                                var feature = asFeature(json);
                                "FeatureCollection" === feature.type ? jsons.push.apply(jsons, feature.features) : jsons.push(feature);
                            }
                        }
                    })), isGeometryCollection ? getFeature(this, {
                        geometries: jsons,
                        type: "GeometryCollection"
                    }) : {
                        type: "FeatureCollection",
                        features: jsons
                    };
                }
            });
            var geoJson = geoJSON, ImageOverlay = Layer.extend({
                options: {
                    opacity: 1,
                    alt: "",
                    interactive: !1,
                    crossOrigin: !1,
                    errorOverlayUrl: "",
                    zIndex: 1,
                    className: ""
                },
                initialize: function(url, bounds, options) {
                    this._url = url, this._bounds = toLatLngBounds(bounds), setOptions(this, options);
                },
                onAdd: function() {
                    this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), 
                    this.options.interactive && (addClass(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), 
                    this.getPane().appendChild(this._image), this._reset();
                },
                onRemove: function() {
                    remove(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);
                },
                setOpacity: function(opacity) {
                    return this.options.opacity = opacity, this._image && this._updateOpacity(), this;
                },
                setStyle: function(styleOpts) {
                    return styleOpts.opacity && this.setOpacity(styleOpts.opacity), this;
                },
                bringToFront: function() {
                    return this._map && toFront(this._image), this;
                },
                bringToBack: function() {
                    return this._map && toBack(this._image), this;
                },
                setUrl: function(url) {
                    return this._url = url, this._image && (this._image.src = url), this;
                },
                setBounds: function(bounds) {
                    return this._bounds = toLatLngBounds(bounds), this._map && this._reset(), this;
                },
                getEvents: function() {
                    var events = {
                        zoom: this._reset,
                        viewreset: this._reset
                    };
                    return this._zoomAnimated && (events.zoomanim = this._animateZoom), events;
                },
                setZIndex: function(value) {
                    return this.options.zIndex = value, this._updateZIndex(), this;
                },
                getBounds: function() {
                    return this._bounds;
                },
                getElement: function() {
                    return this._image;
                },
                _initImage: function() {
                    var wasElementSupplied = "IMG" === this._url.tagName, img = this._image = wasElementSupplied ? this._url : create$1("img");
                    addClass(img, "leaflet-image-layer"), this._zoomAnimated && addClass(img, "leaflet-zoom-animated"), 
                    this.options.className && addClass(img, this.options.className), img.onselectstart = falseFn, 
                    img.onmousemove = falseFn, img.onload = bind(this.fire, this, "load"), img.onerror = bind(this._overlayOnError, this, "error"), 
                    (this.options.crossOrigin || "" === this.options.crossOrigin) && (img.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), 
                    this.options.zIndex && this._updateZIndex(), wasElementSupplied ? this._url = img.src : (img.src = this._url, 
                    img.alt = this.options.alt);
                },
                _animateZoom: function(e) {
                    var scale = this._map.getZoomScale(e.zoom), offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;
                    setTransform(this._image, offset, scale);
                },
                _reset: function() {
                    var image = this._image, bounds = new Bounds(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), size = bounds.getSize();
                    setPosition(image, bounds.min), image.style.width = size.x + "px", image.style.height = size.y + "px";
                },
                _updateOpacity: function() {
                    setOpacity(this._image, this.options.opacity);
                },
                _updateZIndex: function() {
                    this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex);
                },
                _overlayOnError: function() {
                    this.fire("error");
                    var errorUrl = this.options.errorOverlayUrl;
                    errorUrl && this._url !== errorUrl && (this._url = errorUrl, this._image.src = errorUrl);
                },
                getCenter: function() {
                    return this._bounds.getCenter();
                }
            }), imageOverlay = function(url, bounds, options) {
                return new ImageOverlay(url, bounds, options);
            }, VideoOverlay = ImageOverlay.extend({
                options: {
                    autoplay: !0,
                    loop: !0,
                    keepAspectRatio: !0,
                    muted: !1,
                    playsInline: !0
                },
                _initImage: function() {
                    var wasElementSupplied = "VIDEO" === this._url.tagName, vid = this._image = wasElementSupplied ? this._url : create$1("video");
                    if (addClass(vid, "leaflet-image-layer"), this._zoomAnimated && addClass(vid, "leaflet-zoom-animated"), 
                    this.options.className && addClass(vid, this.options.className), vid.onselectstart = falseFn, 
                    vid.onmousemove = falseFn, vid.onloadeddata = bind(this.fire, this, "load"), wasElementSupplied) {
                        for (var sourceElements = vid.getElementsByTagName("source"), sources = [], j = 0; j < sourceElements.length; j++) sources.push(sourceElements[j].src);
                        this._url = sourceElements.length > 0 ? sources : [ vid.src ];
                    } else {
                        isArray(this._url) || (this._url = [ this._url ]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(vid.style, "objectFit") && (vid.style.objectFit = "fill"), 
                        vid.autoplay = !!this.options.autoplay, vid.loop = !!this.options.loop, vid.muted = !!this.options.muted, 
                        vid.playsInline = !!this.options.playsInline;
                        for (var i = 0; i < this._url.length; i++) {
                            var source = create$1("source");
                            source.src = this._url[i], vid.appendChild(source);
                        }
                    }
                }
            });
            function videoOverlay(video, bounds, options) {
                return new VideoOverlay(video, bounds, options);
            }
            var SVGOverlay = ImageOverlay.extend({
                _initImage: function() {
                    var el = this._image = this._url;
                    addClass(el, "leaflet-image-layer"), this._zoomAnimated && addClass(el, "leaflet-zoom-animated"), 
                    this.options.className && addClass(el, this.options.className), el.onselectstart = falseFn, 
                    el.onmousemove = falseFn;
                }
            });
            function svgOverlay(el, bounds, options) {
                return new SVGOverlay(el, bounds, options);
            }
            var DivOverlay = Layer.extend({
                options: {
                    interactive: !1,
                    offset: [ 0, 0 ],
                    className: "",
                    pane: void 0,
                    content: ""
                },
                initialize: function(options, source) {
                    options && (options instanceof LatLng || isArray(options)) ? (this._latlng = toLatLng(options), 
                    setOptions(this, source)) : (setOptions(this, options), this._source = source), 
                    this.options.content && (this._content = this.options.content);
                },
                openOn: function(map) {
                    return (map = arguments.length ? map : this._source._map).hasLayer(this) || map.addLayer(this), 
                    this;
                },
                close: function() {
                    return this._map && this._map.removeLayer(this), this;
                },
                toggle: function(layer) {
                    return this._map ? this.close() : (arguments.length ? this._source = layer : layer = this._source, 
                    this._prepareOpen(), this.openOn(layer._map)), this;
                },
                onAdd: function(map) {
                    this._zoomAnimated = map._zoomAnimated, this._container || this._initLayout(), map._fadeAnimated && setOpacity(this._container, 0), 
                    clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), 
                    this.update(), map._fadeAnimated && setOpacity(this._container, 1), this.bringToFront(), 
                    this.options.interactive && (addClass(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container));
                },
                onRemove: function(map) {
                    map._fadeAnimated ? (setOpacity(this._container, 0), this._removeTimeout = setTimeout(bind(remove, void 0, this._container), 200)) : remove(this._container), 
                    this.options.interactive && (removeClass(this._container, "leaflet-interactive"), 
                    this.removeInteractiveTarget(this._container));
                },
                getLatLng: function() {
                    return this._latlng;
                },
                setLatLng: function(latlng) {
                    return this._latlng = toLatLng(latlng), this._map && (this._updatePosition(), this._adjustPan()), 
                    this;
                },
                getContent: function() {
                    return this._content;
                },
                setContent: function(content) {
                    return this._content = content, this.update(), this;
                },
                getElement: function() {
                    return this._container;
                },
                update: function() {
                    this._map && (this._container.style.visibility = "hidden", this._updateContent(), 
                    this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", 
                    this._adjustPan());
                },
                getEvents: function() {
                    var events = {
                        zoom: this._updatePosition,
                        viewreset: this._updatePosition
                    };
                    return this._zoomAnimated && (events.zoomanim = this._animateZoom), events;
                },
                isOpen: function() {
                    return !!this._map && this._map.hasLayer(this);
                },
                bringToFront: function() {
                    return this._map && toFront(this._container), this;
                },
                bringToBack: function() {
                    return this._map && toBack(this._container), this;
                },
                _prepareOpen: function(latlng) {
                    var source = this._source;
                    if (!source._map) return !1;
                    if (source instanceof FeatureGroup) {
                        source = null;
                        var layers = this._source._layers;
                        for (var id in layers) if (layers[id]._map) {
                            source = layers[id];
                            break;
                        }
                        if (!source) return !1;
                        this._source = source;
                    }
                    if (!latlng) if (source.getCenter) latlng = source.getCenter(); else if (source.getLatLng) latlng = source.getLatLng(); else {
                        if (!source.getBounds) throw new Error("Unable to get source layer LatLng.");
                        latlng = source.getBounds().getCenter();
                    }
                    return this.setLatLng(latlng), this._map && this.update(), !0;
                },
                _updateContent: function() {
                    if (this._content) {
                        var node = this._contentNode, content = "function" == typeof this._content ? this._content(this._source || this) : this._content;
                        if ("string" == typeof content) node.innerHTML = content; else {
                            for (;node.hasChildNodes(); ) node.removeChild(node.firstChild);
                            node.appendChild(content);
                        }
                        this.fire("contentupdate");
                    }
                },
                _updatePosition: function() {
                    if (this._map) {
                        var pos = this._map.latLngToLayerPoint(this._latlng), offset = toPoint(this.options.offset), anchor = this._getAnchor();
                        this._zoomAnimated ? setPosition(this._container, pos.add(anchor)) : offset = offset.add(pos).add(anchor);
                        var bottom = this._containerBottom = -offset.y, left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;
                        this._container.style.bottom = bottom + "px", this._container.style.left = left + "px";
                    }
                },
                _getAnchor: function() {
                    return [ 0, 0 ];
                }
            });
            Map.include({
                _initOverlay: function(OverlayClass, content, latlng, options) {
                    var overlay = content;
                    return overlay instanceof OverlayClass || (overlay = new OverlayClass(options).setContent(content)), 
                    latlng && overlay.setLatLng(latlng), overlay;
                }
            }), Layer.include({
                _initOverlay: function(OverlayClass, old, content, options) {
                    var overlay = content;
                    return overlay instanceof OverlayClass ? (setOptions(overlay, options), overlay._source = this) : (overlay = old && !options ? old : new OverlayClass(options, this)).setContent(content), 
                    overlay;
                }
            });
            var Popup = DivOverlay.extend({
                options: {
                    pane: "popupPane",
                    offset: [ 0, 7 ],
                    maxWidth: 300,
                    minWidth: 50,
                    maxHeight: null,
                    autoPan: !0,
                    autoPanPaddingTopLeft: null,
                    autoPanPaddingBottomRight: null,
                    autoPanPadding: [ 5, 5 ],
                    keepInView: !1,
                    closeButton: !0,
                    autoClose: !0,
                    closeOnEscapeKey: !0,
                    className: ""
                },
                openOn: function(map) {
                    return !(map = arguments.length ? map : this._source._map).hasLayer(this) && map._popup && map._popup.options.autoClose && map.removeLayer(map._popup), 
                    map._popup = this, DivOverlay.prototype.openOn.call(this, map);
                },
                onAdd: function(map) {
                    DivOverlay.prototype.onAdd.call(this, map), map.fire("popupopen", {
                        popup: this
                    }), this._source && (this._source.fire("popupopen", {
                        popup: this
                    }, !0), this._source instanceof Path || this._source.on("preclick", stopPropagation));
                },
                onRemove: function(map) {
                    DivOverlay.prototype.onRemove.call(this, map), map.fire("popupclose", {
                        popup: this
                    }), this._source && (this._source.fire("popupclose", {
                        popup: this
                    }, !0), this._source instanceof Path || this._source.off("preclick", stopPropagation));
                },
                getEvents: function() {
                    var events = DivOverlay.prototype.getEvents.call(this);
                    return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (events.preclick = this.close), 
                    this.options.keepInView && (events.moveend = this._adjustPan), events;
                },
                _initLayout: function() {
                    var prefix = "leaflet-popup", container = this._container = create$1("div", prefix + " " + (this.options.className || "") + " leaflet-zoom-animated"), wrapper = this._wrapper = create$1("div", prefix + "-content-wrapper", container);
                    if (this._contentNode = create$1("div", prefix + "-content", wrapper), disableClickPropagation(container), 
                    disableScrollPropagation(this._contentNode), on(container, "contextmenu", stopPropagation), 
                    this._tipContainer = create$1("div", prefix + "-tip-container", container), this._tip = create$1("div", prefix + "-tip", this._tipContainer), 
                    this.options.closeButton) {
                        var closeButton = this._closeButton = create$1("a", prefix + "-close-button", container);
                        closeButton.setAttribute("role", "button"), closeButton.setAttribute("aria-label", "Close popup"), 
                        closeButton.href = "#close", closeButton.innerHTML = '<span aria-hidden="true">&#215;</span>', 
                        on(closeButton, "click", (function(ev) {
                            preventDefault(ev), this.close();
                        }), this);
                    }
                },
                _updateLayout: function() {
                    var container = this._contentNode, style = container.style;
                    style.width = "", style.whiteSpace = "nowrap";
                    var width = container.offsetWidth;
                    width = Math.min(width, this.options.maxWidth), width = Math.max(width, this.options.minWidth), 
                    style.width = width + 1 + "px", style.whiteSpace = "", style.height = "";
                    var height = container.offsetHeight, maxHeight = this.options.maxHeight, scrolledClass = "leaflet-popup-scrolled";
                    maxHeight && height > maxHeight ? (style.height = maxHeight + "px", addClass(container, scrolledClass)) : removeClass(container, scrolledClass), 
                    this._containerWidth = this._container.offsetWidth;
                },
                _animateZoom: function(e) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center), anchor = this._getAnchor();
                    setPosition(this._container, pos.add(anchor));
                },
                _adjustPan: function() {
                    if (this.options.autoPan) if (this._map._panAnim && this._map._panAnim.stop(), this._autopanning) this._autopanning = !1; else {
                        var map = this._map, marginBottom = parseInt(getStyle(this._container, "marginBottom"), 10) || 0, containerHeight = this._container.offsetHeight + marginBottom, containerWidth = this._containerWidth, layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);
                        layerPos._add(getPosition(this._container));
                        var containerPos = map.layerPointToContainerPoint(layerPos), padding = toPoint(this.options.autoPanPadding), paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding), paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding), size = map.getSize(), dx = 0, dy = 0;
                        containerPos.x + containerWidth + paddingBR.x > size.x && (dx = containerPos.x + containerWidth - size.x + paddingBR.x), 
                        containerPos.x - dx - paddingTL.x < 0 && (dx = containerPos.x - paddingTL.x), containerPos.y + containerHeight + paddingBR.y > size.y && (dy = containerPos.y + containerHeight - size.y + paddingBR.y), 
                        containerPos.y - dy - paddingTL.y < 0 && (dy = containerPos.y - paddingTL.y), (dx || dy) && (this.options.keepInView && (this._autopanning = !0), 
                        map.fire("autopanstart").panBy([ dx, dy ]));
                    }
                },
                _getAnchor: function() {
                    return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [ 0, 0 ]);
                }
            }), popup = function(options, source) {
                return new Popup(options, source);
            };
            Map.mergeOptions({
                closePopupOnClick: !0
            }), Map.include({
                openPopup: function(popup, latlng, options) {
                    return this._initOverlay(Popup, popup, latlng, options).openOn(this), this;
                },
                closePopup: function(popup) {
                    return (popup = arguments.length ? popup : this._popup) && popup.close(), this;
                }
            }), Layer.include({
                bindPopup: function(content, options) {
                    return this._popup = this._initOverlay(Popup, this._popup, content, options), this._popupHandlersAdded || (this.on({
                        click: this._openPopup,
                        keypress: this._onKeyPress,
                        remove: this.closePopup,
                        move: this._movePopup
                    }), this._popupHandlersAdded = !0), this;
                },
                unbindPopup: function() {
                    return this._popup && (this.off({
                        click: this._openPopup,
                        keypress: this._onKeyPress,
                        remove: this.closePopup,
                        move: this._movePopup
                    }), this._popupHandlersAdded = !1, this._popup = null), this;
                },
                openPopup: function(latlng) {
                    return this._popup && (this instanceof FeatureGroup || (this._popup._source = this), 
                    this._popup._prepareOpen(latlng || this._latlng) && this._popup.openOn(this._map)), 
                    this;
                },
                closePopup: function() {
                    return this._popup && this._popup.close(), this;
                },
                togglePopup: function() {
                    return this._popup && this._popup.toggle(this), this;
                },
                isPopupOpen: function() {
                    return !!this._popup && this._popup.isOpen();
                },
                setPopupContent: function(content) {
                    return this._popup && this._popup.setContent(content), this;
                },
                getPopup: function() {
                    return this._popup;
                },
                _openPopup: function(e) {
                    if (this._popup && this._map) {
                        stop(e);
                        var target = e.layer || e.target;
                        this._popup._source !== target || target instanceof Path ? (this._popup._source = target, 
                        this.openPopup(e.latlng)) : this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(e.latlng);
                    }
                },
                _movePopup: function(e) {
                    this._popup.setLatLng(e.latlng);
                },
                _onKeyPress: function(e) {
                    13 === e.originalEvent.keyCode && this._openPopup(e);
                }
            });
            var Tooltip = DivOverlay.extend({
                options: {
                    pane: "tooltipPane",
                    offset: [ 0, 0 ],
                    direction: "auto",
                    permanent: !1,
                    sticky: !1,
                    opacity: .9
                },
                onAdd: function(map) {
                    DivOverlay.prototype.onAdd.call(this, map), this.setOpacity(this.options.opacity), 
                    map.fire("tooltipopen", {
                        tooltip: this
                    }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", {
                        tooltip: this
                    }, !0));
                },
                onRemove: function(map) {
                    DivOverlay.prototype.onRemove.call(this, map), map.fire("tooltipclose", {
                        tooltip: this
                    }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", {
                        tooltip: this
                    }, !0));
                },
                getEvents: function() {
                    var events = DivOverlay.prototype.getEvents.call(this);
                    return this.options.permanent || (events.preclick = this.close), events;
                },
                _initLayout: function() {
                    var className = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
                    this._contentNode = this._container = create$1("div", className), this._container.setAttribute("role", "tooltip"), 
                    this._container.setAttribute("id", "leaflet-tooltip-" + stamp(this));
                },
                _updateLayout: function() {},
                _adjustPan: function() {},
                _setPosition: function(pos) {
                    var subX, subY, map = this._map, container = this._container, centerPoint = map.latLngToContainerPoint(map.getCenter()), tooltipPoint = map.layerPointToContainerPoint(pos), direction = this.options.direction, tooltipWidth = container.offsetWidth, tooltipHeight = container.offsetHeight, offset = toPoint(this.options.offset), anchor = this._getAnchor();
                    "top" === direction ? (subX = tooltipWidth / 2, subY = tooltipHeight) : "bottom" === direction ? (subX = tooltipWidth / 2, 
                    subY = 0) : "center" === direction ? (subX = tooltipWidth / 2, subY = tooltipHeight / 2) : "right" === direction ? (subX = 0, 
                    subY = tooltipHeight / 2) : "left" === direction ? (subX = tooltipWidth, subY = tooltipHeight / 2) : tooltipPoint.x < centerPoint.x ? (direction = "right", 
                    subX = 0, subY = tooltipHeight / 2) : (direction = "left", subX = tooltipWidth + 2 * (offset.x + anchor.x), 
                    subY = tooltipHeight / 2), pos = pos.subtract(toPoint(subX, subY, !0)).add(offset).add(anchor), 
                    removeClass(container, "leaflet-tooltip-right"), removeClass(container, "leaflet-tooltip-left"), 
                    removeClass(container, "leaflet-tooltip-top"), removeClass(container, "leaflet-tooltip-bottom"), 
                    addClass(container, "leaflet-tooltip-" + direction), setPosition(container, pos);
                },
                _updatePosition: function() {
                    var pos = this._map.latLngToLayerPoint(this._latlng);
                    this._setPosition(pos);
                },
                setOpacity: function(opacity) {
                    this.options.opacity = opacity, this._container && setOpacity(this._container, opacity);
                },
                _animateZoom: function(e) {
                    var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
                    this._setPosition(pos);
                },
                _getAnchor: function() {
                    return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [ 0, 0 ]);
                }
            }), tooltip = function(options, source) {
                return new Tooltip(options, source);
            };
            Map.include({
                openTooltip: function(tooltip, latlng, options) {
                    return this._initOverlay(Tooltip, tooltip, latlng, options).openOn(this), this;
                },
                closeTooltip: function(tooltip) {
                    return tooltip.close(), this;
                }
            }), Layer.include({
                bindTooltip: function(content, options) {
                    return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Tooltip, this._tooltip, content, options), 
                    this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), 
                    this;
                },
                unbindTooltip: function() {
                    return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), 
                    this._tooltip = null), this;
                },
                _initTooltipInteractions: function(remove) {
                    if (remove || !this._tooltipHandlersAdded) {
                        var onOff = remove ? "off" : "on", events = {
                            remove: this.closeTooltip,
                            move: this._moveTooltip
                        };
                        this._tooltip.options.permanent ? events.add = this._openTooltip : (events.mouseover = this._openTooltip, 
                        events.mouseout = this.closeTooltip, events.click = this._openTooltip, this._map ? this._addFocusListeners() : events.add = this._addFocusListeners), 
                        this._tooltip.options.sticky && (events.mousemove = this._moveTooltip), this[onOff](events), 
                        this._tooltipHandlersAdded = !remove;
                    }
                },
                openTooltip: function(latlng) {
                    return this._tooltip && (this instanceof FeatureGroup || (this._tooltip._source = this), 
                    this._tooltip._prepareOpen(latlng) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), 
                    this;
                },
                closeTooltip: function() {
                    if (this._tooltip) return this._tooltip.close();
                },
                toggleTooltip: function() {
                    return this._tooltip && this._tooltip.toggle(this), this;
                },
                isTooltipOpen: function() {
                    return this._tooltip.isOpen();
                },
                setTooltipContent: function(content) {
                    return this._tooltip && this._tooltip.setContent(content), this;
                },
                getTooltip: function() {
                    return this._tooltip;
                },
                _addFocusListeners: function() {
                    this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this);
                },
                _addFocusListenersOnLayer: function(layer) {
                    var el = "function" == typeof layer.getElement && layer.getElement();
                    el && (on(el, "focus", (function() {
                        this._tooltip._source = layer, this.openTooltip();
                    }), this), on(el, "blur", this.closeTooltip, this));
                },
                _setAriaDescribedByOnLayer: function(layer) {
                    var el = "function" == typeof layer.getElement && layer.getElement();
                    el && el.setAttribute("aria-describedby", this._tooltip._container.id);
                },
                _openTooltip: function(e) {
                    if (this._tooltip && this._map) if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
                        this._openOnceFlag = !0;
                        var that = this;
                        this._map.once("moveend", (function() {
                            that._openOnceFlag = !1, that._openTooltip(e);
                        }));
                    } else this._tooltip._source = e.layer || e.target, this.openTooltip(this._tooltip.options.sticky ? e.latlng : void 0);
                },
                _moveTooltip: function(e) {
                    var containerPoint, layerPoint, latlng = e.latlng;
                    this._tooltip.options.sticky && e.originalEvent && (containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent), 
                    layerPoint = this._map.containerPointToLayerPoint(containerPoint), latlng = this._map.layerPointToLatLng(layerPoint)), 
                    this._tooltip.setLatLng(latlng);
                }
            });
            var DivIcon = Icon.extend({
                options: {
                    iconSize: [ 12, 12 ],
                    html: !1,
                    bgPos: null,
                    className: "leaflet-div-icon"
                },
                createIcon: function(oldIcon) {
                    var div = oldIcon && "DIV" === oldIcon.tagName ? oldIcon : document.createElement("div"), options = this.options;
                    if (options.html instanceof Element ? (empty(div), div.appendChild(options.html)) : div.innerHTML = !1 !== options.html ? options.html : "", 
                    options.bgPos) {
                        var bgPos = toPoint(options.bgPos);
                        div.style.backgroundPosition = -bgPos.x + "px " + -bgPos.y + "px";
                    }
                    return this._setIconStyles(div, "icon"), div;
                },
                createShadow: function() {
                    return null;
                }
            });
            function divIcon(options) {
                return new DivIcon(options);
            }
            Icon.Default = IconDefault;
            var GridLayer = Layer.extend({
                options: {
                    tileSize: 256,
                    opacity: 1,
                    updateWhenIdle: Browser.mobile,
                    updateWhenZooming: !0,
                    updateInterval: 200,
                    zIndex: 1,
                    bounds: null,
                    minZoom: 0,
                    maxZoom: void 0,
                    maxNativeZoom: void 0,
                    minNativeZoom: void 0,
                    noWrap: !1,
                    pane: "tilePane",
                    className: "",
                    keepBuffer: 2
                },
                initialize: function(options) {
                    setOptions(this, options);
                },
                onAdd: function() {
                    this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView();
                },
                beforeAdd: function(map) {
                    map._addZoomLimit(this);
                },
                onRemove: function(map) {
                    this._removeAllTiles(), remove(this._container), map._removeZoomLimit(this), this._container = null, 
                    this._tileZoom = void 0;
                },
                bringToFront: function() {
                    return this._map && (toFront(this._container), this._setAutoZIndex(Math.max)), this;
                },
                bringToBack: function() {
                    return this._map && (toBack(this._container), this._setAutoZIndex(Math.min)), this;
                },
                getContainer: function() {
                    return this._container;
                },
                setOpacity: function(opacity) {
                    return this.options.opacity = opacity, this._updateOpacity(), this;
                },
                setZIndex: function(zIndex) {
                    return this.options.zIndex = zIndex, this._updateZIndex(), this;
                },
                isLoading: function() {
                    return this._loading;
                },
                redraw: function() {
                    if (this._map) {
                        this._removeAllTiles();
                        var tileZoom = this._clampZoom(this._map.getZoom());
                        tileZoom !== this._tileZoom && (this._tileZoom = tileZoom, this._updateLevels()), 
                        this._update();
                    }
                    return this;
                },
                getEvents: function() {
                    var events = {
                        viewprereset: this._invalidateAll,
                        viewreset: this._resetView,
                        zoom: this._resetView,
                        moveend: this._onMoveEnd
                    };
                    return this.options.updateWhenIdle || (this._onMove || (this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this)), 
                    events.move = this._onMove), this._zoomAnimated && (events.zoomanim = this._animateZoom), 
                    events;
                },
                createTile: function() {
                    return document.createElement("div");
                },
                getTileSize: function() {
                    var s = this.options.tileSize;
                    return s instanceof Point ? s : new Point(s, s);
                },
                _updateZIndex: function() {
                    this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex);
                },
                _setAutoZIndex: function(compare) {
                    for (var zIndex, layers = this.getPane().children, edgeZIndex = -compare(-1 / 0, 1 / 0), i = 0, len = layers.length; i < len; i++) zIndex = layers[i].style.zIndex, 
                    layers[i] !== this._container && zIndex && (edgeZIndex = compare(edgeZIndex, +zIndex));
                    isFinite(edgeZIndex) && (this.options.zIndex = edgeZIndex + compare(-1, 1), this._updateZIndex());
                },
                _updateOpacity: function() {
                    if (this._map && !Browser.ielt9) {
                        setOpacity(this._container, this.options.opacity);
                        var now = +new Date, nextFrame = !1, willPrune = !1;
                        for (var key in this._tiles) {
                            var tile = this._tiles[key];
                            if (tile.current && tile.loaded) {
                                var fade = Math.min(1, (now - tile.loaded) / 200);
                                setOpacity(tile.el, fade), fade < 1 ? nextFrame = !0 : (tile.active ? willPrune = !0 : this._onOpaqueTile(tile), 
                                tile.active = !0);
                            }
                        }
                        willPrune && !this._noPrune && this._pruneTiles(), nextFrame && (cancelAnimFrame(this._fadeFrame), 
                        this._fadeFrame = requestAnimFrame(this._updateOpacity, this));
                    }
                },
                _onOpaqueTile: falseFn,
                _initContainer: function() {
                    this._container || (this._container = create$1("div", "leaflet-layer " + (this.options.className || "")), 
                    this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));
                },
                _updateLevels: function() {
                    var zoom = this._tileZoom, maxZoom = this.options.maxZoom;
                    if (void 0 !== zoom) {
                        for (var z in this._levels) z = Number(z), this._levels[z].el.children.length || z === zoom ? (this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z), 
                        this._onUpdateLevel(z)) : (remove(this._levels[z].el), this._removeTilesAtZoom(z), 
                        this._onRemoveLevel(z), delete this._levels[z]);
                        var level = this._levels[zoom], map = this._map;
                        return level || ((level = this._levels[zoom] = {}).el = create$1("div", "leaflet-tile-container leaflet-zoom-animated", this._container), 
                        level.el.style.zIndex = maxZoom, level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round(), 
                        level.zoom = zoom, this._setZoomTransform(level, map.getCenter(), map.getZoom()), 
                        falseFn(level.el.offsetWidth), this._onCreateLevel(level)), this._level = level, 
                        level;
                    }
                },
                _onUpdateLevel: falseFn,
                _onRemoveLevel: falseFn,
                _onCreateLevel: falseFn,
                _pruneTiles: function() {
                    if (this._map) {
                        var key, tile, zoom = this._map.getZoom();
                        if (zoom > this.options.maxZoom || zoom < this.options.minZoom) this._removeAllTiles(); else {
                            for (key in this._tiles) (tile = this._tiles[key]).retain = tile.current;
                            for (key in this._tiles) if ((tile = this._tiles[key]).current && !tile.active) {
                                var coords = tile.coords;
                                this._retainParent(coords.x, coords.y, coords.z, coords.z - 5) || this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
                            }
                            for (key in this._tiles) this._tiles[key].retain || this._removeTile(key);
                        }
                    }
                },
                _removeTilesAtZoom: function(zoom) {
                    for (var key in this._tiles) this._tiles[key].coords.z === zoom && this._removeTile(key);
                },
                _removeAllTiles: function() {
                    for (var key in this._tiles) this._removeTile(key);
                },
                _invalidateAll: function() {
                    for (var z in this._levels) remove(this._levels[z].el), this._onRemoveLevel(Number(z)), 
                    delete this._levels[z];
                    this._removeAllTiles(), this._tileZoom = void 0;
                },
                _retainParent: function(x, y, z, minZoom) {
                    var x2 = Math.floor(x / 2), y2 = Math.floor(y / 2), z2 = z - 1, coords2 = new Point(+x2, +y2);
                    coords2.z = +z2;
                    var key = this._tileCoordsToKey(coords2), tile = this._tiles[key];
                    return tile && tile.active ? (tile.retain = !0, !0) : (tile && tile.loaded && (tile.retain = !0), 
                    z2 > minZoom && this._retainParent(x2, y2, z2, minZoom));
                },
                _retainChildren: function(x, y, z, maxZoom) {
                    for (var i = 2 * x; i < 2 * x + 2; i++) for (var j = 2 * y; j < 2 * y + 2; j++) {
                        var coords = new Point(i, j);
                        coords.z = z + 1;
                        var key = this._tileCoordsToKey(coords), tile = this._tiles[key];
                        tile && tile.active ? tile.retain = !0 : (tile && tile.loaded && (tile.retain = !0), 
                        z + 1 < maxZoom && this._retainChildren(i, j, z + 1, maxZoom));
                    }
                },
                _resetView: function(e) {
                    var animating = e && (e.pinch || e.flyTo);
                    this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
                },
                _animateZoom: function(e) {
                    this._setView(e.center, e.zoom, !0, e.noUpdate);
                },
                _clampZoom: function(zoom) {
                    var options = this.options;
                    return void 0 !== options.minNativeZoom && zoom < options.minNativeZoom ? options.minNativeZoom : void 0 !== options.maxNativeZoom && options.maxNativeZoom < zoom ? options.maxNativeZoom : zoom;
                },
                _setView: function(center, zoom, noPrune, noUpdate) {
                    var tileZoom = Math.round(zoom);
                    tileZoom = void 0 !== this.options.maxZoom && tileZoom > this.options.maxZoom || void 0 !== this.options.minZoom && tileZoom < this.options.minZoom ? void 0 : this._clampZoom(tileZoom);
                    var tileZoomChanged = this.options.updateWhenZooming && tileZoom !== this._tileZoom;
                    noUpdate && !tileZoomChanged || (this._tileZoom = tileZoom, this._abortLoading && this._abortLoading(), 
                    this._updateLevels(), this._resetGrid(), void 0 !== tileZoom && this._update(center), 
                    noPrune || this._pruneTiles(), this._noPrune = !!noPrune), this._setZoomTransforms(center, zoom);
                },
                _setZoomTransforms: function(center, zoom) {
                    for (var i in this._levels) this._setZoomTransform(this._levels[i], center, zoom);
                },
                _setZoomTransform: function(level, center, zoom) {
                    var scale = this._map.getZoomScale(zoom, level.zoom), translate = level.origin.multiplyBy(scale).subtract(this._map._getNewPixelOrigin(center, zoom)).round();
                    Browser.any3d ? setTransform(level.el, translate, scale) : setPosition(level.el, translate);
                },
                _resetGrid: function() {
                    var map = this._map, crs = map.options.crs, tileSize = this._tileSize = this.getTileSize(), tileZoom = this._tileZoom, bounds = this._map.getPixelWorldBounds(this._tileZoom);
                    bounds && (this._globalTileRange = this._pxBoundsToTileRange(bounds)), this._wrapX = crs.wrapLng && !this.options.noWrap && [ Math.floor(map.project([ 0, crs.wrapLng[0] ], tileZoom).x / tileSize.x), Math.ceil(map.project([ 0, crs.wrapLng[1] ], tileZoom).x / tileSize.y) ], 
                    this._wrapY = crs.wrapLat && !this.options.noWrap && [ Math.floor(map.project([ crs.wrapLat[0], 0 ], tileZoom).y / tileSize.x), Math.ceil(map.project([ crs.wrapLat[1], 0 ], tileZoom).y / tileSize.y) ];
                },
                _onMoveEnd: function() {
                    this._map && !this._map._animatingZoom && this._update();
                },
                _getTiledPixelBounds: function(center) {
                    var map = this._map, mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(), scale = map.getZoomScale(mapZoom, this._tileZoom), pixelCenter = map.project(center, this._tileZoom).floor(), halfSize = map.getSize().divideBy(2 * scale);
                    return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
                },
                _update: function(center) {
                    var map = this._map;
                    if (map) {
                        var zoom = this._clampZoom(map.getZoom());
                        if (void 0 === center && (center = map.getCenter()), void 0 !== this._tileZoom) {
                            var pixelBounds = this._getTiledPixelBounds(center), tileRange = this._pxBoundsToTileRange(pixelBounds), tileCenter = tileRange.getCenter(), queue = [], margin = this.options.keepBuffer, noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([ margin, -margin ]), tileRange.getTopRight().add([ margin, -margin ]));
                            if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) throw new Error("Attempted to load an infinite number of tiles");
                            for (var key in this._tiles) {
                                var c = this._tiles[key].coords;
                                c.z === this._tileZoom && noPruneRange.contains(new Point(c.x, c.y)) || (this._tiles[key].current = !1);
                            }
                            if (Math.abs(zoom - this._tileZoom) > 1) this._setView(center, zoom); else {
                                for (var j = tileRange.min.y; j <= tileRange.max.y; j++) for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
                                    var coords = new Point(i, j);
                                    if (coords.z = this._tileZoom, this._isValidTile(coords)) {
                                        var tile = this._tiles[this._tileCoordsToKey(coords)];
                                        tile ? tile.current = !0 : queue.push(coords);
                                    }
                                }
                                if (queue.sort((function(a, b) {
                                    return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
                                })), 0 !== queue.length) {
                                    this._loading || (this._loading = !0, this.fire("loading"));
                                    var fragment = document.createDocumentFragment();
                                    for (i = 0; i < queue.length; i++) this._addTile(queue[i], fragment);
                                    this._level.el.appendChild(fragment);
                                }
                            }
                        }
                    }
                },
                _isValidTile: function(coords) {
                    var crs = this._map.options.crs;
                    if (!crs.infinite) {
                        var bounds = this._globalTileRange;
                        if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) return !1;
                    }
                    if (!this.options.bounds) return !0;
                    var tileBounds = this._tileCoordsToBounds(coords);
                    return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
                },
                _keyToBounds: function(key) {
                    return this._tileCoordsToBounds(this._keyToTileCoords(key));
                },
                _tileCoordsToNwSe: function(coords) {
                    var map = this._map, tileSize = this.getTileSize(), nwPoint = coords.scaleBy(tileSize), sePoint = nwPoint.add(tileSize);
                    return [ map.unproject(nwPoint, coords.z), map.unproject(sePoint, coords.z) ];
                },
                _tileCoordsToBounds: function(coords) {
                    var bp = this._tileCoordsToNwSe(coords), bounds = new LatLngBounds(bp[0], bp[1]);
                    return this.options.noWrap || (bounds = this._map.wrapLatLngBounds(bounds)), bounds;
                },
                _tileCoordsToKey: function(coords) {
                    return coords.x + ":" + coords.y + ":" + coords.z;
                },
                _keyToTileCoords: function(key) {
                    var k = key.split(":"), coords = new Point(+k[0], +k[1]);
                    return coords.z = +k[2], coords;
                },
                _removeTile: function(key) {
                    var tile = this._tiles[key];
                    tile && (remove(tile.el), delete this._tiles[key], this.fire("tileunload", {
                        tile: tile.el,
                        coords: this._keyToTileCoords(key)
                    }));
                },
                _initTile: function(tile) {
                    addClass(tile, "leaflet-tile");
                    var tileSize = this.getTileSize();
                    tile.style.width = tileSize.x + "px", tile.style.height = tileSize.y + "px", tile.onselectstart = falseFn, 
                    tile.onmousemove = falseFn, Browser.ielt9 && this.options.opacity < 1 && setOpacity(tile, this.options.opacity);
                },
                _addTile: function(coords, container) {
                    var tilePos = this._getTilePos(coords), key = this._tileCoordsToKey(coords), tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));
                    this._initTile(tile), this.createTile.length < 2 && requestAnimFrame(bind(this._tileReady, this, coords, null, tile)), 
                    setPosition(tile, tilePos), this._tiles[key] = {
                        el: tile,
                        coords,
                        current: !0
                    }, container.appendChild(tile), this.fire("tileloadstart", {
                        tile,
                        coords
                    });
                },
                _tileReady: function(coords, err, tile) {
                    err && this.fire("tileerror", {
                        error: err,
                        tile,
                        coords
                    });
                    var key = this._tileCoordsToKey(coords);
                    (tile = this._tiles[key]) && (tile.loaded = +new Date, this._map._fadeAnimated ? (setOpacity(tile.el, 0), 
                    cancelAnimFrame(this._fadeFrame), this._fadeFrame = requestAnimFrame(this._updateOpacity, this)) : (tile.active = !0, 
                    this._pruneTiles()), err || (addClass(tile.el, "leaflet-tile-loaded"), this.fire("tileload", {
                        tile: tile.el,
                        coords
                    })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), Browser.ielt9 || !this._map._fadeAnimated ? requestAnimFrame(this._pruneTiles, this) : setTimeout(bind(this._pruneTiles, this), 250)));
                },
                _getTilePos: function(coords) {
                    return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
                },
                _wrapCoords: function(coords) {
                    var newCoords = new Point(this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x, this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
                    return newCoords.z = coords.z, newCoords;
                },
                _pxBoundsToTileRange: function(bounds) {
                    var tileSize = this.getTileSize();
                    return new Bounds(bounds.min.unscaleBy(tileSize).floor(), bounds.max.unscaleBy(tileSize).ceil().subtract([ 1, 1 ]));
                },
                _noTilesToLoad: function() {
                    for (var key in this._tiles) if (!this._tiles[key].loaded) return !1;
                    return !0;
                }
            });
            function gridLayer(options) {
                return new GridLayer(options);
            }
            var TileLayer = GridLayer.extend({
                options: {
                    minZoom: 0,
                    maxZoom: 18,
                    subdomains: "abc",
                    errorTileUrl: "",
                    zoomOffset: 0,
                    tms: !1,
                    zoomReverse: !1,
                    detectRetina: !1,
                    crossOrigin: !1,
                    referrerPolicy: !1
                },
                initialize: function(url, options) {
                    this._url = url, (options = setOptions(this, options)).detectRetina && Browser.retina && options.maxZoom > 0 ? (options.tileSize = Math.floor(options.tileSize / 2), 
                    options.zoomReverse ? (options.zoomOffset--, options.minZoom = Math.min(options.maxZoom, options.minZoom + 1)) : (options.zoomOffset++, 
                    options.maxZoom = Math.max(options.minZoom, options.maxZoom - 1)), options.minZoom = Math.max(0, options.minZoom)) : options.zoomReverse ? options.minZoom = Math.min(options.maxZoom, options.minZoom) : options.maxZoom = Math.max(options.minZoom, options.maxZoom), 
                    "string" == typeof options.subdomains && (options.subdomains = options.subdomains.split("")), 
                    this.on("tileunload", this._onTileRemove);
                },
                setUrl: function(url, noRedraw) {
                    return this._url === url && void 0 === noRedraw && (noRedraw = !0), this._url = url, 
                    noRedraw || this.redraw(), this;
                },
                createTile: function(coords, done) {
                    var tile = document.createElement("img");
                    return on(tile, "load", bind(this._tileOnLoad, this, done, tile)), on(tile, "error", bind(this._tileOnError, this, done, tile)), 
                    (this.options.crossOrigin || "" === this.options.crossOrigin) && (tile.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), 
                    "string" == typeof this.options.referrerPolicy && (tile.referrerPolicy = this.options.referrerPolicy), 
                    tile.alt = "", tile.src = this.getTileUrl(coords), tile;
                },
                getTileUrl: function(coords) {
                    var data = {
                        r: Browser.retina ? "@2x" : "",
                        s: this._getSubdomain(coords),
                        x: coords.x,
                        y: coords.y,
                        z: this._getZoomForUrl()
                    };
                    if (this._map && !this._map.options.crs.infinite) {
                        var invertedY = this._globalTileRange.max.y - coords.y;
                        this.options.tms && (data.y = invertedY), data["-y"] = invertedY;
                    }
                    return template(this._url, extend(data, this.options));
                },
                _tileOnLoad: function(done, tile) {
                    Browser.ielt9 ? setTimeout(bind(done, this, null, tile), 0) : done(null, tile);
                },
                _tileOnError: function(done, tile, e) {
                    var errorUrl = this.options.errorTileUrl;
                    errorUrl && tile.getAttribute("src") !== errorUrl && (tile.src = errorUrl), done(e, tile);
                },
                _onTileRemove: function(e) {
                    e.tile.onload = null;
                },
                _getZoomForUrl: function() {
                    var zoom = this._tileZoom, maxZoom = this.options.maxZoom;
                    return this.options.zoomReverse && (zoom = maxZoom - zoom), zoom + this.options.zoomOffset;
                },
                _getSubdomain: function(tilePoint) {
                    var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
                    return this.options.subdomains[index];
                },
                _abortLoading: function() {
                    var i, tile;
                    for (i in this._tiles) if (this._tiles[i].coords.z !== this._tileZoom && ((tile = this._tiles[i].el).onload = falseFn, 
                    tile.onerror = falseFn, !tile.complete)) {
                        tile.src = emptyImageUrl;
                        var coords = this._tiles[i].coords;
                        remove(tile), delete this._tiles[i], this.fire("tileabort", {
                            tile,
                            coords
                        });
                    }
                },
                _removeTile: function(key) {
                    var tile = this._tiles[key];
                    if (tile) return tile.el.setAttribute("src", emptyImageUrl), GridLayer.prototype._removeTile.call(this, key);
                },
                _tileReady: function(coords, err, tile) {
                    if (this._map && (!tile || tile.getAttribute("src") !== emptyImageUrl)) return GridLayer.prototype._tileReady.call(this, coords, err, tile);
                }
            });
            function tileLayer(url, options) {
                return new TileLayer(url, options);
            }
            var TileLayerWMS = TileLayer.extend({
                defaultWmsParams: {
                    service: "WMS",
                    request: "GetMap",
                    layers: "",
                    styles: "",
                    format: "image/jpeg",
                    transparent: !1,
                    version: "1.1.1"
                },
                options: {
                    crs: null,
                    uppercase: !1
                },
                initialize: function(url, options) {
                    this._url = url;
                    var wmsParams = extend({}, this.defaultWmsParams);
                    for (var i in options) i in this.options || (wmsParams[i] = options[i]);
                    var realRetina = (options = setOptions(this, options)).detectRetina && Browser.retina ? 2 : 1, tileSize = this.getTileSize();
                    wmsParams.width = tileSize.x * realRetina, wmsParams.height = tileSize.y * realRetina, 
                    this.wmsParams = wmsParams;
                },
                onAdd: function(map) {
                    this._crs = this.options.crs || map.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);
                    var projectionKey = this._wmsVersion >= 1.3 ? "crs" : "srs";
                    this.wmsParams[projectionKey] = this._crs.code, TileLayer.prototype.onAdd.call(this, map);
                },
                getTileUrl: function(coords) {
                    var tileBounds = this._tileCoordsToNwSe(coords), crs = this._crs, bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])), min = bounds.min, max = bounds.max, bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ? [ min.y, min.x, max.y, max.x ] : [ min.x, min.y, max.x, max.y ]).join(","), url = TileLayer.prototype.getTileUrl.call(this, coords);
                    return url + getParamString(this.wmsParams, url, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + bbox;
                },
                setParams: function(params, noRedraw) {
                    return extend(this.wmsParams, params), noRedraw || this.redraw(), this;
                }
            });
            function tileLayerWMS(url, options) {
                return new TileLayerWMS(url, options);
            }
            TileLayer.WMS = TileLayerWMS, tileLayer.wms = tileLayerWMS;
            var Renderer = Layer.extend({
                options: {
                    padding: .1
                },
                initialize: function(options) {
                    setOptions(this, options), stamp(this), this._layers = this._layers || {};
                },
                onAdd: function() {
                    this._container || (this._initContainer(), addClass(this._container, "leaflet-zoom-animated")), 
                    this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this);
                },
                onRemove: function() {
                    this.off("update", this._updatePaths, this), this._destroyContainer();
                },
                getEvents: function() {
                    var events = {
                        viewreset: this._reset,
                        zoom: this._onZoom,
                        moveend: this._update,
                        zoomend: this._onZoomEnd
                    };
                    return this._zoomAnimated && (events.zoomanim = this._onAnimZoom), events;
                },
                _onAnimZoom: function(ev) {
                    this._updateTransform(ev.center, ev.zoom);
                },
                _onZoom: function() {
                    this._updateTransform(this._map.getCenter(), this._map.getZoom());
                },
                _updateTransform: function(center, zoom) {
                    var scale = this._map.getZoomScale(zoom, this._zoom), viewHalf = this._map.getSize().multiplyBy(.5 + this.options.padding), currentCenterPoint = this._map.project(this._center, zoom), topLeftOffset = viewHalf.multiplyBy(-scale).add(currentCenterPoint).subtract(this._map._getNewPixelOrigin(center, zoom));
                    Browser.any3d ? setTransform(this._container, topLeftOffset, scale) : setPosition(this._container, topLeftOffset);
                },
                _reset: function() {
                    for (var id in this._update(), this._updateTransform(this._center, this._zoom), 
                    this._layers) this._layers[id]._reset();
                },
                _onZoomEnd: function() {
                    for (var id in this._layers) this._layers[id]._project();
                },
                _updatePaths: function() {
                    for (var id in this._layers) this._layers[id]._update();
                },
                _update: function() {
                    var p = this.options.padding, size = this._map.getSize(), min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();
                    this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + 2 * p)).round()), this._center = this._map.getCenter(), 
                    this._zoom = this._map.getZoom();
                }
            }), Canvas = Renderer.extend({
                options: {
                    tolerance: 0
                },
                getEvents: function() {
                    var events = Renderer.prototype.getEvents.call(this);
                    return events.viewprereset = this._onViewPreReset, events;
                },
                _onViewPreReset: function() {
                    this._postponeUpdatePaths = !0;
                },
                onAdd: function() {
                    Renderer.prototype.onAdd.call(this), this._draw();
                },
                _initContainer: function() {
                    var container = this._container = document.createElement("canvas");
                    on(container, "mousemove", this._onMouseMove, this), on(container, "click dblclick mousedown mouseup contextmenu", this._onClick, this), 
                    on(container, "mouseout", this._handleMouseOut, this), container._leaflet_disable_events = !0, 
                    this._ctx = container.getContext("2d");
                },
                _destroyContainer: function() {
                    cancelAnimFrame(this._redrawRequest), delete this._ctx, remove(this._container), 
                    off(this._container), delete this._container;
                },
                _updatePaths: function() {
                    if (!this._postponeUpdatePaths) {
                        for (var id in this._redrawBounds = null, this._layers) this._layers[id]._update();
                        this._redraw();
                    }
                },
                _update: function() {
                    if (!this._map._animatingZoom || !this._bounds) {
                        Renderer.prototype._update.call(this);
                        var b = this._bounds, container = this._container, size = b.getSize(), m = Browser.retina ? 2 : 1;
                        setPosition(container, b.min), container.width = m * size.x, container.height = m * size.y, 
                        container.style.width = size.x + "px", container.style.height = size.y + "px", Browser.retina && this._ctx.scale(2, 2), 
                        this._ctx.translate(-b.min.x, -b.min.y), this.fire("update");
                    }
                },
                _reset: function() {
                    Renderer.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, 
                    this._updatePaths());
                },
                _initPath: function(layer) {
                    this._updateDashArray(layer), this._layers[stamp(layer)] = layer;
                    var order = layer._order = {
                        layer,
                        prev: this._drawLast,
                        next: null
                    };
                    this._drawLast && (this._drawLast.next = order), this._drawLast = order, this._drawFirst = this._drawFirst || this._drawLast;
                },
                _addPath: function(layer) {
                    this._requestRedraw(layer);
                },
                _removePath: function(layer) {
                    var order = layer._order, next = order.next, prev = order.prev;
                    next ? next.prev = prev : this._drawLast = prev, prev ? prev.next = next : this._drawFirst = next, 
                    delete layer._order, delete this._layers[stamp(layer)], this._requestRedraw(layer);
                },
                _updatePath: function(layer) {
                    this._extendRedrawBounds(layer), layer._project(), layer._update(), this._requestRedraw(layer);
                },
                _updateStyle: function(layer) {
                    this._updateDashArray(layer), this._requestRedraw(layer);
                },
                _updateDashArray: function(layer) {
                    if ("string" == typeof layer.options.dashArray) {
                        var dashValue, i, parts = layer.options.dashArray.split(/[, ]+/), dashArray = [];
                        for (i = 0; i < parts.length; i++) {
                            if (dashValue = Number(parts[i]), isNaN(dashValue)) return;
                            dashArray.push(dashValue);
                        }
                        layer.options._dashArray = dashArray;
                    } else layer.options._dashArray = layer.options.dashArray;
                },
                _requestRedraw: function(layer) {
                    this._map && (this._extendRedrawBounds(layer), this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this));
                },
                _extendRedrawBounds: function(layer) {
                    if (layer._pxBounds) {
                        var padding = (layer.options.weight || 0) + 1;
                        this._redrawBounds = this._redrawBounds || new Bounds, this._redrawBounds.extend(layer._pxBounds.min.subtract([ padding, padding ])), 
                        this._redrawBounds.extend(layer._pxBounds.max.add([ padding, padding ]));
                    }
                },
                _redraw: function() {
                    this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), 
                    this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;
                },
                _clear: function() {
                    var bounds = this._redrawBounds;
                    if (bounds) {
                        var size = bounds.getSize();
                        this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
                    } else this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), 
                    this._ctx.restore();
                },
                _draw: function() {
                    var layer, bounds = this._redrawBounds;
                    if (this._ctx.save(), bounds) {
                        var size = bounds.getSize();
                        this._ctx.beginPath(), this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y), 
                        this._ctx.clip();
                    }
                    this._drawing = !0;
                    for (var order = this._drawFirst; order; order = order.next) layer = order.layer, 
                    (!bounds || layer._pxBounds && layer._pxBounds.intersects(bounds)) && layer._updatePath();
                    this._drawing = !1, this._ctx.restore();
                },
                _updatePoly: function(layer, closed) {
                    if (this._drawing) {
                        var i, j, len2, p, parts = layer._parts, len = parts.length, ctx = this._ctx;
                        if (len) {
                            for (ctx.beginPath(), i = 0; i < len; i++) {
                                for (j = 0, len2 = parts[i].length; j < len2; j++) p = parts[i][j], ctx[j ? "lineTo" : "moveTo"](p.x, p.y);
                                closed && ctx.closePath();
                            }
                            this._fillStroke(ctx, layer);
                        }
                    }
                },
                _updateCircle: function(layer) {
                    if (this._drawing && !layer._empty()) {
                        var p = layer._point, ctx = this._ctx, r = Math.max(Math.round(layer._radius), 1), s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;
                        1 !== s && (ctx.save(), ctx.scale(1, s)), ctx.beginPath(), ctx.arc(p.x, p.y / s, r, 0, 2 * Math.PI, !1), 
                        1 !== s && ctx.restore(), this._fillStroke(ctx, layer);
                    }
                },
                _fillStroke: function(ctx, layer) {
                    var options = layer.options;
                    options.fill && (ctx.globalAlpha = options.fillOpacity, ctx.fillStyle = options.fillColor || options.color, 
                    ctx.fill(options.fillRule || "evenodd")), options.stroke && 0 !== options.weight && (ctx.setLineDash && ctx.setLineDash(layer.options && layer.options._dashArray || []), 
                    ctx.globalAlpha = options.opacity, ctx.lineWidth = options.weight, ctx.strokeStyle = options.color, 
                    ctx.lineCap = options.lineCap, ctx.lineJoin = options.lineJoin, ctx.stroke());
                },
                _onClick: function(e) {
                    for (var layer, clickedLayer, point = this._map.mouseEventToLayerPoint(e), order = this._drawFirst; order; order = order.next) (layer = order.layer).options.interactive && layer._containsPoint(point) && ("click" !== e.type && "preclick" !== e.type || !this._map._draggableMoved(layer)) && (clickedLayer = layer);
                    this._fireEvent(!!clickedLayer && [ clickedLayer ], e);
                },
                _onMouseMove: function(e) {
                    if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) {
                        var point = this._map.mouseEventToLayerPoint(e);
                        this._handleMouseHover(e, point);
                    }
                },
                _handleMouseOut: function(e) {
                    var layer = this._hoveredLayer;
                    layer && (removeClass(this._container, "leaflet-interactive"), this._fireEvent([ layer ], e, "mouseout"), 
                    this._hoveredLayer = null, this._mouseHoverThrottled = !1);
                },
                _handleMouseHover: function(e, point) {
                    if (!this._mouseHoverThrottled) {
                        for (var layer, candidateHoveredLayer, order = this._drawFirst; order; order = order.next) (layer = order.layer).options.interactive && layer._containsPoint(point) && (candidateHoveredLayer = layer);
                        candidateHoveredLayer !== this._hoveredLayer && (this._handleMouseOut(e), candidateHoveredLayer && (addClass(this._container, "leaflet-interactive"), 
                        this._fireEvent([ candidateHoveredLayer ], e, "mouseover"), this._hoveredLayer = candidateHoveredLayer)), 
                        this._fireEvent(!!this._hoveredLayer && [ this._hoveredLayer ], e), this._mouseHoverThrottled = !0, 
                        setTimeout(bind((function() {
                            this._mouseHoverThrottled = !1;
                        }), this), 32);
                    }
                },
                _fireEvent: function(layers, e, type) {
                    this._map._fireDOMEvent(e, type || e.type, layers);
                },
                _bringToFront: function(layer) {
                    var order = layer._order;
                    if (order) {
                        var next = order.next, prev = order.prev;
                        next && (next.prev = prev, prev ? prev.next = next : next && (this._drawFirst = next), 
                        order.prev = this._drawLast, this._drawLast.next = order, order.next = null, this._drawLast = order, 
                        this._requestRedraw(layer));
                    }
                },
                _bringToBack: function(layer) {
                    var order = layer._order;
                    if (order) {
                        var next = order.next, prev = order.prev;
                        prev && (prev.next = next, next ? next.prev = prev : prev && (this._drawLast = prev), 
                        order.prev = null, order.next = this._drawFirst, this._drawFirst.prev = order, this._drawFirst = order, 
                        this._requestRedraw(layer));
                    }
                }
            });
            function canvas(options) {
                return Browser.canvas ? new Canvas(options) : null;
            }
            var vmlCreate = function() {
                try {
                    return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function(name) {
                        return document.createElement("<lvml:" + name + ' class="lvml">');
                    };
                } catch (e) {}
                return function(name) {
                    return document.createElement("<" + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
                };
            }(), vmlMixin = {
                _initContainer: function() {
                    this._container = create$1("div", "leaflet-vml-container");
                },
                _update: function() {
                    this._map._animatingZoom || (Renderer.prototype._update.call(this), this.fire("update"));
                },
                _initPath: function(layer) {
                    var container = layer._container = vmlCreate("shape");
                    addClass(container, "leaflet-vml-shape " + (this.options.className || "")), container.coordsize = "1 1", 
                    layer._path = vmlCreate("path"), container.appendChild(layer._path), this._updateStyle(layer), 
                    this._layers[stamp(layer)] = layer;
                },
                _addPath: function(layer) {
                    var container = layer._container;
                    this._container.appendChild(container), layer.options.interactive && layer.addInteractiveTarget(container);
                },
                _removePath: function(layer) {
                    var container = layer._container;
                    remove(container), layer.removeInteractiveTarget(container), delete this._layers[stamp(layer)];
                },
                _updateStyle: function(layer) {
                    var stroke = layer._stroke, fill = layer._fill, options = layer.options, container = layer._container;
                    container.stroked = !!options.stroke, container.filled = !!options.fill, options.stroke ? (stroke || (stroke = layer._stroke = vmlCreate("stroke")), 
                    container.appendChild(stroke), stroke.weight = options.weight + "px", stroke.color = options.color, 
                    stroke.opacity = options.opacity, options.dashArray ? stroke.dashStyle = isArray(options.dashArray) ? options.dashArray.join(" ") : options.dashArray.replace(/( *, *)/g, " ") : stroke.dashStyle = "", 
                    stroke.endcap = options.lineCap.replace("butt", "flat"), stroke.joinstyle = options.lineJoin) : stroke && (container.removeChild(stroke), 
                    layer._stroke = null), options.fill ? (fill || (fill = layer._fill = vmlCreate("fill")), 
                    container.appendChild(fill), fill.color = options.fillColor || options.color, fill.opacity = options.fillOpacity) : fill && (container.removeChild(fill), 
                    layer._fill = null);
                },
                _updateCircle: function(layer) {
                    var p = layer._point.round(), r = Math.round(layer._radius), r2 = Math.round(layer._radiusY || r);
                    this._setPath(layer, layer._empty() ? "M0 0" : "AL " + p.x + "," + p.y + " " + r + "," + r2 + " 0,23592600");
                },
                _setPath: function(layer, path) {
                    layer._path.v = path;
                },
                _bringToFront: function(layer) {
                    toFront(layer._container);
                },
                _bringToBack: function(layer) {
                    toBack(layer._container);
                }
            }, create = Browser.vml ? vmlCreate : svgCreate, SVG = Renderer.extend({
                _initContainer: function() {
                    this._container = create("svg"), this._container.setAttribute("pointer-events", "none"), 
                    this._rootGroup = create("g"), this._container.appendChild(this._rootGroup);
                },
                _destroyContainer: function() {
                    remove(this._container), off(this._container), delete this._container, delete this._rootGroup, 
                    delete this._svgSize;
                },
                _update: function() {
                    if (!this._map._animatingZoom || !this._bounds) {
                        Renderer.prototype._update.call(this);
                        var b = this._bounds, size = b.getSize(), container = this._container;
                        this._svgSize && this._svgSize.equals(size) || (this._svgSize = size, container.setAttribute("width", size.x), 
                        container.setAttribute("height", size.y)), setPosition(container, b.min), container.setAttribute("viewBox", [ b.min.x, b.min.y, size.x, size.y ].join(" ")), 
                        this.fire("update");
                    }
                },
                _initPath: function(layer) {
                    var path = layer._path = create("path");
                    layer.options.className && addClass(path, layer.options.className), layer.options.interactive && addClass(path, "leaflet-interactive"), 
                    this._updateStyle(layer), this._layers[stamp(layer)] = layer;
                },
                _addPath: function(layer) {
                    this._rootGroup || this._initContainer(), this._rootGroup.appendChild(layer._path), 
                    layer.addInteractiveTarget(layer._path);
                },
                _removePath: function(layer) {
                    remove(layer._path), layer.removeInteractiveTarget(layer._path), delete this._layers[stamp(layer)];
                },
                _updatePath: function(layer) {
                    layer._project(), layer._update();
                },
                _updateStyle: function(layer) {
                    var path = layer._path, options = layer.options;
                    path && (options.stroke ? (path.setAttribute("stroke", options.color), path.setAttribute("stroke-opacity", options.opacity), 
                    path.setAttribute("stroke-width", options.weight), path.setAttribute("stroke-linecap", options.lineCap), 
                    path.setAttribute("stroke-linejoin", options.lineJoin), options.dashArray ? path.setAttribute("stroke-dasharray", options.dashArray) : path.removeAttribute("stroke-dasharray"), 
                    options.dashOffset ? path.setAttribute("stroke-dashoffset", options.dashOffset) : path.removeAttribute("stroke-dashoffset")) : path.setAttribute("stroke", "none"), 
                    options.fill ? (path.setAttribute("fill", options.fillColor || options.color), path.setAttribute("fill-opacity", options.fillOpacity), 
                    path.setAttribute("fill-rule", options.fillRule || "evenodd")) : path.setAttribute("fill", "none"));
                },
                _updatePoly: function(layer, closed) {
                    this._setPath(layer, pointsToPath(layer._parts, closed));
                },
                _updateCircle: function(layer) {
                    var p = layer._point, r = Math.max(Math.round(layer._radius), 1), arc = "a" + r + "," + (Math.max(Math.round(layer._radiusY), 1) || r) + " 0 1,0 ", d = layer._empty() ? "M0 0" : "M" + (p.x - r) + "," + p.y + arc + 2 * r + ",0 " + arc + 2 * -r + ",0 ";
                    this._setPath(layer, d);
                },
                _setPath: function(layer, path) {
                    layer._path.setAttribute("d", path);
                },
                _bringToFront: function(layer) {
                    toFront(layer._path);
                },
                _bringToBack: function(layer) {
                    toBack(layer._path);
                }
            });
            function svg(options) {
                return Browser.svg || Browser.vml ? new SVG(options) : null;
            }
            Browser.vml && SVG.include(vmlMixin), Map.include({
                getRenderer: function(layer) {
                    var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;
                    return renderer || (renderer = this._renderer = this._createRenderer()), this.hasLayer(renderer) || this.addLayer(renderer), 
                    renderer;
                },
                _getPaneRenderer: function(name) {
                    if ("overlayPane" === name || void 0 === name) return !1;
                    var renderer = this._paneRenderers[name];
                    return void 0 === renderer && (renderer = this._createRenderer({
                        pane: name
                    }), this._paneRenderers[name] = renderer), renderer;
                },
                _createRenderer: function(options) {
                    return this.options.preferCanvas && canvas(options) || svg(options);
                }
            });
            var Rectangle = Polygon.extend({
                initialize: function(latLngBounds, options) {
                    Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
                },
                setBounds: function(latLngBounds) {
                    return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
                },
                _boundsToLatLngs: function(latLngBounds) {
                    return [ (latLngBounds = toLatLngBounds(latLngBounds)).getSouthWest(), latLngBounds.getNorthWest(), latLngBounds.getNorthEast(), latLngBounds.getSouthEast() ];
                }
            });
            function rectangle(latLngBounds, options) {
                return new Rectangle(latLngBounds, options);
            }
            SVG.create = create, SVG.pointsToPath = pointsToPath, GeoJSON.geometryToLayer = geometryToLayer, 
            GeoJSON.coordsToLatLng = coordsToLatLng, GeoJSON.coordsToLatLngs = coordsToLatLngs, 
            GeoJSON.latLngToCoords = latLngToCoords, GeoJSON.latLngsToCoords = latLngsToCoords, 
            GeoJSON.getFeature = getFeature, GeoJSON.asFeature = asFeature, Map.mergeOptions({
                boxZoom: !0
            });
            var BoxZoom = Handler.extend({
                initialize: function(map) {
                    this._map = map, this._container = map._container, this._pane = map._panes.overlayPane, 
                    this._resetStateTimeout = 0, map.on("unload", this._destroy, this);
                },
                addHooks: function() {
                    on(this._container, "mousedown", this._onMouseDown, this);
                },
                removeHooks: function() {
                    off(this._container, "mousedown", this._onMouseDown, this);
                },
                moved: function() {
                    return this._moved;
                },
                _destroy: function() {
                    remove(this._pane), delete this._pane;
                },
                _resetState: function() {
                    this._resetStateTimeout = 0, this._moved = !1;
                },
                _clearDeferredResetState: function() {
                    0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);
                },
                _onMouseDown: function(e) {
                    if (!e.shiftKey || 1 !== e.which && 1 !== e.button) return !1;
                    this._clearDeferredResetState(), this._resetState(), disableTextSelection(), disableImageDrag(), 
                    this._startPoint = this._map.mouseEventToContainerPoint(e), on(document, {
                        contextmenu: stop,
                        mousemove: this._onMouseMove,
                        mouseup: this._onMouseUp,
                        keydown: this._onKeyDown
                    }, this);
                },
                _onMouseMove: function(e) {
                    this._moved || (this._moved = !0, this._box = create$1("div", "leaflet-zoom-box", this._container), 
                    addClass(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), 
                    this._point = this._map.mouseEventToContainerPoint(e);
                    var bounds = new Bounds(this._point, this._startPoint), size = bounds.getSize();
                    setPosition(this._box, bounds.min), this._box.style.width = size.x + "px", this._box.style.height = size.y + "px";
                },
                _finish: function() {
                    this._moved && (remove(this._box), removeClass(this._container, "leaflet-crosshair")), 
                    enableTextSelection(), enableImageDrag(), off(document, {
                        contextmenu: stop,
                        mousemove: this._onMouseMove,
                        mouseup: this._onMouseUp,
                        keydown: this._onKeyDown
                    }, this);
                },
                _onMouseUp: function(e) {
                    if ((1 === e.which || 1 === e.button) && (this._finish(), this._moved)) {
                        this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);
                        var bounds = new LatLngBounds(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));
                        this._map.fitBounds(bounds).fire("boxzoomend", {
                            boxZoomBounds: bounds
                        });
                    }
                },
                _onKeyDown: function(e) {
                    27 === e.keyCode && (this._finish(), this._clearDeferredResetState(), this._resetState());
                }
            });
            Map.addInitHook("addHandler", "boxZoom", BoxZoom), Map.mergeOptions({
                doubleClickZoom: !0
            });
            var DoubleClickZoom = Handler.extend({
                addHooks: function() {
                    this._map.on("dblclick", this._onDoubleClick, this);
                },
                removeHooks: function() {
                    this._map.off("dblclick", this._onDoubleClick, this);
                },
                _onDoubleClick: function(e) {
                    var map = this._map, oldZoom = map.getZoom(), delta = map.options.zoomDelta, zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;
                    "center" === map.options.doubleClickZoom ? map.setZoom(zoom) : map.setZoomAround(e.containerPoint, zoom);
                }
            });
            Map.addInitHook("addHandler", "doubleClickZoom", DoubleClickZoom), Map.mergeOptions({
                dragging: !0,
                inertia: !0,
                inertiaDeceleration: 3400,
                inertiaMaxSpeed: 1 / 0,
                easeLinearity: .2,
                worldCopyJump: !1,
                maxBoundsViscosity: 0
            });
            var Drag = Handler.extend({
                addHooks: function() {
                    if (!this._draggable) {
                        var map = this._map;
                        this._draggable = new Draggable(map._mapPane, map._container), this._draggable.on({
                            dragstart: this._onDragStart,
                            drag: this._onDrag,
                            dragend: this._onDragEnd
                        }, this), this._draggable.on("predrag", this._onPreDragLimit, this), map.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), 
                        map.on("zoomend", this._onZoomEnd, this), map.whenReady(this._onZoomEnd, this));
                    }
                    addClass(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), 
                    this._positions = [], this._times = [];
                },
                removeHooks: function() {
                    removeClass(this._map._container, "leaflet-grab"), removeClass(this._map._container, "leaflet-touch-drag"), 
                    this._draggable.disable();
                },
                moved: function() {
                    return this._draggable && this._draggable._moved;
                },
                moving: function() {
                    return this._draggable && this._draggable._moving;
                },
                _onDragStart: function() {
                    var map = this._map;
                    if (map._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
                        var bounds = toLatLngBounds(this._map.options.maxBounds);
                        this._offsetLimit = toBounds(this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), 
                        this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));
                    } else this._offsetLimit = null;
                    map.fire("movestart").fire("dragstart"), map.options.inertia && (this._positions = [], 
                    this._times = []);
                },
                _onDrag: function(e) {
                    if (this._map.options.inertia) {
                        var time = this._lastTime = +new Date, pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;
                        this._positions.push(pos), this._times.push(time), this._prunePositions(time);
                    }
                    this._map.fire("move", e).fire("drag", e);
                },
                _prunePositions: function(time) {
                    for (;this._positions.length > 1 && time - this._times[0] > 50; ) this._positions.shift(), 
                    this._times.shift();
                },
                _onZoomEnd: function() {
                    var pxCenter = this._map.getSize().divideBy(2), pxWorldCenter = this._map.latLngToLayerPoint([ 0, 0 ]);
                    this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
                },
                _viscousLimit: function(value, threshold) {
                    return value - (value - threshold) * this._viscosity;
                },
                _onPreDragLimit: function() {
                    if (this._viscosity && this._offsetLimit) {
                        var offset = this._draggable._newPos.subtract(this._draggable._startPos), limit = this._offsetLimit;
                        offset.x < limit.min.x && (offset.x = this._viscousLimit(offset.x, limit.min.x)), 
                        offset.y < limit.min.y && (offset.y = this._viscousLimit(offset.y, limit.min.y)), 
                        offset.x > limit.max.x && (offset.x = this._viscousLimit(offset.x, limit.max.x)), 
                        offset.y > limit.max.y && (offset.y = this._viscousLimit(offset.y, limit.max.y)), 
                        this._draggable._newPos = this._draggable._startPos.add(offset);
                    }
                },
                _onPreDragWrap: function() {
                    var worldWidth = this._worldWidth, halfWidth = Math.round(worldWidth / 2), dx = this._initialWorldOffset, x = this._draggable._newPos.x, newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx, newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx, newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;
                    this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = newX;
                },
                _onDragEnd: function(e) {
                    var map = this._map, options = map.options, noInertia = !options.inertia || e.noInertia || this._times.length < 2;
                    if (map.fire("dragend", e), noInertia) map.fire("moveend"); else {
                        this._prunePositions(+new Date);
                        var direction = this._lastPos.subtract(this._positions[0]), duration = (this._lastTime - this._times[0]) / 1e3, ease = options.easeLinearity, speedVector = direction.multiplyBy(ease / duration), speed = speedVector.distanceTo([ 0, 0 ]), limitedSpeed = Math.min(options.inertiaMaxSpeed, speed), limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed), decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease), offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();
                        offset.x || offset.y ? (offset = map._limitOffset(offset, map.options.maxBounds), 
                        requestAnimFrame((function() {
                            map.panBy(offset, {
                                duration: decelerationDuration,
                                easeLinearity: ease,
                                noMoveStart: !0,
                                animate: !0
                            });
                        }))) : map.fire("moveend");
                    }
                }
            });
            Map.addInitHook("addHandler", "dragging", Drag), Map.mergeOptions({
                keyboard: !0,
                keyboardPanDelta: 80
            });
            var Keyboard = Handler.extend({
                keyCodes: {
                    left: [ 37 ],
                    right: [ 39 ],
                    down: [ 40 ],
                    up: [ 38 ],
                    zoomIn: [ 187, 107, 61, 171 ],
                    zoomOut: [ 189, 109, 54, 173 ]
                },
                initialize: function(map) {
                    this._map = map, this._setPanDelta(map.options.keyboardPanDelta), this._setZoomDelta(map.options.zoomDelta);
                },
                addHooks: function() {
                    var container = this._map._container;
                    container.tabIndex <= 0 && (container.tabIndex = "0"), on(container, {
                        focus: this._onFocus,
                        blur: this._onBlur,
                        mousedown: this._onMouseDown
                    }, this), this._map.on({
                        focus: this._addHooks,
                        blur: this._removeHooks
                    }, this);
                },
                removeHooks: function() {
                    this._removeHooks(), off(this._map._container, {
                        focus: this._onFocus,
                        blur: this._onBlur,
                        mousedown: this._onMouseDown
                    }, this), this._map.off({
                        focus: this._addHooks,
                        blur: this._removeHooks
                    }, this);
                },
                _onMouseDown: function() {
                    if (!this._focused) {
                        var body = document.body, docEl = document.documentElement, top = body.scrollTop || docEl.scrollTop, left = body.scrollLeft || docEl.scrollLeft;
                        this._map._container.focus(), window.scrollTo(left, top);
                    }
                },
                _onFocus: function() {
                    this._focused = !0, this._map.fire("focus");
                },
                _onBlur: function() {
                    this._focused = !1, this._map.fire("blur");
                },
                _setPanDelta: function(panDelta) {
                    var i, len, keys = this._panKeys = {}, codes = this.keyCodes;
                    for (i = 0, len = codes.left.length; i < len; i++) keys[codes.left[i]] = [ -1 * panDelta, 0 ];
                    for (i = 0, len = codes.right.length; i < len; i++) keys[codes.right[i]] = [ panDelta, 0 ];
                    for (i = 0, len = codes.down.length; i < len; i++) keys[codes.down[i]] = [ 0, panDelta ];
                    for (i = 0, len = codes.up.length; i < len; i++) keys[codes.up[i]] = [ 0, -1 * panDelta ];
                },
                _setZoomDelta: function(zoomDelta) {
                    var i, len, keys = this._zoomKeys = {}, codes = this.keyCodes;
                    for (i = 0, len = codes.zoomIn.length; i < len; i++) keys[codes.zoomIn[i]] = zoomDelta;
                    for (i = 0, len = codes.zoomOut.length; i < len; i++) keys[codes.zoomOut[i]] = -zoomDelta;
                },
                _addHooks: function() {
                    on(document, "keydown", this._onKeyDown, this);
                },
                _removeHooks: function() {
                    off(document, "keydown", this._onKeyDown, this);
                },
                _onKeyDown: function(e) {
                    if (!(e.altKey || e.ctrlKey || e.metaKey)) {
                        var offset, key = e.keyCode, map = this._map;
                        if (key in this._panKeys) {
                            if (!map._panAnim || !map._panAnim._inProgress) if (offset = this._panKeys[key], 
                            e.shiftKey && (offset = toPoint(offset).multiplyBy(3)), map.options.maxBounds && (offset = map._limitOffset(toPoint(offset), map.options.maxBounds)), 
                            map.options.worldCopyJump) {
                                var newLatLng = map.wrapLatLng(map.unproject(map.project(map.getCenter()).add(offset)));
                                map.panTo(newLatLng);
                            } else map.panBy(offset);
                        } else if (key in this._zoomKeys) map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]); else {
                            if (27 !== key || !map._popup || !map._popup.options.closeOnEscapeKey) return;
                            map.closePopup();
                        }
                        stop(e);
                    }
                }
            });
            Map.addInitHook("addHandler", "keyboard", Keyboard), Map.mergeOptions({
                scrollWheelZoom: !0,
                wheelDebounceTime: 40,
                wheelPxPerZoomLevel: 60
            });
            var ScrollWheelZoom = Handler.extend({
                addHooks: function() {
                    on(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0;
                },
                removeHooks: function() {
                    off(this._map._container, "wheel", this._onWheelScroll, this);
                },
                _onWheelScroll: function(e) {
                    var delta = getWheelDelta(e), debounce = this._map.options.wheelDebounceTime;
                    this._delta += delta, this._lastMousePos = this._map.mouseEventToContainerPoint(e), 
                    this._startTime || (this._startTime = +new Date);
                    var left = Math.max(debounce - (+new Date - this._startTime), 0);
                    clearTimeout(this._timer), this._timer = setTimeout(bind(this._performZoom, this), left), 
                    stop(e);
                },
                _performZoom: function() {
                    var map = this._map, zoom = map.getZoom(), snap = this._map.options.zoomSnap || 0;
                    map._stop();
                    var d2 = this._delta / (4 * this._map.options.wheelPxPerZoomLevel), d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2, d4 = snap ? Math.ceil(d3 / snap) * snap : d3, delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;
                    this._delta = 0, this._startTime = null, delta && ("center" === map.options.scrollWheelZoom ? map.setZoom(zoom + delta) : map.setZoomAround(this._lastMousePos, zoom + delta));
                }
            });
            Map.addInitHook("addHandler", "scrollWheelZoom", ScrollWheelZoom);
            var tapHoldDelay = 600;
            Map.mergeOptions({
                tapHold: Browser.touchNative && Browser.safari && Browser.mobile,
                tapTolerance: 15
            });
            var TapHold = Handler.extend({
                addHooks: function() {
                    on(this._map._container, "touchstart", this._onDown, this);
                },
                removeHooks: function() {
                    off(this._map._container, "touchstart", this._onDown, this);
                },
                _onDown: function(e) {
                    if (clearTimeout(this._holdTimeout), 1 === e.touches.length) {
                        var first = e.touches[0];
                        this._startPos = this._newPos = new Point(first.clientX, first.clientY), this._holdTimeout = setTimeout(bind((function() {
                            this._cancel(), this._isTapValid() && (on(document, "touchend", preventDefault), 
                            on(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", first));
                        }), this), tapHoldDelay), on(document, "touchend touchcancel contextmenu", this._cancel, this), 
                        on(document, "touchmove", this._onMove, this);
                    }
                },
                _cancelClickPrevent: function cancelClickPrevent() {
                    off(document, "touchend", preventDefault), off(document, "touchend touchcancel", cancelClickPrevent);
                },
                _cancel: function() {
                    clearTimeout(this._holdTimeout), off(document, "touchend touchcancel contextmenu", this._cancel, this), 
                    off(document, "touchmove", this._onMove, this);
                },
                _onMove: function(e) {
                    var first = e.touches[0];
                    this._newPos = new Point(first.clientX, first.clientY);
                },
                _isTapValid: function() {
                    return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
                },
                _simulateEvent: function(type, e) {
                    var simulatedEvent = new MouseEvent(type, {
                        bubbles: !0,
                        cancelable: !0,
                        view: window,
                        screenX: e.screenX,
                        screenY: e.screenY,
                        clientX: e.clientX,
                        clientY: e.clientY
                    });
                    simulatedEvent._simulated = !0, e.target.dispatchEvent(simulatedEvent);
                }
            });
            Map.addInitHook("addHandler", "tapHold", TapHold), Map.mergeOptions({
                touchZoom: Browser.touch,
                bounceAtZoomLimits: !0
            });
            var TouchZoom = Handler.extend({
                addHooks: function() {
                    addClass(this._map._container, "leaflet-touch-zoom"), on(this._map._container, "touchstart", this._onTouchStart, this);
                },
                removeHooks: function() {
                    removeClass(this._map._container, "leaflet-touch-zoom"), off(this._map._container, "touchstart", this._onTouchStart, this);
                },
                _onTouchStart: function(e) {
                    var map = this._map;
                    if (e.touches && 2 === e.touches.length && !map._animatingZoom && !this._zooming) {
                        var p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]);
                        this._centerPoint = map.getSize()._divideBy(2), this._startLatLng = map.containerPointToLatLng(this._centerPoint), 
                        "center" !== map.options.touchZoom && (this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2))), 
                        this._startDist = p1.distanceTo(p2), this._startZoom = map.getZoom(), this._moved = !1, 
                        this._zooming = !0, map._stop(), on(document, "touchmove", this._onTouchMove, this), 
                        on(document, "touchend touchcancel", this._onTouchEnd, this), preventDefault(e);
                    }
                },
                _onTouchMove: function(e) {
                    if (e.touches && 2 === e.touches.length && this._zooming) {
                        var map = this._map, p1 = map.mouseEventToContainerPoint(e.touches[0]), p2 = map.mouseEventToContainerPoint(e.touches[1]), scale = p1.distanceTo(p2) / this._startDist;
                        if (this._zoom = map.getScaleZoom(scale, this._startZoom), !map.options.bounceAtZoomLimits && (this._zoom < map.getMinZoom() && scale < 1 || this._zoom > map.getMaxZoom() && scale > 1) && (this._zoom = map._limitZoom(this._zoom)), 
                        "center" === map.options.touchZoom) {
                            if (this._center = this._startLatLng, 1 === scale) return;
                        } else {
                            var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
                            if (1 === scale && 0 === delta.x && 0 === delta.y) return;
                            this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
                        }
                        this._moved || (map._moveStart(!0, !1), this._moved = !0), cancelAnimFrame(this._animRequest);
                        var moveFn = bind(map._move, map, this._center, this._zoom, {
                            pinch: !0,
                            round: !1
                        }, void 0);
                        this._animRequest = requestAnimFrame(moveFn, this, !0), preventDefault(e);
                    }
                },
                _onTouchEnd: function() {
                    this._moved && this._zooming ? (this._zooming = !1, cancelAnimFrame(this._animRequest), 
                    off(document, "touchmove", this._onTouchMove, this), off(document, "touchend touchcancel", this._onTouchEnd, this), 
                    this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1;
                }
            });
            Map.addInitHook("addHandler", "touchZoom", TouchZoom), Map.BoxZoom = BoxZoom, Map.DoubleClickZoom = DoubleClickZoom, 
            Map.Drag = Drag, Map.Keyboard = Keyboard, Map.ScrollWheelZoom = ScrollWheelZoom, 
            Map.TapHold = TapHold, Map.TouchZoom = TouchZoom, exports.Bounds = Bounds, exports.Browser = Browser, 
            exports.CRS = CRS, exports.Canvas = Canvas, exports.Circle = Circle, exports.CircleMarker = CircleMarker, 
            exports.Class = Class, exports.Control = Control, exports.DivIcon = DivIcon, exports.DivOverlay = DivOverlay, 
            exports.DomEvent = DomEvent, exports.DomUtil = DomUtil, exports.Draggable = Draggable, 
            exports.Evented = Evented, exports.FeatureGroup = FeatureGroup, exports.GeoJSON = GeoJSON, 
            exports.GridLayer = GridLayer, exports.Handler = Handler, exports.Icon = Icon, exports.ImageOverlay = ImageOverlay, 
            exports.LatLng = LatLng, exports.LatLngBounds = LatLngBounds, exports.Layer = Layer, 
            exports.LayerGroup = LayerGroup, exports.LineUtil = LineUtil, exports.Map = Map, 
            exports.Marker = Marker, exports.Mixin = Mixin, exports.Path = Path, exports.Point = Point, 
            exports.PolyUtil = PolyUtil, exports.Polygon = Polygon, exports.Polyline = Polyline, 
            exports.Popup = Popup, exports.PosAnimation = PosAnimation, exports.Projection = index, 
            exports.Rectangle = Rectangle, exports.Renderer = Renderer, exports.SVG = SVG, exports.SVGOverlay = SVGOverlay, 
            exports.TileLayer = TileLayer, exports.Tooltip = Tooltip, exports.Transformation = Transformation, 
            exports.Util = Util, exports.VideoOverlay = VideoOverlay, exports.bind = bind, exports.bounds = toBounds, 
            exports.canvas = canvas, exports.circle = circle, exports.circleMarker = circleMarker, 
            exports.control = control, exports.divIcon = divIcon, exports.extend = extend, exports.featureGroup = featureGroup, 
            exports.geoJSON = geoJSON, exports.geoJson = geoJson, exports.gridLayer = gridLayer, 
            exports.icon = icon, exports.imageOverlay = imageOverlay, exports.latLng = toLatLng, 
            exports.latLngBounds = toLatLngBounds, exports.layerGroup = layerGroup, exports.map = createMap, 
            exports.marker = marker, exports.point = toPoint, exports.polygon = polygon, exports.polyline = polyline, 
            exports.popup = popup, exports.rectangle = rectangle, exports.setOptions = setOptions, 
            exports.stamp = stamp, exports.svg = svg, exports.svgOverlay = svgOverlay, exports.tileLayer = tileLayer, 
            exports.tooltip = tooltip, exports.transformation = toTransformation, exports.version = version, 
            exports.videoOverlay = videoOverlay;
            var oldL = window.L;
            exports.noConflict = function() {
                return window.L = oldL, this;
            }, window.L = exports;
        }(exports);
    },
    301: (__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
        "use strict";
        __webpack_require__.d(__webpack_exports__, {
            A: () => lib
        });
        var PJD_3PARAM = 1, PJD_7PARAM = 2, PJD_GRIDSHIFT = 3, PJD_NODATUM = 5, SRS_WGS84_SEMIMAJOR = 6378137, SRS_WGS84_SEMIMINOR = 6356752.314, SRS_WGS84_ESQUARED = .0066943799901413165, SEC_TO_RAD = 484813681109536e-20, HALF_PI = Math.PI / 2, SIXTH = .16666666666666666, RA4 = .04722222222222222, RA6 = .022156084656084655, EPSLN = 1e-10, D2R = .017453292519943295, R2D = 57.29577951308232, FORTPI = Math.PI / 4, TWO_PI = 2 * Math.PI, SPI = 3.14159265359, PrimeMeridian_exports = {
            greenwich: 0,
            lisbon: -9.131906111111,
            paris: 2.337229166667,
            bogota: -74.080916666667,
            madrid: -3.687938888889,
            rome: 12.452333333333,
            bern: 7.439583333333,
            jakarta: 106.807719444444,
            ferro: -17.666666666667,
            brussels: 4.367975,
            stockholm: 18.058277777778,
            athens: 23.7163375,
            oslo: 10.722916666667
        };
        const units = {
            ft: {
                to_meter: .3048
            },
            "us-ft": {
                to_meter: 1200 / 3937
            }
        };
        var ignoredChar = /[\s_\-\/\(\)]/g;
        function match(obj, key) {
            if (obj[key]) return obj[key];
            for (var testkey, keys = Object.keys(obj), lkey = key.toLowerCase().replace(ignoredChar, ""), i = -1; ++i < keys.length; ) if ((testkey = keys[i]).toLowerCase().replace(ignoredChar, "") === lkey) return obj[testkey];
        }
        function projString(defData) {
            var paramName, paramVal, paramOutname, self = {}, paramObj = defData.split("+").map((function(v) {
                return v.trim();
            })).filter((function(a) {
                return a;
            })).reduce((function(p, a) {
                var split = a.split("=");
                return split.push(!0), p[split[0].toLowerCase()] = split[1], p;
            }), {}), params = {
                proj: "projName",
                datum: "datumCode",
                rf: function(v) {
                    self.rf = parseFloat(v);
                },
                lat_0: function(v) {
                    self.lat0 = v * D2R;
                },
                lat_1: function(v) {
                    self.lat1 = v * D2R;
                },
                lat_2: function(v) {
                    self.lat2 = v * D2R;
                },
                lat_ts: function(v) {
                    self.lat_ts = v * D2R;
                },
                lon_0: function(v) {
                    self.long0 = v * D2R;
                },
                lon_1: function(v) {
                    self.long1 = v * D2R;
                },
                lon_2: function(v) {
                    self.long2 = v * D2R;
                },
                alpha: function(v) {
                    self.alpha = parseFloat(v) * D2R;
                },
                gamma: function(v) {
                    self.rectified_grid_angle = parseFloat(v);
                },
                lonc: function(v) {
                    self.longc = v * D2R;
                },
                x_0: function(v) {
                    self.x0 = parseFloat(v);
                },
                y_0: function(v) {
                    self.y0 = parseFloat(v);
                },
                k_0: function(v) {
                    self.k0 = parseFloat(v);
                },
                k: function(v) {
                    self.k0 = parseFloat(v);
                },
                a: function(v) {
                    self.a = parseFloat(v);
                },
                b: function(v) {
                    self.b = parseFloat(v);
                },
                r: function(v) {
                    self.a = self.b = parseFloat(v);
                },
                r_a: function() {
                    self.R_A = !0;
                },
                zone: function(v) {
                    self.zone = parseInt(v, 10);
                },
                south: function() {
                    self.utmSouth = !0;
                },
                towgs84: function(v) {
                    self.datum_params = v.split(",").map((function(a) {
                        return parseFloat(a);
                    }));
                },
                to_meter: function(v) {
                    self.to_meter = parseFloat(v);
                },
                units: function(v) {
                    self.units = v;
                    var unit = match(units, v);
                    unit && (self.to_meter = unit.to_meter);
                },
                from_greenwich: function(v) {
                    self.from_greenwich = v * D2R;
                },
                pm: function(v) {
                    var pm = match(PrimeMeridian_exports, v);
                    self.from_greenwich = (pm || parseFloat(v)) * D2R;
                },
                nadgrids: function(v) {
                    "@null" === v ? self.datumCode = "none" : self.nadgrids = v;
                },
                axis: function(v) {
                    3 === v.length && -1 !== "ewnsud".indexOf(v.substr(0, 1)) && -1 !== "ewnsud".indexOf(v.substr(1, 1)) && -1 !== "ewnsud".indexOf(v.substr(2, 1)) && (self.axis = v);
                },
                approx: function() {
                    self.approx = !0;
                }
            };
            for (paramName in paramObj) paramVal = paramObj[paramName], paramName in params ? "function" == typeof (paramOutname = params[paramName]) ? paramOutname(paramVal) : self[paramOutname] = paramVal : self[paramName] = paramVal;
            return "string" == typeof self.datumCode && "WGS84" !== self.datumCode && (self.datumCode = self.datumCode.toLowerCase()), 
            self;
        }
        const parser = function(txt) {
            var parser = new Parser(txt);
            return parser.output();
        };
        var NEUTRAL = 1, whitespace = /\s/, latin = /[A-Za-z]/, keyword = /[A-Za-z84_]/, endThings = /[,\]]/, digets = /[\d\.E\-\+]/;
        function Parser(text) {
            if ("string" != typeof text) throw new Error("not a string");
            this.text = text.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], 
            this.currentObject = null, this.state = NEUTRAL;
        }
        function mapit(obj, key, value) {
            Array.isArray(key) && (value.unshift(key), key = null);
            var thing = key ? {} : obj, out = value.reduce((function(newObj, item) {
                return sExpr(item, newObj), newObj;
            }), thing);
            key && (obj[key] = out);
        }
        function sExpr(v, obj) {
            if (Array.isArray(v)) {
                var key = v.shift();
                if ("PARAMETER" === key && (key = v.shift()), 1 === v.length) return Array.isArray(v[0]) ? (obj[key] = {}, 
                void sExpr(v[0], obj[key])) : void (obj[key] = v[0]);
                if (v.length) if ("TOWGS84" !== key) {
                    if ("AXIS" === key) return key in obj || (obj[key] = []), void obj[key].push(v);
                    var i;
                    switch (Array.isArray(key) || (obj[key] = {}), key) {
                      case "UNIT":
                      case "PRIMEM":
                      case "VERT_DATUM":
                        return obj[key] = {
                            name: v[0].toLowerCase(),
                            convert: v[1]
                        }, void (3 === v.length && sExpr(v[2], obj[key]));

                      case "SPHEROID":
                      case "ELLIPSOID":
                        return obj[key] = {
                            name: v[0],
                            a: v[1],
                            rf: v[2]
                        }, void (4 === v.length && sExpr(v[3], obj[key]));

                      case "PROJECTEDCRS":
                      case "PROJCRS":
                      case "GEOGCS":
                      case "GEOCCS":
                      case "PROJCS":
                      case "LOCAL_CS":
                      case "GEODCRS":
                      case "GEODETICCRS":
                      case "GEODETICDATUM":
                      case "EDATUM":
                      case "ENGINEERINGDATUM":
                      case "VERT_CS":
                      case "VERTCRS":
                      case "VERTICALCRS":
                      case "COMPD_CS":
                      case "COMPOUNDCRS":
                      case "ENGINEERINGCRS":
                      case "ENGCRS":
                      case "FITTED_CS":
                      case "LOCAL_DATUM":
                      case "DATUM":
                        return v[0] = [ "name", v[0] ], void mapit(obj, key, v);

                      default:
                        for (i = -1; ++i < v.length; ) if (!Array.isArray(v[i])) return sExpr(v, obj[key]);
                        return mapit(obj, key, v);
                    }
                } else obj[key] = v; else obj[key] = !0;
            } else obj[v] = !0;
        }
        Parser.prototype.readCharicter = function() {
            var char = this.text[this.place++];
            if (4 !== this.state) for (;whitespace.test(char); ) {
                if (this.place >= this.text.length) return;
                char = this.text[this.place++];
            }
            switch (this.state) {
              case NEUTRAL:
                return this.neutral(char);

              case 2:
                return this.keyword(char);

              case 4:
                return this.quoted(char);

              case 5:
                return this.afterquote(char);

              case 3:
                return this.number(char);

              case -1:
                return;
            }
        }, Parser.prototype.afterquote = function(char) {
            if ('"' === char) return this.word += '"', void (this.state = 4);
            if (endThings.test(char)) return this.word = this.word.trim(), void this.afterItem(char);
            throw new Error("havn't handled \"" + char + '" in afterquote yet, index ' + this.place);
        }, Parser.prototype.afterItem = function(char) {
            return "," === char ? (null !== this.word && this.currentObject.push(this.word), 
            this.word = null, void (this.state = NEUTRAL)) : "]" === char ? (this.level--, null !== this.word && (this.currentObject.push(this.word), 
            this.word = null), this.state = NEUTRAL, this.currentObject = this.stack.pop(), 
            void (this.currentObject || (this.state = -1))) : void 0;
        }, Parser.prototype.number = function(char) {
            if (!digets.test(char)) {
                if (endThings.test(char)) return this.word = parseFloat(this.word), void this.afterItem(char);
                throw new Error("havn't handled \"" + char + '" in number yet, index ' + this.place);
            }
            this.word += char;
        }, Parser.prototype.quoted = function(char) {
            '"' !== char ? this.word += char : this.state = 5;
        }, Parser.prototype.keyword = function(char) {
            if (keyword.test(char)) this.word += char; else {
                if ("[" === char) {
                    var newObjects = [];
                    return newObjects.push(this.word), this.level++, null === this.root ? this.root = newObjects : this.currentObject.push(newObjects), 
                    this.stack.push(this.currentObject), this.currentObject = newObjects, void (this.state = NEUTRAL);
                }
                if (!endThings.test(char)) throw new Error("havn't handled \"" + char + '" in keyword yet, index ' + this.place);
                this.afterItem(char);
            }
        }, Parser.prototype.neutral = function(char) {
            if (latin.test(char)) return this.word = char, void (this.state = 2);
            if ('"' === char) return this.word = "", void (this.state = 4);
            if (digets.test(char)) return this.word = char, void (this.state = 3);
            if (!endThings.test(char)) throw new Error("havn't handled \"" + char + '" in neutral yet, index ' + this.place);
            this.afterItem(char);
        }, Parser.prototype.output = function() {
            for (;this.place < this.text.length; ) this.readCharicter();
            if (-1 === this.state) return this.root;
            throw new Error('unable to parse string "' + this.text + '". State is ' + this.state);
        };
        var wkt_parser_D2R = .017453292519943295;
        function d2r(input) {
            return input * wkt_parser_D2R;
        }
        function wkt_parser(wkt) {
            var lisp = parser(wkt), type = lisp.shift(), name = lisp.shift();
            lisp.unshift([ "name", name ]), lisp.unshift([ "type", type ]);
            var obj = {};
            return sExpr(lisp, obj), function(wkt) {
                if ("GEOGCS" === wkt.type ? wkt.projName = "longlat" : "LOCAL_CS" === wkt.type ? (wkt.projName = "identity", 
                wkt.local = !0) : "object" == typeof wkt.PROJECTION ? wkt.projName = Object.keys(wkt.PROJECTION)[0] : wkt.projName = wkt.PROJECTION, 
                wkt.AXIS) {
                    for (var axisOrder = "", i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
                        var axis = [ wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase() ];
                        -1 !== axis[0].indexOf("north") || ("y" === axis[0] || "lat" === axis[0]) && "north" === axis[1] ? axisOrder += "n" : -1 !== axis[0].indexOf("south") || ("y" === axis[0] || "lat" === axis[0]) && "south" === axis[1] ? axisOrder += "s" : -1 !== axis[0].indexOf("east") || ("x" === axis[0] || "lon" === axis[0]) && "east" === axis[1] ? axisOrder += "e" : -1 === axis[0].indexOf("west") && ("x" !== axis[0] && "lon" !== axis[0] || "west" !== axis[1]) || (axisOrder += "w");
                    }
                    2 === axisOrder.length && (axisOrder += "u"), 3 === axisOrder.length && (wkt.axis = axisOrder);
                }
                wkt.UNIT && (wkt.units = wkt.UNIT.name.toLowerCase(), "metre" === wkt.units && (wkt.units = "meter"), 
                wkt.UNIT.convert && ("GEOGCS" === wkt.type ? wkt.DATUM && wkt.DATUM.SPHEROID && (wkt.to_meter = wkt.UNIT.convert * wkt.DATUM.SPHEROID.a) : wkt.to_meter = wkt.UNIT.convert));
                var geogcs = wkt.GEOGCS;
                function toMeter(input) {
                    return input * (wkt.to_meter || 1);
                }
                "GEOGCS" === wkt.type && (geogcs = wkt), geogcs && (geogcs.DATUM ? wkt.datumCode = geogcs.DATUM.name.toLowerCase() : wkt.datumCode = geogcs.name.toLowerCase(), 
                "d_" === wkt.datumCode.slice(0, 2) && (wkt.datumCode = wkt.datumCode.slice(2)), 
                "new_zealand_geodetic_datum_1949" !== wkt.datumCode && "new_zealand_1949" !== wkt.datumCode || (wkt.datumCode = "nzgd49"), 
                "wgs_1984" !== wkt.datumCode && "world_geodetic_system_1984" !== wkt.datumCode || ("Mercator_Auxiliary_Sphere" === wkt.PROJECTION && (wkt.sphere = !0), 
                wkt.datumCode = "wgs84"), "_ferro" === wkt.datumCode.slice(-6) && (wkt.datumCode = wkt.datumCode.slice(0, -6)), 
                "_jakarta" === wkt.datumCode.slice(-8) && (wkt.datumCode = wkt.datumCode.slice(0, -8)), 
                ~wkt.datumCode.indexOf("belge") && (wkt.datumCode = "rnb72"), geogcs.DATUM && geogcs.DATUM.SPHEROID && (wkt.ellps = geogcs.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/, "clrk"), 
                "international" === wkt.ellps.toLowerCase().slice(0, 13) && (wkt.ellps = "intl"), 
                wkt.a = geogcs.DATUM.SPHEROID.a, wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10)), 
                geogcs.DATUM && geogcs.DATUM.TOWGS84 && (wkt.datum_params = geogcs.DATUM.TOWGS84), 
                ~wkt.datumCode.indexOf("osgb_1936") && (wkt.datumCode = "osgb36"), ~wkt.datumCode.indexOf("osni_1952") && (wkt.datumCode = "osni52"), 
                (~wkt.datumCode.indexOf("tm65") || ~wkt.datumCode.indexOf("geodetic_datum_of_1965")) && (wkt.datumCode = "ire65"), 
                "ch1903+" === wkt.datumCode && (wkt.datumCode = "ch1903"), ~wkt.datumCode.indexOf("israel") && (wkt.datumCode = "isr93")), 
                wkt.b && !isFinite(wkt.b) && (wkt.b = wkt.a), [ [ "standard_parallel_1", "Standard_Parallel_1" ], [ "standard_parallel_1", "Latitude of 1st standard parallel" ], [ "standard_parallel_2", "Standard_Parallel_2" ], [ "standard_parallel_2", "Latitude of 2nd standard parallel" ], [ "false_easting", "False_Easting" ], [ "false_easting", "False easting" ], [ "false-easting", "Easting at false origin" ], [ "false_northing", "False_Northing" ], [ "false_northing", "False northing" ], [ "false_northing", "Northing at false origin" ], [ "central_meridian", "Central_Meridian" ], [ "central_meridian", "Longitude of natural origin" ], [ "central_meridian", "Longitude of false origin" ], [ "latitude_of_origin", "Latitude_Of_Origin" ], [ "latitude_of_origin", "Central_Parallel" ], [ "latitude_of_origin", "Latitude of natural origin" ], [ "latitude_of_origin", "Latitude of false origin" ], [ "scale_factor", "Scale_Factor" ], [ "k0", "scale_factor" ], [ "latitude_of_center", "Latitude_Of_Center" ], [ "latitude_of_center", "Latitude_of_center" ], [ "lat0", "latitude_of_center", d2r ], [ "longitude_of_center", "Longitude_Of_Center" ], [ "longitude_of_center", "Longitude_of_center" ], [ "longc", "longitude_of_center", d2r ], [ "x0", "false_easting", toMeter ], [ "y0", "false_northing", toMeter ], [ "long0", "central_meridian", d2r ], [ "lat0", "latitude_of_origin", d2r ], [ "lat0", "standard_parallel_1", d2r ], [ "lat1", "standard_parallel_1", d2r ], [ "lat2", "standard_parallel_2", d2r ], [ "azimuth", "Azimuth" ], [ "alpha", "azimuth", d2r ], [ "srsCode", "name" ] ].forEach((function(a) {
                    return function(obj, params) {
                        var outName = params[0], inName = params[1];
                        !(outName in obj) && inName in obj && (obj[outName] = obj[inName], 3 === params.length && (obj[outName] = params[2](obj[outName])));
                    }(wkt, a);
                })), wkt.long0 || !wkt.longc || "Albers_Conic_Equal_Area" !== wkt.projName && "Lambert_Azimuthal_Equal_Area" !== wkt.projName || (wkt.long0 = wkt.longc), 
                wkt.lat_ts || !wkt.lat1 || "Stereographic_South_Pole" !== wkt.projName && "Polar Stereographic (variant B)" !== wkt.projName ? !wkt.lat_ts && wkt.lat0 && "Polar_Stereographic" === wkt.projName && (wkt.lat_ts = wkt.lat0, 
                wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90)) : (wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90), 
                wkt.lat_ts = wkt.lat1);
            }(obj), obj;
        }
        function defs(name) {
            var that = this;
            if (2 === arguments.length) {
                var def = arguments[1];
                "string" == typeof def ? "+" === def.charAt(0) ? defs[name] = projString(arguments[1]) : defs[name] = wkt_parser(arguments[1]) : defs[name] = def;
            } else if (1 === arguments.length) {
                if (Array.isArray(name)) return name.map((function(v) {
                    Array.isArray(v) ? defs.apply(that, v) : defs(v);
                }));
                if ("string" == typeof name) {
                    if (name in defs) return defs[name];
                } else "EPSG" in name ? defs["EPSG:" + name.EPSG] = name : "ESRI" in name ? defs["ESRI:" + name.ESRI] = name : "IAU2000" in name ? defs["IAU2000:" + name.IAU2000] = name : console.log(name);
                return;
            }
        }
        !function(defs) {
            defs("EPSG:4326", "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), 
            defs("EPSG:4269", "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), 
            defs("EPSG:3857", "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), 
            defs.WGS84 = defs["EPSG:4326"], defs["EPSG:3785"] = defs["EPSG:3857"], defs.GOOGLE = defs["EPSG:3857"], 
            defs["EPSG:900913"] = defs["EPSG:3857"], defs["EPSG:102113"] = defs["EPSG:3857"];
        }(defs);
        const lib_defs = defs;
        var codeWords = [ "PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS", "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS" ];
        var codes = [ "3857", "900913", "3785", "102113" ];
        const parseCode = function(code) {
            if (!function(code) {
                return "string" == typeof code;
            }(code)) return code;
            if (function(code) {
                return code in lib_defs;
            }(code)) return lib_defs[code];
            if (function(code) {
                return codeWords.some((function(word) {
                    return code.indexOf(word) > -1;
                }));
            }(code)) {
                var out = wkt_parser(code);
                if (function(item) {
                    var auth = match(item, "authority");
                    if (auth) {
                        var code = match(auth, "epsg");
                        return code && codes.indexOf(code) > -1;
                    }
                }(out)) return lib_defs["EPSG:3857"];
                var maybeProjStr = function(item) {
                    var ext = match(item, "extension");
                    if (ext) return match(ext, "proj4");
                }(out);
                return maybeProjStr ? projString(maybeProjStr) : out;
            }
            return function(code) {
                return "+" === code[0];
            }(code) ? projString(code) : void 0;
        };
        function extend(destination, source) {
            var value, property;
            if (destination = destination || {}, !source) return destination;
            for (property in source) void 0 !== (value = source[property]) && (destination[property] = value);
            return destination;
        }
        function msfnz(eccent, sinphi, cosphi) {
            var con = eccent * sinphi;
            return cosphi / Math.sqrt(1 - con * con);
        }
        function sign(x) {
            return x < 0 ? -1 : 1;
        }
        function adjust_lon(x) {
            return Math.abs(x) <= SPI ? x : x - sign(x) * TWO_PI;
        }
        function tsfnz(eccent, phi, sinphi) {
            var con = eccent * sinphi, com = .5 * eccent;
            return con = Math.pow((1 - con) / (1 + con), com), Math.tan(.5 * (HALF_PI - phi)) / con;
        }
        function phi2z(eccent, ts) {
            for (var con, dphi, eccnth = .5 * eccent, phi = HALF_PI - 2 * Math.atan(ts), i = 0; i <= 15; i++) if (con = eccent * Math.sin(phi), 
            phi += dphi = HALF_PI - 2 * Math.atan(ts * Math.pow((1 - con) / (1 + con), eccnth)) - phi, 
            Math.abs(dphi) <= 1e-10) return phi;
            return -9999;
        }
        function identity(pt) {
            return pt;
        }
        var projs = [ {
            init: function() {
                var con = this.b / this.a;
                this.es = 1 - con * con, "x0" in this || (this.x0 = 0), "y0" in this || (this.y0 = 0), 
                this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere ? this.k0 = Math.cos(this.lat_ts) : this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k : this.k0 = 1);
            },
            forward: function(p) {
                var x, y, lon = p.x, lat = p.y;
                if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) return null;
                if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) return null;
                if (this.sphere) x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0), 
                y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + .5 * lat)); else {
                    var sinphi = Math.sin(lat), ts = tsfnz(this.e, lat, sinphi);
                    x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0), y = this.y0 - this.a * this.k0 * Math.log(ts);
                }
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var lon, lat, x = p.x - this.x0, y = p.y - this.y0;
                if (this.sphere) lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0))); else {
                    var ts = Math.exp(-y / (this.a * this.k0));
                    if (-9999 === (lat = phi2z(this.e, ts))) return null;
                }
                return lon = adjust_lon(this.long0 + x / (this.a * this.k0)), p.x = lon, p.y = lat, 
                p;
            },
            names: [ "Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc" ]
        }, {
            init: function() {},
            forward: identity,
            inverse: identity,
            names: [ "longlat", "identity" ]
        } ], projections_names = {}, projStore = [];
        function add(proj, i) {
            var len = projStore.length;
            return proj.names ? (projStore[len] = proj, proj.names.forEach((function(n) {
                projections_names[n.toLowerCase()] = len;
            })), this) : (console.log(i), !0);
        }
        const projections = {
            start: function() {
                projs.forEach(add);
            },
            add,
            get: function(name) {
                if (!name) return !1;
                var n = name.toLowerCase();
                return void 0 !== projections_names[n] && projStore[projections_names[n]] ? projStore[projections_names[n]] : void 0;
            }
        };
        var Ellipsoid_exports = {
            MERIT: {
                a: 6378137,
                rf: 298.257,
                ellipseName: "MERIT 1983"
            },
            SGS85: {
                a: 6378136,
                rf: 298.257,
                ellipseName: "Soviet Geodetic System 85"
            },
            GRS80: {
                a: 6378137,
                rf: 298.257222101,
                ellipseName: "GRS 1980(IUGG, 1980)"
            },
            IAU76: {
                a: 6378140,
                rf: 298.257,
                ellipseName: "IAU 1976"
            },
            airy: {
                a: 6377563.396,
                b: 6356256.91,
                ellipseName: "Airy 1830"
            },
            APL4: {
                a: 6378137,
                rf: 298.25,
                ellipseName: "Appl. Physics. 1965"
            },
            NWL9D: {
                a: 6378145,
                rf: 298.25,
                ellipseName: "Naval Weapons Lab., 1965"
            },
            mod_airy: {
                a: 6377340.189,
                b: 6356034.446,
                ellipseName: "Modified Airy"
            },
            andrae: {
                a: 6377104.43,
                rf: 300,
                ellipseName: "Andrae 1876 (Den., Iclnd.)"
            },
            aust_SA: {
                a: 6378160,
                rf: 298.25,
                ellipseName: "Australian Natl & S. Amer. 1969"
            },
            GRS67: {
                a: 6378160,
                rf: 298.247167427,
                ellipseName: "GRS 67(IUGG 1967)"
            },
            bessel: {
                a: 6377397.155,
                rf: 299.1528128,
                ellipseName: "Bessel 1841"
            },
            bess_nam: {
                a: 6377483.865,
                rf: 299.1528128,
                ellipseName: "Bessel 1841 (Namibia)"
            },
            clrk66: {
                a: 6378206.4,
                b: 6356583.8,
                ellipseName: "Clarke 1866"
            },
            clrk80: {
                a: 6378249.145,
                rf: 293.4663,
                ellipseName: "Clarke 1880 mod."
            },
            clrk80ign: {
                a: 6378249.2,
                b: 6356515,
                rf: 293.4660213,
                ellipseName: "Clarke 1880 (IGN)"
            },
            clrk58: {
                a: 6378293.645208759,
                rf: 294.2606763692654,
                ellipseName: "Clarke 1858"
            },
            CPM: {
                a: 6375738.7,
                rf: 334.29,
                ellipseName: "Comm. des Poids et Mesures 1799"
            },
            delmbr: {
                a: 6376428,
                rf: 311.5,
                ellipseName: "Delambre 1810 (Belgium)"
            },
            engelis: {
                a: 6378136.05,
                rf: 298.2566,
                ellipseName: "Engelis 1985"
            },
            evrst30: {
                a: 6377276.345,
                rf: 300.8017,
                ellipseName: "Everest 1830"
            },
            evrst48: {
                a: 6377304.063,
                rf: 300.8017,
                ellipseName: "Everest 1948"
            },
            evrst56: {
                a: 6377301.243,
                rf: 300.8017,
                ellipseName: "Everest 1956"
            },
            evrst69: {
                a: 6377295.664,
                rf: 300.8017,
                ellipseName: "Everest 1969"
            },
            evrstSS: {
                a: 6377298.556,
                rf: 300.8017,
                ellipseName: "Everest (Sabah & Sarawak)"
            },
            fschr60: {
                a: 6378166,
                rf: 298.3,
                ellipseName: "Fischer (Mercury Datum) 1960"
            },
            fschr60m: {
                a: 6378155,
                rf: 298.3,
                ellipseName: "Fischer 1960"
            },
            fschr68: {
                a: 6378150,
                rf: 298.3,
                ellipseName: "Fischer 1968"
            },
            helmert: {
                a: 6378200,
                rf: 298.3,
                ellipseName: "Helmert 1906"
            },
            hough: {
                a: 6378270,
                rf: 297,
                ellipseName: "Hough"
            },
            intl: {
                a: 6378388,
                rf: 297,
                ellipseName: "International 1909 (Hayford)"
            },
            kaula: {
                a: 6378163,
                rf: 298.24,
                ellipseName: "Kaula 1961"
            },
            lerch: {
                a: 6378139,
                rf: 298.257,
                ellipseName: "Lerch 1979"
            },
            mprts: {
                a: 6397300,
                rf: 191,
                ellipseName: "Maupertius 1738"
            },
            new_intl: {
                a: 6378157.5,
                b: 6356772.2,
                ellipseName: "New International 1967"
            },
            plessis: {
                a: 6376523,
                rf: 6355863,
                ellipseName: "Plessis 1817 (France)"
            },
            krass: {
                a: 6378245,
                rf: 298.3,
                ellipseName: "Krassovsky, 1942"
            },
            SEasia: {
                a: 6378155,
                b: 6356773.3205,
                ellipseName: "Southeast Asia"
            },
            walbeck: {
                a: 6376896,
                b: 6355834.8467,
                ellipseName: "Walbeck"
            },
            WGS60: {
                a: 6378165,
                rf: 298.3,
                ellipseName: "WGS 60"
            },
            WGS66: {
                a: 6378145,
                rf: 298.25,
                ellipseName: "WGS 66"
            },
            WGS7: {
                a: 6378135,
                rf: 298.26,
                ellipseName: "WGS 72"
            }
        }, WGS84 = Ellipsoid_exports.WGS84 = {
            a: 6378137,
            rf: 298.257223563,
            ellipseName: "WGS 84"
        };
        Ellipsoid_exports.sphere = {
            a: 6370997,
            b: 6370997,
            ellipseName: "Normal Sphere (r=6370997)"
        };
        var Datum_exports = {};
        Datum_exports.wgs84 = {
            towgs84: "0,0,0",
            ellipse: "WGS84",
            datumName: "WGS84"
        }, Datum_exports.ch1903 = {
            towgs84: "674.374,15.056,405.346",
            ellipse: "bessel",
            datumName: "swiss"
        }, Datum_exports.ggrs87 = {
            towgs84: "-199.87,74.79,246.62",
            ellipse: "GRS80",
            datumName: "Greek_Geodetic_Reference_System_1987"
        }, Datum_exports.nad83 = {
            towgs84: "0,0,0",
            ellipse: "GRS80",
            datumName: "North_American_Datum_1983"
        }, Datum_exports.nad27 = {
            nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
            ellipse: "clrk66",
            datumName: "North_American_Datum_1927"
        }, Datum_exports.potsdam = {
            towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
            ellipse: "bessel",
            datumName: "Potsdam Rauenberg 1950 DHDN"
        }, Datum_exports.carthage = {
            towgs84: "-263.0,6.0,431.0",
            ellipse: "clark80",
            datumName: "Carthage 1934 Tunisia"
        }, Datum_exports.hermannskogel = {
            towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
            ellipse: "bessel",
            datumName: "Hermannskogel"
        }, Datum_exports.militargeographische_institut = {
            towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
            ellipse: "bessel",
            datumName: "Militar-Geographische Institut"
        }, Datum_exports.osni52 = {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "airy",
            datumName: "Irish National"
        }, Datum_exports.ire65 = {
            towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
            ellipse: "mod_airy",
            datumName: "Ireland 1965"
        }, Datum_exports.rassadiran = {
            towgs84: "-133.63,-157.5,-158.62",
            ellipse: "intl",
            datumName: "Rassadiran"
        }, Datum_exports.nzgd49 = {
            towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
            ellipse: "intl",
            datumName: "New Zealand Geodetic Datum 1949"
        }, Datum_exports.osgb36 = {
            towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
            ellipse: "airy",
            datumName: "Airy 1830"
        }, Datum_exports.s_jtsk = {
            towgs84: "589,76,480",
            ellipse: "bessel",
            datumName: "S-JTSK (Ferro)"
        }, Datum_exports.beduaram = {
            towgs84: "-106,-87,188",
            ellipse: "clrk80",
            datumName: "Beduaram"
        }, Datum_exports.gunung_segara = {
            towgs84: "-403,684,41",
            ellipse: "bessel",
            datumName: "Gunung Segara Jakarta"
        }, Datum_exports.rnb72 = {
            towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
            ellipse: "intl",
            datumName: "Reseau National Belge 1972"
        };
        const lib_datum = function(datumCode, datum_params, a, b, es, ep2, nadgrids) {
            var out = {};
            return out.datum_type = void 0 === datumCode || "none" === datumCode ? PJD_NODATUM : 4, 
            datum_params && (out.datum_params = datum_params.map(parseFloat), 0 === out.datum_params[0] && 0 === out.datum_params[1] && 0 === out.datum_params[2] || (out.datum_type = PJD_3PARAM), 
            out.datum_params.length > 3 && (0 === out.datum_params[3] && 0 === out.datum_params[4] && 0 === out.datum_params[5] && 0 === out.datum_params[6] || (out.datum_type = PJD_7PARAM, 
            out.datum_params[3] *= SEC_TO_RAD, out.datum_params[4] *= SEC_TO_RAD, out.datum_params[5] *= SEC_TO_RAD, 
            out.datum_params[6] = out.datum_params[6] / 1e6 + 1))), nadgrids && (out.datum_type = PJD_GRIDSHIFT, 
            out.grids = nadgrids), out.a = a, out.b = b, out.es = es, out.ep2 = ep2, out;
        };
        var loadedNadgrids = {};
        function parseNadgridString(value) {
            if (0 === value.length) return null;
            var optional = "@" === value[0];
            return optional && (value = value.slice(1)), "null" === value ? {
                name: "null",
                mandatory: !optional,
                grid: null,
                isNull: !0
            } : {
                name: value,
                mandatory: !optional,
                grid: loadedNadgrids[value] || null,
                isNull: !1
            };
        }
        function secondsToRadians(seconds) {
            return seconds / 3600 * Math.PI / 180;
        }
        function decodeString(view, start, end) {
            return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
        }
        function mapNodes(nodes) {
            return nodes.map((function(r) {
                return [ secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift) ];
            }));
        }
        function readGridHeader(view, offset, isLittleEndian) {
            return {
                name: decodeString(view, offset + 8, offset + 16).trim(),
                parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
                lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
                upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
                lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
                upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
                latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
                longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
                gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
            };
        }
        function readGridNodes(view, offset, gridHeader, isLittleEndian) {
            for (var nodesOffset = offset + 176, gridShiftRecords = [], i = 0; i < gridHeader.gridNodeCount; i++) {
                var record = {
                    latitudeShift: view.getFloat32(nodesOffset + 16 * i, isLittleEndian),
                    longitudeShift: view.getFloat32(nodesOffset + 16 * i + 4, isLittleEndian),
                    latitudeAccuracy: view.getFloat32(nodesOffset + 16 * i + 8, isLittleEndian),
                    longitudeAccuracy: view.getFloat32(nodesOffset + 16 * i + 12, isLittleEndian)
                };
                gridShiftRecords.push(record);
            }
            return gridShiftRecords;
        }
        function Projection(srsCode, callback) {
            if (!(this instanceof Projection)) return new Projection(srsCode);
            callback = callback || function(error) {
                if (error) throw error;
            };
            var json = parseCode(srsCode);
            if ("object" == typeof json) {
                var ourProj = Projection.projections.get(json.projName);
                if (ourProj) {
                    if (json.datumCode && "none" !== json.datumCode) {
                        var datumDef = match(Datum_exports, json.datumCode);
                        datumDef && (json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(",") : null), 
                        json.ellps = datumDef.ellipse, json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode);
                    }
                    json.k0 = json.k0 || 1, json.axis = json.axis || "enu", json.ellps = json.ellps || "wgs84", 
                    json.lat1 = json.lat1 || json.lat0;
                    var a, b, R_A, a2, b2, es, e, sphere_ = function(a, b, rf, ellps, sphere) {
                        if (!a) {
                            var ellipse = match(Ellipsoid_exports, ellps);
                            ellipse || (ellipse = WGS84), a = ellipse.a, b = ellipse.b, rf = ellipse.rf;
                        }
                        return rf && !b && (b = (1 - 1 / rf) * a), (0 === rf || Math.abs(a - b) < EPSLN) && (sphere = !0, 
                        b = a), {
                            a,
                            b,
                            rf,
                            sphere
                        };
                    }(json.a, json.b, json.rf, json.ellps, json.sphere), ecc = (a = sphere_.a, b = sphere_.b, 
                    sphere_.rf, R_A = json.R_A, es = ((a2 = a * a) - (b2 = b * b)) / a2, e = 0, R_A ? (a2 = (a *= 1 - es * (SIXTH + es * (RA4 + es * RA6))) * a, 
                    es = 0) : e = Math.sqrt(es), {
                        es,
                        e,
                        ep2: (a2 - b2) / b2
                    }), nadgrids = function(nadgrids) {
                        return void 0 === nadgrids ? null : nadgrids.split(",").map(parseNadgridString);
                    }(json.nadgrids), datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2, nadgrids);
                    extend(this, json), extend(this, ourProj), this.a = sphere_.a, this.b = sphere_.b, 
                    this.rf = sphere_.rf, this.sphere = sphere_.sphere, this.es = ecc.es, this.e = ecc.e, 
                    this.ep2 = ecc.ep2, this.datum = datumObj, this.init(), callback(null, this);
                } else callback("Could not get projection name from: " + srsCode);
            } else callback("Could not parse to valid json: " + srsCode);
        }
        Projection.projections = projections, Projection.projections.start();
        const Proj = Projection;
        function geodeticToGeocentric(p, es, a) {
            var Rn, Sin_Lat, Sin2_Lat, Cos_Lat, Longitude = p.x, Latitude = p.y, Height = p.z ? p.z : 0;
            if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) Latitude = -HALF_PI; else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) Latitude = HALF_PI; else {
                if (Latitude < -HALF_PI) return {
                    x: -1 / 0,
                    y: -1 / 0,
                    z: p.z
                };
                if (Latitude > HALF_PI) return {
                    x: 1 / 0,
                    y: 1 / 0,
                    z: p.z
                };
            }
            return Longitude > Math.PI && (Longitude -= 2 * Math.PI), Sin_Lat = Math.sin(Latitude), 
            Cos_Lat = Math.cos(Latitude), Sin2_Lat = Sin_Lat * Sin_Lat, {
                x: ((Rn = a / Math.sqrt(1 - es * Sin2_Lat)) + Height) * Cos_Lat * Math.cos(Longitude),
                y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
                z: (Rn * (1 - es) + Height) * Sin_Lat
            };
        }
        function geocentricToGeodetic(p, es, a, b) {
            var P, RR, CT, ST, RX, RK, RN, CPHI0, SPHI0, CPHI, SPHI, SDPHI, iter, Longitude, Height, X = p.x, Y = p.y, Z = p.z ? p.z : 0;
            if (P = Math.sqrt(X * X + Y * Y), RR = Math.sqrt(X * X + Y * Y + Z * Z), P / a < 1e-12) {
                if (Longitude = 0, RR / a < 1e-12) return Height = -b, {
                    x: p.x,
                    y: p.y,
                    z: p.z
                };
            } else Longitude = Math.atan2(Y, X);
            CT = Z / RR, CPHI0 = (ST = P / RR) * (1 - es) * (RX = 1 / Math.sqrt(1 - es * (2 - es) * ST * ST)), 
            SPHI0 = CT * RX, iter = 0;
            do {
                iter++, RK = es * (RN = a / Math.sqrt(1 - es * SPHI0 * SPHI0)) / (RN + (Height = P * CPHI0 + Z * SPHI0 - RN * (1 - es * SPHI0 * SPHI0))), 
                SDPHI = (SPHI = CT * (RX = 1 / Math.sqrt(1 - RK * (2 - RK) * ST * ST))) * CPHI0 - (CPHI = ST * (1 - RK) * RX) * SPHI0, 
                CPHI0 = CPHI, SPHI0 = SPHI;
            } while (SDPHI * SDPHI > 1e-24 && iter < 30);
            return {
                x: Longitude,
                y: Math.atan(SPHI / Math.abs(CPHI)),
                z: Height
            };
        }
        function checkParams(type) {
            return type === PJD_3PARAM || type === PJD_7PARAM;
        }
        function datum_transform(source, dest, point) {
            if (function(source, dest) {
                return source.datum_type === dest.datum_type && !(source.a !== dest.a || Math.abs(source.es - dest.es) > 5e-11) && (source.datum_type === PJD_3PARAM ? source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] : source.datum_type !== PJD_7PARAM || source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
            }(source, dest)) return point;
            if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) return point;
            var source_a = source.a, source_es = source.es;
            if (source.datum_type === PJD_GRIDSHIFT) {
                if (0 !== applyGridShift(source, !1, point)) return;
                source_a = SRS_WGS84_SEMIMAJOR, source_es = SRS_WGS84_ESQUARED;
            }
            var dest_a = dest.a, dest_b = dest.b, dest_es = dest.es;
            if (dest.datum_type === PJD_GRIDSHIFT && (dest_a = SRS_WGS84_SEMIMAJOR, dest_b = SRS_WGS84_SEMIMINOR, 
            dest_es = SRS_WGS84_ESQUARED), source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) && !checkParams(dest.datum_type)) return point;
            if ((point = geodeticToGeocentric(point, source_es, source_a), checkParams(source.datum_type) && (point = function(p, datum_type, datum_params) {
                if (datum_type === PJD_3PARAM) return {
                    x: p.x + datum_params[0],
                    y: p.y + datum_params[1],
                    z: p.z + datum_params[2]
                };
                if (datum_type === PJD_7PARAM) {
                    var Dx_BF = datum_params[0], Dy_BF = datum_params[1], Dz_BF = datum_params[2], Rx_BF = datum_params[3], Ry_BF = datum_params[4], Rz_BF = datum_params[5], M_BF = datum_params[6];
                    return {
                        x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
                        y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
                        z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
                    };
                }
            }(point, source.datum_type, source.datum_params)), checkParams(dest.datum_type) && (point = function(p, datum_type, datum_params) {
                if (datum_type === PJD_3PARAM) return {
                    x: p.x - datum_params[0],
                    y: p.y - datum_params[1],
                    z: p.z - datum_params[2]
                };
                if (datum_type === PJD_7PARAM) {
                    var Dx_BF = datum_params[0], Dy_BF = datum_params[1], Dz_BF = datum_params[2], Rx_BF = datum_params[3], Ry_BF = datum_params[4], Rz_BF = datum_params[5], M_BF = datum_params[6], x_tmp = (p.x - Dx_BF) / M_BF, y_tmp = (p.y - Dy_BF) / M_BF, z_tmp = (p.z - Dz_BF) / M_BF;
                    return {
                        x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
                        y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
                        z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
                    };
                }
            }(point, dest.datum_type, dest.datum_params)), point = geocentricToGeodetic(point, dest_es, dest_a, dest_b), 
            dest.datum_type === PJD_GRIDSHIFT) && 0 !== applyGridShift(dest, !0, point)) return;
            return point;
        }
        function applyGridShift(source, inverse, point) {
            if (null === source.grids || 0 === source.grids.length) return console.log("Grid shift grids not found"), 
            -1;
            var input = {
                x: -point.x,
                y: point.y
            }, output = {
                x: Number.NaN,
                y: Number.NaN
            }, attemptedGrids = [];
            outer: for (var i = 0; i < source.grids.length; i++) {
                var grid = source.grids[i];
                if (attemptedGrids.push(grid.name), grid.isNull) {
                    output = input;
                    break;
                }
                if (grid.mandatory, null !== grid.grid) for (var subgrids = grid.grid.subgrids, j = 0, jj = subgrids.length; j < jj; j++) {
                    var subgrid = subgrids[j], epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 1e4, minX = subgrid.ll[0] - epsilon, minY = subgrid.ll[1] - epsilon, maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon, maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
                    if (!(minY > input.y || minX > input.x || maxY < input.y || maxX < input.x) && (output = applySubgridShift(input, inverse, subgrid), 
                    !isNaN(output.x))) break outer;
                } else if (grid.mandatory) return console.log("Unable to find mandatory grid '" + grid.name + "'"), 
                -1;
            }
            return isNaN(output.x) ? (console.log("Failed to find a grid shift table for location '" + -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'"), 
            -1) : (point.x = -output.x, point.y = output.y, 0);
        }
        function applySubgridShift(pin, inverse, ct) {
            var val = {
                x: Number.NaN,
                y: Number.NaN
            };
            if (isNaN(pin.x)) return val;
            var tb = {
                x: pin.x,
                y: pin.y
            };
            tb.x -= ct.ll[0], tb.y -= ct.ll[1], tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
            var t = nadInterpolate(tb, ct);
            if (inverse) {
                if (isNaN(t.x)) return val;
                t.x = tb.x - t.x, t.y = tb.y - t.y;
                var dif, del, i = 9;
                do {
                    if (del = nadInterpolate(t, ct), isNaN(del.x)) {
                        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
                        break;
                    }
                    dif = {
                        x: tb.x - (del.x + t.x),
                        y: tb.y - (del.y + t.y)
                    }, t.x += dif.x, t.y += dif.y;
                } while (i-- && Math.abs(dif.x) > 1e-12 && Math.abs(dif.y) > 1e-12);
                if (i < 0) return console.log("Inverse grid shift iterator failed to converge."), 
                val;
                val.x = adjust_lon(t.x + ct.ll[0]), val.y = t.y + ct.ll[1];
            } else isNaN(t.x) || (val.x = pin.x + t.x, val.y = pin.y + t.y);
            return val;
        }
        function nadInterpolate(pin, ct) {
            var inx, t = {
                x: pin.x / ct.del[0],
                y: pin.y / ct.del[1]
            }, indx_x = Math.floor(t.x), indx_y = Math.floor(t.y), frct_x = t.x - 1 * indx_x, frct_y = t.y - 1 * indx_y, val = {
                x: Number.NaN,
                y: Number.NaN
            };
            if (indx_x < 0 || indx_x >= ct.lim[0]) return val;
            if (indx_y < 0 || indx_y >= ct.lim[1]) return val;
            inx = indx_y * ct.lim[0] + indx_x;
            var f00_x = ct.cvs[inx][0], f00_y = ct.cvs[inx][1];
            inx++;
            var f10_x = ct.cvs[inx][0], f10_y = ct.cvs[inx][1];
            inx += ct.lim[0];
            var f11_x = ct.cvs[inx][0], f11_y = ct.cvs[inx][1];
            inx--;
            var f01_x = ct.cvs[inx][0], f01_y = ct.cvs[inx][1], m11 = frct_x * frct_y, m10 = frct_x * (1 - frct_y), m00 = (1 - frct_x) * (1 - frct_y), m01 = (1 - frct_x) * frct_y;
            return val.x = m00 * f00_x + m10 * f10_x + m01 * f01_x + m11 * f11_x, val.y = m00 * f00_y + m10 * f10_y + m01 * f01_y + m11 * f11_y, 
            val;
        }
        function adjust_axis(crs, denorm, point) {
            var v, t, i, xin = point.x, yin = point.y, zin = point.z || 0, out = {};
            for (i = 0; i < 3; i++) if (!denorm || 2 !== i || void 0 !== point.z) switch (0 === i ? (v = xin, 
            t = -1 !== "ew".indexOf(crs.axis[i]) ? "x" : "y") : 1 === i ? (v = yin, t = -1 !== "ns".indexOf(crs.axis[i]) ? "y" : "x") : (v = zin, 
            t = "z"), crs.axis[i]) {
              case "e":
              case "n":
                out[t] = v;
                break;

              case "w":
              case "s":
                out[t] = -v;
                break;

              case "u":
                void 0 !== point[t] && (out.z = v);
                break;

              case "d":
                void 0 !== point[t] && (out.z = -v);
                break;

              default:
                return null;
            }
            return out;
        }
        function toPoint(array) {
            var out = {
                x: array[0],
                y: array[1]
            };
            return array.length > 2 && (out.z = array[2]), array.length > 3 && (out.m = array[3]), 
            out;
        }
        function checkCoord(num) {
            if ("function" == typeof Number.isFinite) {
                if (Number.isFinite(num)) return;
                throw new TypeError("coordinates must be finite numbers");
            }
            if ("number" != typeof num || num != num || !isFinite(num)) throw new TypeError("coordinates must be finite numbers");
        }
        function transform(source, dest, point, enforceAxis) {
            var wgs84, hasZ = void 0 !== (point = Array.isArray(point) ? toPoint(point) : {
                x: point.x,
                y: point.y,
                z: point.z,
                m: point.m
            }).z;
            if (function(point) {
                checkCoord(point.x), checkCoord(point.y);
            }(point), source.datum && dest.datum && function(source, dest) {
                return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && "WGS84" !== dest.datumCode || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && "WGS84" !== source.datumCode;
            }(source, dest) && (point = transform(source, wgs84 = new Proj("WGS84"), point, enforceAxis), 
            source = wgs84), enforceAxis && "enu" !== source.axis && (point = adjust_axis(source, !1, point)), 
            "longlat" === source.projName) point = {
                x: point.x * D2R,
                y: point.y * D2R,
                z: point.z || 0
            }; else if (source.to_meter && (point = {
                x: point.x * source.to_meter,
                y: point.y * source.to_meter,
                z: point.z || 0
            }), !(point = source.inverse(point))) return;
            if (source.from_greenwich && (point.x += source.from_greenwich), point = datum_transform(source.datum, dest.datum, point)) return dest.from_greenwich && (point = {
                x: point.x - dest.from_greenwich,
                y: point.y,
                z: point.z || 0
            }), "longlat" === dest.projName ? point = {
                x: point.x * R2D,
                y: point.y * R2D,
                z: point.z || 0
            } : (point = dest.forward(point), dest.to_meter && (point = {
                x: point.x / dest.to_meter,
                y: point.y / dest.to_meter,
                z: point.z || 0
            })), enforceAxis && "enu" !== dest.axis ? adjust_axis(dest, !0, point) : (point && !hasZ && delete point.z, 
            point);
        }
        var wgs84 = Proj("WGS84");
        function transformer(from, to, coords, enforceAxis) {
            var transformedArray, out, keys;
            return Array.isArray(coords) ? (transformedArray = transform(from, to, coords, enforceAxis) || {
                x: NaN,
                y: NaN
            }, coords.length > 2 ? void 0 !== from.name && "geocent" === from.name || void 0 !== to.name && "geocent" === to.name ? "number" == typeof transformedArray.z ? [ transformedArray.x, transformedArray.y, transformedArray.z ].concat(coords.splice(3)) : [ transformedArray.x, transformedArray.y, coords[2] ].concat(coords.splice(3)) : [ transformedArray.x, transformedArray.y ].concat(coords.splice(2)) : [ transformedArray.x, transformedArray.y ]) : (out = transform(from, to, coords, enforceAxis), 
            2 === (keys = Object.keys(coords)).length || keys.forEach((function(key) {
                if (void 0 !== from.name && "geocent" === from.name || void 0 !== to.name && "geocent" === to.name) {
                    if ("x" === key || "y" === key || "z" === key) return;
                } else if ("x" === key || "y" === key) return;
                out[key] = coords[key];
            })), out);
        }
        function checkProj(item) {
            return item instanceof Proj ? item : item.oProj ? item.oProj : Proj(item);
        }
        const core = function(fromProj, toProj, coord) {
            fromProj = checkProj(fromProj);
            var obj, single = !1;
            return void 0 === toProj ? (toProj = fromProj, fromProj = wgs84, single = !0) : (void 0 !== toProj.x || Array.isArray(toProj)) && (coord = toProj, 
            toProj = fromProj, fromProj = wgs84, single = !0), toProj = checkProj(toProj), coord ? transformer(fromProj, toProj, coord) : (obj = {
                forward: function(coords, enforceAxis) {
                    return transformer(fromProj, toProj, coords, enforceAxis);
                },
                inverse: function(coords, enforceAxis) {
                    return transformer(toProj, fromProj, coords, enforceAxis);
                }
            }, single && (obj.oProj = toProj), obj);
        };
        var NUM_100K_SETS = 6, SET_ORIGIN_COLUMN_LETTERS = "AJSAJS", SET_ORIGIN_ROW_LETTERS = "AFAFAF", A = 65, I = 73, O = 79, V = 86, Z = 90;
        const mgrs = {
            forward: mgrs_forward,
            inverse: function(mgrs) {
                var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
                if (bbox.lat && bbox.lon) return [ bbox.lon, bbox.lat, bbox.lon, bbox.lat ];
                return [ bbox.left, bbox.bottom, bbox.right, bbox.top ];
            },
            toPoint: mgrs_toPoint
        };
        function mgrs_forward(ll, accuracy) {
            return accuracy = accuracy || 5, function(utm, accuracy) {
                var seasting = "00000" + utm.easting, snorthing = "00000" + utm.northing;
                return utm.zoneNumber + utm.zoneLetter + (easting = utm.easting, northing = utm.northing, 
                zoneNumber = utm.zoneNumber, setParm = get100kSetForZone(zoneNumber), setColumn = Math.floor(easting / 1e5), 
                setRow = Math.floor(northing / 1e5) % 20, column = setColumn, row = setRow, parm = setParm, 
                index = parm - 1, colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index), rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index), 
                colInt = colOrigin + column - 1, rowInt = rowOrigin + row, rollover = !1, colInt > Z && (colInt = colInt - Z + A - 1, 
                rollover = !0), (colInt === I || colOrigin < I && colInt > I || (colInt > I || colOrigin < I) && rollover) && colInt++, 
                (colInt === O || colOrigin < O && colInt > O || (colInt > O || colOrigin < O) && rollover) && ++colInt === I && colInt++, 
                colInt > Z && (colInt = colInt - Z + A - 1), rowInt > V ? (rowInt = rowInt - V + A - 1, 
                rollover = !0) : rollover = !1, (rowInt === I || rowOrigin < I && rowInt > I || (rowInt > I || rowOrigin < I) && rollover) && rowInt++, 
                (rowInt === O || rowOrigin < O && rowInt > O || (rowInt > O || rowOrigin < O) && rollover) && ++rowInt === I && rowInt++, 
                rowInt > V && (rowInt = rowInt - V + A - 1), String.fromCharCode(colInt) + String.fromCharCode(rowInt)) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
                var column, row, parm, index, colOrigin, rowOrigin, colInt, rowInt, rollover;
                var easting, northing, zoneNumber, setParm, setColumn, setRow;
            }(function(ll) {
                var eccPrimeSquared, N, T, C, A, M, LongOriginRad, ZoneNumber, Lat = ll.lat, Long = ll.lon, a = 6378137, eccSquared = .00669438, k0 = .9996, LatRad = degToRad(Lat), LongRad = degToRad(Long);
                ZoneNumber = Math.floor((Long + 180) / 6) + 1, 180 === Long && (ZoneNumber = 60);
                Lat >= 56 && Lat < 64 && Long >= 3 && Long < 12 && (ZoneNumber = 32);
                Lat >= 72 && Lat < 84 && (Long >= 0 && Long < 9 ? ZoneNumber = 31 : Long >= 9 && Long < 21 ? ZoneNumber = 33 : Long >= 21 && Long < 33 ? ZoneNumber = 35 : Long >= 33 && Long < 42 && (ZoneNumber = 37));
                LongOriginRad = degToRad(6 * (ZoneNumber - 1) - 180 + 3), eccPrimeSquared = eccSquared / (1 - eccSquared), 
                N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad)), T = Math.tan(LatRad) * Math.tan(LatRad), 
                C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad), A = Math.cos(LatRad) * (LongRad - LongOriginRad), 
                M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - 35 * eccSquared * eccSquared * eccSquared / 3072 * Math.sin(6 * LatRad));
                var UTMEasting = k0 * N * (A + (1 - T + C) * A * A * A / 6 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120) + 5e5, UTMNorthing = k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720));
                Lat < 0 && (UTMNorthing += 1e7);
                return {
                    northing: Math.round(UTMNorthing),
                    easting: Math.round(UTMEasting),
                    zoneNumber: ZoneNumber,
                    zoneLetter: getLetterDesignator(Lat)
                };
            }({
                lat: ll[1],
                lon: ll[0]
            }), accuracy);
        }
        function mgrs_toPoint(mgrs) {
            var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
            return bbox.lat && bbox.lon ? [ bbox.lon, bbox.lat ] : [ (bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2 ];
        }
        function degToRad(deg) {
            return deg * (Math.PI / 180);
        }
        function radToDeg(rad) {
            return rad / Math.PI * 180;
        }
        function UTMtoLL(utm) {
            var UTMNorthing = utm.northing, UTMEasting = utm.easting, zoneLetter = utm.zoneLetter, zoneNumber = utm.zoneNumber;
            if (zoneNumber < 0 || zoneNumber > 60) return null;
            var N1, T1, C1, R1, D, LongOrigin, mu, phi1Rad, a = 6378137, e1 = (1 - Math.sqrt(.99330562)) / (1 + Math.sqrt(.99330562)), x = UTMEasting - 5e5, y = UTMNorthing;
            zoneLetter < "N" && (y -= 1e7), LongOrigin = 6 * (zoneNumber - 1) - 180 + 3, phi1Rad = (mu = y / .9996 / 6367449.145945056) + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + 151 * e1 * e1 * e1 / 96 * Math.sin(6 * mu), 
            N1 = a / Math.sqrt(1 - .00669438 * Math.sin(phi1Rad) * Math.sin(phi1Rad)), T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad), 
            C1 = .006739496752268451 * Math.cos(phi1Rad) * Math.cos(phi1Rad), R1 = .99330562 * a / Math.pow(1 - .00669438 * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5), 
            D = x / (.9996 * N1);
            var lat = phi1Rad - N1 * Math.tan(phi1Rad) / R1 * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - .06065547077041606) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 1.6983531815716497 - 3 * C1 * C1) * D * D * D * D * D * D / 720);
            lat = radToDeg(lat);
            var result, lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + .05391597401814761 + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
            if (lon = LongOrigin + radToDeg(lon), utm.accuracy) {
                var topRight = UTMtoLL({
                    northing: utm.northing + utm.accuracy,
                    easting: utm.easting + utm.accuracy,
                    zoneLetter: utm.zoneLetter,
                    zoneNumber: utm.zoneNumber
                });
                result = {
                    top: topRight.lat,
                    right: topRight.lon,
                    bottom: lat,
                    left: lon
                };
            } else result = {
                lat,
                lon
            };
            return result;
        }
        function getLetterDesignator(lat) {
            var LetterDesignator = "Z";
            return 84 >= lat && lat >= 72 ? LetterDesignator = "X" : 72 > lat && lat >= 64 ? LetterDesignator = "W" : 64 > lat && lat >= 56 ? LetterDesignator = "V" : 56 > lat && lat >= 48 ? LetterDesignator = "U" : 48 > lat && lat >= 40 ? LetterDesignator = "T" : 40 > lat && lat >= 32 ? LetterDesignator = "S" : 32 > lat && lat >= 24 ? LetterDesignator = "R" : 24 > lat && lat >= 16 ? LetterDesignator = "Q" : 16 > lat && lat >= 8 ? LetterDesignator = "P" : 8 > lat && lat >= 0 ? LetterDesignator = "N" : 0 > lat && lat >= -8 ? LetterDesignator = "M" : -8 > lat && lat >= -16 ? LetterDesignator = "L" : -16 > lat && lat >= -24 ? LetterDesignator = "K" : -24 > lat && lat >= -32 ? LetterDesignator = "J" : -32 > lat && lat >= -40 ? LetterDesignator = "H" : -40 > lat && lat >= -48 ? LetterDesignator = "G" : -48 > lat && lat >= -56 ? LetterDesignator = "F" : -56 > lat && lat >= -64 ? LetterDesignator = "E" : -64 > lat && lat >= -72 ? LetterDesignator = "D" : -72 > lat && lat >= -80 && (LetterDesignator = "C"), 
            LetterDesignator;
        }
        function get100kSetForZone(i) {
            var setParm = i % NUM_100K_SETS;
            return 0 === setParm && (setParm = NUM_100K_SETS), setParm;
        }
        function decode(mgrsString) {
            if (mgrsString && 0 === mgrsString.length) throw "MGRSPoint coverting from nothing";
            for (var testChar, length = mgrsString.length, hunK = null, sb = "", i = 0; !/[A-Z]/.test(testChar = mgrsString.charAt(i)); ) {
                if (i >= 2) throw "MGRSPoint bad conversion from: " + mgrsString;
                sb += testChar, i++;
            }
            var zoneNumber = parseInt(sb, 10);
            if (0 === i || i + 3 > length) throw "MGRSPoint bad conversion from: " + mgrsString;
            var zoneLetter = mgrsString.charAt(i++);
            if (zoneLetter <= "A" || "B" === zoneLetter || "Y" === zoneLetter || zoneLetter >= "Z" || "I" === zoneLetter || "O" === zoneLetter) throw "MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString;
            hunK = mgrsString.substring(i, i += 2);
            for (var set = get100kSetForZone(zoneNumber), east100k = function(e, set) {
                var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1), eastingValue = 1e5, rewindMarker = !1;
                for (;curCol !== e.charCodeAt(0); ) {
                    if (++curCol === I && curCol++, curCol === O && curCol++, curCol > Z) {
                        if (rewindMarker) throw "Bad character: " + e;
                        curCol = A, rewindMarker = !0;
                    }
                    eastingValue += 1e5;
                }
                return eastingValue;
            }(hunK.charAt(0), set), north100k = function(n, set) {
                if (n > "V") throw "MGRSPoint given invalid Northing " + n;
                var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1), northingValue = 0, rewindMarker = !1;
                for (;curRow !== n.charCodeAt(0); ) {
                    if (++curRow === I && curRow++, curRow === O && curRow++, curRow > V) {
                        if (rewindMarker) throw "Bad character: " + n;
                        curRow = A, rewindMarker = !0;
                    }
                    northingValue += 1e5;
                }
                return northingValue;
            }(hunK.charAt(1), set); north100k < getMinNorthing(zoneLetter); ) north100k += 2e6;
            var remainder = length - i;
            if (remainder % 2 != 0) throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString;
            var accuracyBonus, sepEastingString, sepNorthingString, sep = remainder / 2, sepEasting = 0, sepNorthing = 0;
            return sep > 0 && (accuracyBonus = 1e5 / Math.pow(10, sep), sepEastingString = mgrsString.substring(i, i + sep), 
            sepEasting = parseFloat(sepEastingString) * accuracyBonus, sepNorthingString = mgrsString.substring(i + sep), 
            sepNorthing = parseFloat(sepNorthingString) * accuracyBonus), {
                easting: sepEasting + east100k,
                northing: sepNorthing + north100k,
                zoneLetter,
                zoneNumber,
                accuracy: accuracyBonus
            };
        }
        function getMinNorthing(zoneLetter) {
            var northing;
            switch (zoneLetter) {
              case "C":
                northing = 11e5;
                break;

              case "D":
                northing = 2e6;
                break;

              case "E":
                northing = 28e5;
                break;

              case "F":
                northing = 37e5;
                break;

              case "G":
                northing = 46e5;
                break;

              case "H":
                northing = 55e5;
                break;

              case "J":
                northing = 64e5;
                break;

              case "K":
                northing = 73e5;
                break;

              case "L":
                northing = 82e5;
                break;

              case "M":
                northing = 91e5;
                break;

              case "N":
                northing = 0;
                break;

              case "P":
                northing = 8e5;
                break;

              case "Q":
                northing = 17e5;
                break;

              case "R":
                northing = 26e5;
                break;

              case "S":
                northing = 35e5;
                break;

              case "T":
                northing = 44e5;
                break;

              case "U":
                northing = 53e5;
                break;

              case "V":
                northing = 62e5;
                break;

              case "W":
                northing = 7e6;
                break;

              case "X":
                northing = 79e5;
                break;

              default:
                northing = -1;
            }
            if (northing >= 0) return northing;
            throw "Invalid zone letter: " + zoneLetter;
        }
        function Point(x, y, z) {
            if (!(this instanceof Point)) return new Point(x, y, z);
            if (Array.isArray(x)) this.x = x[0], this.y = x[1], this.z = x[2] || 0; else if ("object" == typeof x) this.x = x.x, 
            this.y = x.y, this.z = x.z || 0; else if ("string" == typeof x && void 0 === y) {
                var coords = x.split(",");
                this.x = parseFloat(coords[0], 10), this.y = parseFloat(coords[1], 10), this.z = parseFloat(coords[2], 10) || 0;
            } else this.x = x, this.y = y, this.z = z || 0;
            console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");
        }
        Point.fromMGRS = function(mgrsStr) {
            return new Point(mgrs_toPoint(mgrsStr));
        }, Point.prototype.toMGRS = function(accuracy) {
            return mgrs_forward([ this.x, this.y ], accuracy);
        };
        const lib_Point = Point;
        var C00 = 1, C02 = .25, C04 = .046875, C06 = .01953125, C08 = .01068115234375, C22 = .75, C44 = .46875, C46 = .013020833333333334, C48 = .007120768229166667, C66 = .3645833333333333, C68 = .005696614583333333, C88 = .3076171875;
        function pj_enfn(es) {
            var en = [];
            en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08))), en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
            var t = es * es;
            return en[2] = t * (C44 - es * (C46 + es * C48)), t *= es, en[3] = t * (C66 - es * C68), 
            en[4] = t * es * C88, en;
        }
        function pj_mlfn(phi, sphi, cphi, en) {
            return cphi *= sphi, sphi *= sphi, en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4])));
        }
        var MAX_ITER = 20;
        function pj_inv_mlfn(arg, es, en) {
            for (var k = 1 / (1 - es), phi = arg, i = MAX_ITER; i; --i) {
                var s = Math.sin(phi), t = 1 - es * s * s;
                if (phi -= t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k, 
                Math.abs(t) < EPSLN) return phi;
            }
            return phi;
        }
        const tmerc = {
            init: function() {
                this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, 
                this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, 
                this.es && (this.en = pj_enfn(this.es), this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en));
            },
            forward: function(p) {
                var con, x, y, lon = p.x, lat = p.y, delta_lon = adjust_lon(lon - this.long0), sin_phi = Math.sin(lat), cos_phi = Math.cos(lat);
                if (this.es) {
                    var al = cos_phi * delta_lon, als = Math.pow(al, 2), c = this.ep2 * Math.pow(cos_phi, 2), cs = Math.pow(c, 2), tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0, t = Math.pow(tq, 2), ts = Math.pow(t, 2);
                    con = 1 - this.es * Math.pow(sin_phi, 2), al /= Math.sqrt(con);
                    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
                    x = this.a * (this.k0 * al * (1 + als / 6 * (1 - t + c + als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c + als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) + this.x0, 
                    y = this.a * (this.k0 * (ml - this.ml0 + sin_phi * delta_lon * al / 2 * (1 + als / 12 * (5 - t + 9 * c + 4 * cs + als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c + als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) + this.y0;
                } else {
                    var b = cos_phi * Math.sin(delta_lon);
                    if (Math.abs(Math.abs(b) - 1) < EPSLN) return 93;
                    if (x = .5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0, y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2)), 
                    (b = Math.abs(y)) >= 1) {
                        if (b - 1 > EPSLN) return 93;
                        y = 0;
                    } else y = Math.acos(y);
                    lat < 0 && (y = -y), y = this.a * this.k0 * (y - this.lat0) + this.y0;
                }
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var con, phi, lat, lon, x = (p.x - this.x0) * (1 / this.a), y = (p.y - this.y0) * (1 / this.a);
                if (this.es) if (phi = pj_inv_mlfn(con = this.ml0 + y / this.k0, this.es, this.en), 
                Math.abs(phi) < HALF_PI) {
                    var sin_phi = Math.sin(phi), cos_phi = Math.cos(phi), tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0, c = this.ep2 * Math.pow(cos_phi, 2), cs = Math.pow(c, 2), t = Math.pow(tan_phi, 2), ts = Math.pow(t, 2);
                    con = 1 - this.es * Math.pow(sin_phi, 2);
                    var d = x * Math.sqrt(con) / this.k0, ds = Math.pow(d, 2);
                    lat = phi - (con *= tan_phi) * ds / (1 - this.es) * .5 * (1 - ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs - ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c - ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t)))), 
                    lon = adjust_lon(this.long0 + d * (1 - ds / 6 * (1 + 2 * t + c - ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c - ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi);
                } else lat = HALF_PI * sign(y), lon = 0; else {
                    var f = Math.exp(x / this.k0), g = .5 * (f - 1 / f), temp = this.lat0 + y / this.k0, h = Math.cos(temp);
                    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2))), lat = Math.asin(con), 
                    y < 0 && (lat = -lat), lon = 0 === g && 0 === h ? 0 : adjust_lon(Math.atan2(g, h) + this.long0);
                }
                return p.x = lon, p.y = lat, p;
            },
            names: [ "Fast_Transverse_Mercator", "Fast Transverse Mercator" ]
        };
        function sinh(x) {
            var r = Math.exp(x);
            return r = (r - 1 / r) / 2;
        }
        function hypot(x, y) {
            x = Math.abs(x), y = Math.abs(y);
            var a = Math.max(x, y), b = Math.min(x, y) / (a || 1);
            return a * Math.sqrt(1 + Math.pow(b, 2));
        }
        function asinhy(x) {
            var y = Math.abs(x);
            return y = function(x) {
                var y = 1 + x, z = y - 1;
                return 0 === z ? x : x * Math.log(y) / z;
            }(y * (1 + y / (hypot(1, y) + 1))), x < 0 ? -y : y;
        }
        function gatg(pp, B) {
            for (var h, cos_2B = 2 * Math.cos(2 * B), i = pp.length - 1, h1 = pp[i], h2 = 0; --i >= 0; ) h = cos_2B * h1 - h2 + pp[i], 
            h2 = h1, h1 = h;
            return B + h * Math.sin(2 * B);
        }
        function clens_cmplx(pp, arg_r, arg_i) {
            for (var hr2, hi2, sin_arg_r = Math.sin(arg_r), cos_arg_r = Math.cos(arg_r), sinh_arg_i = sinh(arg_i), cosh_arg_i = function(x) {
                var r = Math.exp(x);
                return (r + 1 / r) / 2;
            }(arg_i), r = 2 * cos_arg_r * cosh_arg_i, i = -2 * sin_arg_r * sinh_arg_i, j = pp.length - 1, hr = pp[j], hi1 = 0, hr1 = 0, hi = 0; --j >= 0; ) hr2 = hr1, 
            hi2 = hi1, hr = r * (hr1 = hr) - hr2 - i * (hi1 = hi) + pp[j], hi = i * hr1 - hi2 + r * hi1;
            return [ (r = sin_arg_r * cosh_arg_i) * hr - (i = cos_arg_r * sinh_arg_i) * hi, r * hi + i * hr ];
        }
        const etmerc = {
            init: function() {
                if (!this.approx && (isNaN(this.es) || this.es <= 0)) throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
                this.approx && (tmerc.init.apply(this), this.forward = tmerc.forward, this.inverse = tmerc.inverse), 
                this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0 : 0, 
                this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0 !== this.lat0 ? this.lat0 : 0, 
                this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
                var f = this.es / (1 + Math.sqrt(1 - this.es)), n = f / (2 - f), np = n;
                this.cgb[0] = n * (2 + n * (-2 / 3 + n * (n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675))) - 2))), 
                this.cbg[0] = n * (n * (2 / 3 + n * (4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))) - 2), 
                np *= n, this.cgb[1] = np * (7 / 3 + n * (n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945))) - 1.6)), 
                this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * (-13 / 9 + n * (904 / 315 + n * (-1522 / 945))))), 
                np *= n, this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835)))), 
                this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (1.6 + n * (-12686 / 2835)))), 
                np *= n, this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175))), 
                this.cbg[3] = np * (1237 / 630 + n * (n * (-24832 / 14175) - 2.4)), np *= n, this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237)), 
                this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185)), np *= n, this.cgb[5] = np * (601676 / 22275), 
                this.cbg[5] = np * (444337 / 155925), np = Math.pow(n, 2), this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256))), 
                this.utg[0] = n * (n * (2 / 3 + n * (-37 / 96 + n * (1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))) - .5), 
                this.gtu[0] = n * (.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800)))))), 
                this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720))))), 
                this.gtu[1] = np * (13 / 48 + n * (n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360))) - .6)), 
                np *= n, this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720)))), 
                this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440)))), 
                np *= n, this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600))), 
                this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600))), 
                np *= n, this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680)), this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840)), 
                np *= n, this.utg[5] = np * (-20648693 / 638668800), this.gtu[5] = .6650675310896665 * np;
                var Z = gatg(this.cbg, this.lat0);
                this.Zb = -this.Qn * (Z + function(pp, arg_r) {
                    for (var hr, r = 2 * Math.cos(arg_r), i = pp.length - 1, hr1 = pp[i], hr2 = 0; --i >= 0; ) hr = r * hr1 - hr2 + pp[i], 
                    hr2 = hr1, hr1 = hr;
                    return Math.sin(arg_r) * hr;
                }(this.gtu, 2 * Z));
            },
            forward: function(p) {
                var Ce = adjust_lon(p.x - this.long0), Cn = p.y;
                Cn = gatg(this.cbg, Cn);
                var sin_Cn = Math.sin(Cn), cos_Cn = Math.cos(Cn), sin_Ce = Math.sin(Ce), cos_Ce = Math.cos(Ce);
                Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn), Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce)), 
                Ce = asinhy(Math.tan(Ce));
                var x, y, tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
                return Cn += tmp[0], Ce += tmp[1], Math.abs(Ce) <= 2.623395162778 ? (x = this.a * (this.Qn * Ce) + this.x0, 
                y = this.a * (this.Qn * Cn + this.Zb) + this.y0) : (x = 1 / 0, y = 1 / 0), p.x = x, 
                p.y = y, p;
            },
            inverse: function(p) {
                var lon, lat, Ce = (p.x - this.x0) * (1 / this.a), Cn = (p.y - this.y0) * (1 / this.a);
                if (Cn = (Cn - this.Zb) / this.Qn, Ce /= this.Qn, Math.abs(Ce) <= 2.623395162778) {
                    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
                    Cn += tmp[0], Ce += tmp[1], Ce = Math.atan(sinh(Ce));
                    var sin_Cn = Math.sin(Cn), cos_Cn = Math.cos(Cn), sin_Ce = Math.sin(Ce), cos_Ce = Math.cos(Ce);
                    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn)), lon = adjust_lon((Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn)) + this.long0), 
                    lat = gatg(this.cgb, Cn);
                } else lon = 1 / 0, lat = 1 / 0;
                return p.x = lon, p.y = lat, p;
            },
            names: [ "Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "Gauss Kruger", "Gauss_Kruger", "tmerc" ]
        };
        const utm = {
            init: function() {
                var zone = function(zone, lon) {
                    if (void 0 === zone) {
                        if ((zone = Math.floor(30 * (adjust_lon(lon) + Math.PI) / Math.PI) + 1) < 0) return 0;
                        if (zone > 60) return 60;
                    }
                    return zone;
                }(this.zone, this.long0);
                if (void 0 === zone) throw new Error("unknown utm zone");
                this.lat0 = 0, this.long0 = (6 * Math.abs(zone) - 183) * D2R, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7 : 0, 
                this.k0 = .9996, etmerc.init.apply(this), this.forward = etmerc.forward, this.inverse = etmerc.inverse;
            },
            names: [ "Universal Transverse Mercator System", "utm" ],
            dependsOn: "etmerc"
        };
        function srat(esinp, exp) {
            return Math.pow((1 - esinp) / (1 + esinp), exp);
        }
        const gauss = {
            init: function() {
                var sphi = Math.sin(this.lat0), cphi = Math.cos(this.lat0);
                cphi *= cphi, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi), this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es)), 
                this.phic0 = Math.asin(sphi / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
            },
            forward: function(p) {
                var lon = p.x, lat = p.y;
                return p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI, 
                p.x = this.C * lon, p;
            },
            inverse: function(p) {
                for (var lon = p.x / this.C, lat = p.y, num = Math.pow(Math.tan(.5 * lat + FORTPI) / this.K, 1 / this.C), i = 20; i > 0 && (lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), -.5 * this.e)) - HALF_PI, 
                !(Math.abs(lat - p.y) < 1e-14)); --i) p.y = lat;
                return i ? (p.x = lon, p.y = lat, p) : null;
            },
            names: [ "gauss" ]
        };
        const sterea = {
            init: function() {
                gauss.init.apply(this), this.rc && (this.sinc0 = Math.sin(this.phic0), this.cosc0 = Math.cos(this.phic0), 
                this.R2 = 2 * this.rc, this.title || (this.title = "Oblique Stereographic Alternative"));
            },
            forward: function(p) {
                var sinc, cosc, cosl, k;
                return p.x = adjust_lon(p.x - this.long0), gauss.forward.apply(this, [ p ]), sinc = Math.sin(p.y), 
                cosc = Math.cos(p.y), cosl = Math.cos(p.x), k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl), 
                p.x = k * cosc * Math.sin(p.x), p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl), 
                p.x = this.a * p.x + this.x0, p.y = this.a * p.y + this.y0, p;
            },
            inverse: function(p) {
                var sinc, cosc, lon, lat, rho;
                if (p.x = (p.x - this.x0) / this.a, p.y = (p.y - this.y0) / this.a, p.x /= this.k0, 
                p.y /= this.k0, rho = hypot(p.x, p.y)) {
                    var c = 2 * Math.atan2(rho, this.R2);
                    sinc = Math.sin(c), cosc = Math.cos(c), lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho), 
                    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
                } else lat = this.phic0, lon = 0;
                return p.x = lon, p.y = lat, gauss.inverse.apply(this, [ p ]), p.x = adjust_lon(p.x + this.long0), 
                p;
            },
            names: [ "Stereographic_North_Pole", "Oblique_Stereographic", "sterea", "Oblique Stereographic Alternative", "Double_Stereographic" ]
        };
        const stere = {
            init: function() {
                this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, 
                this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere ? 1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && (this.k0 = .5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= EPSLN && (this.lat0 > 0 ? this.con = 1 : this.con = -1), 
                this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 
                1 === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN && Math.abs(Math.cos(this.lat_ts)) > EPSLN && (this.k0 = .5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts))), 
                this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI, 
                this.cosX0 = Math.cos(this.X0), this.sinX0 = Math.sin(this.X0));
            },
            forward: function(p) {
                var A, X, sinX, cosX, ts, rh, lon = p.x, lat = p.y, sinlat = Math.sin(lat), coslat = Math.cos(lat), dlon = adjust_lon(lon - this.long0);
                return Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN ? (p.x = NaN, 
                p.y = NaN, p) : this.sphere ? (A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon)), 
                p.x = this.a * A * coslat * Math.sin(dlon) + this.x0, p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0, 
                p) : (X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI, cosX = Math.cos(X), 
                sinX = Math.sin(X), Math.abs(this.coslat0) <= EPSLN ? (ts = tsfnz(this.e, lat * this.con, this.con * sinlat), 
                rh = 2 * this.a * this.k0 * ts / this.cons, p.x = this.x0 + rh * Math.sin(lon - this.long0), 
                p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0), p) : (Math.abs(this.sinlat0) < EPSLN ? (A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon)), 
                p.y = A * sinX) : (A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon))), 
                p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0), p.x = A * cosX * Math.sin(dlon) + this.x0, 
                p));
            },
            inverse: function(p) {
                var lon, lat, ts, ce, Chi;
                p.x -= this.x0, p.y -= this.y0;
                var rh = Math.sqrt(p.x * p.x + p.y * p.y);
                if (this.sphere) {
                    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
                    return lon = this.long0, lat = this.lat0, rh <= EPSLN ? (p.x = lon, p.y = lat, p) : (lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh), 
                    lon = Math.abs(this.coslat0) < EPSLN ? this.lat0 > 0 ? adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y)) : adjust_lon(this.long0 + Math.atan2(p.x, p.y)) : adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c))), 
                    p.x = lon, p.y = lat, p);
                }
                if (Math.abs(this.coslat0) <= EPSLN) {
                    if (rh <= EPSLN) return lat = this.lat0, lon = this.long0, p.x = lon, p.y = lat, 
                    p;
                    p.x *= this.con, p.y *= this.con, ts = rh * this.cons / (2 * this.a * this.k0), 
                    lat = this.con * phi2z(this.e, ts), lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, -1 * p.y));
                } else ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), 
                lon = this.long0, rh <= EPSLN ? Chi = this.X0 : (Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh), 
                lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)))), 
                lat = -1 * phi2z(this.e, Math.tan(.5 * (HALF_PI + Chi)));
                return p.x = lon, p.y = lat, p;
            },
            names: [ "stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)", "Polar_Stereographic" ],
            ssfn_: function(phit, sinphi, eccen) {
                return sinphi *= eccen, Math.tan(.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), .5 * eccen);
            }
        };
        const somerc = {
            init: function() {
                var phy0 = this.lat0;
                this.lambda0 = this.long0;
                var sinPhy0 = Math.sin(phy0), semiMajorAxis = this.a, flattening = 1 / this.rf, e2 = 2 * flattening - Math.pow(flattening, 2), e = this.e = Math.sqrt(e2);
                this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2)), 
                this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4)), this.b0 = Math.asin(sinPhy0 / this.alpha);
                var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)), k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2)), k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
                this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
            },
            forward: function(p) {
                var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2)), Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y))), S = -this.alpha * (Sa1 + Sa2) + this.K, b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4), I = this.alpha * (p.x - this.lambda0), rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I))), rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
                return p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0, 
                p.x = this.R * rotI + this.x0, p;
            },
            inverse: function(p) {
                for (var Y = p.x - this.x0, X = p.y - this.y0, rotI = Y / this.R, rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4), b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI)), I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB))), lambda = this.lambda0 + I / this.alpha, S = 0, phy = b, prevPhy = -1e3, iteration = 0; Math.abs(phy - prevPhy) > 1e-7; ) {
                    if (++iteration > 20) return;
                    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2)), 
                    prevPhy = phy, phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
                }
                return p.x = lambda, p.y = phy, p;
            },
            names: [ "somerc" ]
        };
        const omerc = {
            init: function() {
                var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma0, P, projectionName, gamma = 0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0;
                this.no_off = (projectionName = "object" == typeof (P = this).PROJECTION ? Object.keys(P.PROJECTION)[0] : P.PROJECTION, 
                "no_uoff" in P || "no_off" in P || -1 !== [ "Hotine_Oblique_Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin" ].indexOf(projectionName)), 
                this.no_rot = "no_rot" in this;
                var alp = !1;
                "alpha" in this && (alp = !0);
                var gam = !1;
                if ("rectified_grid_angle" in this && (gam = !0), alp && (alpha_c = this.alpha), 
                gam && (gamma = this.rectified_grid_angle * D2R), alp || gam) lamc = this.longc; else if (lam1 = this.long1, 
                phi1 = this.lat1, lam2 = this.long2, phi2 = this.lat2, Math.abs(phi1 - phi2) <= 1e-7 || (con = Math.abs(phi1)) <= 1e-7 || Math.abs(con - HALF_PI) <= 1e-7 || Math.abs(Math.abs(this.lat0) - HALF_PI) <= 1e-7 || Math.abs(Math.abs(phi2) - HALF_PI) <= 1e-7) throw new Error;
                var one_es = 1 - this.es;
                com = Math.sqrt(one_es), Math.abs(this.lat0) > EPSLN ? (sinph0 = Math.sin(this.lat0), 
                cosph0 = Math.cos(this.lat0), con = 1 - this.es * sinph0 * sinph0, this.B = cosph0 * cosph0, 
                this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es), this.A = this.B * this.k0 * com / con, 
                (F = (D = this.B * com / (cosph0 * Math.sqrt(con))) * D - 1) <= 0 ? F = 0 : (F = Math.sqrt(F), 
                this.lat0 < 0 && (F = -F)), this.E = F += D, this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B)) : (this.B = 1 / com, 
                this.A = this.k0, this.E = D = F = 1), alp || gam ? (alp ? (gamma0 = Math.asin(Math.sin(alpha_c) / D), 
                gam || (gamma = alpha_c)) : (gamma0 = gamma, alpha_c = Math.asin(D * Math.sin(gamma0))), 
                this.lam0 = lamc - Math.asin(.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B) : (H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B), 
                L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B), F = this.E / H, p = (L - H) / (L + H), 
                J = ((J = this.E * this.E) - L * H) / (J + L * H), (con = lam1 - lam2) < -Math.pi ? lam2 -= TWO_PI : con > Math.pi && (lam2 += TWO_PI), 
                this.lam0 = adjust_lon(.5 * (lam1 + lam2) - Math.atan(J * Math.tan(.5 * this.B * (lam1 - lam2)) / p) / this.B), 
                gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F)), 
                gamma = alpha_c = Math.asin(D * Math.sin(gamma0))), this.singam = Math.sin(gamma0), 
                this.cosgam = Math.cos(gamma0), this.sinrot = Math.sin(gamma), this.cosrot = Math.cos(gamma), 
                this.rB = 1 / this.B, this.ArB = this.A * this.rB, this.BrA = 1 / this.ArB, this.A, 
                this.B, this.no_off ? this.u_0 = 0 : (this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c))), 
                this.lat0 < 0 && (this.u_0 = -this.u_0)), F = .5 * gamma0, this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F)), 
                this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
            },
            forward: function(p) {
                var S, T, U, V, W, temp, u, v, coords = {};
                if (p.x = p.x - this.lam0, Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
                    if (S = .5 * ((W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B)) - (temp = 1 / W)), 
                    T = .5 * (W + temp), V = Math.sin(this.B * p.x), U = (S * this.singam - V * this.cosgam) / T, 
                    Math.abs(Math.abs(U) - 1) < EPSLN) throw new Error;
                    v = .5 * this.ArB * Math.log((1 - U) / (1 + U)), temp = Math.cos(this.B * p.x), 
                    u = Math.abs(temp) < 1e-7 ? this.A * p.x : this.ArB * Math.atan2(S * this.cosgam + V * this.singam, temp);
                } else v = p.y > 0 ? this.v_pole_n : this.v_pole_s, u = this.ArB * p.y;
                return this.no_rot ? (coords.x = u, coords.y = v) : (u -= this.u_0, coords.x = v * this.cosrot + u * this.sinrot, 
                coords.y = u * this.cosrot - v * this.sinrot), coords.x = this.a * coords.x + this.x0, 
                coords.y = this.a * coords.y + this.y0, coords;
            },
            inverse: function(p) {
                var u, v, Qp, Sp, Tp, Vp, Up, coords = {};
                if (p.x = (p.x - this.x0) * (1 / this.a), p.y = (p.y - this.y0) * (1 / this.a), 
                this.no_rot ? (v = p.y, u = p.x) : (v = p.x * this.cosrot - p.y * this.sinrot, u = p.y * this.cosrot + p.x * this.sinrot + this.u_0), 
                Sp = .5 * ((Qp = Math.exp(-this.BrA * v)) - 1 / Qp), Tp = .5 * (Qp + 1 / Qp), Up = ((Vp = Math.sin(this.BrA * u)) * this.cosgam + Sp * this.singam) / Tp, 
                Math.abs(Math.abs(Up) - 1) < EPSLN) coords.x = 0, coords.y = Up < 0 ? -HALF_PI : HALF_PI; else {
                    if (coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up)), coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B)), 
                    coords.y === 1 / 0) throw new Error;
                    coords.x = -this.rB * Math.atan2(Sp * this.cosgam - Vp * this.singam, Math.cos(this.BrA * u));
                }
                return coords.x += this.lam0, coords;
            },
            names: [ "Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc" ]
        };
        const lcc = {
            init: function() {
                if (this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0 || 0, 
                this.y0 = this.y0 || 0, !(Math.abs(this.lat1 + this.lat2) < EPSLN)) {
                    var temp = this.b / this.a;
                    this.e = Math.sqrt(1 - temp * temp);
                    var sin1 = Math.sin(this.lat1), cos1 = Math.cos(this.lat1), ms1 = msfnz(this.e, sin1, cos1), ts1 = tsfnz(this.e, this.lat1, sin1), sin2 = Math.sin(this.lat2), cos2 = Math.cos(this.lat2), ms2 = msfnz(this.e, sin2, cos2), ts2 = tsfnz(this.e, this.lat2, sin2), ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
                    Math.abs(this.lat1 - this.lat2) > EPSLN ? this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2) : this.ns = sin1, 
                    isNaN(this.ns) && (this.ns = sin1), this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns)), 
                    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns), this.title || (this.title = "Lambert Conformal Conic");
                }
            },
            forward: function(p) {
                var lon = p.x, lat = p.y;
                Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN && (lat = sign(lat) * (HALF_PI - 2 * EPSLN));
                var ts, rh1, con = Math.abs(Math.abs(lat) - HALF_PI);
                if (con > EPSLN) ts = tsfnz(this.e, lat, Math.sin(lat)), rh1 = this.a * this.f0 * Math.pow(ts, this.ns); else {
                    if ((con = lat * this.ns) <= 0) return null;
                    rh1 = 0;
                }
                var theta = this.ns * adjust_lon(lon - this.long0);
                return p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0, p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0, 
                p;
            },
            inverse: function(p) {
                var rh1, con, ts, lat, lon, x = (p.x - this.x0) / this.k0, y = this.rh - (p.y - this.y0) / this.k0;
                this.ns > 0 ? (rh1 = Math.sqrt(x * x + y * y), con = 1) : (rh1 = -Math.sqrt(x * x + y * y), 
                con = -1);
                var theta = 0;
                if (0 !== rh1 && (theta = Math.atan2(con * x, con * y)), 0 !== rh1 || this.ns > 0) {
                    if (con = 1 / this.ns, ts = Math.pow(rh1 / (this.a * this.f0), con), -9999 === (lat = phi2z(this.e, ts))) return null;
                } else lat = -HALF_PI;
                return lon = adjust_lon(theta / this.ns + this.long0), p.x = lon, p.y = lat, p;
            },
            names: [ "Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_1SP", "Lambert_Conformal_Conic_2SP", "lcc", "Lambert Conic Conformal (1SP)", "Lambert Conic Conformal (2SP)" ]
        };
        const krovak = {
            init: function() {
                this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(this.es), this.lat0 || (this.lat0 = .863937979737193), 
                this.long0 || (this.long0 = .4334234309119251), this.k0 || (this.k0 = .9999), this.s45 = .785398163397448, 
                this.s90 = 2 * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(this.e2), 
                this.alfa = Math.sqrt(1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1 - this.e2)), 
                this.uq = 1.04216856380474, this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa), 
                this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2), 
                this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g, 
                this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2)), 
                this.s0 = 1.37008346281555, this.n = Math.sin(this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), 
                this.ad = this.s90 - this.uq;
            },
            forward: function(p) {
                var gfi, u, deltav, s, d, eps, ro, lon = p.x, lat = p.y, delta_lon = adjust_lon(lon - this.long0);
                return gfi = Math.pow((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat)), this.alfa * this.e / 2), 
                u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45), 
                deltav = -delta_lon * this.alfa, s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav)), 
                d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s)), eps = this.n * d, ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n), 
                p.y = ro * Math.cos(eps) / 1, p.x = ro * Math.sin(eps) / 1, this.czech || (p.y *= -1, 
                p.x *= -1), p;
            },
            inverse: function(p) {
                var u, deltav, s, d, ro, fi1, ok, tmp = p.x;
                p.x = p.y, p.y = tmp, this.czech || (p.y *= -1, p.x *= -1), ro = Math.sqrt(p.x * p.x + p.y * p.y), 
                d = Math.atan2(p.y, p.x) / Math.sin(this.s0), s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45), 
                u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d)), 
                deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u)), p.x = this.long0 - deltav / this.alfa, 
                fi1 = u, ok = 0;
                var iter = 0;
                do {
                    p.y = 2 * (Math.atan(Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45), 
                    Math.abs(fi1 - p.y) < 1e-10 && (ok = 1), fi1 = p.y, iter += 1;
                } while (0 === ok && iter < 15);
                return iter >= 15 ? null : p;
            },
            names: [ "Krovak", "krovak" ]
        };
        function mlfn(e0, e1, e2, e3, phi) {
            return e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi);
        }
        function e0fn(x) {
            return 1 - .25 * x * (1 + x / 16 * (3 + 1.25 * x));
        }
        function e1fn(x) {
            return .375 * x * (1 + .25 * x * (1 + .46875 * x));
        }
        function e2fn(x) {
            return .05859375 * x * x * (1 + .75 * x);
        }
        function e3fn(x) {
            return x * x * x * (35 / 3072);
        }
        function gN(a, e, sinphi) {
            var temp = e * sinphi;
            return a / Math.sqrt(1 - temp * temp);
        }
        function adjust_lat(x) {
            return Math.abs(x) < HALF_PI ? x : x - sign(x) * Math.PI;
        }
        function imlfn(ml, e0, e1, e2, e3) {
            var phi, dphi;
            phi = ml / e0;
            for (var i = 0; i < 15; i++) if (phi += dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi)), 
            Math.abs(dphi) <= 1e-10) return phi;
            return NaN;
        }
        const cass = {
            init: function() {
                this.sphere || (this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), 
                this.e3 = e3fn(this.es), this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0));
            },
            forward: function(p) {
                var x, y, lam = p.x, phi = p.y;
                if (lam = adjust_lon(lam - this.long0), this.sphere) x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam)), 
                y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0); else {
                    var sinphi = Math.sin(phi), cosphi = Math.cos(phi), nl = gN(this.a, this.e, sinphi), tl = Math.tan(phi) * Math.tan(phi), al = lam * Math.cos(phi), asq = al * al, cl = this.es * cosphi * cosphi / (1 - this.es);
                    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120)), y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi) - this.ml0 + nl * sinphi / cosphi * asq * (.5 + (5 - tl + 6 * cl) * asq / 24);
                }
                return p.x = x + this.x0, p.y = y + this.y0, p;
            },
            inverse: function(p) {
                p.x -= this.x0, p.y -= this.y0;
                var phi, lam, x = p.x / this.a, y = p.y / this.a;
                if (this.sphere) {
                    var dd = y + this.lat0;
                    phi = Math.asin(Math.sin(dd) * Math.cos(x)), lam = Math.atan2(Math.tan(x), Math.cos(dd));
                } else {
                    var phi1 = imlfn(this.ml0 / this.a + y, this.e0, this.e1, this.e2, this.e3);
                    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) return p.x = this.long0, p.y = HALF_PI, 
                    y < 0 && (p.y *= -1), p;
                    var nl1 = gN(this.a, this.e, Math.sin(phi1)), rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es), tl1 = Math.pow(Math.tan(phi1), 2), dl = x * this.a / nl1, dsq = dl * dl;
                    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (.5 - (1 + 3 * tl1) * dl * dl / 24), 
                    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
                }
                return p.x = adjust_lon(lam + this.long0), p.y = adjust_lat(phi), p;
            },
            names: [ "Cassini", "Cassini_Soldner", "cass" ]
        };
        function qsfnz(eccent, sinphi) {
            var con;
            return eccent > 1e-7 ? (1 - eccent * eccent) * (sinphi / (1 - (con = eccent * sinphi) * con) - .5 / eccent * Math.log((1 - con) / (1 + con))) : 2 * sinphi;
        }
        var P00 = .3333333333333333, P01 = .17222222222222222, P02 = .10257936507936508, P10 = .06388888888888888, P11 = .0664021164021164, P20 = .016415012942191543;
        const laea = {
            init: function() {
                var sinphi, t = Math.abs(this.lat0);
                if (Math.abs(t - HALF_PI) < EPSLN ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE : Math.abs(t) < EPSLN ? this.mode = this.EQUIT : this.mode = this.OBLIQ, 
                this.es > 0) switch (this.qp = qsfnz(this.e, 1), this.mmf = .5 / (1 - this.es), 
                this.apa = function(es) {
                    var t, APA = [];
                    return APA[0] = es * P00, t = es * es, APA[0] += t * P01, APA[1] = t * P10, t *= es, 
                    APA[0] += t * P02, APA[1] += t * P11, APA[2] = t * P20, APA;
                }(this.es), this.mode) {
                  case this.N_POLE:
                  case this.S_POLE:
                    this.dd = 1;
                    break;

                  case this.EQUIT:
                    this.rq = Math.sqrt(.5 * this.qp), this.dd = 1 / this.rq, this.xmf = 1, this.ymf = .5 * this.qp;
                    break;

                  case this.OBLIQ:
                    this.rq = Math.sqrt(.5 * this.qp), sinphi = Math.sin(this.lat0), this.sinb1 = qsfnz(this.e, sinphi) / this.qp, 
                    this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1), this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1), 
                    this.ymf = (this.xmf = this.rq) / this.dd, this.xmf *= this.dd;
                } else this.mode === this.OBLIQ && (this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0));
            },
            forward: function(p) {
                var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi, lam = p.x, phi = p.y;
                if (lam = adjust_lon(lam - this.long0), this.sphere) {
                    if (sinphi = Math.sin(phi), cosphi = Math.cos(phi), coslam = Math.cos(lam), this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                        if ((y = this.mode === this.EQUIT ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam) <= EPSLN) return null;
                        x = (y = Math.sqrt(2 / y)) * cosphi * Math.sin(lam), y *= this.mode === this.EQUIT ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
                    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                        if (this.mode === this.N_POLE && (coslam = -coslam), Math.abs(phi + this.lat0) < EPSLN) return null;
                        y = FORTPI - .5 * phi, x = (y = 2 * (this.mode === this.S_POLE ? Math.cos(y) : Math.sin(y))) * Math.sin(lam), 
                        y *= coslam;
                    }
                } else {
                    switch (sinb = 0, cosb = 0, b = 0, coslam = Math.cos(lam), sinlam = Math.sin(lam), 
                    sinphi = Math.sin(phi), q = qsfnz(this.e, sinphi), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (sinb = q / this.qp, 
                    cosb = Math.sqrt(1 - sinb * sinb)), this.mode) {
                      case this.OBLIQ:
                        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
                        break;

                      case this.EQUIT:
                        b = 1 + cosb * coslam;
                        break;

                      case this.N_POLE:
                        b = HALF_PI + phi, q = this.qp - q;
                        break;

                      case this.S_POLE:
                        b = phi - HALF_PI, q = this.qp + q;
                    }
                    if (Math.abs(b) < EPSLN) return null;
                    switch (this.mode) {
                      case this.OBLIQ:
                      case this.EQUIT:
                        b = Math.sqrt(2 / b), y = this.mode === this.OBLIQ ? this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam) : (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf, 
                        x = this.xmf * b * cosb * sinlam;
                        break;

                      case this.N_POLE:
                      case this.S_POLE:
                        q >= 0 ? (x = (b = Math.sqrt(q)) * sinlam, y = coslam * (this.mode === this.S_POLE ? b : -b)) : x = y = 0;
                    }
                }
                return p.x = this.a * x + this.x0, p.y = this.a * y + this.y0, p;
            },
            inverse: function(p) {
                p.x -= this.x0, p.y -= this.y0;
                var lam, phi, cCe, sCe, q, rho, ab, beta, APA, t, x = p.x / this.a, y = p.y / this.a;
                if (this.sphere) {
                    var rh, cosz = 0, sinz = 0;
                    if ((phi = .5 * (rh = Math.sqrt(x * x + y * y))) > 1) return null;
                    switch (phi = 2 * Math.asin(phi), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (sinz = Math.sin(phi), 
                    cosz = Math.cos(phi)), this.mode) {
                      case this.EQUIT:
                        phi = Math.abs(rh) <= EPSLN ? 0 : Math.asin(y * sinz / rh), x *= sinz, y = cosz * rh;
                        break;

                      case this.OBLIQ:
                        phi = Math.abs(rh) <= EPSLN ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh), 
                        x *= sinz * this.cosph0, y = (cosz - Math.sin(phi) * this.sinph0) * rh;
                        break;

                      case this.N_POLE:
                        y = -y, phi = HALF_PI - phi;
                        break;

                      case this.S_POLE:
                        phi -= HALF_PI;
                    }
                    lam = 0 !== y || this.mode !== this.EQUIT && this.mode !== this.OBLIQ ? Math.atan2(x, y) : 0;
                } else {
                    if (ab = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                        if (x /= this.dd, y *= this.dd, (rho = Math.sqrt(x * x + y * y)) < EPSLN) return p.x = this.long0, 
                        p.y = this.lat0, p;
                        sCe = 2 * Math.asin(.5 * rho / this.rq), cCe = Math.cos(sCe), x *= sCe = Math.sin(sCe), 
                        this.mode === this.OBLIQ ? (ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho, 
                        q = this.qp * ab, y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe) : (ab = y * sCe / rho, 
                        q = this.qp * ab, y = rho * cCe);
                    } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                        if (this.mode === this.N_POLE && (y = -y), !(q = x * x + y * y)) return p.x = this.long0, 
                        p.y = this.lat0, p;
                        ab = 1 - q / this.qp, this.mode === this.S_POLE && (ab = -ab);
                    }
                    lam = Math.atan2(x, y), beta = Math.asin(ab), APA = this.apa, t = beta + beta, phi = beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t);
                }
                return p.x = adjust_lon(this.long0 + lam), p.y = phi, p;
            },
            names: [ "Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea" ],
            S_POLE: 1,
            N_POLE: 2,
            EQUIT: 3,
            OBLIQ: 4
        };
        function asinz(x) {
            return Math.abs(x) > 1 && (x = x > 1 ? 1 : -1), Math.asin(x);
        }
        const aea = {
            init: function() {
                Math.abs(this.lat1 + this.lat2) < EPSLN || (this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), 
                this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(this.lat1), this.cos_po = Math.cos(this.lat1), 
                this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po), 
                this.qs1 = qsfnz(this.e3, this.sin_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(this.lat2), 
                this.t2 = this.sin_po, this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po), this.qs2 = qsfnz(this.e3, this.sin_po), 
                this.sin_po = Math.sin(this.lat0), this.cos_po = Math.cos(this.lat0), this.t3 = this.sin_po, 
                this.qs0 = qsfnz(this.e3, this.sin_po), Math.abs(this.lat1 - this.lat2) > EPSLN ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1) : this.ns0 = this.con, 
                this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0);
            },
            forward: function(p) {
                var lon = p.x, lat = p.y;
                this.sin_phi = Math.sin(lat), this.cos_phi = Math.cos(lat);
                var qs = qsfnz(this.e3, this.sin_phi), rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0, theta = this.ns0 * adjust_lon(lon - this.long0), x = rh1 * Math.sin(theta) + this.x0, y = this.rh - rh1 * Math.cos(theta) + this.y0;
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var rh1, qs, con, theta, lon, lat;
                return p.x -= this.x0, p.y = this.rh - p.y + this.y0, this.ns0 >= 0 ? (rh1 = Math.sqrt(p.x * p.x + p.y * p.y), 
                con = 1) : (rh1 = -Math.sqrt(p.x * p.x + p.y * p.y), con = -1), theta = 0, 0 !== rh1 && (theta = Math.atan2(con * p.x, con * p.y)), 
                con = rh1 * this.ns0 / this.a, this.sphere ? lat = Math.asin((this.c - con * con) / (2 * this.ns0)) : (qs = (this.c - con * con) / this.ns0, 
                lat = this.phi1z(this.e3, qs)), lon = adjust_lon(theta / this.ns0 + this.long0), 
                p.x = lon, p.y = lat, p;
            },
            names: [ "Albers_Conic_Equal_Area", "Albers", "aea" ],
            phi1z: function(eccent, qs) {
                var sinphi, con, com, dphi, phi = asinz(.5 * qs);
                if (eccent < EPSLN) return phi;
                for (var eccnts = eccent * eccent, i = 1; i <= 25; i++) if (phi += dphi = .5 * (com = 1 - (con = eccent * (sinphi = Math.sin(phi))) * con) * com / Math.cos(phi) * (qs / (1 - eccnts) - sinphi / com + .5 / eccent * Math.log((1 - con) / (1 + con))), 
                Math.abs(dphi) <= 1e-7) return phi;
                return null;
            }
        };
        const gnom = {
            init: function() {
                this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0), this.infinity_dist = 1e3 * this.a, 
                this.rc = 1;
            },
            forward: function(p) {
                var sinphi, cosphi, dlon, coslon, g, x, y, lon = p.x, lat = p.y;
                return dlon = adjust_lon(lon - this.long0), sinphi = Math.sin(lat), cosphi = Math.cos(lat), 
                coslon = Math.cos(dlon), (g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon) > 0 || Math.abs(g) <= EPSLN ? (x = this.x0 + 1 * this.a * cosphi * Math.sin(dlon) / g, 
                y = this.y0 + 1 * this.a * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g) : (x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon), 
                y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon)), 
                p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var rh, sinc, cosc, c, lon, lat;
                return p.x = (p.x - this.x0) / this.a, p.y = (p.y - this.y0) / this.a, p.x /= this.k0, 
                p.y /= this.k0, (rh = Math.sqrt(p.x * p.x + p.y * p.y)) ? (c = Math.atan2(rh, this.rc), 
                sinc = Math.sin(c), lat = asinz((cosc = Math.cos(c)) * this.sin_p14 + p.y * sinc * this.cos_p14 / rh), 
                lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc), 
                lon = adjust_lon(this.long0 + lon)) : (lat = this.phic0, lon = 0), p.x = lon, p.y = lat, 
                p;
            },
            names: [ "gnom" ]
        };
        const cea = {
            init: function() {
                this.sphere || (this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)));
            },
            forward: function(p) {
                var x, y, lon = p.x, lat = p.y, dlon = adjust_lon(lon - this.long0);
                if (this.sphere) x = this.x0 + this.a * dlon * Math.cos(this.lat_ts), y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts); else {
                    var qs = qsfnz(this.e, Math.sin(lat));
                    x = this.x0 + this.a * this.k0 * dlon, y = this.y0 + this.a * qs * .5 / this.k0;
                }
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var lon, lat;
                return p.x -= this.x0, p.y -= this.y0, this.sphere ? (lon = adjust_lon(this.long0 + p.x / this.a / Math.cos(this.lat_ts)), 
                lat = Math.asin(p.y / this.a * Math.cos(this.lat_ts))) : (lat = function(eccent, q) {
                    var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
                    if (Math.abs(Math.abs(q) - temp) < 1e-6) return q < 0 ? -1 * HALF_PI : HALF_PI;
                    for (var dphi, sin_phi, cos_phi, con, phi = Math.asin(.5 * q), i = 0; i < 30; i++) if (sin_phi = Math.sin(phi), 
                    cos_phi = Math.cos(phi), con = eccent * sin_phi, phi += dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + .5 / eccent * Math.log((1 - con) / (1 + con))), 
                    Math.abs(dphi) <= 1e-10) return phi;
                    return NaN;
                }(this.e, 2 * p.y * this.k0 / this.a), lon = adjust_lon(this.long0 + p.x / (this.a * this.k0))), 
                p.x = lon, p.y = lat, p;
            },
            names: [ "cea" ]
        };
        const eqc = {
            init: function() {
                this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, 
                this.lat_ts = this.lat_ts || 0, this.title = this.title || "Equidistant Cylindrical (Plate Carre)", 
                this.rc = Math.cos(this.lat_ts);
            },
            forward: function(p) {
                var lon = p.x, lat = p.y, dlon = adjust_lon(lon - this.long0), dlat = adjust_lat(lat - this.lat0);
                return p.x = this.x0 + this.a * dlon * this.rc, p.y = this.y0 + this.a * dlat, p;
            },
            inverse: function(p) {
                var x = p.x, y = p.y;
                return p.x = adjust_lon(this.long0 + (x - this.x0) / (this.a * this.rc)), p.y = adjust_lat(this.lat0 + (y - this.y0) / this.a), 
                p;
            },
            names: [ "Equirectangular", "Equidistant_Cylindrical", "eqc" ]
        };
        const poly = {
            init: function() {
                this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), 
                this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), 
                this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
            },
            forward: function(p) {
                var x, y, el, lon = p.x, lat = p.y, dlon = adjust_lon(lon - this.long0);
                if (el = dlon * Math.sin(lat), this.sphere) Math.abs(lat) <= EPSLN ? (x = this.a * dlon, 
                y = -1 * this.a * this.lat0) : (x = this.a * Math.sin(el) / Math.tan(lat), y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat))); else if (Math.abs(lat) <= EPSLN) x = this.a * dlon, 
                y = -1 * this.ml0; else {
                    var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
                    x = nl * Math.sin(el), y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
                }
                return p.x = x + this.x0, p.y = y + this.y0, p;
            },
            inverse: function(p) {
                var lon, lat, x, y, i, al, bl, phi, dphi;
                if (x = p.x - this.x0, y = p.y - this.y0, this.sphere) if (Math.abs(y + this.a * this.lat0) <= EPSLN) lon = adjust_lon(x / this.a + this.long0), 
                lat = 0; else {
                    var tanphi;
                    for (al = this.lat0 + y / this.a, bl = x * x / this.a / this.a + al * al, phi = al, 
                    i = 20; i; --i) if (phi += dphi = -1 * (al * (phi * (tanphi = Math.tan(phi)) + 1) - phi - .5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1), 
                    Math.abs(dphi) <= EPSLN) {
                        lat = phi;
                        break;
                    }
                    lon = adjust_lon(this.long0 + Math.asin(x * Math.tan(phi) / this.a) / Math.sin(lat));
                } else if (Math.abs(y + this.ml0) <= EPSLN) lat = 0, lon = adjust_lon(this.long0 + x / this.a); else {
                    var cl, mln, mlnp, ma, con;
                    for (al = (this.ml0 + y) / this.a, bl = x * x / this.a / this.a + al * al, phi = al, 
                    i = 20; i; --i) if (con = this.e * Math.sin(phi), cl = Math.sqrt(1 - con * con) * Math.tan(phi), 
                    mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi), mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi), 
                    phi -= dphi = (al * (cl * (ma = mln / this.a) + 1) - ma - .5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp), 
                    Math.abs(dphi) <= EPSLN) {
                        lat = phi;
                        break;
                    }
                    cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat), lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
                }
                return p.x = lon, p.y = lat, p;
            },
            names: [ "Polyconic", "poly" ]
        };
        const nzmg = {
            init: function() {
                this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, 
                this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, 
                this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], 
                this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, 
                this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, 
                this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, 
                this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], 
                this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, 
                this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, 
                this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, 
                this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, 
                this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, 
                this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013;
            },
            forward: function(p) {
                var n, lon = p.x, delta_lat = p.y - this.lat0, delta_lon = lon - this.long0, d_phi = delta_lat / SEC_TO_RAD * 1e-5, d_lambda = delta_lon, d_phi_n = 1, d_psi = 0;
                for (n = 1; n <= 10; n++) d_phi_n *= d_phi, d_psi += this.A[n] * d_phi_n;
                var th_n_im1, th_re = d_psi, th_im = d_lambda, th_n_re = 1, th_n_im = 0, z_re = 0, z_im = 0;
                for (n = 1; n <= 6; n++) th_n_im1 = th_n_im * th_re + th_n_re * th_im, th_n_re = th_n_re * th_re - th_n_im * th_im, 
                th_n_im = th_n_im1, z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im, 
                z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
                return p.x = z_im * this.a + this.x0, p.y = z_re * this.a + this.y0, p;
            },
            inverse: function(p) {
                var n, z_n_im1, x = p.x, y = p.y, delta_x = x - this.x0, z_re = (y - this.y0) / this.a, z_im = delta_x / this.a, z_n_re = 1, z_n_im = 0, th_re = 0, th_im = 0;
                for (n = 1; n <= 6; n++) z_n_im1 = z_n_im * z_re + z_n_re * z_im, z_n_re = z_n_re * z_re - z_n_im * z_im, 
                z_n_im = z_n_im1, th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im, 
                th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
                for (var i = 0; i < this.iterations; i++) {
                    var th_n_im1, th_n_re = th_re, th_n_im = th_im, num_re = z_re, num_im = z_im;
                    for (n = 2; n <= 6; n++) th_n_im1 = th_n_im * th_re + th_n_re * th_im, th_n_re = th_n_re * th_re - th_n_im * th_im, 
                    th_n_im = th_n_im1, num_re += (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im), 
                    num_im += (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
                    th_n_re = 1, th_n_im = 0;
                    var den_re = this.B_re[1], den_im = this.B_im[1];
                    for (n = 2; n <= 6; n++) th_n_im1 = th_n_im * th_re + th_n_re * th_im, th_n_re = th_n_re * th_re - th_n_im * th_im, 
                    th_n_im = th_n_im1, den_re += n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im), 
                    den_im += n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
                    var den2 = den_re * den_re + den_im * den_im;
                    th_re = (num_re * den_re + num_im * den_im) / den2, th_im = (num_im * den_re - num_re * den_im) / den2;
                }
                var d_psi = th_re, d_lambda = th_im, d_psi_n = 1, d_phi = 0;
                for (n = 1; n <= 9; n++) d_psi_n *= d_psi, d_phi += this.D[n] * d_psi_n;
                var lat = this.lat0 + d_phi * SEC_TO_RAD * 1e5, lon = this.long0 + d_lambda;
                return p.x = lon, p.y = lat, p;
            },
            names: [ "New_Zealand_Map_Grid", "nzmg" ]
        };
        const mill = {
            init: function() {},
            forward: function(p) {
                var lon = p.x, lat = p.y, dlon = adjust_lon(lon - this.long0), x = this.x0 + this.a * dlon, y = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + lat / 2.5)) * 1.25;
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                p.x -= this.x0, p.y -= this.y0;
                var lon = adjust_lon(this.long0 + p.x / this.a), lat = 2.5 * (Math.atan(Math.exp(.8 * p.y / this.a)) - Math.PI / 4);
                return p.x = lon, p.y = lat, p;
            },
            names: [ "Miller_Cylindrical", "mill" ]
        };
        const sinu = {
            init: function() {
                this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt((this.m + 1) / this.n), 
                this.C_x = this.C_y / (this.m + 1)) : this.en = pj_enfn(this.es);
            },
            forward: function(p) {
                var x, y, lon = p.x, lat = p.y;
                if (lon = adjust_lon(lon - this.long0), this.sphere) {
                    if (this.m) for (var k = this.n * Math.sin(lat), i = 20; i; --i) {
                        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
                        if (lat -= V, Math.abs(V) < EPSLN) break;
                    } else lat = 1 !== this.n ? Math.asin(this.n * Math.sin(lat)) : lat;
                    x = this.a * this.C_x * lon * (this.m + Math.cos(lat)), y = this.a * this.C_y * lat;
                } else {
                    var s = Math.sin(lat), c = Math.cos(lat);
                    y = this.a * pj_mlfn(lat, s, c, this.en), x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
                }
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var lat, lon, s;
                return p.x -= this.x0, lon = p.x / this.a, p.y -= this.y0, lat = p.y / this.a, this.sphere ? (lat /= this.C_y, 
                lon /= this.C_x * (this.m + Math.cos(lat)), this.m ? lat = asinz((this.m * lat + Math.sin(lat)) / this.n) : 1 !== this.n && (lat = asinz(Math.sin(lat) / this.n)), 
                lon = adjust_lon(lon + this.long0), lat = adjust_lat(lat)) : (lat = pj_inv_mlfn(p.y / this.a, this.es, this.en), 
                (s = Math.abs(lat)) < HALF_PI ? (s = Math.sin(lat), lon = adjust_lon(this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat)))) : s - EPSLN < HALF_PI && (lon = this.long0)), 
                p.x = lon, p.y = lat, p;
            },
            names: [ "Sinusoidal", "sinu" ]
        };
        const moll = {
            init: function() {},
            forward: function(p) {
                for (var lon = p.x, lat = p.y, delta_lon = adjust_lon(lon - this.long0), theta = lat, con = Math.PI * Math.sin(lat); ;) {
                    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
                    if (theta += delta_theta, Math.abs(delta_theta) < EPSLN) break;
                }
                theta /= 2, Math.PI / 2 - Math.abs(lat) < EPSLN && (delta_lon = 0);
                var x = .900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0, y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var theta, arg;
                p.x -= this.x0, p.y -= this.y0, arg = p.y / (1.4142135623731 * this.a), Math.abs(arg) > .999999999999 && (arg = .999999999999), 
                theta = Math.asin(arg);
                var lon = adjust_lon(this.long0 + p.x / (.900316316158 * this.a * Math.cos(theta)));
                lon < -Math.PI && (lon = -Math.PI), lon > Math.PI && (lon = Math.PI), arg = (2 * theta + Math.sin(2 * theta)) / Math.PI, 
                Math.abs(arg) > 1 && (arg = 1);
                var lat = Math.asin(arg);
                return p.x = lon, p.y = lat, p;
            },
            names: [ "Mollweide", "moll" ]
        };
        const eqdc = {
            init: function() {
                Math.abs(this.lat1 + this.lat2) < EPSLN || (this.lat2 = this.lat2 || this.lat1, 
                this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp, 2), this.e = Math.sqrt(this.es), 
                this.e0 = e0fn(this.es), this.e1 = e1fn(this.es), this.e2 = e2fn(this.es), this.e3 = e3fn(this.es), 
                this.sinphi = Math.sin(this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = msfnz(this.e, this.sinphi, this.cosphi), 
                this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1), Math.abs(this.lat1 - this.lat2) < EPSLN ? this.ns = this.sinphi : (this.sinphi = Math.sin(this.lat2), 
                this.cosphi = Math.cos(this.lat2), this.ms2 = msfnz(this.e, this.sinphi, this.cosphi), 
                this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1)), 
                this.g = this.ml1 + this.ms1 / this.ns, this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0), 
                this.rh = this.a * (this.g - this.ml0));
            },
            forward: function(p) {
                var rh1, lon = p.x, lat = p.y;
                if (this.sphere) rh1 = this.a * (this.g - lat); else {
                    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
                    rh1 = this.a * (this.g - ml);
                }
                var theta = this.ns * adjust_lon(lon - this.long0), x = this.x0 + rh1 * Math.sin(theta), y = this.y0 + this.rh - rh1 * Math.cos(theta);
                return p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var con, rh1, lat, lon;
                p.x -= this.x0, p.y = this.rh - p.y + this.y0, this.ns >= 0 ? (rh1 = Math.sqrt(p.x * p.x + p.y * p.y), 
                con = 1) : (rh1 = -Math.sqrt(p.x * p.x + p.y * p.y), con = -1);
                var theta = 0;
                return 0 !== rh1 && (theta = Math.atan2(con * p.x, con * p.y)), this.sphere ? (lon = adjust_lon(this.long0 + theta / this.ns), 
                lat = adjust_lat(this.g - rh1 / this.a), p.x = lon, p.y = lat, p) : (lat = imlfn(this.g - rh1 / this.a, this.e0, this.e1, this.e2, this.e3), 
                lon = adjust_lon(this.long0 + theta / this.ns), p.x = lon, p.y = lat, p);
            },
            names: [ "Equidistant_Conic", "eqdc" ]
        };
        const vandg = {
            init: function() {
                this.R = this.a;
            },
            forward: function(p) {
                var x, y, lon = p.x, lat = p.y, dlon = adjust_lon(lon - this.long0);
                Math.abs(lat) <= EPSLN && (x = this.x0 + this.R * dlon, y = this.y0);
                var theta = asinz(2 * Math.abs(lat / Math.PI));
                (Math.abs(dlon) <= EPSLN || Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) && (x = this.x0, 
                y = lat >= 0 ? this.y0 + Math.PI * this.R * Math.tan(.5 * theta) : this.y0 + Math.PI * this.R * -Math.tan(.5 * theta));
                var al = .5 * Math.abs(Math.PI / dlon - dlon / Math.PI), asq = al * al, sinth = Math.sin(theta), costh = Math.cos(theta), g = costh / (sinth + costh - 1), gsq = g * g, m = g * (2 / sinth - 1), msq = m * m, con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
                dlon < 0 && (con = -con), x = this.x0 + con;
                var q = asq + g;
                return con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq), 
                y = lat >= 0 ? this.y0 + con : this.y0 - con, p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var lon, lat, xx, yy, xys, c1, c2, c3, a1, m1, con, th1;
                return p.x -= this.x0, p.y -= this.y0, con = Math.PI * this.R, xys = (xx = p.x / con) * xx + (yy = p.y / con) * yy, 
                con = 3 * (yy * yy / (c3 = -2 * (c1 = -Math.abs(yy) * (1 + xys)) + 1 + 2 * yy * yy + xys * xys) + (2 * (c2 = c1 - 2 * yy * yy + xx * xx) * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27) / (a1 = (c1 - c2 * c2 / 3 / c3) / c3) / (m1 = 2 * Math.sqrt(-a1 / 3)), 
                Math.abs(con) > 1 && (con = con >= 0 ? 1 : -1), th1 = Math.acos(con) / 3, lat = p.y >= 0 ? (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI : -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI, 
                lon = Math.abs(xx) < EPSLN ? this.long0 : adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx), 
                p.x = lon, p.y = lat, p;
            },
            names: [ "Van_der_Grinten_I", "VanDerGrinten", "vandg" ]
        };
        const aeqd = {
            init: function() {
                this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0);
            },
            forward: function(p) {
                var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, lon = p.x, lat = p.y, sinphi = Math.sin(p.y), cosphi = Math.cos(p.y), dlon = adjust_lon(lon - this.long0);
                return this.sphere ? Math.abs(this.sin_p12 - 1) <= EPSLN ? (p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon), 
                p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon), p) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon), 
                p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon), p) : (cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon), 
                kp = (c = Math.acos(cos_c)) ? c / Math.sin(c) : 1, p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon), 
                p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon)), 
                p) : (e0 = e0fn(this.es), e1 = e1fn(this.es), e2 = e2fn(this.es), e3 = e3fn(this.es), 
                Math.abs(this.sin_p12 - 1) <= EPSLN ? (Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI), 
                Ml = this.a * mlfn(e0, e1, e2, e3, lat), p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon), 
                p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon), p) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI), 
                Ml = this.a * mlfn(e0, e1, e2, e3, lat), p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon), 
                p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon), p) : (tanphi = sinphi / cosphi, Nl1 = gN(this.a, this.e, this.sin_p12), 
                Nl = gN(this.a, this.e, sinphi), psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi)), 
                s = 0 === (Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon))) ? Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi)) : Math.abs(Math.abs(Az) - Math.PI) <= EPSLN ? -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi)) : Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az)), 
                G = this.e * this.sin_p12 / Math.sqrt(1 - this.es), c = Nl1 * s * (1 - (s2 = s * s) * (Hs = (H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es)) * H) * (1 - Hs) / 6 + (s3 = s2 * s) / 8 * (GH = G * H) * (1 - 2 * Hs) + (s4 = s3 * s) / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s4 * s / 48 * GH), 
                p.x = this.x0 + c * Math.sin(Az), p.y = this.y0 + c * Math.cos(Az), p));
            },
            inverse: function(p) {
                var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
                if (p.x -= this.x0, p.y -= this.y0, this.sphere) {
                    if ((rh = Math.sqrt(p.x * p.x + p.y * p.y)) > 2 * HALF_PI * this.a) return;
                    return z = rh / this.a, sinz = Math.sin(z), cosz = Math.cos(z), lon = this.long0, 
                    Math.abs(rh) <= EPSLN ? lat = this.lat0 : (lat = asinz(cosz * this.sin_p12 + p.y * sinz * this.cos_p12 / rh), 
                    con = Math.abs(this.lat0) - HALF_PI, lon = Math.abs(con) <= EPSLN ? this.lat0 >= 0 ? adjust_lon(this.long0 + Math.atan2(p.x, -p.y)) : adjust_lon(this.long0 - Math.atan2(-p.x, p.y)) : adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz))), 
                    p.x = lon, p.y = lat, p;
                }
                return e0 = e0fn(this.es), e1 = e1fn(this.es), e2 = e2fn(this.es), e3 = e3fn(this.es), 
                Math.abs(this.sin_p12 - 1) <= EPSLN ? (lat = imlfn(((Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI)) - (rh = Math.sqrt(p.x * p.x + p.y * p.y))) / this.a, e0, e1, e2, e3), 
                lon = adjust_lon(this.long0 + Math.atan2(p.x, -1 * p.y)), p.x = lon, p.y = lat, 
                p) : Math.abs(this.sin_p12 + 1) <= EPSLN ? (Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI), 
                lat = imlfn(((rh = Math.sqrt(p.x * p.x + p.y * p.y)) - Mlp) / this.a, e0, e1, e2, e3), 
                lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y)), p.x = lon, p.y = lat, p) : (rh = Math.sqrt(p.x * p.x + p.y * p.y), 
                Az = Math.atan2(p.x, p.y), N1 = gN(this.a, this.e, this.sin_p12), cosAz = Math.cos(Az), 
                A = -(tmp = this.e * this.cos_p12 * cosAz) * tmp / (1 - this.es), B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es), 
                F = 1 - A * (Ee = (D = rh / N1) - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24) * Ee / 2 - D * Ee * Ee * Ee / 6, 
                psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz), 
                lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi))), 
                sinpsi = Math.sin(psi), lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es)), 
                p.x = lon, p.y = lat, p);
            },
            names: [ "Azimuthal_Equidistant", "aeqd" ]
        };
        const ortho = {
            init: function() {
                this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0);
            },
            forward: function(p) {
                var sinphi, cosphi, dlon, coslon, g, x, y, lon = p.x, lat = p.y;
                return dlon = adjust_lon(lon - this.long0), sinphi = Math.sin(lat), cosphi = Math.cos(lat), 
                coslon = Math.cos(dlon), ((g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon) > 0 || Math.abs(g) <= EPSLN) && (x = 1 * this.a * cosphi * Math.sin(dlon), 
                y = this.y0 + 1 * this.a * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon)), 
                p.x = x, p.y = y, p;
            },
            inverse: function(p) {
                var rh, z, sinz, cosz, con, lon, lat;
                return p.x -= this.x0, p.y -= this.y0, z = asinz((rh = Math.sqrt(p.x * p.x + p.y * p.y)) / this.a), 
                sinz = Math.sin(z), cosz = Math.cos(z), lon = this.long0, Math.abs(rh) <= EPSLN ? (lat = this.lat0, 
                p.x = lon, p.y = lat, p) : (lat = asinz(cosz * this.sin_p14 + p.y * sinz * this.cos_p14 / rh), 
                con = Math.abs(this.lat0) - HALF_PI, Math.abs(con) <= EPSLN ? (lon = this.lat0 >= 0 ? adjust_lon(this.long0 + Math.atan2(p.x, -p.y)) : adjust_lon(this.long0 - Math.atan2(-p.x, p.y)), 
                p.x = lon, p.y = lat, p) : (lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz)), 
                p.x = lon, p.y = lat, p));
            },
            names: [ "ortho" ]
        };
        var FACE_ENUM_FRONT = 1, FACE_ENUM_RIGHT = 2, FACE_ENUM_BACK = 3, FACE_ENUM_LEFT = 4, FACE_ENUM_TOP = 5, FACE_ENUM_BOTTOM = 6, AREA_ENUM = {
            AREA_0: 1,
            AREA_1: 2,
            AREA_2: 3,
            AREA_3: 4
        };
        function qsc_fwd_equat_face_theta(phi, y, x, area) {
            var theta;
            return phi < EPSLN ? (area.value = AREA_ENUM.AREA_0, theta = 0) : (theta = Math.atan2(y, x), 
            Math.abs(theta) <= FORTPI ? area.value = AREA_ENUM.AREA_0 : theta > FORTPI && theta <= HALF_PI + FORTPI ? (area.value = AREA_ENUM.AREA_1, 
            theta -= HALF_PI) : theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI) ? (area.value = AREA_ENUM.AREA_2, 
            theta = theta >= 0 ? theta - SPI : theta + SPI) : (area.value = AREA_ENUM.AREA_3, 
            theta += HALF_PI)), theta;
        }
        function qsc_shift_lon_origin(lon, offset) {
            var slon = lon + offset;
            return slon < -SPI ? slon += TWO_PI : slon > +SPI && (slon -= TWO_PI), slon;
        }
        const qsc = {
            init: function() {
                this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0 || 0, this.long0 = this.long0 || 0, 
                this.lat_ts = this.lat_ts || 0, this.title = this.title || "Quadrilateralized Spherical Cube", 
                this.lat0 >= HALF_PI - FORTPI / 2 ? this.face = FACE_ENUM_TOP : this.lat0 <= -(HALF_PI - FORTPI / 2) ? this.face = FACE_ENUM_BOTTOM : Math.abs(this.long0) <= FORTPI ? this.face = FACE_ENUM_FRONT : Math.abs(this.long0) <= HALF_PI + FORTPI ? this.face = this.long0 > 0 ? FACE_ENUM_RIGHT : FACE_ENUM_LEFT : this.face = FACE_ENUM_BACK, 
                0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b) / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f);
            },
            forward: function(p) {
                var lat, lon, theta, phi, t, mu, xy = {
                    x: 0,
                    y: 0
                }, area = {
                    value: 0
                };
                if (p.x -= this.long0, lat = 0 !== this.es ? Math.atan(this.one_minus_f_squared * Math.tan(p.y)) : p.y, 
                lon = p.x, this.face === FACE_ENUM_TOP) phi = HALF_PI - lat, lon >= FORTPI && lon <= HALF_PI + FORTPI ? (area.value = AREA_ENUM.AREA_0, 
                theta = lon - HALF_PI) : lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI) ? (area.value = AREA_ENUM.AREA_1, 
                theta = lon > 0 ? lon - SPI : lon + SPI) : lon > -(HALF_PI + FORTPI) && lon <= -FORTPI ? (area.value = AREA_ENUM.AREA_2, 
                theta = lon + HALF_PI) : (area.value = AREA_ENUM.AREA_3, theta = lon); else if (this.face === FACE_ENUM_BOTTOM) phi = HALF_PI + lat, 
                lon >= FORTPI && lon <= HALF_PI + FORTPI ? (area.value = AREA_ENUM.AREA_0, theta = -lon + HALF_PI) : lon < FORTPI && lon >= -FORTPI ? (area.value = AREA_ENUM.AREA_1, 
                theta = -lon) : lon < -FORTPI && lon >= -(HALF_PI + FORTPI) ? (area.value = AREA_ENUM.AREA_2, 
                theta = -lon - HALF_PI) : (area.value = AREA_ENUM.AREA_3, theta = lon > 0 ? -lon + SPI : -lon - SPI); else {
                    var q, r, s, sinlat, coslat, sinlon;
                    this.face === FACE_ENUM_RIGHT ? lon = qsc_shift_lon_origin(lon, +HALF_PI) : this.face === FACE_ENUM_BACK ? lon = qsc_shift_lon_origin(lon, +SPI) : this.face === FACE_ENUM_LEFT && (lon = qsc_shift_lon_origin(lon, -HALF_PI)), 
                    sinlat = Math.sin(lat), coslat = Math.cos(lat), sinlon = Math.sin(lon), q = coslat * Math.cos(lon), 
                    r = coslat * sinlon, s = sinlat, this.face === FACE_ENUM_FRONT ? theta = qsc_fwd_equat_face_theta(phi = Math.acos(q), s, r, area) : this.face === FACE_ENUM_RIGHT ? theta = qsc_fwd_equat_face_theta(phi = Math.acos(r), s, -q, area) : this.face === FACE_ENUM_BACK ? theta = qsc_fwd_equat_face_theta(phi = Math.acos(-q), s, -r, area) : this.face === FACE_ENUM_LEFT ? theta = qsc_fwd_equat_face_theta(phi = Math.acos(-r), s, q, area) : (phi = theta = 0, 
                    area.value = AREA_ENUM.AREA_0);
                }
                return mu = Math.atan(12 / SPI * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI)), 
                t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta))))), 
                area.value === AREA_ENUM.AREA_1 ? mu += HALF_PI : area.value === AREA_ENUM.AREA_2 ? mu += SPI : area.value === AREA_ENUM.AREA_3 && (mu += 1.5 * SPI), 
                xy.x = t * Math.cos(mu), xy.y = t * Math.sin(mu), xy.x = xy.x * this.a + this.x0, 
                xy.y = xy.y * this.a + this.y0, p.x = xy.x, p.y = xy.y, p;
            },
            inverse: function(p) {
                var mu, nu, cosmu, tannu, tantheta, theta, cosphi, phi, t, invert_sign, tanphi, xa, lp = {
                    lam: 0,
                    phi: 0
                }, area = {
                    value: 0
                };
                if (p.x = (p.x - this.x0) / this.a, p.y = (p.y - this.y0) / this.a, nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y)), 
                mu = Math.atan2(p.y, p.x), p.x >= 0 && p.x >= Math.abs(p.y) ? area.value = AREA_ENUM.AREA_0 : p.y >= 0 && p.y >= Math.abs(p.x) ? (area.value = AREA_ENUM.AREA_1, 
                mu -= HALF_PI) : p.x < 0 && -p.x >= Math.abs(p.y) ? (area.value = AREA_ENUM.AREA_2, 
                mu = mu < 0 ? mu + SPI : mu - SPI) : (area.value = AREA_ENUM.AREA_3, mu += HALF_PI), 
                t = SPI / 12 * Math.tan(mu), tantheta = Math.sin(t) / (Math.cos(t) - 1 / Math.sqrt(2)), 
                theta = Math.atan(tantheta), (cosphi = 1 - (cosmu = Math.cos(mu)) * cosmu * (tannu = Math.tan(nu)) * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))))) < -1 ? cosphi = -1 : cosphi > 1 && (cosphi = 1), 
                this.face === FACE_ENUM_TOP) phi = Math.acos(cosphi), lp.phi = HALF_PI - phi, area.value === AREA_ENUM.AREA_0 ? lp.lam = theta + HALF_PI : area.value === AREA_ENUM.AREA_1 ? lp.lam = theta < 0 ? theta + SPI : theta - SPI : area.value === AREA_ENUM.AREA_2 ? lp.lam = theta - HALF_PI : lp.lam = theta; else if (this.face === FACE_ENUM_BOTTOM) phi = Math.acos(cosphi), 
                lp.phi = phi - HALF_PI, area.value === AREA_ENUM.AREA_0 ? lp.lam = -theta + HALF_PI : area.value === AREA_ENUM.AREA_1 ? lp.lam = -theta : area.value === AREA_ENUM.AREA_2 ? lp.lam = -theta - HALF_PI : lp.lam = theta < 0 ? -theta - SPI : -theta + SPI; else {
                    var q, r, s;
                    t = (q = cosphi) * q, r = (t += (s = t >= 1 ? 0 : Math.sqrt(1 - t) * Math.sin(theta)) * s) >= 1 ? 0 : Math.sqrt(1 - t), 
                    area.value === AREA_ENUM.AREA_1 ? (t = r, r = -s, s = t) : area.value === AREA_ENUM.AREA_2 ? (r = -r, 
                    s = -s) : area.value === AREA_ENUM.AREA_3 && (t = r, r = s, s = -t), this.face === FACE_ENUM_RIGHT ? (t = q, 
                    q = -r, r = t) : this.face === FACE_ENUM_BACK ? (q = -q, r = -r) : this.face === FACE_ENUM_LEFT && (t = q, 
                    q = r, r = -t), lp.phi = Math.acos(-s) - HALF_PI, lp.lam = Math.atan2(r, q), this.face === FACE_ENUM_RIGHT ? lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI) : this.face === FACE_ENUM_BACK ? lp.lam = qsc_shift_lon_origin(lp.lam, -SPI) : this.face === FACE_ENUM_LEFT && (lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI));
                }
                return 0 !== this.es && (invert_sign = lp.phi < 0 ? 1 : 0, tanphi = Math.tan(lp.phi), 
                xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared), lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa)), 
                invert_sign && (lp.phi = -lp.phi)), lp.lam += this.long0, p.x = lp.lam, p.y = lp.phi, 
                p;
            },
            names: [ "Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc" ]
        };
        var COEFS_X = [ [ 1, 22199e-21, -715515e-10, 31103e-10 ], [ .9986, -482243e-9, -24897e-9, -13309e-10 ], [ .9954, -83103e-8, -448605e-10, -9.86701e-7 ], [ .99, -.00135364, -59661e-9, 36777e-10 ], [ .9822, -.00167442, -449547e-11, -572411e-11 ], [ .973, -.00214868, -903571e-10, 1.8736e-8 ], [ .96, -.00305085, -900761e-10, 164917e-11 ], [ .9427, -.00382792, -653386e-10, -26154e-10 ], [ .9216, -.00467746, -10457e-8, 481243e-11 ], [ .8962, -.00536223, -323831e-10, -543432e-11 ], [ .8679, -.00609363, -113898e-9, 332484e-11 ], [ .835, -.00698325, -640253e-10, 9.34959e-7 ], [ .7986, -.00755338, -500009e-10, 9.35324e-7 ], [ .7597, -.00798324, -35971e-9, -227626e-11 ], [ .7186, -.00851367, -701149e-10, -86303e-10 ], [ .6732, -.00986209, -199569e-9, 191974e-10 ], [ .6213, -.010418, 883923e-10, 624051e-11 ], [ .5722, -.00906601, 182e-6, 624051e-11 ], [ .5322, -.00677797, 275608e-9, 624051e-11 ] ], COEFS_Y = [ [ -520417e-23, .0124, 121431e-23, -845284e-16 ], [ .062, .0124, -1.26793e-9, 4.22642e-10 ], [ .124, .0124, 5.07171e-9, -1.60604e-9 ], [ .186, .0123999, -1.90189e-8, 6.00152e-9 ], [ .248, .0124002, 7.10039e-8, -2.24e-8 ], [ .31, .0123992, -2.64997e-7, 8.35986e-8 ], [ .372, .0124029, 9.88983e-7, -3.11994e-7 ], [ .434, .0123893, -369093e-11, -4.35621e-7 ], [ .4958, .0123198, -102252e-10, -3.45523e-7 ], [ .5571, .0121916, -154081e-10, -5.82288e-7 ], [ .6176, .0119938, -241424e-10, -5.25327e-7 ], [ .6769, .011713, -320223e-10, -5.16405e-7 ], [ .7346, .0113541, -397684e-10, -6.09052e-7 ], [ .7903, .0109107, -489042e-10, -104739e-11 ], [ .8435, .0103431, -64615e-9, -1.40374e-9 ], [ .8936, .00969686, -64636e-9, -8547e-9 ], [ .9394, .00840947, -192841e-9, -42106e-10 ], [ .9761, .00616527, -256e-6, -42106e-10 ], [ 1, .00328947, -319159e-9, -42106e-10 ] ], C1 = R2D / 5, RC1 = 1 / C1, poly3_val = function(coefs, x) {
            return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
        };
        const robin = {
            init: function() {
                this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0 || 0, this.es = 0, 
                this.title = this.title || "Robinson";
            },
            forward: function(ll) {
                var lon = adjust_lon(ll.x - this.long0), dphi = Math.abs(ll.y), i = Math.floor(dphi * C1);
                i < 0 ? i = 0 : i >= 18 && (i = 17);
                var xy = {
                    x: poly3_val(COEFS_X[i], dphi = R2D * (dphi - RC1 * i)) * lon,
                    y: poly3_val(COEFS_Y[i], dphi)
                };
                return ll.y < 0 && (xy.y = -xy.y), xy.x = xy.x * this.a * .8487 + this.x0, xy.y = xy.y * this.a * 1.3523 + this.y0, 
                xy;
            },
            inverse: function(xy) {
                var ll = {
                    x: (xy.x - this.x0) / (.8487 * this.a),
                    y: Math.abs(xy.y - this.y0) / (1.3523 * this.a)
                };
                if (ll.y >= 1) ll.x /= COEFS_X[18][0], ll.y = xy.y < 0 ? -HALF_PI : HALF_PI; else {
                    var i = Math.floor(18 * ll.y);
                    for (i < 0 ? i = 0 : i >= 18 && (i = 17); ;) if (COEFS_Y[i][0] > ll.y) --i; else {
                        if (!(COEFS_Y[i + 1][0] <= ll.y)) break;
                        ++i;
                    }
                    var coefs = COEFS_Y[i], t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i + 1][0] - coefs[0]);
                    t = function(f_df, start, max_err, iters) {
                        for (var x = start; iters; --iters) {
                            var upd = f_df(x);
                            if (x -= upd, Math.abs(upd) < max_err) break;
                        }
                        return x;
                    }((function(x) {
                        return (poly3_val(coefs, x) - ll.y) / function(coefs, x) {
                            return coefs[1] + x * (2 * coefs[2] + 3 * x * coefs[3]);
                        }(coefs, x);
                    }), t, EPSLN, 100), ll.x /= poly3_val(COEFS_X[i], t), ll.y = (5 * i + t) * D2R, 
                    xy.y < 0 && (ll.y = -ll.y);
                }
                return ll.x = adjust_lon(ll.x + this.long0), ll;
            },
            names: [ "Robinson", "robin" ]
        };
        const geocent = {
            init: function() {
                this.name = "geocent";
            },
            forward: function(p) {
                return geodeticToGeocentric(p, this.es, this.a);
            },
            inverse: function(p) {
                return geocentricToGeodetic(p, this.es, this.a, this.b);
            },
            names: [ "Geocentric", "geocentric", "geocent", "Geocent" ]
        };
        var mode_N_POLE = 0, mode_S_POLE = 1, mode_EQUIT = 2, mode_OBLIQ = 3, params = {
            h: {
                def: 1e5,
                num: !0
            },
            azi: {
                def: 0,
                num: !0,
                degrees: !0
            },
            tilt: {
                def: 0,
                num: !0,
                degrees: !0
            },
            long0: {
                def: 0,
                num: !0
            },
            lat0: {
                def: 0,
                num: !0
            }
        };
        const tpers = {
            init: function() {
                if (Object.keys(params).forEach(function(p) {
                    if (void 0 === this[p]) this[p] = params[p].def; else {
                        if (params[p].num && isNaN(this[p])) throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
                        params[p].num && (this[p] = parseFloat(this[p]));
                    }
                    params[p].degrees && (this[p] = this[p] * D2R);
                }.bind(this)), Math.abs(Math.abs(this.lat0) - HALF_PI) < EPSLN ? this.mode = this.lat0 < 0 ? mode_S_POLE : mode_N_POLE : Math.abs(this.lat0) < EPSLN ? this.mode = mode_EQUIT : (this.mode = mode_OBLIQ, 
                this.sinph0 = Math.sin(this.lat0), this.cosph0 = Math.cos(this.lat0)), this.pn1 = this.h / this.a, 
                this.pn1 <= 0 || this.pn1 > 1e10) throw new Error("Invalid height");
                this.p = 1 + this.pn1, this.rp = 1 / this.p, this.h1 = 1 / this.pn1, this.pfact = (this.p + 1) * this.h1, 
                this.es = 0;
                var omega = this.tilt, gamma = this.azi;
                this.cg = Math.cos(gamma), this.sg = Math.sin(gamma), this.cw = Math.cos(omega), 
                this.sw = Math.sin(omega);
            },
            forward: function(p) {
                p.x -= this.long0;
                var x, y, yt, ba, sinphi = Math.sin(p.y), cosphi = Math.cos(p.y), coslam = Math.cos(p.x);
                switch (this.mode) {
                  case mode_OBLIQ:
                    y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
                    break;

                  case mode_EQUIT:
                    y = cosphi * coslam;
                    break;

                  case mode_S_POLE:
                    y = -sinphi;
                    break;

                  case mode_N_POLE:
                    y = sinphi;
                }
                switch (x = (y = this.pn1 / (this.p - y)) * cosphi * Math.sin(p.x), this.mode) {
                  case mode_OBLIQ:
                    y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
                    break;

                  case mode_EQUIT:
                    y *= sinphi;
                    break;

                  case mode_N_POLE:
                    y *= -cosphi * coslam;
                    break;

                  case mode_S_POLE:
                    y *= cosphi * coslam;
                }
                return ba = 1 / ((yt = y * this.cg + x * this.sg) * this.sw * this.h1 + this.cw), 
                x = (x * this.cg - y * this.sg) * this.cw * ba, y = yt * ba, p.x = x * this.a, p.y = y * this.a, 
                p;
            },
            inverse: function(p) {
                p.x /= this.a, p.y /= this.a;
                var bm, bq, yt, r = {
                    x: p.x,
                    y: p.y
                };
                yt = 1 / (this.pn1 - p.y * this.sw), bm = this.pn1 * p.x * yt, bq = this.pn1 * p.y * this.cw * yt, 
                p.x = bm * this.cg + bq * this.sg, p.y = bq * this.cg - bm * this.sg;
                var rh = hypot(p.x, p.y);
                if (Math.abs(rh) < EPSLN) r.x = 0, r.y = p.y; else {
                    var cosz, sinz;
                    switch (sinz = 1 - rh * rh * this.pfact, sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1), 
                    cosz = Math.sqrt(1 - sinz * sinz), this.mode) {
                      case mode_OBLIQ:
                        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh), p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh, 
                        p.x *= sinz * this.cosph0;
                        break;

                      case mode_EQUIT:
                        r.y = Math.asin(p.y * sinz / rh), p.y = cosz * rh, p.x *= sinz;
                        break;

                      case mode_N_POLE:
                        r.y = Math.asin(cosz), p.y = -p.y;
                        break;

                      case mode_S_POLE:
                        r.y = -Math.asin(cosz);
                    }
                    r.x = Math.atan2(p.x, p.y);
                }
                return p.x = r.x + this.long0, p.y = r.y, p;
            },
            names: [ "Tilted_Perspective", "tpers" ]
        };
        const geos = {
            init: function() {
                if (this.flip_axis = "x" === this.sweep ? 1 : 0, this.h = Number(this.h), this.radius_g_1 = this.h / this.a, 
                this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) throw new Error;
                if (this.radius_g = 1 + this.radius_g_1, this.C = this.radius_g * this.radius_g - 1, 
                0 !== this.es) {
                    var one_es = 1 - this.es, rone_es = 1 / one_es;
                    this.radius_p = Math.sqrt(one_es), this.radius_p2 = one_es, this.radius_p_inv2 = rone_es, 
                    this.shape = "ellipse";
                } else this.radius_p = 1, this.radius_p2 = 1, this.radius_p_inv2 = 1, this.shape = "sphere";
                this.title || (this.title = "Geostationary Satellite View");
            },
            forward: function(p) {
                var tmp, v_x, v_y, v_z, lon = p.x, lat = p.y;
                if (lon -= this.long0, "ellipse" === this.shape) {
                    lat = Math.atan(this.radius_p2 * Math.tan(lat));
                    var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));
                    if (v_x = r * Math.cos(lon) * Math.cos(lat), v_y = r * Math.sin(lon) * Math.cos(lat), 
                    v_z = r * Math.sin(lat), (this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2 < 0) return p.x = Number.NaN, 
                    p.y = Number.NaN, p;
                    tmp = this.radius_g - v_x, this.flip_axis ? (p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp)), 
                    p.y = this.radius_g_1 * Math.atan(v_z / tmp)) : (p.x = this.radius_g_1 * Math.atan(v_y / tmp), 
                    p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp)));
                } else "sphere" === this.shape && (tmp = Math.cos(lat), v_x = Math.cos(lon) * tmp, 
                v_y = Math.sin(lon) * tmp, v_z = Math.sin(lat), tmp = this.radius_g - v_x, this.flip_axis ? (p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp)), 
                p.y = this.radius_g_1 * Math.atan(v_z / tmp)) : (p.x = this.radius_g_1 * Math.atan(v_y / tmp), 
                p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp))));
                return p.x = p.x * this.a, p.y = p.y * this.a, p;
            },
            inverse: function(p) {
                var a, b, det, k, v_x = -1, v_y = 0, v_z = 0;
                if (p.x = p.x / this.a, p.y = p.y / this.a, "ellipse" === this.shape) {
                    this.flip_axis ? (v_z = Math.tan(p.y / this.radius_g_1), v_y = Math.tan(p.x / this.radius_g_1) * hypot(1, v_z)) : (v_y = Math.tan(p.x / this.radius_g_1), 
                    v_z = Math.tan(p.y / this.radius_g_1) * hypot(1, v_y));
                    var v_zp = v_z / this.radius_p;
                    if (a = v_y * v_y + v_zp * v_zp + v_x * v_x, (det = (b = 2 * this.radius_g * v_x) * b - 4 * a * this.C) < 0) return p.x = Number.NaN, 
                    p.y = Number.NaN, p;
                    k = (-b - Math.sqrt(det)) / (2 * a), v_x = this.radius_g + k * v_x, v_y *= k, v_z *= k, 
                    p.x = Math.atan2(v_y, v_x), p.y = Math.atan(v_z * Math.cos(p.x) / v_x), p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
                } else if ("sphere" === this.shape) {
                    if (this.flip_axis ? (v_z = Math.tan(p.y / this.radius_g_1), v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1 + v_z * v_z)) : (v_y = Math.tan(p.x / this.radius_g_1), 
                    v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1 + v_y * v_y)), a = v_y * v_y + v_z * v_z + v_x * v_x, 
                    (det = (b = 2 * this.radius_g * v_x) * b - 4 * a * this.C) < 0) return p.x = Number.NaN, 
                    p.y = Number.NaN, p;
                    k = (-b - Math.sqrt(det)) / (2 * a), v_x = this.radius_g + k * v_x, v_y *= k, v_z *= k, 
                    p.x = Math.atan2(v_y, v_x), p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
                }
                return p.x = p.x + this.long0, p;
            },
            names: [ "Geostationary Satellite View", "Geostationary_Satellite", "geos" ]
        };
        var A1 = 1.340264, A2 = -.081106, A3 = 893e-6, A4 = .003796, M = Math.sqrt(3) / 2;
        const eqearth = {
            init: function() {
                this.es = 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0;
            },
            forward: function(p) {
                var lam = adjust_lon(p.x - this.long0), phi = p.y, paramLat = Math.asin(M * Math.sin(phi)), paramLatSq = paramLat * paramLat, paramLatPow6 = paramLatSq * paramLatSq * paramLatSq;
                return p.x = lam * Math.cos(paramLat) / (M * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq))), 
                p.y = paramLat * (A1 + A2 * paramLatSq + paramLatPow6 * (A3 + A4 * paramLatSq)), 
                p.x = this.a * p.x + this.x0, p.y = this.a * p.y + this.y0, p;
            },
            inverse: function(p) {
                p.x = (p.x - this.x0) / this.a, p.y = (p.y - this.y0) / this.a;
                var paramLatSq, paramLatPow6, dlat, i, paramLat = p.y;
                for (i = 0; i < 12 && (paramLat -= dlat = (paramLat * (A1 + A2 * (paramLatSq = paramLat * paramLat) + (paramLatPow6 = paramLatSq * paramLatSq * paramLatSq) * (A3 + A4 * paramLatSq)) - p.y) / (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)), 
                !(Math.abs(dlat) < 1e-9)); ++i) ;
                return paramLatPow6 = (paramLatSq = paramLat * paramLat) * paramLatSq * paramLatSq, 
                p.x = M * p.x * (A1 + 3 * A2 * paramLatSq + paramLatPow6 * (7 * A3 + 9 * A4 * paramLatSq)) / Math.cos(paramLat), 
                p.y = Math.asin(Math.sin(paramLat) / M), p.x = adjust_lon(p.x + this.long0), p;
            },
            names: [ "eqearth", "Equal Earth", "Equal_Earth" ]
        };
        var EPS10 = 1e-10;
        function e_fwd(p) {
            var rh, E, c, lam = adjust_lon(p.x - (this.long0 || 0)), phi = p.y;
            return rh = this.am1 + this.m1 - pj_mlfn(phi, E = Math.sin(phi), c = Math.cos(phi), this.en), 
            E = c * lam / (rh * Math.sqrt(1 - this.es * E * E)), p.x = rh * Math.sin(E), p.y = this.am1 - rh * Math.cos(E), 
            p.x = this.a * p.x + (this.x0 || 0), p.y = this.a * p.y + (this.y0 || 0), p;
        }
        function e_inv(p) {
            var s, rh, lam, phi;
            if (p.x = (p.x - (this.x0 || 0)) / this.a, p.y = (p.y - (this.y0 || 0)) / this.a, 
            rh = hypot(p.x, p.y = this.am1 - p.y), phi = pj_inv_mlfn(this.am1 + this.m1 - rh, this.es, this.en), 
            (s = Math.abs(phi)) < HALF_PI) s = Math.sin(phi), lam = rh * Math.atan2(p.x, p.y) * Math.sqrt(1 - this.es * s * s) / Math.cos(phi); else {
                if (!(Math.abs(s - HALF_PI) <= EPS10)) throw new Error;
                lam = 0;
            }
            return p.x = adjust_lon(lam + (this.long0 || 0)), p.y = adjust_lat(phi), p;
        }
        function s_fwd(p) {
            var E, rh, lam = adjust_lon(p.x - (this.long0 || 0)), phi = p.y;
            return rh = this.cphi1 + this.phi1 - phi, Math.abs(rh) > EPS10 ? (p.x = rh * Math.sin(E = lam * Math.cos(phi) / rh), 
            p.y = this.cphi1 - rh * Math.cos(E)) : p.x = p.y = 0, p.x = this.a * p.x + (this.x0 || 0), 
            p.y = this.a * p.y + (this.y0 || 0), p;
        }
        function s_inv(p) {
            var lam, phi;
            p.x = (p.x - (this.x0 || 0)) / this.a, p.y = (p.y - (this.y0 || 0)) / this.a;
            var rh = hypot(p.x, p.y = this.cphi1 - p.y);
            if (phi = this.cphi1 + this.phi1 - rh, Math.abs(phi) > HALF_PI) throw new Error;
            return lam = Math.abs(Math.abs(phi) - HALF_PI) <= EPS10 ? 0 : rh * Math.atan2(p.x, p.y) / Math.cos(phi), 
            p.x = adjust_lon(lam + (this.long0 || 0)), p.y = adjust_lat(phi), p;
        }
        const bonne = {
            init: function() {
                var c;
                if (this.phi1 = this.lat1, Math.abs(this.phi1) < EPS10) throw new Error;
                this.es ? (this.en = pj_enfn(this.es), this.m1 = pj_mlfn(this.phi1, this.am1 = Math.sin(this.phi1), c = Math.cos(this.phi1), this.en), 
                this.am1 = c / (Math.sqrt(1 - this.es * this.am1 * this.am1) * this.am1), this.inverse = e_inv, 
                this.forward = e_fwd) : (Math.abs(this.phi1) + EPS10 >= HALF_PI ? this.cphi1 = 0 : this.cphi1 = 1 / Math.tan(this.phi1), 
                this.inverse = s_inv, this.forward = s_fwd);
            },
            names: [ "bonne", "Bonne (Werner lat_1=90)" ]
        };
        core.defaultDatum = "WGS84", core.Proj = Proj, core.WGS84 = new core.Proj("WGS84"), 
        core.Point = lib_Point, core.toPoint = toPoint, core.defs = lib_defs, core.nadgrid = function(key, data) {
            var view = new DataView(data), isLittleEndian = function(view) {
                var nFields = view.getInt32(8, !1);
                if (11 === nFields) return !1;
                nFields = view.getInt32(8, !0), 11 !== nFields && console.warn("Failed to detect nadgrid endian-ness, defaulting to little-endian");
                return !0;
            }(view), header = function(view, isLittleEndian) {
                return {
                    nFields: view.getInt32(8, isLittleEndian),
                    nSubgridFields: view.getInt32(24, isLittleEndian),
                    nSubgrids: view.getInt32(40, isLittleEndian),
                    shiftType: decodeString(view, 56, 64).trim(),
                    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
                    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
                    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
                    toSemiMinorAxis: view.getFloat64(168, isLittleEndian)
                };
            }(view, isLittleEndian), subgrids = function(view, header, isLittleEndian) {
                for (var gridOffset = 176, grids = [], i = 0; i < header.nSubgrids; i++) {
                    var subHeader = readGridHeader(view, gridOffset, isLittleEndian), nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian), lngColumnCount = Math.round(1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval), latColumnCount = Math.round(1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
                    grids.push({
                        ll: [ secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude) ],
                        del: [ secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval) ],
                        lim: [ lngColumnCount, latColumnCount ],
                        count: subHeader.gridNodeCount,
                        cvs: mapNodes(nodes)
                    }), gridOffset += 176 + 16 * subHeader.gridNodeCount;
                }
                return grids;
            }(view, header, isLittleEndian), nadgrid = {
                header,
                subgrids
            };
            return loadedNadgrids[key] = nadgrid, nadgrid;
        }, core.transform = transform, core.mgrs = mgrs, core.version = "__VERSION__", function(proj4) {
            proj4.Proj.projections.add(tmerc), proj4.Proj.projections.add(etmerc), proj4.Proj.projections.add(utm), 
            proj4.Proj.projections.add(sterea), proj4.Proj.projections.add(stere), proj4.Proj.projections.add(somerc), 
            proj4.Proj.projections.add(omerc), proj4.Proj.projections.add(lcc), proj4.Proj.projections.add(krovak), 
            proj4.Proj.projections.add(cass), proj4.Proj.projections.add(laea), proj4.Proj.projections.add(aea), 
            proj4.Proj.projections.add(gnom), proj4.Proj.projections.add(cea), proj4.Proj.projections.add(eqc), 
            proj4.Proj.projections.add(poly), proj4.Proj.projections.add(nzmg), proj4.Proj.projections.add(mill), 
            proj4.Proj.projections.add(sinu), proj4.Proj.projections.add(moll), proj4.Proj.projections.add(eqdc), 
            proj4.Proj.projections.add(vandg), proj4.Proj.projections.add(aeqd), proj4.Proj.projections.add(ortho), 
            proj4.Proj.projections.add(qsc), proj4.Proj.projections.add(robin), proj4.Proj.projections.add(geocent), 
            proj4.Proj.projections.add(tpers), proj4.Proj.projections.add(geos), proj4.Proj.projections.add(eqearth), 
            proj4.Proj.projections.add(bonne);
        }(core);
        const lib = core;
    },
    589: (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
        "use strict";
        var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(292), _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(893), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(383), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(884), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(997), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__), _css_loader_dist_cjs_js_angular_material_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(100), options = {};
        options.styleTagTransform = _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default(), 
        options.setAttributes = _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default(), 
        options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head"), 
        options.domAPI = _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default(), 
        options.insertStyleElement = _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();
        _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_angular_material_css__WEBPACK_IMPORTED_MODULE_6__.A, options), 
        _css_loader_dist_cjs_js_angular_material_css__WEBPACK_IMPORTED_MODULE_6__.A && _css_loader_dist_cjs_js_angular_material_css__WEBPACK_IMPORTED_MODULE_6__.A.locals && _css_loader_dist_cjs_js_angular_material_css__WEBPACK_IMPORTED_MODULE_6__.A.locals;
    },
    556: (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
        "use strict";
        var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(292), _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(893), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(383), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(884), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(997), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__), _css_loader_dist_cjs_js_MarkerCluster_Default_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(703), options = {};
        options.styleTagTransform = _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default(), 
        options.setAttributes = _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default(), 
        options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head"), 
        options.domAPI = _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default(), 
        options.insertStyleElement = _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();
        _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_MarkerCluster_Default_css__WEBPACK_IMPORTED_MODULE_6__.A, options), 
        _css_loader_dist_cjs_js_MarkerCluster_Default_css__WEBPACK_IMPORTED_MODULE_6__.A && _css_loader_dist_cjs_js_MarkerCluster_Default_css__WEBPACK_IMPORTED_MODULE_6__.A.locals && _css_loader_dist_cjs_js_MarkerCluster_Default_css__WEBPACK_IMPORTED_MODULE_6__.A.locals;
    },
    325: (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
        "use strict";
        var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(292), _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(893), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(383), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(884), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(997), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__), _css_loader_dist_cjs_js_MarkerCluster_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(914), options = {};
        options.styleTagTransform = _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default(), 
        options.setAttributes = _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default(), 
        options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head"), 
        options.domAPI = _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default(), 
        options.insertStyleElement = _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();
        _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_MarkerCluster_css__WEBPACK_IMPORTED_MODULE_6__.A, options), 
        _css_loader_dist_cjs_js_MarkerCluster_css__WEBPACK_IMPORTED_MODULE_6__.A && _css_loader_dist_cjs_js_MarkerCluster_css__WEBPACK_IMPORTED_MODULE_6__.A.locals && _css_loader_dist_cjs_js_MarkerCluster_css__WEBPACK_IMPORTED_MODULE_6__.A.locals;
    },
    696: (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
        "use strict";
        var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(292), _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(893), _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(383), _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = __webpack_require__.n(_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(884), _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(88), _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = __webpack_require__.n(_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(997), _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = __webpack_require__.n(_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__), _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(139), options = {};
        options.styleTagTransform = _style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default(), 
        options.setAttributes = _style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default(), 
        options.insert = _style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head"), 
        options.domAPI = _style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default(), 
        options.insertStyleElement = _style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();
        _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__.A, options), 
        _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__.A && _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__.A.locals && _css_loader_dist_cjs_js_leaflet_css__WEBPACK_IMPORTED_MODULE_6__.A.locals;
    },
    292: module => {
        "use strict";
        var stylesInDOM = [];
        function getIndexByIdentifier(identifier) {
            for (var result = -1, i = 0; i < stylesInDOM.length; i++) if (stylesInDOM[i].identifier === identifier) {
                result = i;
                break;
            }
            return result;
        }
        function modulesToDom(list, options) {
            for (var idCountMap = {}, identifiers = [], i = 0; i < list.length; i++) {
                var item = list[i], id = options.base ? item[0] + options.base : item[0], count = idCountMap[id] || 0, identifier = "".concat(id, " ").concat(count);
                idCountMap[id] = count + 1;
                var indexByIdentifier = getIndexByIdentifier(identifier), obj = {
                    css: item[1],
                    media: item[2],
                    sourceMap: item[3],
                    supports: item[4],
                    layer: item[5]
                };
                if (-1 !== indexByIdentifier) stylesInDOM[indexByIdentifier].references++, stylesInDOM[indexByIdentifier].updater(obj); else {
                    var updater = addElementStyle(obj, options);
                    options.byIndex = i, stylesInDOM.splice(i, 0, {
                        identifier,
                        updater,
                        references: 1
                    });
                }
                identifiers.push(identifier);
            }
            return identifiers;
        }
        function addElementStyle(obj, options) {
            var api = options.domAPI(options);
            api.update(obj);
            return function(newObj) {
                if (newObj) {
                    if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) return;
                    api.update(obj = newObj);
                } else api.remove();
            };
        }
        module.exports = function(list, options) {
            var lastIdentifiers = modulesToDom(list = list || [], options = options || {});
            return function(newList) {
                newList = newList || [];
                for (var i = 0; i < lastIdentifiers.length; i++) {
                    var index = getIndexByIdentifier(lastIdentifiers[i]);
                    stylesInDOM[index].references--;
                }
                for (var newLastIdentifiers = modulesToDom(newList, options), _i = 0; _i < lastIdentifiers.length; _i++) {
                    var _index = getIndexByIdentifier(lastIdentifiers[_i]);
                    0 === stylesInDOM[_index].references && (stylesInDOM[_index].updater(), stylesInDOM.splice(_index, 1));
                }
                lastIdentifiers = newLastIdentifiers;
            };
        };
    },
    383: module => {
        "use strict";
        var memo = {};
        module.exports = function(insert, style) {
            var target = function(target) {
                if (void 0 === memo[target]) {
                    var styleTarget = document.querySelector(target);
                    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) try {
                        styleTarget = styleTarget.contentDocument.head;
                    } catch (e) {
                        styleTarget = null;
                    }
                    memo[target] = styleTarget;
                }
                return memo[target];
            }(insert);
            if (!target) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
            target.appendChild(style);
        };
    },
    88: module => {
        "use strict";
        module.exports = function(options) {
            var element = document.createElement("style");
            return options.setAttributes(element, options.attributes), options.insert(element, options.options), 
            element;
        };
    },
    884: (module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        module.exports = function(styleElement) {
            var nonce = __webpack_require__.nc;
            nonce && styleElement.setAttribute("nonce", nonce);
        };
    },
    893: module => {
        "use strict";
        module.exports = function(options) {
            if ("undefined" == typeof document) return {
                update: function() {},
                remove: function() {}
            };
            var styleElement = options.insertStyleElement(options);
            return {
                update: function(obj) {
                    !function(styleElement, options, obj) {
                        var css = "";
                        obj.supports && (css += "@supports (".concat(obj.supports, ") {")), obj.media && (css += "@media ".concat(obj.media, " {"));
                        var needLayer = void 0 !== obj.layer;
                        needLayer && (css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {")), 
                        css += obj.css, needLayer && (css += "}"), obj.media && (css += "}"), obj.supports && (css += "}");
                        var sourceMap = obj.sourceMap;
                        sourceMap && "undefined" != typeof btoa && (css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */")), 
                        options.styleTagTransform(css, styleElement, options.options);
                    }(styleElement, options, obj);
                },
                remove: function() {
                    !function(styleElement) {
                        if (null === styleElement.parentNode) return !1;
                        styleElement.parentNode.removeChild(styleElement);
                    }(styleElement);
                }
            };
        };
    },
    997: module => {
        "use strict";
        module.exports = function(css, styleElement) {
            if (styleElement.styleSheet) styleElement.styleSheet.cssText = css; else {
                for (;styleElement.firstChild; ) styleElement.removeChild(styleElement.firstChild);
                styleElement.appendChild(document.createTextNode(css));
            }
        };
    },
    524: (module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        module.exports = __webpack_require__.p + "b18a220ea3ed601ec968.png";
    },
    835: (module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        module.exports = __webpack_require__.p + "95ce97b96124cddcc6ff.png";
    },
    845: (module, __unused_webpack_exports, __webpack_require__) => {
        "use strict";
        module.exports = __webpack_require__.p + "d68ae9f02541036a991d.png";
    }
} ]);